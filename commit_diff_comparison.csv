Myers Diff,Histogram Diff,equal_diffs,file_path,is_code
"@@ -0,0 +1,3 @@
+<component name=""ProjectDictionaryState"">
+  <dictionary name=""fabian"" />
+</component>
\ No newline at end of file
","@@ -0,0 +1,3 @@
+<component name=""ProjectDictionaryState"">
+  <dictionary name=""fabian"" />
+</component>
\ No newline at end of file
",True,.idea/dictionaries/fabian.xml,False
"@@ -1,12 +0,0 @@
-# .. an example with a for loop ..
-
-
-@profile
-def my_func():
-    a = {}
-    for i in range(10000):
-        a[i] =  i + 1
-    return
-
-if __name__ == '__main__':
-    my_func()
","@@ -1,12 +0,0 @@
-# .. an example with a for loop ..
-
-
-@profile
-def my_func():
-    a = {}
-    for i in range(10000):
-        a[i] =  i + 1
-    return
-
-if __name__ == '__main__':
-    my_func()
",True,,False
"@@ -231,14 +231,14 @@ def show_results(prof, stream=None):
         # move everything one frame up
         keys = sorted(lines.keys())
 
+        k_old = keys[0] - 1
         lines_normalized[keys[0] - 1] = lines[keys[0]]
         k = keys.pop(0)
         while keys:
-            if len(lines[keys[0]]) > 1:
-                # .. inside a loop ..
-                lines_normalized[k] = lines[k]
-            else:
-                lines_normalized[k] = lines[keys[0]]
+            lines_normalized[k] = lines[keys[0]]
+            for i in range(len(lines_normalized[k_old]), len(lines_normalized[k])):
+                lines_normalized[k][i] = -1.
+            k_old = k
             k = keys.pop(0)
 
         first_line = sorted(lines_normalized.keys())[0]
@@ -254,6 +254,7 @@ def show_results(prof, stream=None):
                 inc = '{0:5.2f} MB'.format(inc)
             line = linecache.getline(filename, l)
             stream.write(template.format(l, mem, inc, line))
+        stream.write('\n')
 
 if __name__ == '__main__':
     from optparse import OptionParser
","@@ -231,14 +231,14 @@ def show_results(prof, stream=None):
         # move everything one frame up
         keys = sorted(lines.keys())
 
+        k_old = keys[0] - 1
         lines_normalized[keys[0] - 1] = lines[keys[0]]
         k = keys.pop(0)
         while keys:
-            if len(lines[keys[0]]) > 1:
-                # .. inside a loop ..
-                lines_normalized[k] = lines[k]
-            else:
-                lines_normalized[k] = lines[keys[0]]
+            lines_normalized[k] = lines[keys[0]]
+            for i in range(len(lines_normalized[k_old]), len(lines_normalized[k])):
+                lines_normalized[k][i] = -1.
+            k_old = k
             k = keys.pop(0)
 
         first_line = sorted(lines_normalized.keys())[0]
@@ -254,6 +254,7 @@ def show_results(prof, stream=None):
                 inc = '{0:5.2f} MB'.format(inc)
             line = linecache.getline(filename, l)
             stream.write(template.format(l, mem, inc, line))
+        stream.write('\n')
 
 if __name__ == '__main__':
     from optparse import OptionParser
",True,memory_profiler.py,True
"@@ -0,0 +1 @@
+__author__ = 'fabian'
","@@ -0,0 +1 @@
+__author__ = 'fabian'
",True,test/__init__.py,True
"@@ -0,0 +1,24 @@
+# .. an example with a for loop ..
+
+@profile
+def test_1():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    del b
+
+    for i in range(2):
+        a = [1] * (10 ** 6)
+        b = [2] * (2 * 10 ** 7)
+        del b
+    return a
+
+@profile
+def test_2():
+    a = {}
+    for i in range(10000):
+        a[i] =  i + 1
+    return
+
+if __name__ == '__main__':
+    test_1()
+    test_2()
","@@ -0,0 +1,24 @@
+# .. an example with a for loop ..
+
+@profile
+def test_1():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    del b
+
+    for i in range(2):
+        a = [1] * (10 ** 6)
+        b = [2] * (2 * 10 ** 7)
+        del b
+    return a
+
+@profile
+def test_2():
+    a = {}
+    for i in range(10000):
+        a[i] =  i + 1
+    return
+
+if __name__ == '__main__':
+    test_1()
+    test_2()
",True,test/test_loop.py,True
"@@ -0,0 +1,3 @@
+.idea
+dist
+*.pyc
","@@ -0,0 +1,3 @@
+.idea
+dist
+*.pyc
",True,.gitignore,False
"@@ -1,3 +0,0 @@
-<component name=""ProjectDictionaryState"">
-  <dictionary name=""fabian"" />
-</component>
\ No newline at end of file
","@@ -1,3 +0,0 @@
-<component name=""ProjectDictionaryState"">
-  <dictionary name=""fabian"" />
-</component>
\ No newline at end of file
",True,,False
"@@ -0,0 +1,14 @@
+
+@profile
+def test_1():
+    # .. will be called twice ..
+    a = 2.
+    b = 3
+    c = {}
+    for i in range(1000):
+        c[i] = 2
+    c[0] = 2.
+
+if __name__ == '__main__':
+    test_1()
+    test_1()
","@@ -0,0 +1,14 @@
+
+@profile
+def test_1():
+    # .. will be called twice ..
+    a = 2.
+    b = 3
+    c = {}
+    for i in range(1000):
+        c[i] = 2
+    c[0] = 2.
+
+if __name__ == '__main__':
+    test_1()
+    test_1()
",True,test/test_func.py,True
"@@ -266,6 +266,9 @@ if __name__ == '__main__':
 
     (options, args) = parser.parse_args()
 
+    # .. remove memory_profiler from sys.argv ..
+    sys.argv.pop(0)
+
     prof = LineProfiler()
     __file__ = _find_script(args[0])
     if sys.version_info[0] < 3:
","@@ -266,6 +266,9 @@ if __name__ == '__main__':
 
     (options, args) = parser.parse_args()
 
+    # .. remove memory_profiler from sys.argv ..
+    sys.argv.pop(0)
+
     prof = LineProfiler()
     __file__ = _find_script(args[0])
     if sys.version_info[0] < 3:
",True,memory_profiler.py,True
"@@ -2,12 +2,9 @@
 @profile
 def test_1():
     # .. will be called twice ..
-    a = 2.
-    b = 3
     c = {}
     for i in range(1000):
         c[i] = 2
-    c[0] = 2.
 
 if __name__ == '__main__':
     test_1()
","@@ -2,12 +2,9 @@
 @profile
 def test_1():
     # .. will be called twice ..
-    a = 2.
-    b = 3
     c = {}
     for i in range(1000):
         c[i] = 2
-    c[0] = 2.
 
 if __name__ == '__main__':
     test_1()
",True,test/test_func.py,True
"@@ -1,6 +1,6 @@
 """"""Get process information""""""
 
-__version__ = '0.12'
+__version__ = '0.13'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
@@ -16,8 +16,7 @@ try:
 
 except ImportError:
 
-    warnings.warn(""psutil module not found. This module provides ""
-                  ""speed enhacements and windows support"")
+    warnings.warn(""psutil module not found. memory_profiler will be slow"")
 
     import subprocess
     if os.name == 'posix':
","@@ -1,6 +1,6 @@
 """"""Get process information""""""
 
-__version__ = '0.12'
+__version__ = '0.13'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
@@ -16,8 +16,7 @@ try:
 
 except ImportError:
 
-    warnings.warn(""psutil module not found. This module provides ""
-                  ""speed enhacements and windows support"")
+    warnings.warn(""psutil module not found. memory_profiler will be slow"")
 
     import subprocess
     if os.name == 'posix':
",True,memory_profiler.py,True
"@@ -142,7 +142,6 @@ class LineProfiler:
         try:
             code = func.__code__
         except AttributeError:
-            import warnings
             warnings.warn(""Could not extract a code object for the object {0!r}""
                             .format(func))
             return
@@ -180,8 +179,7 @@ class LineProfiler:
 
     def trace_memory_usage(self, frame, event, arg):
 
-        if event in ('line', 'return'):
-            if frame.f_code in self.code_map:
+        if event in ('line', 'return') and frame.f_code in self.code_map:
                 lineno = frame.f_lineno
                 if event == 'return':
                     lineno += 1
@@ -219,8 +217,7 @@ def show_results(prof, stream=None):
             # .. measurements are empty ..
             continue
         filename = code.co_filename
-        if (filename.endswith("".pyc"") or
-            filename.endswith("".pyo"")):
+        if filename.endswith(("".pyc"", "".pyo"")):
             filename = filename[:-1]
         all_lines = linecache.getlines(filename)
         sub_lines = inspect.getblock(all_lines[code.co_firstlineno-1:])
","@@ -142,7 +142,6 @@ class LineProfiler:
         try:
             code = func.__code__
         except AttributeError:
-            import warnings
             warnings.warn(""Could not extract a code object for the object {0!r}""
                             .format(func))
             return
@@ -180,8 +179,7 @@ class LineProfiler:
 
     def trace_memory_usage(self, frame, event, arg):
 
-        if event in ('line', 'return'):
-            if frame.f_code in self.code_map:
+        if event in ('line', 'return') and frame.f_code in self.code_map:
                 lineno = frame.f_lineno
                 if event == 'return':
                     lineno += 1
@@ -219,8 +217,7 @@ def show_results(prof, stream=None):
             # .. measurements are empty ..
             continue
         filename = code.co_filename
-        if (filename.endswith("".pyc"") or
-            filename.endswith("".pyo"")):
+        if filename.endswith(("".pyc"", "".pyo"")):
             filename = filename[:-1]
         all_lines = linecache.getlines(filename)
         sub_lines = inspect.getblock(all_lines[code.co_firstlineno-1:])
",True,memory_profiler.py,True
"@@ -239,7 +239,7 @@ def show_results(prof, stream=None):
 
         first_line = sorted(lines_normalized.keys())[0]
         mem_old = max(lines_normalized[first_line])
-        for l in linenos:
+        for i, l in enumerate(linenos):
             mem = ''
             inc = ''
             if l in lines_normalized:
@@ -248,8 +248,7 @@ def show_results(prof, stream=None):
                 mem_old = mem
                 mem = '{0:5.2f} MB'.format(mem)
                 inc = '{0:5.2f} MB'.format(inc)
-            line = linecache.getline(filename, l)
-            stream.write(template.format(l, mem, inc, line))
+            stream.write(template.format(l, mem, inc, sub_lines[i]))
         stream.write('\n')
 
 if __name__ == '__main__':
","@@ -239,7 +239,7 @@ def show_results(prof, stream=None):
 
         first_line = sorted(lines_normalized.keys())[0]
         mem_old = max(lines_normalized[first_line])
-        for l in linenos:
+        for i, l in enumerate(linenos):
             mem = ''
             inc = ''
             if l in lines_normalized:
@@ -248,8 +248,7 @@ def show_results(prof, stream=None):
                 mem_old = mem
                 mem = '{0:5.2f} MB'.format(mem)
                 inc = '{0:5.2f} MB'.format(inc)
-            line = linecache.getline(filename, l)
-            stream.write(template.format(l, mem, inc, line))
+            stream.write(template.format(l, mem, inc, sub_lines[i]))
         stream.write('\n')
 
 if __name__ == '__main__':
",True,memory_profiler.py,True
"@@ -1,3 +1,4 @@
 .idea
 dist
 *.pyc
+MANIFEST
","@@ -1,3 +1,4 @@
 .idea
 dist
 *.pyc
+MANIFEST
",True,.gitignore,False
"@@ -91,8 +91,7 @@ the code that has been profiled.
  Support, bugs & wish list
 ===========================
 For support, please ask your question on `stack overflow
-<http://stackoverflow.com/>`_ and tag it with the *memory-profiler*
-keyword.
+<http://stackoverflow.com/>`_ and add the *profiling* tag.
 Send issues, proposals, etc. to `github's issue tracker
 <https://github.com/fabianp/memory_profiler/issues>`_ .
 
","@@ -91,8 +91,7 @@ the code that has been profiled.
  Support, bugs & wish list
 ===========================
 For support, please ask your question on `stack overflow
-<http://stackoverflow.com/>`_ and tag it with the *memory-profiler*
-keyword.
+<http://stackoverflow.com/>`_ and add the *profiling* tag.
 Send issues, proposals, etc. to `github's issue tracker
 <https://github.com/fabianp/memory_profiler/issues>`_ .
 
",True,README.rst,False
"@@ -1,6 +1,6 @@
 """"""Get process information""""""
 
-__version__ = '0.13'
+__version__ = '0.14'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -1,6 +1,6 @@
 """"""Get process information""""""
 
-__version__ = '0.13'
+__version__ = '0.14'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -207,9 +207,6 @@ def show_results(prof, stream=None):
     if stream is None:
         stream = sys.stdout
     template = '{0:>6} {1:>12} {2:>10}   {3:<}'
-    header = template.format('Line #', 'Mem usage', 'Increment', 'Line Contents')
-    stream.write(header + '\n')
-    stream.write('=' * len(header) + '\n')
 
     for code in prof.code_map:
         lines = prof.code_map[code]
@@ -219,11 +216,18 @@ def show_results(prof, stream=None):
         filename = code.co_filename
         if filename.endswith(("".pyc"", "".pyo"")):
             filename = filename[:-1]
+        stream.write('Filename: ' + filename + '\n\n')
+        if not os.path.exists(filename):
+            stream.write('ERROR: Could not find file ' + filenam + '\n')
+            continue
         all_lines = linecache.getlines(filename)
         sub_lines = inspect.getblock(all_lines[code.co_firstlineno-1:])
         linenos = range(code.co_firstlineno, code.co_firstlineno + len(sub_lines))
         lines_normalized = {}
 
+        header = template.format('Line #', 'Mem usage', 'Increment', 'Line Contents')
+        stream.write(header + '\n')
+        stream.write('=' * len(header) + '\n')
         # move everything one frame up
         keys = sorted(lines.keys())
 
@@ -249,7 +253,7 @@ def show_results(prof, stream=None):
                 mem = '{0:5.2f} MB'.format(mem)
                 inc = '{0:5.2f} MB'.format(inc)
             stream.write(template.format(l, mem, inc, sub_lines[i]))
-        stream.write('\n')
+        stream.write('\n\n')
 
 if __name__ == '__main__':
     from optparse import OptionParser
","@@ -207,9 +207,6 @@ def show_results(prof, stream=None):
     if stream is None:
         stream = sys.stdout
     template = '{0:>6} {1:>12} {2:>10}   {3:<}'
-    header = template.format('Line #', 'Mem usage', 'Increment', 'Line Contents')
-    stream.write(header + '\n')
-    stream.write('=' * len(header) + '\n')
 
     for code in prof.code_map:
         lines = prof.code_map[code]
@@ -219,11 +216,18 @@ def show_results(prof, stream=None):
         filename = code.co_filename
         if filename.endswith(("".pyc"", "".pyo"")):
             filename = filename[:-1]
+        stream.write('Filename: ' + filename + '\n\n')
+        if not os.path.exists(filename):
+            stream.write('ERROR: Could not find file ' + filenam + '\n')
+            continue
         all_lines = linecache.getlines(filename)
         sub_lines = inspect.getblock(all_lines[code.co_firstlineno-1:])
         linenos = range(code.co_firstlineno, code.co_firstlineno + len(sub_lines))
         lines_normalized = {}
 
+        header = template.format('Line #', 'Mem usage', 'Increment', 'Line Contents')
+        stream.write(header + '\n')
+        stream.write('=' * len(header) + '\n')
         # move everything one frame up
         keys = sorted(lines.keys())
 
@@ -249,7 +253,7 @@ def show_results(prof, stream=None):
                 mem = '{0:5.2f} MB'.format(mem)
                 inc = '{0:5.2f} MB'.format(inc)
             stream.write(template.format(l, mem, inc, sub_lines[i]))
-        stream.write('\n')
+        stream.write('\n\n')
 
 if __name__ == '__main__':
     from optparse import OptionParser
",True,memory_profiler.py,True
"@@ -1,11 +1,15 @@
-""""""Get process information""""""
+""""""Profile the memory usage of a Python program""""""
 
 __version__ = '0.14'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
-import time, sys, os, warnings
-import linecache, inspect
+import time
+import sys
+import os
+import warnings
+import linecache
+import inspect
 
 try:
     import psutil
@@ -36,7 +40,8 @@ except ImportError:
     else:
         raise NotImplementedError('The psutil module is required for non-unix platforms')
 
-def memory_usage(proc= -1, num= -1, interval=.1):
+
+def memory_usage(proc=-1, num=-1, interval=.1):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -70,6 +75,7 @@ def memory_usage(proc= -1, num= -1, interval=.1):
         filename = _find_script(proc)
         with open(filename) as f:
             proc = f.read()
+
         # TODO: make sure script's directory is on sys.path
         def f_exec(x, locals):
             # function interface for exec
@@ -84,7 +90,7 @@ def memory_usage(proc= -1, num= -1, interval=.1):
             proc = (proc[0], proc[1], {})
         p = Process(target=proc[0], args=proc[1], kwargs=proc[2])
         p.start()
-        while p.is_alive(): # FIXME: or num
+        while p.is_alive():  # FIXME: or num
             ret.append(_get_memory(p.pid))
             time.sleep(interval)
     else:
@@ -100,6 +106,7 @@ def memory_usage(proc= -1, num= -1, interval=.1):
 # ..
 # .. utility functions for line-by-line ..
 
+
 def _find_script(script_name):
     """""" Find the script.
 
@@ -202,6 +209,7 @@ class LineProfiler:
         self.last_time = {}
         sys.settrace(None)
 
+
 def show_results(prof, stream=None):
 
     if stream is None:
@@ -218,14 +226,16 @@ def show_results(prof, stream=None):
             filename = filename[:-1]
         stream.write('Filename: ' + filename + '\n\n')
         if not os.path.exists(filename):
-            stream.write('ERROR: Could not find file ' + filenam + '\n')
+            stream.write('ERROR: Could not find file ' + filename + '\n')
             continue
         all_lines = linecache.getlines(filename)
-        sub_lines = inspect.getblock(all_lines[code.co_firstlineno-1:])
-        linenos = range(code.co_firstlineno, code.co_firstlineno + len(sub_lines))
+        sub_lines = inspect.getblock(all_lines[code.co_firstlineno - 1:])
+        linenos = range(code.co_firstlineno, code.co_firstlineno +
+                        len(sub_lines))
         lines_normalized = {}
 
-        header = template.format('Line #', 'Mem usage', 'Increment', 'Line Contents')
+        header = template.format('Line #', 'Mem usage', 'Increment',
+                                 'Line Contents')
         stream.write(header + '\n')
         stream.write('=' * len(header) + '\n')
         # move everything one frame up
@@ -236,7 +246,8 @@ def show_results(prof, stream=None):
         k = keys.pop(0)
         while keys:
             lines_normalized[k] = lines[keys[0]]
-            for i in range(len(lines_normalized[k_old]), len(lines_normalized[k])):
+            for i in range(len(lines_normalized[k_old]),
+                           len(lines_normalized[k])):
                 lines_normalized[k][i] = -1.
             k_old = k
             k = keys.pop(0)
@@ -277,6 +288,7 @@ if __name__ == '__main__':
     else:
         import builtins
         builtins.__dict__['profile'] = prof
-        exec(compile(open(__file__).read(), __file__, 'exec'), locals(), globals())
+        exec(compile(open(__file__).read(), __file__, 'exec'), locals(),
+                                                               globals())
 
     show_results(prof)
","@@ -1,11 +1,15 @@
-""""""Get process information""""""
+""""""Profile the memory usage of a Python program""""""
 
 __version__ = '0.14'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
-import time, sys, os, warnings
-import linecache, inspect
+import time
+import sys
+import os
+import warnings
+import linecache
+import inspect
 
 try:
     import psutil
@@ -36,7 +40,8 @@ except ImportError:
     else:
         raise NotImplementedError('The psutil module is required for non-unix platforms')
 
-def memory_usage(proc= -1, num= -1, interval=.1):
+
+def memory_usage(proc=-1, num=-1, interval=.1):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -70,6 +75,7 @@ def memory_usage(proc= -1, num= -1, interval=.1):
         filename = _find_script(proc)
         with open(filename) as f:
             proc = f.read()
+
         # TODO: make sure script's directory is on sys.path
         def f_exec(x, locals):
             # function interface for exec
@@ -84,7 +90,7 @@ def memory_usage(proc= -1, num= -1, interval=.1):
             proc = (proc[0], proc[1], {})
         p = Process(target=proc[0], args=proc[1], kwargs=proc[2])
         p.start()
-        while p.is_alive(): # FIXME: or num
+        while p.is_alive():  # FIXME: or num
             ret.append(_get_memory(p.pid))
             time.sleep(interval)
     else:
@@ -100,6 +106,7 @@ def memory_usage(proc= -1, num= -1, interval=.1):
 # ..
 # .. utility functions for line-by-line ..
 
+
 def _find_script(script_name):
     """""" Find the script.
 
@@ -202,6 +209,7 @@ class LineProfiler:
         self.last_time = {}
         sys.settrace(None)
 
+
 def show_results(prof, stream=None):
 
     if stream is None:
@@ -218,14 +226,16 @@ def show_results(prof, stream=None):
             filename = filename[:-1]
         stream.write('Filename: ' + filename + '\n\n')
         if not os.path.exists(filename):
-            stream.write('ERROR: Could not find file ' + filenam + '\n')
+            stream.write('ERROR: Could not find file ' + filename + '\n')
             continue
         all_lines = linecache.getlines(filename)
-        sub_lines = inspect.getblock(all_lines[code.co_firstlineno-1:])
-        linenos = range(code.co_firstlineno, code.co_firstlineno + len(sub_lines))
+        sub_lines = inspect.getblock(all_lines[code.co_firstlineno - 1:])
+        linenos = range(code.co_firstlineno, code.co_firstlineno +
+                        len(sub_lines))
         lines_normalized = {}
 
-        header = template.format('Line #', 'Mem usage', 'Increment', 'Line Contents')
+        header = template.format('Line #', 'Mem usage', 'Increment',
+                                 'Line Contents')
         stream.write(header + '\n')
         stream.write('=' * len(header) + '\n')
         # move everything one frame up
@@ -236,7 +246,8 @@ def show_results(prof, stream=None):
         k = keys.pop(0)
         while keys:
             lines_normalized[k] = lines[keys[0]]
-            for i in range(len(lines_normalized[k_old]), len(lines_normalized[k])):
+            for i in range(len(lines_normalized[k_old]),
+                           len(lines_normalized[k])):
                 lines_normalized[k][i] = -1.
             k_old = k
             k = keys.pop(0)
@@ -277,6 +288,7 @@ if __name__ == '__main__':
     else:
         import builtins
         builtins.__dict__['profile'] = prof
-        exec(compile(open(__file__).read(), __file__, 'exec'), locals(), globals())
+        exec(compile(open(__file__).read(), __file__, 'exec'), locals(),
+                                                               globals())
 
     show_results(prof)
",True,memory_profiler.py,True
"@@ -133,6 +133,8 @@ class LineProfiler:
         self.functions = list(functions)
         self.code_map = {}
         self.enable_count = 0
+        for func in functions:
+            self.add_function(func)
 
     def __call__(self, func):
         self.add_function(func)
@@ -147,10 +149,11 @@ class LineProfiler:
         """""" Record line profiling information for the given Python function.
         """"""
         try:
-            code = func.__code__
+            code = func.func_code
         except AttributeError:
-            warnings.warn(""Could not extract a code object for the object {0!r}""
-                            .format(func))
+            import warnings
+            warnings.warn(""Could not extract a code object for the object %r""
+                          % (func,))
             return
         if code not in self.code_map:
             self.code_map[code] = {}
@@ -168,6 +171,32 @@ class LineProfiler:
             return result
         return f
 
+    def run(self, cmd):
+        """""" Profile a single executable statment in the main namespace.
+        """"""
+        import __main__
+        dict = __main__.__dict__
+        return self.runctx(cmd, dict, dict)
+
+    def runctx(self, cmd, globals, locals):
+        """""" Profile a single executable statement in the given namespaces.
+        """"""
+        self.enable_by_count()
+        try:
+            exec cmd in globals, locals
+        finally:
+            self.disable_by_count()
+        return self
+
+    def runcall(self, func, *args, **kw):
+        """""" Profile a single function call.
+        """"""
+        self.enable_by_count()
+        try:
+            return func(*args, **kw)
+        finally:
+            self.disable_by_count()
+
     def enable_by_count(self):
         """""" Enable the profiler if it hasn't been enabled before.
         """"""
@@ -193,7 +222,6 @@ class LineProfiler:
                 entry = self.code_map[frame.f_code].setdefault(lineno, [])
                 entry.append(_get_memory(os.getpid()))
 
-        # why this is needed, I don't know
         return self.trace_memory_usage
 
     def __enter__(self):
@@ -211,7 +239,6 @@ class LineProfiler:
 
 
 def show_results(prof, stream=None):
-
     if stream is None:
         stream = sys.stdout
     template = '{0:>6} {1:>12} {2:>10}   {3:<}'
@@ -261,11 +288,132 @@ def show_results(prof, stream=None):
                 mem = max(lines_normalized[l])
                 inc = mem - mem_old
                 mem_old = mem
-                mem = '{0:5.2f} MB'.format(mem)
-                inc = '{0:5.2f} MB'.format(inc)
+                mem = '{0:5.4f} MB'.format(mem)
+                inc = '{0:5.4f} MB'.format(inc)
             stream.write(template.format(l, mem, inc, sub_lines[i]))
         stream.write('\n\n')
 
+
+# A %lprun magic for IPython.
+def magic_mprun(self, parameter_s=''):
+    """""" Execute a statement under the line-by-line memory profiler from the
+    memory_profilser module.
+
+    Usage:
+      %mprun -f func1 -f func2 <statement>
+
+    The given statement (which doesn't require quote marks) is run via the
+    LineProfiler. Profiling is enabled for the functions specified by the -f
+    options. The statistics will be shown side-by-side with the code through the
+    pager once the statement has completed.
+
+    Options:
+
+    -f <function>: LineProfiler only profiles functions and methods it is told
+    to profile.  This option tells the profiler about these functions. Multiple
+    -f options may be used. The argument may be any expression that gives
+    a Python function or method object. However, one must be careful to avoid
+    spaces that may confuse the option parser. Additionally, functions defined
+    in the interpreter at the In[] prompt or via %run currently cannot be
+    displayed.  Write these functions out to a separate file and import them.
+
+    One or more -f options are required to get any useful results.
+
+    -T <filename>: dump the text-formatted statistics with the code side-by-side
+    out to a text file.
+
+    -r: return the LineProfiler object after it has completed profiling.
+    """"""
+    from StringIO import StringIO
+
+    # Local imports to avoid hard dependency.
+    from distutils.version import LooseVersion
+    import IPython
+    ipython_version = LooseVersion(IPython.__version__)
+    if ipython_version < '0.11':
+        from IPython.genutils import page
+        from IPython.ipstruct import Struct
+        from IPython.ipapi import UsageError
+    else:
+        from IPython.core.page import page
+        from IPython.utils.ipstruct import Struct
+        from IPython.core.error import UsageError
+
+    # Escape quote markers.
+    opts_def = Struct(T=[''], f=[])
+    parameter_s = parameter_s.replace('""', r'\""').replace(""'"", r""\'"")
+    opts, arg_str = self.parse_options(parameter_s, 'rf:T:', list_all=True)
+    opts.merge(opts_def)
+    print arg_str
+    global_ns = self.shell.user_global_ns
+    local_ns = self.shell.user_ns
+
+    # Get the requested functions.
+    funcs = []
+    for name in opts.f:
+        try:
+            funcs.append(eval(name, global_ns, local_ns))
+        except Exception, e:
+            raise UsageError('Could not find function %r.\n%s: %s' % (name,
+                e.__class__.__name__, e))
+
+    profile = LineProfiler(*funcs)
+    print funcs
+    # Add the profiler to the builtins for @profile.
+    import __builtin__
+    if 'profile' in __builtin__.__dict__:
+        had_profile = True
+        old_profile = __builtin__.__dict__['profile']
+    else:
+        had_profile = False
+        old_profile = None
+    __builtin__.__dict__['profile'] = profile
+
+    try:
+        try:
+            profile.runctx(arg_str, global_ns, local_ns)
+            message = ''
+        except SystemExit:
+            message = ""*** SystemExit exception caught in code being profiled.""
+        except KeyboardInterrupt:
+            message = (""*** KeyboardInterrupt exception caught in code being ""
+                ""profiled."")
+    finally:
+        if had_profile:
+            __builtin__.__dict__['profile'] = old_profile
+
+    # Trap text output.
+    stdout_trap = StringIO()
+    show_results(profile, stdout_trap)
+    output = stdout_trap.getvalue()
+    output = output.rstrip()
+
+    if ipython_version < '0.11':
+        page(output, screen_lines=self.shell.rc.screen_length)
+    else:
+        page(output)
+    print message,
+
+#    dump_file = opts.D[0]
+#    if dump_file:
+#        profile.dump_stats(dump_file)
+#        print '\n*** Profile stats pickled to file',\
+#              `dump_file` + '.', message
+
+    text_file = opts.T[0]
+    if text_file:
+        pfile = open(text_file, 'w')
+        pfile.write(output)
+        pfile.close()
+        print '\n*** Profile printout saved to text file %s. %s' % (text_file,
+                                                                    message)
+
+    return_value = None
+    if 'r' in opts:
+        return_value = profile
+
+    return return_value
+
 if __name__ == '__main__':
     from optparse import OptionParser
     parser = OptionParser(usage=_CMD_USAGE)
","@@ -133,6 +133,8 @@ class LineProfiler:
         self.functions = list(functions)
         self.code_map = {}
         self.enable_count = 0
+        for func in functions:
+            self.add_function(func)
 
     def __call__(self, func):
         self.add_function(func)
@@ -147,10 +149,11 @@ class LineProfiler:
         """""" Record line profiling information for the given Python function.
         """"""
         try:
-            code = func.__code__
+            code = func.func_code
         except AttributeError:
-            warnings.warn(""Could not extract a code object for the object {0!r}""
-                            .format(func))
+            import warnings
+            warnings.warn(""Could not extract a code object for the object %r""
+                          % (func,))
             return
         if code not in self.code_map:
             self.code_map[code] = {}
@@ -168,6 +171,32 @@ class LineProfiler:
             return result
         return f
 
+    def run(self, cmd):
+        """""" Profile a single executable statment in the main namespace.
+        """"""
+        import __main__
+        dict = __main__.__dict__
+        return self.runctx(cmd, dict, dict)
+
+    def runctx(self, cmd, globals, locals):
+        """""" Profile a single executable statement in the given namespaces.
+        """"""
+        self.enable_by_count()
+        try:
+            exec cmd in globals, locals
+        finally:
+            self.disable_by_count()
+        return self
+
+    def runcall(self, func, *args, **kw):
+        """""" Profile a single function call.
+        """"""
+        self.enable_by_count()
+        try:
+            return func(*args, **kw)
+        finally:
+            self.disable_by_count()
+
     def enable_by_count(self):
         """""" Enable the profiler if it hasn't been enabled before.
         """"""
@@ -193,7 +222,6 @@ class LineProfiler:
                 entry = self.code_map[frame.f_code].setdefault(lineno, [])
                 entry.append(_get_memory(os.getpid()))
 
-        # why this is needed, I don't know
         return self.trace_memory_usage
 
     def __enter__(self):
@@ -211,7 +239,6 @@ class LineProfiler:
 
 
 def show_results(prof, stream=None):
-
     if stream is None:
         stream = sys.stdout
     template = '{0:>6} {1:>12} {2:>10}   {3:<}'
@@ -261,11 +288,132 @@ def show_results(prof, stream=None):
                 mem = max(lines_normalized[l])
                 inc = mem - mem_old
                 mem_old = mem
-                mem = '{0:5.2f} MB'.format(mem)
-                inc = '{0:5.2f} MB'.format(inc)
+                mem = '{0:5.4f} MB'.format(mem)
+                inc = '{0:5.4f} MB'.format(inc)
             stream.write(template.format(l, mem, inc, sub_lines[i]))
         stream.write('\n\n')
 
+
+# A %lprun magic for IPython.
+def magic_mprun(self, parameter_s=''):
+    """""" Execute a statement under the line-by-line memory profiler from the
+    memory_profilser module.
+
+    Usage:
+      %mprun -f func1 -f func2 <statement>
+
+    The given statement (which doesn't require quote marks) is run via the
+    LineProfiler. Profiling is enabled for the functions specified by the -f
+    options. The statistics will be shown side-by-side with the code through the
+    pager once the statement has completed.
+
+    Options:
+
+    -f <function>: LineProfiler only profiles functions and methods it is told
+    to profile.  This option tells the profiler about these functions. Multiple
+    -f options may be used. The argument may be any expression that gives
+    a Python function or method object. However, one must be careful to avoid
+    spaces that may confuse the option parser. Additionally, functions defined
+    in the interpreter at the In[] prompt or via %run currently cannot be
+    displayed.  Write these functions out to a separate file and import them.
+
+    One or more -f options are required to get any useful results.
+
+    -T <filename>: dump the text-formatted statistics with the code side-by-side
+    out to a text file.
+
+    -r: return the LineProfiler object after it has completed profiling.
+    """"""
+    from StringIO import StringIO
+
+    # Local imports to avoid hard dependency.
+    from distutils.version import LooseVersion
+    import IPython
+    ipython_version = LooseVersion(IPython.__version__)
+    if ipython_version < '0.11':
+        from IPython.genutils import page
+        from IPython.ipstruct import Struct
+        from IPython.ipapi import UsageError
+    else:
+        from IPython.core.page import page
+        from IPython.utils.ipstruct import Struct
+        from IPython.core.error import UsageError
+
+    # Escape quote markers.
+    opts_def = Struct(T=[''], f=[])
+    parameter_s = parameter_s.replace('""', r'\""').replace(""'"", r""\'"")
+    opts, arg_str = self.parse_options(parameter_s, 'rf:T:', list_all=True)
+    opts.merge(opts_def)
+    print arg_str
+    global_ns = self.shell.user_global_ns
+    local_ns = self.shell.user_ns
+
+    # Get the requested functions.
+    funcs = []
+    for name in opts.f:
+        try:
+            funcs.append(eval(name, global_ns, local_ns))
+        except Exception, e:
+            raise UsageError('Could not find function %r.\n%s: %s' % (name,
+                e.__class__.__name__, e))
+
+    profile = LineProfiler(*funcs)
+    print funcs
+    # Add the profiler to the builtins for @profile.
+    import __builtin__
+    if 'profile' in __builtin__.__dict__:
+        had_profile = True
+        old_profile = __builtin__.__dict__['profile']
+    else:
+        had_profile = False
+        old_profile = None
+    __builtin__.__dict__['profile'] = profile
+
+    try:
+        try:
+            profile.runctx(arg_str, global_ns, local_ns)
+            message = ''
+        except SystemExit:
+            message = ""*** SystemExit exception caught in code being profiled.""
+        except KeyboardInterrupt:
+            message = (""*** KeyboardInterrupt exception caught in code being ""
+                ""profiled."")
+    finally:
+        if had_profile:
+            __builtin__.__dict__['profile'] = old_profile
+
+    # Trap text output.
+    stdout_trap = StringIO()
+    show_results(profile, stdout_trap)
+    output = stdout_trap.getvalue()
+    output = output.rstrip()
+
+    if ipython_version < '0.11':
+        page(output, screen_lines=self.shell.rc.screen_length)
+    else:
+        page(output)
+    print message,
+
+#    dump_file = opts.D[0]
+#    if dump_file:
+#        profile.dump_stats(dump_file)
+#        print '\n*** Profile stats pickled to file',\
+#              `dump_file` + '.', message
+
+    text_file = opts.T[0]
+    if text_file:
+        pfile = open(text_file, 'w')
+        pfile.write(output)
+        pfile.close()
+        print '\n*** Profile printout saved to text file %s. %s' % (text_file,
+                                                                    message)
+
+    return_value = None
+    if 'r' in opts:
+        return_value = profile
+
+    return return_value
+
 if __name__ == '__main__':
     from optparse import OptionParser
     parser = OptionParser(usage=_CMD_USAGE)
",True,memory_profiler.py,True
"@@ -294,7 +294,7 @@ def show_results(prof, stream=None):
         stream.write('\n\n')
 
 
-# A %lprun magic for IPython.
+# A lprun-style %mprun magic for IPython.
 def magic_mprun(self, parameter_s=''):
     """""" Execute a statement under the line-by-line memory profiler from the
     memory_profilser module.
@@ -344,7 +344,6 @@ def magic_mprun(self, parameter_s=''):
     parameter_s = parameter_s.replace('""', r'\""').replace(""'"", r""\'"")
     opts, arg_str = self.parse_options(parameter_s, 'rf:T:', list_all=True)
     opts.merge(opts_def)
-    print arg_str
     global_ns = self.shell.user_global_ns
     local_ns = self.shell.user_ns
 
@@ -358,7 +357,6 @@ def magic_mprun(self, parameter_s=''):
                 e.__class__.__name__, e))
 
     profile = LineProfiler(*funcs)
-    print funcs
     # Add the profiler to the builtins for @profile.
     import __builtin__
     if 'profile' in __builtin__.__dict__:
@@ -414,6 +412,88 @@ def magic_mprun(self, parameter_s=''):
 
     return return_value
 
+
+# a timeit-style %memit magic for IPython
+def magic_memit(self, line=''):
+    """"""Measure memory usage of a Python statement
+
+    Usage, in line mode:
+      %memit [-r<R>] statement
+
+    Options:
+    -r<R>: repeat the loop iteration <R> times and take the best result.
+    Default: 3
+
+    -t<T>: timeout after <T> seconds. Default: None
+
+    Examples
+    --------
+    ::
+
+      In [1]: import numpy as np
+
+      In [2]: %memit np.zeros(1e7)
+      best of 3: 76.402344 MB per loop
+      Out[2]: 76.40234375
+
+      In [3]: %memit np.ones(1e6)
+      best of 3: 7.820312 MB per loop
+      Out[3]: 7.8203125
+
+      In [4]: %memit -r 10 np.empty(1e8)
+      best of 10: 0.101562 MB per loop
+      Out[4]: 0.1015625
+
+    """"""
+
+    import multiprocessing as pr
+    from multiprocessing.queues import SimpleQueue
+
+    opts, stmt = self.parse_options(line, 'r:t:tcp:',
+                                    posix=False, strict=False)
+    repeat = int(getattr(opts, ""r"", 3))
+    if repeat < 1:
+        repeat == 1
+    timeout = int(getattr(opts, ""t"", 0))
+    if timeout <= 0:
+        timeout = None
+
+    ns = self.shell.user_ns
+
+    def _get_usage(q, stmt, setup='pass', ns={}):
+        from memory_profiler import memory_usage as _mu
+        try:
+            exec setup in ns
+            _mu0 = _mu()[0]
+            exec stmt in ns
+            _mu1 = _mu()[0]
+            q.put(_mu1 - _mu0)
+        except:
+            q.put(float('-inf'))
+
+    q = SimpleQueue()
+    # try once in the current process
+    _get_usage(q, stmt, 'pass', ns)
+    # try in child processes
+    at_least_one_worked = False
+    for _ in xrange(repeat):
+        p = pr.Process(target=_get_usage, args=(q, stmt, 'pass', ns))
+        p.start()
+        p.join(timeout=timeout)
+        if p.exitcode == 0:
+            at_least_one_worked = True
+        else:
+            p.terminate()
+            q.put(float('-inf'))
+
+    if not at_least_one_worked:
+        print 'ERROR: subprocesses failed, result may be inaccurate.'
+
+    usages = [q.get() for _ in xrange(repeat)]
+    usage = max(usages)
+    print u""worst of %d: %f MB per loop"" % (repeat, usage)
+
+
 if __name__ == '__main__':
     from optparse import OptionParser
     parser = OptionParser(usage=_CMD_USAGE)
","@@ -294,7 +294,7 @@ def show_results(prof, stream=None):
         stream.write('\n\n')
 
 
-# A %lprun magic for IPython.
+# A lprun-style %mprun magic for IPython.
 def magic_mprun(self, parameter_s=''):
     """""" Execute a statement under the line-by-line memory profiler from the
     memory_profilser module.
@@ -344,7 +344,6 @@ def magic_mprun(self, parameter_s=''):
     parameter_s = parameter_s.replace('""', r'\""').replace(""'"", r""\'"")
     opts, arg_str = self.parse_options(parameter_s, 'rf:T:', list_all=True)
     opts.merge(opts_def)
-    print arg_str
     global_ns = self.shell.user_global_ns
     local_ns = self.shell.user_ns
 
@@ -358,7 +357,6 @@ def magic_mprun(self, parameter_s=''):
                 e.__class__.__name__, e))
 
     profile = LineProfiler(*funcs)
-    print funcs
     # Add the profiler to the builtins for @profile.
     import __builtin__
     if 'profile' in __builtin__.__dict__:
@@ -414,6 +412,88 @@ def magic_mprun(self, parameter_s=''):
 
     return return_value
 
+
+# a timeit-style %memit magic for IPython
+def magic_memit(self, line=''):
+    """"""Measure memory usage of a Python statement
+
+    Usage, in line mode:
+      %memit [-r<R>] statement
+
+    Options:
+    -r<R>: repeat the loop iteration <R> times and take the best result.
+    Default: 3
+
+    -t<T>: timeout after <T> seconds. Default: None
+
+    Examples
+    --------
+    ::
+
+      In [1]: import numpy as np
+
+      In [2]: %memit np.zeros(1e7)
+      best of 3: 76.402344 MB per loop
+      Out[2]: 76.40234375
+
+      In [3]: %memit np.ones(1e6)
+      best of 3: 7.820312 MB per loop
+      Out[3]: 7.8203125
+
+      In [4]: %memit -r 10 np.empty(1e8)
+      best of 10: 0.101562 MB per loop
+      Out[4]: 0.1015625
+
+    """"""
+
+    import multiprocessing as pr
+    from multiprocessing.queues import SimpleQueue
+
+    opts, stmt = self.parse_options(line, 'r:t:tcp:',
+                                    posix=False, strict=False)
+    repeat = int(getattr(opts, ""r"", 3))
+    if repeat < 1:
+        repeat == 1
+    timeout = int(getattr(opts, ""t"", 0))
+    if timeout <= 0:
+        timeout = None
+
+    ns = self.shell.user_ns
+
+    def _get_usage(q, stmt, setup='pass', ns={}):
+        from memory_profiler import memory_usage as _mu
+        try:
+            exec setup in ns
+            _mu0 = _mu()[0]
+            exec stmt in ns
+            _mu1 = _mu()[0]
+            q.put(_mu1 - _mu0)
+        except:
+            q.put(float('-inf'))
+
+    q = SimpleQueue()
+    # try once in the current process
+    _get_usage(q, stmt, 'pass', ns)
+    # try in child processes
+    at_least_one_worked = False
+    for _ in xrange(repeat):
+        p = pr.Process(target=_get_usage, args=(q, stmt, 'pass', ns))
+        p.start()
+        p.join(timeout=timeout)
+        if p.exitcode == 0:
+            at_least_one_worked = True
+        else:
+            p.terminate()
+            q.put(float('-inf'))
+
+    if not at_least_one_worked:
+        print 'ERROR: subprocesses failed, result may be inaccurate.'
+
+    usages = [q.get() for _ in xrange(repeat)]
+    usage = max(usages)
+    print u""worst of %d: %f MB per loop"" % (repeat, usage)
+
+
 if __name__ == '__main__':
     from optparse import OptionParser
     parser = OptionParser(usage=_CMD_USAGE)
",True,memory_profiler.py,True
"@@ -120,6 +120,8 @@ inspired by Robert Kern's `line profiler
 `Victor <https://github.com/octavo>`_ added python3, bugfixes and general
 cleanup.
 
+`Vlad Niculae <http://vene.ro>`_ added IPython magic functions.
+
 
 =========
  License
","@@ -120,6 +120,8 @@ inspired by Robert Kern's `line profiler
 `Victor <https://github.com/octavo>`_ added python3, bugfixes and general
 cleanup.
 
+`Vlad Niculae <http://vene.ro>`_ added IPython magic functions.
+
 
 =========
  License
",True,README.rst,False
"@@ -38,7 +38,8 @@ except ImportError:
             except:
                 return -1
     else:
-        raise NotImplementedError('The psutil module is required for non-unix platforms')
+        raise NotImplementedError('The psutil module is required for non-unix '
+                                  'platforms')
 
 
 def memory_usage(proc=-1, num=-1, interval=.1):
@@ -304,8 +305,8 @@ def magic_mprun(self, parameter_s=''):
 
     The given statement (which doesn't require quote marks) is run via the
     LineProfiler. Profiling is enabled for the functions specified by the -f
-    options. The statistics will be shown side-by-side with the code through the
-    pager once the statement has completed.
+    options. The statistics will be shown side-by-side with the code through
+    the pager once the statement has completed.
 
     Options:
 
@@ -319,8 +320,8 @@ def magic_mprun(self, parameter_s=''):
 
     One or more -f options are required to get any useful results.
 
-    -T <filename>: dump the text-formatted statistics with the code side-by-side
-    out to a text file.
+    -T <filename>: dump the text-formatted statistics with the code
+    side-by-side out to a text file.
 
     -r: return the LineProfiler object after it has completed profiling.
     """"""
@@ -418,13 +419,17 @@ def magic_memit(self, line=''):
     """"""Measure memory usage of a Python statement
 
     Usage, in line mode:
-      %memit [-r<R>] statement
+      %memit [-ir<R>t<T>] statement
 
     Options:
     -r<R>: repeat the loop iteration <R> times and take the best result.
     Default: 3
 
-    -t<T>: timeout after <T> seconds. Default: None
+    -i: run the code in the current environment, without forking a new process.
+    This is required on some MacOS versions of Accelerate if your line contains
+    a call to `np.dot`.
+
+    -t<T>: timeout after <T> seconds. Unused if `-i` is active. Default: None
 
     Examples
     --------
@@ -433,30 +438,46 @@ def magic_memit(self, line=''):
       In [1]: import numpy as np
 
       In [2]: %memit np.zeros(1e7)
-      best of 3: 76.402344 MB per loop
-      Out[2]: 76.40234375
+      maximum of 3: 76.402344 MB per loop
 
       In [3]: %memit np.ones(1e6)
-      best of 3: 7.820312 MB per loop
-      Out[3]: 7.8203125
+      maximum of 3: 7.820312 MB per loop
 
       In [4]: %memit -r 10 np.empty(1e8)
-      best of 10: 0.101562 MB per loop
-      Out[4]: 0.1015625
-
-    """"""
+      maximum of 10: 0.101562 MB per loop
 
-    import multiprocessing as pr
-    from multiprocessing.queues import SimpleQueue
+      In [5]: memit -t 3 while True: pass;
+      Subprocess timed out.
+      Subprocess timed out.
+      Subprocess timed out.
+      ERROR: all subprocesses exited unsuccessfully. Try again with the `-i`
+      option.
+      maximum of 3: -inf MB per loop
 
-    opts, stmt = self.parse_options(line, 'r:t:tcp:',
-                                    posix=False, strict=False)
-    repeat = int(getattr(opts, ""r"", 3))
+    """"""
+    opts, stmt = self.parse_options(line, 'r:t:i', posix=False, strict=False)
+    repeat = int(getattr(opts, 'r', 3))
     if repeat < 1:
         repeat == 1
-    timeout = int(getattr(opts, ""t"", 0))
+    timeout = int(getattr(opts, 't', 0))
     if timeout <= 0:
         timeout = None
+    run_in_place = hasattr(opts, 'i')
+
+    # Don't depend on multiprocessing:
+    try:
+        import multiprocessing as pr
+        from multiprocessing.queues import SimpleQueue
+        q = SimpleQueue()
+    except ImportError:
+        class ListWithPut(list):
+            ""Just a list where the `append` method is aliased to `put`.""
+            def put(self, x):
+                self.append(x)
+        q = ListWithPut()
+        print ('WARNING: cannot import module `multiprocessing`. Forcing the'
+               '`-i` option.')
+        run_in_place = True
 
     ns = self.shell.user_ns
 
@@ -468,30 +489,37 @@ def magic_memit(self, line=''):
             exec stmt in ns
             _mu1 = _mu()[0]
             q.put(_mu1 - _mu0)
-        except:
+        except Exception as e:
             q.put(float('-inf'))
+            raise e
 
-    q = SimpleQueue()
-    # try once in the current process
-    _get_usage(q, stmt, 'pass', ns)
-    # try in child processes
-    at_least_one_worked = False
-    for _ in xrange(repeat):
-        p = pr.Process(target=_get_usage, args=(q, stmt, 'pass', ns))
-        p.start()
-        p.join(timeout=timeout)
-        if p.exitcode == 0:
-            at_least_one_worked = True
-        else:
-            p.terminate()
-            q.put(float('-inf'))
-
-    if not at_least_one_worked:
-        print 'ERROR: subprocesses failed, result may be inaccurate.'
+    if run_in_place:
+        for _ in xrange(repeat):
+            _get_usage(q, stmt, ns=ns)
+    else:
+        # run in consecutive subprocesses
+        at_least_one_worked = False
+        for _ in xrange(repeat):
+            p = pr.Process(target=_get_usage, args=(q, stmt, 'pass', ns))
+            p.start()
+            p.join(timeout=timeout)
+            if p.exitcode == 0:
+                at_least_one_worked = True
+            else:
+                p.terminate()
+                if p.exitcode == None:
+                    print 'Subprocess timed out.'
+                else:
+                    print 'Subprocess exited with code %d.' % p.exitcode
+                q.put(float('-inf'))
+
+        if not at_least_one_worked:
+            print ('ERROR: all subprocesses exited unsuccessfully. Try again '
+                   'with the `-i` option.')
 
     usages = [q.get() for _ in xrange(repeat)]
     usage = max(usages)
-    print u""worst of %d: %f MB per loop"" % (repeat, usage)
+    print u""maximum of %d: %f MB per loop"" % (repeat, usage)
 
 
 if __name__ == '__main__':
","@@ -38,7 +38,8 @@ except ImportError:
             except:
                 return -1
     else:
-        raise NotImplementedError('The psutil module is required for non-unix platforms')
+        raise NotImplementedError('The psutil module is required for non-unix '
+                                  'platforms')
 
 
 def memory_usage(proc=-1, num=-1, interval=.1):
@@ -304,8 +305,8 @@ def magic_mprun(self, parameter_s=''):
 
     The given statement (which doesn't require quote marks) is run via the
     LineProfiler. Profiling is enabled for the functions specified by the -f
-    options. The statistics will be shown side-by-side with the code through the
-    pager once the statement has completed.
+    options. The statistics will be shown side-by-side with the code through
+    the pager once the statement has completed.
 
     Options:
 
@@ -319,8 +320,8 @@ def magic_mprun(self, parameter_s=''):
 
     One or more -f options are required to get any useful results.
 
-    -T <filename>: dump the text-formatted statistics with the code side-by-side
-    out to a text file.
+    -T <filename>: dump the text-formatted statistics with the code
+    side-by-side out to a text file.
 
     -r: return the LineProfiler object after it has completed profiling.
     """"""
@@ -418,13 +419,17 @@ def magic_memit(self, line=''):
     """"""Measure memory usage of a Python statement
 
     Usage, in line mode:
-      %memit [-r<R>] statement
+      %memit [-ir<R>t<T>] statement
 
     Options:
     -r<R>: repeat the loop iteration <R> times and take the best result.
     Default: 3
 
-    -t<T>: timeout after <T> seconds. Default: None
+    -i: run the code in the current environment, without forking a new process.
+    This is required on some MacOS versions of Accelerate if your line contains
+    a call to `np.dot`.
+
+    -t<T>: timeout after <T> seconds. Unused if `-i` is active. Default: None
 
     Examples
     --------
@@ -433,30 +438,46 @@ def magic_memit(self, line=''):
       In [1]: import numpy as np
 
       In [2]: %memit np.zeros(1e7)
-      best of 3: 76.402344 MB per loop
-      Out[2]: 76.40234375
+      maximum of 3: 76.402344 MB per loop
 
       In [3]: %memit np.ones(1e6)
-      best of 3: 7.820312 MB per loop
-      Out[3]: 7.8203125
+      maximum of 3: 7.820312 MB per loop
 
       In [4]: %memit -r 10 np.empty(1e8)
-      best of 10: 0.101562 MB per loop
-      Out[4]: 0.1015625
+      maximum of 10: 0.101562 MB per loop
+
+      In [5]: memit -t 3 while True: pass;
+      Subprocess timed out.
+      Subprocess timed out.
+      Subprocess timed out.
+      ERROR: all subprocesses exited unsuccessfully. Try again with the `-i`
+      option.
+      maximum of 3: -inf MB per loop
 
     """"""
-
-    import multiprocessing as pr
-    from multiprocessing.queues import SimpleQueue
-
-    opts, stmt = self.parse_options(line, 'r:t:tcp:',
-                                    posix=False, strict=False)
-    repeat = int(getattr(opts, ""r"", 3))
+    opts, stmt = self.parse_options(line, 'r:t:i', posix=False, strict=False)
+    repeat = int(getattr(opts, 'r', 3))
     if repeat < 1:
         repeat == 1
-    timeout = int(getattr(opts, ""t"", 0))
+    timeout = int(getattr(opts, 't', 0))
     if timeout <= 0:
         timeout = None
+    run_in_place = hasattr(opts, 'i')
+
+    # Don't depend on multiprocessing:
+    try:
+        import multiprocessing as pr
+        from multiprocessing.queues import SimpleQueue
+        q = SimpleQueue()
+    except ImportError:
+        class ListWithPut(list):
+            ""Just a list where the `append` method is aliased to `put`.""
+            def put(self, x):
+                self.append(x)
+        q = ListWithPut()
+        print ('WARNING: cannot import module `multiprocessing`. Forcing the'
+               '`-i` option.')
+        run_in_place = True
 
     ns = self.shell.user_ns
 
@@ -468,30 +489,37 @@ def magic_memit(self, line=''):
             exec stmt in ns
             _mu1 = _mu()[0]
             q.put(_mu1 - _mu0)
-        except:
+        except Exception as e:
             q.put(float('-inf'))
+            raise e
 
-    q = SimpleQueue()
-    # try once in the current process
-    _get_usage(q, stmt, 'pass', ns)
-    # try in child processes
-    at_least_one_worked = False
-    for _ in xrange(repeat):
-        p = pr.Process(target=_get_usage, args=(q, stmt, 'pass', ns))
-        p.start()
-        p.join(timeout=timeout)
-        if p.exitcode == 0:
-            at_least_one_worked = True
-        else:
-            p.terminate()
-            q.put(float('-inf'))
+    if run_in_place:
+        for _ in xrange(repeat):
+            _get_usage(q, stmt, ns=ns)
+    else:
+        # run in consecutive subprocesses
+        at_least_one_worked = False
+        for _ in xrange(repeat):
+            p = pr.Process(target=_get_usage, args=(q, stmt, 'pass', ns))
+            p.start()
+            p.join(timeout=timeout)
+            if p.exitcode == 0:
+                at_least_one_worked = True
+            else:
+                p.terminate()
+                if p.exitcode == None:
+                    print 'Subprocess timed out.'
+                else:
+                    print 'Subprocess exited with code %d.' % p.exitcode
+                q.put(float('-inf'))
 
-    if not at_least_one_worked:
-        print 'ERROR: subprocesses failed, result may be inaccurate.'
+        if not at_least_one_worked:
+            print ('ERROR: all subprocesses exited unsuccessfully. Try again '
+                   'with the `-i` option.')
 
     usages = [q.get() for _ in xrange(repeat)]
     usage = max(usages)
-    print u""worst of %d: %f MB per loop"" % (repeat, usage)
+    print u""maximum of %d: %f MB per loop"" % (repeat, usage)
 
 
 if __name__ == '__main__':
",False,memory_profiler.py,True
"@@ -21,7 +21,40 @@ To install from source, download the package, extract and type::
 
     $ python setup.py install
 
+After installing the module, if you use IPython, you can set up the `%mprun`
+and `%memit` magics by following these steps.
 
+For IPython 0.10, you can install it by editing the IPython configuration
+file ~/.ipython/ipy_user_conf.py to add the following lines::
+
+    # These two lines are standard and probably already there.
+    import IPython.ipapi
+    ip = IPython.ipapi.get()
+
+    # These two are the important ones.
+    import memory_profiler    
+    ip.expose_magic('mprun', memory_profiler.magic_mprun)
+    ip.expose_magic('memit', memory_profiler.magic_memit)prun)
+
+For IPython 0.11+, you have to  create a file named
+~/.ipython/extensions/memory_profiler_ext.py with the following content::
+
+    import memory_profiler
+     
+    def load_ipython_extension(ip):
+        ip.define_magic('mprun', memory_profiler.magic_mprun)
+        ip.define_magic('memit', memory_profiler.magic_memit)
+
+Then, edit the configuration file for your IPython profile,
+~/.ipython/profile_default/ipython_config.py, to register the extension like
+this (If you already have other extensions, just add this one to the list)::
+
+    c.TerminalIPythonApp.extensions = [
+        'memory_profiler_ext',
+    ]
+    c.InteractiveShellApp.extensions = [
+        'memory_profiler_ext',
+    ]
 
 =======
  Usage
@@ -69,6 +102,24 @@ Python interpreter after that line has been executed. The third column
 with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
+The same output can be obtained in IPython by using the `%mprun` magic command.
+In this case, you can skip the `@profile` decorator and instead use the
+`-f` parameter, like this::
+
+    In [1] from example import my_func
+
+    In [2] %mprun -f my_func my_func()
+
+Another useful magic that we define is `%memit`, which is analogous to
+`%timeit`. It can be used as follows::
+
+    In [1]: import numpy as np
+
+    In [2]: %memit np.zeros(1e7)
+    maximum of 3: 76.402344 MB per loop
+
+For more details, see the docstrings of the magics.
+
 ============================
  Frequently Asked Questions
 ============================
@@ -120,6 +171,8 @@ inspired by Robert Kern's `line profiler
 `Victor <https://github.com/octavo>`_ added python3, bugfixes and general
 cleanup.
 
+`Vlad <http://vene.ro/>`_ added the `%mprun` and `%memit` IPython magics. 
+
 
 =========
  License
","@@ -21,7 +21,40 @@ To install from source, download the package, extract and type::
 
     $ python setup.py install
 
+After installing the module, if you use IPython, you can set up the `%mprun`
+and `%memit` magics by following these steps.
 
+For IPython 0.10, you can install it by editing the IPython configuration
+file ~/.ipython/ipy_user_conf.py to add the following lines::
+
+    # These two lines are standard and probably already there.
+    import IPython.ipapi
+    ip = IPython.ipapi.get()
+
+    # These two are the important ones.
+    import memory_profiler    
+    ip.expose_magic('mprun', memory_profiler.magic_mprun)
+    ip.expose_magic('memit', memory_profiler.magic_memit)prun)
+
+For IPython 0.11+, you have to  create a file named
+~/.ipython/extensions/memory_profiler_ext.py with the following content::
+
+    import memory_profiler
+     
+    def load_ipython_extension(ip):
+        ip.define_magic('mprun', memory_profiler.magic_mprun)
+        ip.define_magic('memit', memory_profiler.magic_memit)
+
+Then, edit the configuration file for your IPython profile,
+~/.ipython/profile_default/ipython_config.py, to register the extension like
+this (If you already have other extensions, just add this one to the list)::
+
+    c.TerminalIPythonApp.extensions = [
+        'memory_profiler_ext',
+    ]
+    c.InteractiveShellApp.extensions = [
+        'memory_profiler_ext',
+    ]
 
 =======
  Usage
@@ -69,6 +102,24 @@ Python interpreter after that line has been executed. The third column
 with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
+The same output can be obtained in IPython by using the `%mprun` magic command.
+In this case, you can skip the `@profile` decorator and instead use the
+`-f` parameter, like this::
+
+    In [1] from example import my_func
+
+    In [2] %mprun -f my_func my_func()
+
+Another useful magic that we define is `%memit`, which is analogous to
+`%timeit`. It can be used as follows::
+
+    In [1]: import numpy as np
+
+    In [2]: %memit np.zeros(1e7)
+    maximum of 3: 76.402344 MB per loop
+
+For more details, see the docstrings of the magics.
+
 ============================
  Frequently Asked Questions
 ============================
@@ -120,6 +171,8 @@ inspired by Robert Kern's `line profiler
 `Victor <https://github.com/octavo>`_ added python3, bugfixes and general
 cleanup.
 
+`Vlad <http://vene.ro/>`_ added the `%mprun` and `%memit` IPython magics. 
+
 
 =========
  License
",True,README.rst,False
"@@ -271,6 +271,8 @@ def show_results(prof, stream=None):
 
         k_old = keys[0] - 1
         lines_normalized[keys[0] - 1] = lines[keys[0]]
+        for i in range(1, len(lines_normalized[keys[0] - 1])):
+            lines_normalized[keys[0] - 1][i] = -1.
         k = keys.pop(0)
         while keys:
             lines_normalized[k] = lines[keys[0]]
","@@ -271,6 +271,8 @@ def show_results(prof, stream=None):
 
         k_old = keys[0] - 1
         lines_normalized[keys[0] - 1] = lines[keys[0]]
+        for i in range(1, len(lines_normalized[keys[0] - 1])):
+            lines_normalized[keys[0] - 1][i] = -1.
         k = keys.pop(0)
         while keys:
             lines_normalized[k] = lines[keys[0]]
",True,memory_profiler.py,True
"@@ -184,7 +184,7 @@ class LineProfiler:
         """"""
         self.enable_by_count()
         try:
-            exec cmd in globals, locals
+            exec(cmd, globals, locals)
         finally:
             self.disable_by_count()
         return self
","@@ -184,7 +184,7 @@ class LineProfiler:
         """"""
         self.enable_by_count()
         try:
-            exec cmd in globals, locals
+            exec(cmd, globals, locals)
         finally:
             self.disable_by_count()
         return self
",True,memory_profiler.py,True
"@@ -45,6 +45,11 @@ For IPython 0.11+, you have to  create a file named
         ip.define_magic('mprun', memory_profiler.magic_mprun)
         ip.define_magic('memit', memory_profiler.magic_memit)
 
+If you don't have an IPython profile already set up, create one using the
+following command::
+
+    $ ipython profile create
+
 Then, edit the configuration file for your IPython profile,
 ~/.ipython/profile_default/ipython_config.py, to register the extension like
 this (If you already have other extensions, just add this one to the list)::
","@@ -45,6 +45,11 @@ For IPython 0.11+, you have to  create a file named
         ip.define_magic('mprun', memory_profiler.magic_mprun)
         ip.define_magic('memit', memory_profiler.magic_memit)
 
+If you don't have an IPython profile already set up, create one using the
+following command::
+
+    $ ipython profile create
+
 Then, edit the configuration file for your IPython profile,
 ~/.ipython/profile_default/ipython_config.py, to register the extension like
 this (If you already have other extensions, just add this one to the list)::
",True,README.rst,False
"@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.14'
+__version__ = '0.15'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.14'
+__version__ = '0.15'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -255,6 +255,9 @@ def show_results(prof, stream=None):
         stream.write('Filename: ' + filename + '\n\n')
         if not os.path.exists(filename):
             stream.write('ERROR: Could not find file ' + filename + '\n')
+            if filename.startswith(""ipython-input""):
+                print(""NOTE: %mprun can only be used on functions defined in ""
+                      ""physical files, and not in the IPython environment."")
             continue
         all_lines = linecache.getlines(filename)
         sub_lines = inspect.getblock(all_lines[code.co_firstlineno - 1:])
@@ -425,7 +428,7 @@ def magic_memit(self, line=''):
 
     Options:
     -r<R>: repeat the loop iteration <R> times and take the best result.
-    Default: 3
+    Default: 1
 
     -i: run the code in the current environment, without forking a new process.
     This is required on some MacOS versions of Accelerate if your line contains
@@ -440,10 +443,10 @@ def magic_memit(self, line=''):
       In [1]: import numpy as np
 
       In [2]: %memit np.zeros(1e7)
-      maximum of 3: 76.402344 MB per loop
+      maximum of 1: 76.402344 MB per loop
 
       In [3]: %memit np.ones(1e6)
-      maximum of 3: 7.820312 MB per loop
+      maximum of 1: 7.820312 MB per loop
 
       In [4]: %memit -r 10 np.empty(1e8)
       maximum of 10: 0.101562 MB per loop
@@ -454,11 +457,11 @@ def magic_memit(self, line=''):
       Subprocess timed out.
       ERROR: all subprocesses exited unsuccessfully. Try again with the `-i`
       option.
-      maximum of 3: -inf MB per loop
+      maximum of 1: -inf MB per loop
 
     """"""
     opts, stmt = self.parse_options(line, 'r:t:i', posix=False, strict=False)
-    repeat = int(getattr(opts, 'r', 3))
+    repeat = int(getattr(opts, 'r', 1))
     if repeat < 1:
         repeat == 1
     timeout = int(getattr(opts, 't', 0))
","@@ -255,6 +255,9 @@ def show_results(prof, stream=None):
         stream.write('Filename: ' + filename + '\n\n')
         if not os.path.exists(filename):
             stream.write('ERROR: Could not find file ' + filename + '\n')
+            if filename.startswith(""ipython-input""):
+                print(""NOTE: %mprun can only be used on functions defined in ""
+                      ""physical files, and not in the IPython environment."")
             continue
         all_lines = linecache.getlines(filename)
         sub_lines = inspect.getblock(all_lines[code.co_firstlineno - 1:])
@@ -425,7 +428,7 @@ def magic_memit(self, line=''):
 
     Options:
     -r<R>: repeat the loop iteration <R> times and take the best result.
-    Default: 3
+    Default: 1
 
     -i: run the code in the current environment, without forking a new process.
     This is required on some MacOS versions of Accelerate if your line contains
@@ -440,10 +443,10 @@ def magic_memit(self, line=''):
       In [1]: import numpy as np
 
       In [2]: %memit np.zeros(1e7)
-      maximum of 3: 76.402344 MB per loop
+      maximum of 1: 76.402344 MB per loop
 
       In [3]: %memit np.ones(1e6)
-      maximum of 3: 7.820312 MB per loop
+      maximum of 1: 7.820312 MB per loop
 
       In [4]: %memit -r 10 np.empty(1e8)
       maximum of 10: 0.101562 MB per loop
@@ -454,11 +457,11 @@ def magic_memit(self, line=''):
       Subprocess timed out.
       ERROR: all subprocesses exited unsuccessfully. Try again with the `-i`
       option.
-      maximum of 3: -inf MB per loop
+      maximum of 1: -inf MB per loop
 
     """"""
     opts, stmt = self.parse_options(line, 'r:t:i', posix=False, strict=False)
-    repeat = int(getattr(opts, 'r', 3))
+    repeat = int(getattr(opts, 'r', 1))
     if repeat < 1:
         repeat == 1
     timeout = int(getattr(opts, 't', 0))
",True,memory_profiler.py,True
"@@ -294,8 +294,8 @@ def show_results(prof, stream=None):
                 mem = max(lines_normalized[l])
                 inc = mem - mem_old
                 mem_old = mem
-                mem = '{0:5.4f} MB'.format(mem)
-                inc = '{0:5.4f} MB'.format(inc)
+                mem = '{0:9.2f} MB'.format(mem)
+                inc = '{0:9.2f} MB'.format(inc)
             stream.write(template.format(l, mem, inc, sub_lines[i]))
         stream.write('\n\n')
 
","@@ -294,8 +294,8 @@ def show_results(prof, stream=None):
                 mem = max(lines_normalized[l])
                 inc = mem - mem_old
                 mem_old = mem
-                mem = '{0:5.4f} MB'.format(mem)
-                inc = '{0:5.4f} MB'.format(inc)
+                mem = '{0:9.2f} MB'.format(mem)
+                inc = '{0:9.2f} MB'.format(inc)
             stream.write(template.format(l, mem, inc, sub_lines[i]))
         stream.write('\n\n')
 
",True,memory_profiler.py,True
"@@ -242,7 +242,7 @@ class LineProfiler:
 def show_results(prof, stream=None):
     if stream is None:
         stream = sys.stdout
-    template = '{0:>6} {1:>12} {2:>10}   {3:<}'
+    template = '{0:>6} {1:>12} {2:>12}   {3:<}'
 
     for code in prof.code_map:
         lines = prof.code_map[code]
","@@ -242,7 +242,7 @@ class LineProfiler:
 def show_results(prof, stream=None):
     if stream is None:
         stream = sys.stdout
-    template = '{0:>6} {1:>12} {2:>10}   {3:<}'
+    template = '{0:>6} {1:>12} {2:>12}   {3:<}'
 
     for code in prof.code_map:
         lines = prof.code_map[code]
",True,memory_profiler.py,True
"@@ -4,13 +4,12 @@ __version__ = '0.15'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
-import time
-import sys
-import os
+import time, sys, os, pdb
 import warnings
 import linecache
 import inspect
 
+
 try:
     import psutil
 
@@ -42,6 +41,7 @@ except ImportError:
                                   'platforms')
 
 
+
 def memory_usage(proc=-1, num=-1, interval=.1):
     """"""
     Return the memory usage of a process or piece of code
@@ -130,12 +130,13 @@ def _find_script(script_name):
 class LineProfiler:
     """""" A profiler that records the amount of memory for each line """"""
 
-    def __init__(self, *functions):
+    def __init__(self, *functions, **kw):
         self.functions = list(functions)
         self.code_map = {}
         self.enable_count = 0
         for func in functions:
             self.add_function(func)
+        self.max_mem = kw.get('max_mem', None)
 
     def __call__(self, func):
         self.add_function(func)
@@ -163,6 +164,7 @@ class LineProfiler:
     def wrap_function(self, func):
         """""" Wrap a function to profile it.
         """"""
+
         def f(*args, **kwds):
             self.enable_by_count()
             try:
@@ -225,6 +227,26 @@ class LineProfiler:
 
         return self.trace_memory_usage
 
+    def trace_max_mem(self, frame, event, arg):
+        # run into PDB as soon as memory is higher than MAX_MEM
+        if event in ('line', 'return'):
+            c = _get_memory(os.getpid())
+            if c >= self.max_mem:
+                t = 'Current memory {0:.2f} MB exceeded the maximum '.format(c) + \
+                    'of {0:.2f} MB\n'.format(self.max_mem)
+                sys.stdout.write(t)
+                sys.stdout.write('Stepping into the debugger \n')
+                frame.f_lineno -= 2
+                p = pdb.Pdb()
+                p.quitting = False
+                p.stopframe = frame
+                p.returnframe = None
+                p.stoplineno = frame.f_lineno - 3
+                p.botframe = None
+                return p.trace_dispatch
+
+        return self.trace_max_mem
+
     def __enter__(self):
         self.enable_by_count()
 
@@ -232,7 +254,10 @@ class LineProfiler:
         self.disable_by_count()
 
     def enable(self):
-        sys.settrace(self.trace_memory_usage)
+        if self.max_mem is not None:
+            sys.settrace(self.trace_max_mem)
+        else:
+            sys.settrace(self.trace_memory_usage)
 
     def disable(self):
         self.last_time = {}
@@ -529,7 +554,10 @@ def magic_memit(self, line=''):
 
 if __name__ == '__main__':
     from optparse import OptionParser
-    parser = OptionParser(usage=_CMD_USAGE)
+    parser = OptionParser(usage=_CMD_USAGE, version=__version__)
+    parser.add_option(""--pdb-mmem"", dest=""max_mem"", metavar=""MAXMEM"",
+        type=""float"", action=""store"",
+        help=""step into the debugger when memory exceeds MAXMEM"")
 
     if not sys.argv[1:]:
         parser.print_help()
@@ -537,10 +565,7 @@ if __name__ == '__main__':
 
     (options, args) = parser.parse_args()
 
-    # .. remove memory_profiler from sys.argv ..
-    sys.argv.pop(0)
-
-    prof = LineProfiler()
+    prof = LineProfiler(max_mem=options.max_mem)
     __file__ = _find_script(args[0])
     if sys.version_info[0] < 3:
         import __builtin__
","@@ -4,13 +4,12 @@ __version__ = '0.15'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
-import time
-import sys
-import os
+import time, sys, os, pdb
 import warnings
 import linecache
 import inspect
 
+
 try:
     import psutil
 
@@ -42,6 +41,7 @@ except ImportError:
                                   'platforms')
 
 
+
 def memory_usage(proc=-1, num=-1, interval=.1):
     """"""
     Return the memory usage of a process or piece of code
@@ -130,12 +130,13 @@ def _find_script(script_name):
 class LineProfiler:
     """""" A profiler that records the amount of memory for each line """"""
 
-    def __init__(self, *functions):
+    def __init__(self, *functions, **kw):
         self.functions = list(functions)
         self.code_map = {}
         self.enable_count = 0
         for func in functions:
             self.add_function(func)
+        self.max_mem = kw.get('max_mem', None)
 
     def __call__(self, func):
         self.add_function(func)
@@ -163,6 +164,7 @@ class LineProfiler:
     def wrap_function(self, func):
         """""" Wrap a function to profile it.
         """"""
+
         def f(*args, **kwds):
             self.enable_by_count()
             try:
@@ -225,6 +227,26 @@ class LineProfiler:
 
         return self.trace_memory_usage
 
+    def trace_max_mem(self, frame, event, arg):
+        # run into PDB as soon as memory is higher than MAX_MEM
+        if event in ('line', 'return'):
+            c = _get_memory(os.getpid())
+            if c >= self.max_mem:
+                t = 'Current memory {0:.2f} MB exceeded the maximum '.format(c) + \
+                    'of {0:.2f} MB\n'.format(self.max_mem)
+                sys.stdout.write(t)
+                sys.stdout.write('Stepping into the debugger \n')
+                frame.f_lineno -= 2
+                p = pdb.Pdb()
+                p.quitting = False
+                p.stopframe = frame
+                p.returnframe = None
+                p.stoplineno = frame.f_lineno - 3
+                p.botframe = None
+                return p.trace_dispatch
+
+        return self.trace_max_mem
+
     def __enter__(self):
         self.enable_by_count()
 
@@ -232,7 +254,10 @@ class LineProfiler:
         self.disable_by_count()
 
     def enable(self):
-        sys.settrace(self.trace_memory_usage)
+        if self.max_mem is not None:
+            sys.settrace(self.trace_max_mem)
+        else:
+            sys.settrace(self.trace_memory_usage)
 
     def disable(self):
         self.last_time = {}
@@ -529,7 +554,10 @@ def magic_memit(self, line=''):
 
 if __name__ == '__main__':
     from optparse import OptionParser
-    parser = OptionParser(usage=_CMD_USAGE)
+    parser = OptionParser(usage=_CMD_USAGE, version=__version__)
+    parser.add_option(""--pdb-mmem"", dest=""max_mem"", metavar=""MAXMEM"",
+        type=""float"", action=""store"",
+        help=""step into the debugger when memory exceeds MAXMEM"")
 
     if not sys.argv[1:]:
         parser.print_help()
@@ -537,10 +565,7 @@ if __name__ == '__main__':
 
     (options, args) = parser.parse_args()
 
-    # .. remove memory_profiler from sys.argv ..
-    sys.argv.pop(0)
-
-    prof = LineProfiler()
+    prof = LineProfiler(max_mem=options.max_mem)
     __file__ = _find_script(args[0])
     if sys.version_info[0] < 3:
         import __builtin__
",True,memory_profiler.py,True
"@@ -383,7 +383,7 @@ def magic_mprun(self, parameter_s=''):
     for name in opts.f:
         try:
             funcs.append(eval(name, global_ns, local_ns))
-        except Exception, e:
+        except Exception as e:
             raise UsageError('Could not find function %r.\n%s: %s' % (name,
                 e.__class__.__name__, e))
 
@@ -421,7 +421,7 @@ def magic_mprun(self, parameter_s=''):
         page(output, screen_lines=self.shell.rc.screen_length)
     else:
         page(output)
-    print message,
+    print(message,)
 
 #    dump_file = opts.D[0]
 #    if dump_file:
@@ -434,8 +434,8 @@ def magic_mprun(self, parameter_s=''):
         pfile = open(text_file, 'w')
         pfile.write(output)
         pfile.close()
-        print '\n*** Profile printout saved to text file %s. %s' % (text_file,
-                                                                    message)
+        print('\n*** Profile printout saved to text file %s. %s' % (text_file,
+                                                                    message))
 
     return_value = None
     if 'r' in opts:
@@ -538,9 +538,9 @@ def magic_memit(self, line=''):
             else:
                 p.terminate()
                 if p.exitcode == None:
-                    print 'Subprocess timed out.'
+                    print('Subprocess timed out.')
                 else:
-                    print 'Subprocess exited with code %d.' % p.exitcode
+                    print('Subprocess exited with code %d.' % p.exitcode)
                 q.put(float('-inf'))
 
         if not at_least_one_worked:
@@ -549,7 +549,7 @@ def magic_memit(self, line=''):
 
     usages = [q.get() for _ in xrange(repeat)]
     usage = max(usages)
-    print u""maximum of %d: %f MB per loop"" % (repeat, usage)
+    print('maximum of %d: %f MB per loop' % (repeat, usage))
 
 
 if __name__ == '__main__':
","@@ -383,7 +383,7 @@ def magic_mprun(self, parameter_s=''):
     for name in opts.f:
         try:
             funcs.append(eval(name, global_ns, local_ns))
-        except Exception, e:
+        except Exception as e:
             raise UsageError('Could not find function %r.\n%s: %s' % (name,
                 e.__class__.__name__, e))
 
@@ -421,7 +421,7 @@ def magic_mprun(self, parameter_s=''):
         page(output, screen_lines=self.shell.rc.screen_length)
     else:
         page(output)
-    print message,
+    print(message,)
 
 #    dump_file = opts.D[0]
 #    if dump_file:
@@ -434,8 +434,8 @@ def magic_mprun(self, parameter_s=''):
         pfile = open(text_file, 'w')
         pfile.write(output)
         pfile.close()
-        print '\n*** Profile printout saved to text file %s. %s' % (text_file,
-                                                                    message)
+        print('\n*** Profile printout saved to text file %s. %s' % (text_file,
+                                                                    message))
 
     return_value = None
     if 'r' in opts:
@@ -538,9 +538,9 @@ def magic_memit(self, line=''):
             else:
                 p.terminate()
                 if p.exitcode == None:
-                    print 'Subprocess timed out.'
+                    print('Subprocess timed out.')
                 else:
-                    print 'Subprocess exited with code %d.' % p.exitcode
+                    print('Subprocess exited with code %d.' % p.exitcode)
                 q.put(float('-inf'))
 
         if not at_least_one_worked:
@@ -549,7 +549,7 @@ def magic_memit(self, line=''):
 
     usages = [q.get() for _ in xrange(repeat)]
     usage = max(usages)
-    print u""maximum of %d: %f MB per loop"" % (repeat, usage)
+    print('maximum of %d: %f MB per loop' % (repeat, usage))
 
 
 if __name__ == '__main__':
",True,memory_profiler.py,True
"@@ -443,6 +443,19 @@ def magic_mprun(self, parameter_s=''):
 
     return return_value
 
+# utility function used in magic_memit
+# TODO: merge sith memory_usage
+def _get_usage(q, stmt, setup='pass', ns={}):
+    from memory_profiler import memory_usage as _mu
+    try:
+        exec(setup, ns)
+        _mu0 = _mu()[0]
+        exec(stmt, ns)
+        _mu1 = _mu()[0]
+        q.put(_mu1 - _mu0)
+    except Exception as e:
+        q.put(float('-inf'))
+        raise e
 
 # a timeit-style %memit magic for IPython
 def magic_memit(self, line=''):
@@ -511,18 +524,6 @@ def magic_memit(self, line=''):
 
     ns = self.shell.user_ns
 
-    def _get_usage(q, stmt, setup='pass', ns={}):
-        from memory_profiler import memory_usage as _mu
-        try:
-            exec setup in ns
-            _mu0 = _mu()[0]
-            exec stmt in ns
-            _mu1 = _mu()[0]
-            q.put(_mu1 - _mu0)
-        except Exception as e:
-            q.put(float('-inf'))
-            raise e
-
     if run_in_place:
         for _ in xrange(repeat):
             _get_usage(q, stmt, ns=ns)
","@@ -443,6 +443,19 @@ def magic_mprun(self, parameter_s=''):
 
     return return_value
 
+# utility function used in magic_memit
+# TODO: merge sith memory_usage
+def _get_usage(q, stmt, setup='pass', ns={}):
+    from memory_profiler import memory_usage as _mu
+    try:
+        exec(setup, ns)
+        _mu0 = _mu()[0]
+        exec(stmt, ns)
+        _mu1 = _mu()[0]
+        q.put(_mu1 - _mu0)
+    except Exception as e:
+        q.put(float('-inf'))
+        raise e
 
 # a timeit-style %memit magic for IPython
 def magic_memit(self, line=''):
@@ -511,18 +524,6 @@ def magic_memit(self, line=''):
 
     ns = self.shell.user_ns
 
-    def _get_usage(q, stmt, setup='pass', ns={}):
-        from memory_profiler import memory_usage as _mu
-        try:
-            exec setup in ns
-            _mu0 = _mu()[0]
-            exec stmt in ns
-            _mu1 = _mu()[0]
-            q.put(_mu1 - _mu0)
-        except Exception as e:
-            q.put(float('-inf'))
-            raise e
-
     if run_in_place:
         for _ in xrange(repeat):
             _get_usage(q, stmt, ns=ns)
",True,memory_profiler.py,True
"@@ -21,45 +21,6 @@ To install from source, download the package, extract and type::
 
     $ python setup.py install
 
-After installing the module, if you use IPython, you can set up the `%mprun`
-and `%memit` magics by following these steps.
-
-For IPython 0.10, you can install it by editing the IPython configuration
-file ~/.ipython/ipy_user_conf.py to add the following lines::
-
-    # These two lines are standard and probably already there.
-    import IPython.ipapi
-    ip = IPython.ipapi.get()
-
-    # These two are the important ones.
-    import memory_profiler    
-    ip.expose_magic('mprun', memory_profiler.magic_mprun)
-    ip.expose_magic('memit', memory_profiler.magic_memit)prun)
-
-For IPython 0.11+, you have to  create a file named
-~/.ipython/extensions/memory_profiler_ext.py with the following content::
-
-    import memory_profiler
-     
-    def load_ipython_extension(ip):
-        ip.define_magic('mprun', memory_profiler.magic_mprun)
-        ip.define_magic('memit', memory_profiler.magic_memit)
-
-If you don't have an IPython profile already set up, create one using the
-following command::
-
-    $ ipython profile create
-
-Then, edit the configuration file for your IPython profile,
-~/.ipython/profile_default/ipython_config.py, to register the extension like
-this (If you already have other extensions, just add this one to the list)::
-
-    c.TerminalIPythonApp.extensions = [
-        'memory_profiler_ext',
-    ]
-    c.InteractiveShellApp.extensions = [
-        'memory_profiler_ext',
-    ]
 
 =======
  Usage
@@ -107,9 +68,55 @@ Python interpreter after that line has been executed. The third column
 with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
-The same output can be obtained in IPython by using the `%mprun` magic command.
-In this case, you can skip the `@profile` decorator and instead use the
-`-f` parameter, like this::
+
+
+===================
+Ipython integration
+===================
+
+After installing the module, if you use IPython, you can set up the `%mprun`
+and `%memit` magics by following these steps.
+
+For IPython 0.10, you can install it by editing the IPython configuration
+file ~/.ipython/ipy_user_conf.py to add the following lines::
+
+    # These two lines are standard and probably already there.
+    import IPython.ipapi
+    ip = IPython.ipapi.get()
+
+    # These two are the important ones.
+    import memory_profiler
+    ip.expose_magic('mprun', memory_profiler.magic_mprun)
+    ip.expose_magic('memit', memory_profiler.magic_memit)prun)
+
+For IPython 0.11+, you have to edit the file
+~/.ipython/extensions/memory_profiler_ext.py with the following content::
+
+    import memory_profiler
+
+    def load_ipython_extension(ip):
+        ip.define_magic('mprun', memory_profiler.magic_mprun)
+        ip.define_magic('memit', memory_profiler.magic_memit)
+
+If you don't have an IPython profile already set up, create one using the
+following command::
+
+    $ ipython profile create
+
+Then, edit the configuration file for your IPython profile,
+~/.ipython/profile_default/ipython_config.py, to register the extension like
+this (If you already have other extensions, just add this one to the list)::
+
+    c.TerminalIPythonApp.extensions = [
+        'memory_profiler_ext',
+    ]
+    c.InteractiveShellApp.extensions = [
+        'memory_profiler_ext',
+    ]
+
+It then can be used directly from IPython to obtain a line-by-line report using
+the `%mprun` magic command. In this case, you can skip the `@profile` decorator
+and instead use the `-f` parameter, like this::
 
     In [1] from example import my_func
 
@@ -176,7 +183,7 @@ inspired by Robert Kern's `line profiler
 `Victor <https://github.com/octavo>`_ added python3, bugfixes and general
 cleanup.
 
-`Vlad Niculae <http://vene.ro/>`_ added the `%mprun` and `%memit` IPython magics. 
+`Vlad Niculae <http://vene.ro/>`_ added the `%mprun` and `%memit` IPython magics.
 
 
 
","@@ -21,45 +21,6 @@ To install from source, download the package, extract and type::
 
     $ python setup.py install
 
-After installing the module, if you use IPython, you can set up the `%mprun`
-and `%memit` magics by following these steps.
-
-For IPython 0.10, you can install it by editing the IPython configuration
-file ~/.ipython/ipy_user_conf.py to add the following lines::
-
-    # These two lines are standard and probably already there.
-    import IPython.ipapi
-    ip = IPython.ipapi.get()
-
-    # These two are the important ones.
-    import memory_profiler    
-    ip.expose_magic('mprun', memory_profiler.magic_mprun)
-    ip.expose_magic('memit', memory_profiler.magic_memit)prun)
-
-For IPython 0.11+, you have to  create a file named
-~/.ipython/extensions/memory_profiler_ext.py with the following content::
-
-    import memory_profiler
-     
-    def load_ipython_extension(ip):
-        ip.define_magic('mprun', memory_profiler.magic_mprun)
-        ip.define_magic('memit', memory_profiler.magic_memit)
-
-If you don't have an IPython profile already set up, create one using the
-following command::
-
-    $ ipython profile create
-
-Then, edit the configuration file for your IPython profile,
-~/.ipython/profile_default/ipython_config.py, to register the extension like
-this (If you already have other extensions, just add this one to the list)::
-
-    c.TerminalIPythonApp.extensions = [
-        'memory_profiler_ext',
-    ]
-    c.InteractiveShellApp.extensions = [
-        'memory_profiler_ext',
-    ]
 
 =======
  Usage
@@ -107,9 +68,55 @@ Python interpreter after that line has been executed. The third column
 with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
-The same output can be obtained in IPython by using the `%mprun` magic command.
-In this case, you can skip the `@profile` decorator and instead use the
-`-f` parameter, like this::
+
+
+===================
+Ipython integration
+===================
+
+After installing the module, if you use IPython, you can set up the `%mprun`
+and `%memit` magics by following these steps.
+
+For IPython 0.10, you can install it by editing the IPython configuration
+file ~/.ipython/ipy_user_conf.py to add the following lines::
+
+    # These two lines are standard and probably already there.
+    import IPython.ipapi
+    ip = IPython.ipapi.get()
+
+    # These two are the important ones.
+    import memory_profiler
+    ip.expose_magic('mprun', memory_profiler.magic_mprun)
+    ip.expose_magic('memit', memory_profiler.magic_memit)prun)
+
+For IPython 0.11+, you have to edit the file
+~/.ipython/extensions/memory_profiler_ext.py with the following content::
+
+    import memory_profiler
+
+    def load_ipython_extension(ip):
+        ip.define_magic('mprun', memory_profiler.magic_mprun)
+        ip.define_magic('memit', memory_profiler.magic_memit)
+
+If you don't have an IPython profile already set up, create one using the
+following command::
+
+    $ ipython profile create
+
+Then, edit the configuration file for your IPython profile,
+~/.ipython/profile_default/ipython_config.py, to register the extension like
+this (If you already have other extensions, just add this one to the list)::
+
+    c.TerminalIPythonApp.extensions = [
+        'memory_profiler_ext',
+    ]
+    c.InteractiveShellApp.extensions = [
+        'memory_profiler_ext',
+    ]
+
+It then can be used directly from IPython to obtain a line-by-line report using
+the `%mprun` magic command. In this case, you can skip the `@profile` decorator
+and instead use the `-f` parameter, like this::
 
     In [1] from example import my_func
 
@@ -176,7 +183,7 @@ inspired by Robert Kern's `line profiler
 `Victor <https://github.com/octavo>`_ added python3, bugfixes and general
 cleanup.
 
-`Vlad Niculae <http://vene.ro/>`_ added the `%mprun` and `%memit` IPython magics. 
+`Vlad Niculae <http://vene.ro/>`_ added the `%mprun` and `%memit` IPython magics.
 
 
 
",True,README.rst,False
"@@ -151,7 +151,8 @@ class LineProfiler:
         """""" Record line profiling information for the given Python function.
         """"""
         try:
-            code = func.func_code
+            # func_code does not exist in Python3
+            code = func.__code__
         except AttributeError:
             import warnings
             warnings.warn(""Could not extract a code object for the object %r""
","@@ -151,7 +151,8 @@ class LineProfiler:
         """""" Record line profiling information for the given Python function.
         """"""
         try:
-            code = func.func_code
+            # func_code does not exist in Python3
+            code = func.__code__
         except AttributeError:
             import warnings
             warnings.warn(""Could not extract a code object for the object %r""
",True,memory_profiler.py,True
"@@ -180,7 +180,7 @@ inspired by Robert Kern's `line profiler
 `Tom <http://tomforb.es/>`_ added windows support and speed improvements via the
 `psutil <http://pypi.python.org/pypi/psutil>`_ module.
 
-`Victor <https://github.com/octavo>`_ added python3, bugfixes and general
+`Victor <https://github.com/octavo>`_ added python3 support, bugfixes and general
 cleanup.
 
 `Vlad Niculae <http://vene.ro/>`_ added the `%mprun` and `%memit` IPython magics.
","@@ -180,7 +180,7 @@ inspired by Robert Kern's `line profiler
 `Tom <http://tomforb.es/>`_ added windows support and speed improvements via the
 `psutil <http://pypi.python.org/pypi/psutil>`_ module.
 
-`Victor <https://github.com/octavo>`_ added python3, bugfixes and general
+`Victor <https://github.com/octavo>`_ added python3 support, bugfixes and general
 cleanup.
 
 `Vlad Niculae <http://vene.ro/>`_ added the `%mprun` and `%memit` IPython magics.
",True,README.rst,False
"@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.15'
+__version__ = '0.16'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.15'
+__version__ = '0.16'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -87,7 +87,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
     # These two are the important ones.
     import memory_profiler
     ip.expose_magic('mprun', memory_profiler.magic_mprun)
-    ip.expose_magic('memit', memory_profiler.magic_memit)prun)
+    ip.expose_magic('memit', memory_profiler.magic_memit)
 
 For IPython 0.11+, you have to edit the file
 ~/.ipython/extensions/memory_profiler_ext.py with the following content::
","@@ -87,7 +87,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
     # These two are the important ones.
     import memory_profiler
     ip.expose_magic('mprun', memory_profiler.magic_mprun)
-    ip.expose_magic('memit', memory_profiler.magic_memit)prun)
+    ip.expose_magic('memit', memory_profiler.magic_memit)
 
 For IPython 0.11+, you have to edit the file
 ~/.ipython/extensions/memory_profiler_ext.py with the following content::
",True,README.rst,False
"@@ -57,8 +57,7 @@ def memory_usage(proc=-1, num=-1, interval=.1):
     interval : int, optional
 
     num : int, optional
-        Number of samples to generate. In the case of
-        defaults to -1, meaning
+        Maximum number of retrievals. In the case of -1, meaning
         to wait until the process has finished if proc is a string or
         to get just one if proc is an integer.
 
@@ -67,7 +66,7 @@ def memory_usage(proc=-1, num=-1, interval=.1):
 
     Returns
     -------
-    mm : list of integers
+    mm : list of integers, size less than num
         memory usage, in KB
     """"""
     ret = []
","@@ -57,8 +57,7 @@ def memory_usage(proc=-1, num=-1, interval=.1):
     interval : int, optional
 
     num : int, optional
-        Number of samples to generate. In the case of
-        defaults to -1, meaning
+        Maximum number of retrievals. In the case of -1, meaning
         to wait until the process has finished if proc is a string or
         to get just one if proc is an integer.
 
@@ -67,7 +66,7 @@ def memory_usage(proc=-1, num=-1, interval=.1):
 
     Returns
     -------
-    mm : list of integers
+    mm : list of integers, size less than num
         memory usage, in KB
     """"""
     ret = []
",True,memory_profiler.py,True
"@@ -69,6 +69,34 @@ with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
 
+====
+API
+====
+
+memory_profiler exposes a number of functions to be used in third-party
+code.
+
+`memory_usage(proc=-1, num=-1, interval=.1)` returns the memory usage
+over a time interval. The first argument, `proc` represents what
+should be monitored.  This can either be the PID of a process (not
+necessarily a Python program), a string containing some python code to
+be evaluated or a tuple (f, args, kw) containing a function and its
+arguments to be evaluated as f(*args, **kw). For example::
+
+
+    >>> # define a simple function
+    >>> def f(a, n=100):
+        ...     import time
+        ...     time.sleep(2)
+        ...     b = [a] * n
+        ...     time.sleep(1)
+        ...     return b
+        ...
+    >>> from memory_profiler import memory_usage
+    >>> memory_usage((f, (1,), {'n' : int(1e6)}))
+
+
+
 
 ===================
 Ipython integration
","@@ -69,6 +69,34 @@ with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
 
+====
+API
+====
+
+memory_profiler exposes a number of functions to be used in third-party
+code.
+
+`memory_usage(proc=-1, num=-1, interval=.1)` returns the memory usage
+over a time interval. The first argument, `proc` represents what
+should be monitored.  This can either be the PID of a process (not
+necessarily a Python program), a string containing some python code to
+be evaluated or a tuple (f, args, kw) containing a function and its
+arguments to be evaluated as f(*args, **kw). For example::
+
+
+    >>> # define a simple function
+    >>> def f(a, n=100):
+        ...     import time
+        ...     time.sleep(2)
+        ...     b = [a] * n
+        ...     time.sleep(1)
+        ...     return b
+        ...
+    >>> from memory_profiler import memory_usage
+    >>> memory_usage((f, (1,), {'n' : int(1e6)}))
+
+
+
 
 ===================
 Ipython integration
",True,README.rst,False
"@@ -5,7 +5,7 @@ __version__ = '0.16'
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
 import time, sys, os, pdb
-import warnings
+import warnings, multiprocessing
 import linecache
 import inspect
 
@@ -41,18 +41,17 @@ except ImportError:
                                   'platforms')
 
 
-
 def memory_usage(proc=-1, num=-1, interval=.1):
     """"""
     Return the memory usage of a process or piece of code
 
     Parameters
     ----------
-    proc : {int, string, tuple}
-        The process to monitor. Can be given by a PID or by a string
-        containing a filename. A tuple containing (f, args, kwargs) specifies
-        to run the function f(*args, **kwargs). Set to -1 (default)for
-        current process.
+    proc : {int, string, tuple}, optional
+        The process to monitor. Can be given by a PID, by a string
+        containing a filename or by a tuple. The tuple should contain
+        three values (f, args, kw) specifies to run the function
+        f(*args, **kw).  Set to -1 (default) for current process.
 
     interval : int, optional
 
@@ -61,8 +60,6 @@ def memory_usage(proc=-1, num=-1, interval=.1):
         to wait until the process has finished if proc is a string or
         to get just one if proc is an integer.
 
-    locals : dict
-        Local variables.
 
     Returns
     -------
@@ -71,29 +68,35 @@ def memory_usage(proc=-1, num=-1, interval=.1):
     """"""
     ret = []
 
+
     if str(proc).endswith('.py'):
         filename = _find_script(proc)
         with open(filename) as f:
             proc = f.read()
-
-        # TODO: make sure script's directory is on sys.path
-        def f_exec(x, locals):
-            # function interface for exec
-            exec(x, locals)
-        proc = (f_exec, (), {})
+        raise NotImplementedError
 
     if isinstance(proc, (list, tuple)):
-        from multiprocessing import Process
+
         if len(proc) == 1:
-            proc = (proc[0], (), {})
+            f, args, kw = (proc[0], (), {})
         elif len(proc) == 2:
-            proc = (proc[0], proc[1], {})
-        p = Process(target=proc[0], args=proc[1], kwargs=proc[2])
-        p.start()
-        while p.is_alive():  # FIXME: or num
-            ret.append(_get_memory(p.pid))
+            f, args, kw = (proc[0], proc[1], {})
+        elif len(proc) == 3:
+            f, args, kw = (proc[0], proc[1], proc[2])
+        else:
+            raise ValueError
+        main_thread = multiprocessing.Process(target=f, args=args, kwargs=kw)
+        i = 0
+        max_iter = num if num > 0 else float(""inf"")
+        main_thread.start()
+        while i < max_iter and main_thread.is_alive():
+            m = _get_memory(main_thread.pid)
+            ret.append(m)
             time.sleep(interval)
+            i += 1
+        main_thread.join()
     else:
+        # external process
         if proc == -1:
             proc = os.getpid()
         if num == -1:
","@@ -5,7 +5,7 @@ __version__ = '0.16'
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
 import time, sys, os, pdb
-import warnings
+import warnings, multiprocessing
 import linecache
 import inspect
 
@@ -41,18 +41,17 @@ except ImportError:
                                   'platforms')
 
 
-
 def memory_usage(proc=-1, num=-1, interval=.1):
     """"""
     Return the memory usage of a process or piece of code
 
     Parameters
     ----------
-    proc : {int, string, tuple}
-        The process to monitor. Can be given by a PID or by a string
-        containing a filename. A tuple containing (f, args, kwargs) specifies
-        to run the function f(*args, **kwargs). Set to -1 (default)for
-        current process.
+    proc : {int, string, tuple}, optional
+        The process to monitor. Can be given by a PID, by a string
+        containing a filename or by a tuple. The tuple should contain
+        three values (f, args, kw) specifies to run the function
+        f(*args, **kw).  Set to -1 (default) for current process.
 
     interval : int, optional
 
@@ -61,8 +60,6 @@ def memory_usage(proc=-1, num=-1, interval=.1):
         to wait until the process has finished if proc is a string or
         to get just one if proc is an integer.
 
-    locals : dict
-        Local variables.
 
     Returns
     -------
@@ -71,29 +68,35 @@ def memory_usage(proc=-1, num=-1, interval=.1):
     """"""
     ret = []
 
+
     if str(proc).endswith('.py'):
         filename = _find_script(proc)
         with open(filename) as f:
             proc = f.read()
-
-        # TODO: make sure script's directory is on sys.path
-        def f_exec(x, locals):
-            # function interface for exec
-            exec(x, locals)
-        proc = (f_exec, (), {})
+        raise NotImplementedError
 
     if isinstance(proc, (list, tuple)):
-        from multiprocessing import Process
+
         if len(proc) == 1:
-            proc = (proc[0], (), {})
+            f, args, kw = (proc[0], (), {})
         elif len(proc) == 2:
-            proc = (proc[0], proc[1], {})
-        p = Process(target=proc[0], args=proc[1], kwargs=proc[2])
-        p.start()
-        while p.is_alive():  # FIXME: or num
-            ret.append(_get_memory(p.pid))
+            f, args, kw = (proc[0], proc[1], {})
+        elif len(proc) == 3:
+            f, args, kw = (proc[0], proc[1], proc[2])
+        else:
+            raise ValueError
+        main_thread = multiprocessing.Process(target=f, args=args, kwargs=kw)
+        i = 0
+        max_iter = num if num > 0 else float(""inf"")
+        main_thread.start()
+        while i < max_iter and main_thread.is_alive():
+            m = _get_memory(main_thread.pid)
+            ret.append(m)
             time.sleep(interval)
+            i += 1
+        main_thread.join()
     else:
+        # external process
         if proc == -1:
             proc = os.getpid()
         if num == -1:
",True,memory_profiler.py,True
"@@ -169,8 +169,9 @@ For more details, see the docstrings of the magics.
       operating system kernel about the ammount of memory the current
       process has allocated, which might be slightly different from
       the ammount of memory that is actually used by the Python
-      interpreter. For this reason, the output is only an
-      approximation, and might vary between runs.
+      interpreter. Also, because of how the garbage collector works in
+      Python the result might be different between platforms and even
+      between runs.
 
     * Q: Does it work under windows ?
     * A: Yes, but you will need the
","@@ -169,8 +169,9 @@ For more details, see the docstrings of the magics.
       operating system kernel about the ammount of memory the current
       process has allocated, which might be slightly different from
       the ammount of memory that is actually used by the Python
-      interpreter. For this reason, the output is only an
-      approximation, and might vary between runs.
+      interpreter. Also, because of how the garbage collector works in
+      Python the result might be different between platforms and even
+      between runs.
 
     * Q: Does it work under windows ?
     * A: Yes, but you will need the
",True,README.rst,False
"@@ -197,6 +197,7 @@ class LineProfiler:
     def runcall(self, func, *args, **kw):
         """""" Profile a single function call.
         """"""
+        # XXX where is this used ? can be removed ?
         self.enable_by_count()
         try:
             return func(*args, **kw)
@@ -220,7 +221,7 @@ class LineProfiler:
                 self.disable()
 
     def trace_memory_usage(self, frame, event, arg):
-
+        """"""Callback for sys.settrace""""""
         if event in ('line', 'return') and frame.f_code in self.code_map:
                 lineno = frame.f_lineno
                 if event == 'return':
","@@ -197,6 +197,7 @@ class LineProfiler:
     def runcall(self, func, *args, **kw):
         """""" Profile a single function call.
         """"""
+        # XXX where is this used ? can be removed ?
         self.enable_by_count()
         try:
             return func(*args, **kw)
@@ -220,7 +221,7 @@ class LineProfiler:
                 self.disable()
 
     def trace_memory_usage(self, frame, event, arg):
-
+        """"""Callback for sys.settrace""""""
         if event in ('line', 'return') and frame.f_code in self.code_map:
                 lineno = frame.f_lineno
                 if event == 'return':
",True,memory_profiler.py,True
"@@ -142,9 +142,11 @@ this (If you already have other extensions, just add this one to the list)::
         'memory_profiler_ext',
     ]
 
-It then can be used directly from IPython to obtain a line-by-line report using
-the `%mprun` magic command. In this case, you can skip the `@profile` decorator
-and instead use the `-f` parameter, like this::
+It then can be used directly from IPython to obtain a line-by-line
+report using the `%mprun` magic command. In this case, you can skip
+the `@profile` decorator and instead use the `-f` parameter, like
+this. Note however that function my_func must be defined in a file
+(cannot have been defined interactively in the Python interpreter)::
 
     In [1] from example import my_func
 
","@@ -142,9 +142,11 @@ this (If you already have other extensions, just add this one to the list)::
         'memory_profiler_ext',
     ]
 
-It then can be used directly from IPython to obtain a line-by-line report using
-the `%mprun` magic command. In this case, you can skip the `@profile` decorator
-and instead use the `-f` parameter, like this::
+It then can be used directly from IPython to obtain a line-by-line
+report using the `%mprun` magic command. In this case, you can skip
+the `@profile` decorator and instead use the `-f` parameter, like
+this. Note however that function my_func must be defined in a file
+(cannot have been defined interactively in the Python interpreter)::
 
     In [1] from example import my_func
 
",True,README.rst,False
"@@ -5,7 +5,7 @@ __version__ = '0.16'
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
 import time, sys, os, pdb
-import warnings, multiprocessing
+import warnings
 import linecache
 import inspect
 
@@ -15,7 +15,12 @@ try:
 
     def _get_memory(pid):
         process = psutil.Process(pid)
-        return float(process.get_memory_info()[0]) / (1024 ** 2)
+        try:
+            mem = float(process.get_memory_info()[0] / (1024 ** 2))
+        except psutil.AccessDenied:
+            mem = -1
+        return mem
+
 
 except ImportError:
 
@@ -41,7 +46,7 @@ except ImportError:
                                   'platforms')
 
 
-def memory_usage(proc=-1, num=-1, interval=.1):
+def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -60,6 +65,11 @@ def memory_usage(proc=-1, num=-1, interval=.1):
         to wait until the process has finished if proc is a string or
         to get just one if proc is an integer.
 
+    run_in_place : boolean, optional. False by default
+        If False fork the process and retrieve timings from a different
+        process. You shouldn't need to change this unless you are affected
+        by this (http://blog.vene.ro/2012/07/04/on-why-my-memit-fails-on-osx)
+        bug.
 
     Returns
     -------
@@ -68,7 +78,6 @@ def memory_usage(proc=-1, num=-1, interval=.1):
     """"""
     ret = []
 
-
     if str(proc).endswith('.py'):
         filename = _find_script(proc)
         with open(filename) as f:
@@ -85,12 +94,27 @@ def memory_usage(proc=-1, num=-1, interval=.1):
             f, args, kw = (proc[0], proc[1], proc[2])
         else:
             raise ValueError
-        main_thread = multiprocessing.Process(target=f, args=args, kwargs=kw)
+        try:
+            import multiprocessing
+        except ImportError:
+            print ('WARNING: cannot import module `multiprocessing`. Forcing to'
+                   ' run inplace.')
+            # force inplace
+            run_in_place = True
+        if run_in_place:
+            import threading
+            main_thread = threading.Thread(target=f, args=args, kwargs=kw)
+        else:
+            main_thread = multiprocessing.Process(target=f, args=args, kwargs=kw)
         i = 0
-        max_iter = num if num > 0 else float(""inf"")
+        if timeout is not None:
+            max_iter = timeout / interval
+        else:
+            max_iter = float('inf')
         main_thread.start()
+        pid = getattr(main_thread, 'pid', os.getpid())
         while i < max_iter and main_thread.is_alive():
-            m = _get_memory(main_thread.pid)
+            m = _get_memory(pid)
             ret.append(m)
             time.sleep(interval)
             i += 1
@@ -132,12 +156,10 @@ def _find_script(script_name):
 class LineProfiler:
     """""" A profiler that records the amount of memory for each line """"""
 
-    def __init__(self, *functions, **kw):
-        self.functions = list(functions)
+    def __init__(self, **kw):
+        self.functions = list()
         self.code_map = {}
         self.enable_count = 0
-        for func in functions:
-            self.add_function(func)
         self.max_mem = kw.get('max_mem', None)
 
     def __call__(self, func):
@@ -391,7 +413,8 @@ def magic_mprun(self, parameter_s=''):
             raise UsageError('Could not find function %r.\n%s: %s' % (name,
                 e.__class__.__name__, e))
 
-    profile = LineProfiler(*funcs)
+    profile = LineProfiler()
+    map(profile, funcs)
     # Add the profiler to the builtins for @profile.
     import __builtin__
     if 'profile' in __builtin__.__dict__:
@@ -447,19 +470,11 @@ def magic_mprun(self, parameter_s=''):
 
     return return_value
 
-# utility function used in magic_memit
-# TODO: merge sith memory_usage
-def _get_usage(q, stmt, setup='pass', ns={}):
-    from memory_profiler import memory_usage as _mu
-    try:
-        exec(setup, ns)
-        _mu0 = _mu()[0]
-        exec(stmt, ns)
-        _mu1 = _mu()[0]
-        q.put(_mu1 - _mu0)
-    except Exception as e:
-        q.put(float('-inf'))
-        raise e
+
+def _func_exec(stmt, ns):
+    # helper for magic_memit, just a function proxy for the exec
+    # statement
+    exec(stmt, ns)
 
 # a timeit-style %memit magic for IPython
 def magic_memit(self, line=''):
@@ -511,50 +526,13 @@ def magic_memit(self, line=''):
         timeout = None
     run_in_place = hasattr(opts, 'i')
 
-    # Don't depend on multiprocessing:
-    try:
-        import multiprocessing as pr
-        from multiprocessing.queues import SimpleQueue
-        q = SimpleQueue()
-    except ImportError:
-        class ListWithPut(list):
-            ""Just a list where the `append` method is aliased to `put`.""
-            def put(self, x):
-                self.append(x)
-        q = ListWithPut()
-        print ('WARNING: cannot import module `multiprocessing`. Forcing the'
-               '`-i` option.')
-        run_in_place = True
-
-    ns = self.shell.user_ns
-
-    if run_in_place:
-        for _ in xrange(repeat):
-            _get_usage(q, stmt, ns=ns)
+    mem_usage = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout,
+        run_in_place=run_in_place)
+
+    if mem_usage:
+        print('maximum of %d: %f MB per loop' % (repeat, max(mem_usage)))
     else:
-        # run in consecutive subprocesses
-        at_least_one_worked = False
-        for _ in xrange(repeat):
-            p = pr.Process(target=_get_usage, args=(q, stmt, 'pass', ns))
-            p.start()
-            p.join(timeout=timeout)
-            if p.exitcode == 0:
-                at_least_one_worked = True
-            else:
-                p.terminate()
-                if p.exitcode == None:
-                    print('Subprocess timed out.')
-                else:
-                    print('Subprocess exited with code %d.' % p.exitcode)
-                q.put(float('-inf'))
-
-        if not at_least_one_worked:
-            print ('ERROR: all subprocesses exited unsuccessfully. Try again '
-                   'with the `-i` option.')
-
-    usages = [q.get() for _ in xrange(repeat)]
-    usage = max(usages)
-    print('maximum of %d: %f MB per loop' % (repeat, usage))
+        print('ERROR: could not read memory usage, try with a lower interval or more iterations')
 
 
 if __name__ == '__main__':
","@@ -5,7 +5,7 @@ __version__ = '0.16'
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
 import time, sys, os, pdb
-import warnings, multiprocessing
+import warnings
 import linecache
 import inspect
 
@@ -15,7 +15,12 @@ try:
 
     def _get_memory(pid):
         process = psutil.Process(pid)
-        return float(process.get_memory_info()[0]) / (1024 ** 2)
+        try:
+            mem = float(process.get_memory_info()[0] / (1024 ** 2))
+        except psutil.AccessDenied:
+            mem = -1
+        return mem
+
 
 except ImportError:
 
@@ -41,7 +46,7 @@ except ImportError:
                                   'platforms')
 
 
-def memory_usage(proc=-1, num=-1, interval=.1):
+def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -60,6 +65,11 @@ def memory_usage(proc=-1, num=-1, interval=.1):
         to wait until the process has finished if proc is a string or
         to get just one if proc is an integer.
 
+    run_in_place : boolean, optional. False by default
+        If False fork the process and retrieve timings from a different
+        process. You shouldn't need to change this unless you are affected
+        by this (http://blog.vene.ro/2012/07/04/on-why-my-memit-fails-on-osx)
+        bug.
 
     Returns
     -------
@@ -68,7 +78,6 @@ def memory_usage(proc=-1, num=-1, interval=.1):
     """"""
     ret = []
 
-
     if str(proc).endswith('.py'):
         filename = _find_script(proc)
         with open(filename) as f:
@@ -85,12 +94,27 @@ def memory_usage(proc=-1, num=-1, interval=.1):
             f, args, kw = (proc[0], proc[1], proc[2])
         else:
             raise ValueError
-        main_thread = multiprocessing.Process(target=f, args=args, kwargs=kw)
+        try:
+            import multiprocessing
+        except ImportError:
+            print ('WARNING: cannot import module `multiprocessing`. Forcing to'
+                   ' run inplace.')
+            # force inplace
+            run_in_place = True
+        if run_in_place:
+            import threading
+            main_thread = threading.Thread(target=f, args=args, kwargs=kw)
+        else:
+            main_thread = multiprocessing.Process(target=f, args=args, kwargs=kw)
         i = 0
-        max_iter = num if num > 0 else float(""inf"")
+        if timeout is not None:
+            max_iter = timeout / interval
+        else:
+            max_iter = float('inf')
         main_thread.start()
+        pid = getattr(main_thread, 'pid', os.getpid())
         while i < max_iter and main_thread.is_alive():
-            m = _get_memory(main_thread.pid)
+            m = _get_memory(pid)
             ret.append(m)
             time.sleep(interval)
             i += 1
@@ -132,12 +156,10 @@ def _find_script(script_name):
 class LineProfiler:
     """""" A profiler that records the amount of memory for each line """"""
 
-    def __init__(self, *functions, **kw):
-        self.functions = list(functions)
+    def __init__(self, **kw):
+        self.functions = list()
         self.code_map = {}
         self.enable_count = 0
-        for func in functions:
-            self.add_function(func)
         self.max_mem = kw.get('max_mem', None)
 
     def __call__(self, func):
@@ -391,7 +413,8 @@ def magic_mprun(self, parameter_s=''):
             raise UsageError('Could not find function %r.\n%s: %s' % (name,
                 e.__class__.__name__, e))
 
-    profile = LineProfiler(*funcs)
+    profile = LineProfiler()
+    map(profile, funcs)
     # Add the profiler to the builtins for @profile.
     import __builtin__
     if 'profile' in __builtin__.__dict__:
@@ -447,19 +470,11 @@ def magic_mprun(self, parameter_s=''):
 
     return return_value
 
-# utility function used in magic_memit
-# TODO: merge sith memory_usage
-def _get_usage(q, stmt, setup='pass', ns={}):
-    from memory_profiler import memory_usage as _mu
-    try:
-        exec(setup, ns)
-        _mu0 = _mu()[0]
-        exec(stmt, ns)
-        _mu1 = _mu()[0]
-        q.put(_mu1 - _mu0)
-    except Exception as e:
-        q.put(float('-inf'))
-        raise e
+
+def _func_exec(stmt, ns):
+    # helper for magic_memit, just a function proxy for the exec
+    # statement
+    exec(stmt, ns)
 
 # a timeit-style %memit magic for IPython
 def magic_memit(self, line=''):
@@ -511,50 +526,13 @@ def magic_memit(self, line=''):
         timeout = None
     run_in_place = hasattr(opts, 'i')
 
-    # Don't depend on multiprocessing:
-    try:
-        import multiprocessing as pr
-        from multiprocessing.queues import SimpleQueue
-        q = SimpleQueue()
-    except ImportError:
-        class ListWithPut(list):
-            ""Just a list where the `append` method is aliased to `put`.""
-            def put(self, x):
-                self.append(x)
-        q = ListWithPut()
-        print ('WARNING: cannot import module `multiprocessing`. Forcing the'
-               '`-i` option.')
-        run_in_place = True
+    mem_usage = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout,
+        run_in_place=run_in_place)
 
-    ns = self.shell.user_ns
-
-    if run_in_place:
-        for _ in xrange(repeat):
-            _get_usage(q, stmt, ns=ns)
+    if mem_usage:
+        print('maximum of %d: %f MB per loop' % (repeat, max(mem_usage)))
     else:
-        # run in consecutive subprocesses
-        at_least_one_worked = False
-        for _ in xrange(repeat):
-            p = pr.Process(target=_get_usage, args=(q, stmt, 'pass', ns))
-            p.start()
-            p.join(timeout=timeout)
-            if p.exitcode == 0:
-                at_least_one_worked = True
-            else:
-                p.terminate()
-                if p.exitcode == None:
-                    print('Subprocess timed out.')
-                else:
-                    print('Subprocess exited with code %d.' % p.exitcode)
-                q.put(float('-inf'))
-
-        if not at_least_one_worked:
-            print ('ERROR: all subprocesses exited unsuccessfully. Try again '
-                   'with the `-i` option.')
-
-    usages = [q.get() for _ in xrange(repeat)]
-    usage = max(usages)
-    print('maximum of %d: %f MB per loop' % (repeat, usage))
+        print('ERROR: could not read memory usage, try with a lower interval or more iterations')
 
 
 if __name__ == '__main__':
",False,memory_profiler.py,True
"@@ -58,12 +58,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         three values (f, args, kw) specifies to run the function
         f(*args, **kw).  Set to -1 (default) for current process.
 
-    interval : int, optional
+    interval : float, optional
+
+    timeout : float, optional
 
-    num : int, optional
-        Maximum number of retrievals. In the case of -1, meaning
-        to wait until the process has finished if proc is a string or
-        to get just one if proc is an integer.
 
     run_in_place : boolean, optional. False by default
         If False fork the process and retrieve timings from a different
","@@ -58,12 +58,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         three values (f, args, kw) specifies to run the function
         f(*args, **kw).  Set to -1 (default) for current process.
 
-    interval : int, optional
+    interval : float, optional
+
+    timeout : float, optional
 
-    num : int, optional
-        Maximum number of retrievals. In the case of -1, meaning
-        to wait until the process has finished if proc is a string or
-        to get just one if proc is an integer.
 
     run_in_place : boolean, optional. False by default
         If False fork the process and retrieve timings from a different
",True,memory_profiler.py,True
"@@ -76,7 +76,7 @@ API
 memory_profiler exposes a number of functions to be used in third-party
 code.
 
-`memory_usage(proc=-1, num=-1, interval=.1)` returns the memory usage
+`memory_usage(proc=-1, interval=.1, timeout=None)` returns the memory usage
 over a time interval. The first argument, `proc` represents what
 should be monitored.  This can either be the PID of a process (not
 necessarily a Python program), a string containing some python code to
","@@ -76,7 +76,7 @@ API
 memory_profiler exposes a number of functions to be used in third-party
 code.
 
-`memory_usage(proc=-1, num=-1, interval=.1)` returns the memory usage
+`memory_usage(proc=-1, interval=.1, timeout=None)` returns the memory usage
 over a time interval. The first argument, `proc` represents what
 should be monitored.  This can either be the PID of a process (not
 necessarily a Python program), a string containing some python code to
",True,README.rst,False
"@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.16'
+__version__ = '0.17'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.16'
+__version__ = '0.17'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -69,19 +69,18 @@ with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
 
-====
-API
-====
-
+=====
+ API
+=====
 memory_profiler exposes a number of functions to be used in third-party
 code.
 
-`memory_usage(proc=-1, interval=.1, timeout=None)` returns the memory usage
-over a time interval. The first argument, `proc` represents what
+``memory_usage(proc=-1, interval=.1, timeout=None)`` returns the memory usage
+over a time interval. The first argument, ``proc`` represents what
 should be monitored.  This can either be the PID of a process (not
 necessarily a Python program), a string containing some python code to
-be evaluated or a tuple (f, args, kw) containing a function and its
-arguments to be evaluated as f(*args, **kw). For example::
+be evaluated or a tuple ``(f, args, kw)`` containing a function and its
+arguments to be evaluated as ``f(*args, **kw)``. For example::
 
 
     >>> # define a simple function
@@ -98,10 +97,9 @@ arguments to be evaluated as f(*args, **kw). For example::
 
 
 
-===================
-Ipython integration
-===================
-
+=====================
+ Ipython integration
+=====================
 After installing the module, if you use IPython, you can set up the `%mprun`
 and `%memit` magics by following these steps.
 
@@ -165,7 +163,6 @@ For more details, see the docstrings of the magics.
 ============================
  Frequently Asked Questions
 ============================
-
     * Q: How accurate are the results ?
     * A: This module gets the memory consumption by querying the
       operating system kernel about the ammount of memory the current
","@@ -69,19 +69,18 @@ with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
 
-====
-API
-====
-
+=====
+ API
+=====
 memory_profiler exposes a number of functions to be used in third-party
 code.
 
-`memory_usage(proc=-1, interval=.1, timeout=None)` returns the memory usage
-over a time interval. The first argument, `proc` represents what
+``memory_usage(proc=-1, interval=.1, timeout=None)`` returns the memory usage
+over a time interval. The first argument, ``proc`` represents what
 should be monitored.  This can either be the PID of a process (not
 necessarily a Python program), a string containing some python code to
-be evaluated or a tuple (f, args, kw) containing a function and its
-arguments to be evaluated as f(*args, **kw). For example::
+be evaluated or a tuple ``(f, args, kw)`` containing a function and its
+arguments to be evaluated as ``f(*args, **kw)``. For example::
 
 
     >>> # define a simple function
@@ -98,10 +97,9 @@ arguments to be evaluated as f(*args, **kw). For example::
 
 
 
-===================
-Ipython integration
-===================
-
+=====================
+ Ipython integration
+=====================
 After installing the module, if you use IPython, you can set up the `%mprun`
 and `%memit` magics by following these steps.
 
@@ -165,7 +163,6 @@ For more details, see the docstrings of the magics.
 ============================
  Frequently Asked Questions
 ============================
-
     * Q: How accurate are the results ?
     * A: This module gets the memory consumption by querying the
       operating system kernel about the ammount of memory the current
",True,README.rst,False
"@@ -2,7 +2,7 @@ import memory_profiler
 from distutils.core import setup
 
 CLASSIFIERS = """"""\
-Development Status :: 4 - Beta
+Development Status :: 5 - Production/Stable
 Intended Audience :: Science/Research
 Intended Audience :: Developers
 License :: OSI Approved
@@ -24,5 +24,6 @@ setup(
     url='http://pypi.python.org/pypi/memory_profiler',
 	py_modules=['memory_profiler'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
+    license='Simplified BSD'
 
 )
\ No newline at end of file
","@@ -2,7 +2,7 @@ import memory_profiler
 from distutils.core import setup
 
 CLASSIFIERS = """"""\
-Development Status :: 4 - Beta
+Development Status :: 5 - Production/Stable
 Intended Audience :: Science/Research
 Intended Audience :: Developers
 License :: OSI Approved
@@ -24,5 +24,6 @@ setup(
     url='http://pypi.python.org/pypi/memory_profiler',
 	py_modules=['memory_profiler'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
+    license='Simplified BSD'
 
 )
\ No newline at end of file
",True,setup.py,True
"@@ -69,6 +69,9 @@ with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
 
+TODO: alternatives to decoation (for example when you don't want to modify
+the file where your function).
+
 =====
  API
 =====
@@ -189,6 +192,8 @@ Send issues, proposals, etc. to `github's issue tracker
 If you've got questions regarding development, you can email me
 directly at fabian@fseoane.net
 
+.. image:: http://fseoane.net/static/tux_memory_small.png
+
 
 =============
  Development
","@@ -69,6 +69,9 @@ with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
 
+TODO: alternatives to decoation (for example when you don't want to modify
+the file where your function).
+
 =====
  API
 =====
@@ -189,6 +192,8 @@ Send issues, proposals, etc. to `github's issue tracker
 If you've got questions regarding development, you can email me
 directly at fabian@fseoane.net
 
+.. image:: http://fseoane.net/static/tux_memory_small.png
+
 
 =============
  Development
",True,README.rst,False
"@@ -69,7 +69,7 @@ with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
 
-TODO: alternatives to decoation (for example when you don't want to modify
+TODO: alternatives to decoration (for example when you don't want to modify
 the file where your function).
 
 =====
","@@ -69,7 +69,7 @@ with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
 
-TODO: alternatives to decoation (for example when you don't want to modify
+TODO: alternatives to decoration (for example when you don't want to modify
 the file where your function).
 
 =====
",True,README.rst,False
"@@ -168,7 +168,7 @@ For more details, see the docstrings of the magics.
 ============================
     * Q: How accurate are the results ?
     * A: This module gets the memory consumption by querying the
-      operating system kernel about the ammount of memory the current
+      operating system kernel about the amount of memory the current
       process has allocated, which might be slightly different from
       the ammount of memory that is actually used by the Python
       interpreter. Also, because of how the garbage collector works in
","@@ -168,7 +168,7 @@ For more details, see the docstrings of the magics.
 ============================
     * Q: How accurate are the results ?
     * A: This module gets the memory consumption by querying the
-      operating system kernel about the ammount of memory the current
+      operating system kernel about the amount of memory the current
       process has allocated, which might be slightly different from
       the ammount of memory that is actually used by the Python
       interpreter. Also, because of how the garbage collector works in
",True,README.rst,False
"@@ -101,7 +101,7 @@ arguments to be evaluated as ``f(*args, **kw)``. For example::
 
 
 =====================
- Ipython integration
+ IPython integration
 =====================
 After installing the module, if you use IPython, you can set up the `%mprun`
 and `%memit` magics by following these steps.
","@@ -101,7 +101,7 @@ arguments to be evaluated as ``f(*args, **kw)``. For example::
 
 
 =====================
- Ipython integration
+ IPython integration
 =====================
 After installing the module, if you use IPython, you can set up the `%mprun`
 and `%memit` magics by following these steps.
",True,README.rst,False
"@@ -16,7 +16,7 @@ try:
     def _get_memory(pid):
         process = psutil.Process(pid)
         try:
-            mem = float(process.get_memory_info()[0] / (1024 ** 2))
+            mem = float(process.get_memory_info()[0]) / (1024 ** 2)
         except psutil.AccessDenied:
             mem = -1
         return mem
","@@ -16,7 +16,7 @@ try:
     def _get_memory(pid):
         process = psutil.Process(pid)
         try:
-            mem = float(process.get_memory_info()[0] / (1024 ** 2))
+            mem = float(process.get_memory_info()[0]) / (1024 ** 2)
         except psutil.AccessDenied:
             mem = -1
         return mem
",True,memory_profiler.py,True
"@@ -253,7 +253,7 @@ class LineProfiler:
 
     def trace_max_mem(self, frame, event, arg):
         # run into PDB as soon as memory is higher than MAX_MEM
-        if event in ('line', 'return'):
+        if event in ('line', 'return') and frame.f_code in self.code_map:
             c = _get_memory(os.getpid())
             if c >= self.max_mem:
                 t = 'Current memory {0:.2f} MB exceeded the maximum '.format(c) + \
","@@ -253,7 +253,7 @@ class LineProfiler:
 
     def trace_max_mem(self, frame, event, arg):
         # run into PDB as soon as memory is higher than MAX_MEM
-        if event in ('line', 'return'):
+        if event in ('line', 'return') and frame.f_code in self.code_map:
             c = _get_memory(os.getpid())
             if c >= self.max_mem:
                 t = 'Current memory {0:.2f} MB exceeded the maximum '.format(c) + \
",True,memory_profiler.py,True
"@@ -0,0 +1 @@
+__author__ = 'fabian'
","@@ -0,0 +1 @@
+__author__ = 'fabian'
",True,test/test_with.py,True
"@@ -76,6 +76,15 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
     """"""
     ret = []
 
+    if timeout is not None:
+        max_iter = timeout / interval
+    elif isinstance(proc, int):
+        # external process and no timeout
+        max_iter = 1
+    else:
+        # for a Python function wait until it finishes
+        max_iter = float('inf')
+
     if str(proc).endswith('.py'):
         filename = _find_script(proc)
         with open(filename) as f:
@@ -105,10 +114,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         else:
             main_thread = multiprocessing.Process(target=f, args=args, kwargs=kw)
         i = 0
-        if timeout is not None:
-            max_iter = timeout / interval
-        else:
-            max_iter = float('inf')
         main_thread.start()
         pid = getattr(main_thread, 'pid', os.getpid())
         while i < max_iter and main_thread.is_alive():
@@ -121,9 +126,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         # external process
         if proc == -1:
             proc = os.getpid()
-        if num == -1:
-            num = 1
-        for _ in range(num):
+        if max_iter == -1:
+            max_iter = 1
+        for _ in range(max_iter):
             ret.append(_get_memory(proc))
             time.sleep(interval)
     return ret
","@@ -76,6 +76,15 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
     """"""
     ret = []
 
+    if timeout is not None:
+        max_iter = timeout / interval
+    elif isinstance(proc, int):
+        # external process and no timeout
+        max_iter = 1
+    else:
+        # for a Python function wait until it finishes
+        max_iter = float('inf')
+
     if str(proc).endswith('.py'):
         filename = _find_script(proc)
         with open(filename) as f:
@@ -105,10 +114,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         else:
             main_thread = multiprocessing.Process(target=f, args=args, kwargs=kw)
         i = 0
-        if timeout is not None:
-            max_iter = timeout / interval
-        else:
-            max_iter = float('inf')
         main_thread.start()
         pid = getattr(main_thread, 'pid', os.getpid())
         while i < max_iter and main_thread.is_alive():
@@ -121,9 +126,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         # external process
         if proc == -1:
             proc = os.getpid()
-        if num == -1:
-            num = 1
-        for _ in range(num):
+        if max_iter == -1:
+            max_iter = 1
+        for _ in range(max_iter):
             ret.append(_get_memory(proc))
             time.sleep(interval)
     return ret
",True,memory_profiler.py,True
"@@ -68,9 +68,23 @@ Python interpreter after that line has been executed. The third column
 with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
-
-TODO: alternatives to decoration (for example when you don't want to modify
-the file where your function).
+Setting debugger breakpoints
+=============================
+It is possible to set breakpoints depending on the amount of memory used.
+That is, you can specify a threshold and as soon as the program uses more
+memory than what is specified in the threshold it will stop execution
+and run into the pdb debugger. To use it, you will have to decorate
+the function as done in the previous section with ``@profile`` and then
+run your script with the option ``-m memory_profiler --pdb-mmem=X``,
+where X is a number representing the memory threshold in MB. For example::
+
+    $ python -m memory_profiler --pdb-mmem=100 my_script.py
+
+will run ``my_script.py`` and step into the pdb debugger as soon as the code
+uses more than 100 MB in the decorated function.
+
+.. TODO: alternatives to decoration (for example when you don't want to modify
+    the file where your function lives).
 
 =====
  API
","@@ -68,9 +68,23 @@ Python interpreter after that line has been executed. The third column
 with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
+Setting debugger breakpoints
+=============================
+It is possible to set breakpoints depending on the amount of memory used.
+That is, you can specify a threshold and as soon as the program uses more
+memory than what is specified in the threshold it will stop execution
+and run into the pdb debugger. To use it, you will have to decorate
+the function as done in the previous section with ``@profile`` and then
+run your script with the option ``-m memory_profiler --pdb-mmem=X``,
+where X is a number representing the memory threshold in MB. For example::
 
-TODO: alternatives to decoration (for example when you don't want to modify
-the file where your function).
+    $ python -m memory_profiler --pdb-mmem=100 my_script.py
+
+will run ``my_script.py`` and step into the pdb debugger as soon as the code
+uses more than 100 MB in the decorated function.
+
+.. TODO: alternatives to decoration (for example when you don't want to modify
+    the file where your function lives).
 
 =====
  API
",False,README.rst,False
"@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.17'
+__version__ = '0.18'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.17'
+__version__ = '0.18'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -68,23 +68,34 @@ Python interpreter after that line has been executed. The third column
 with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
-Setting debugger breakpoints
-=============================
-It is possible to set breakpoints depending on the amount of memory used.
-That is, you can specify a threshold and as soon as the program uses more
-memory than what is specified in the threshold it will stop execution
-and run into the pdb debugger. To use it, you will have to decorate
-the function as done in the previous section with ``@profile`` and then
-run your script with the option ``-m memory_profiler --pdb-mmem=X``,
-where X is a number representing the memory threshold in MB. For example::
 
-    $ python -m memory_profiler --pdb-mmem=100 my_script.py
+The second usage pattern is to omit the decorator and to add command
+line options for target-file and target-function::
 
-will run ``my_script.py`` and step into the pdb debugger as soon as the code
-uses more than 100 MB in the decorated function.
+    $ python -m memory_profiler example_undecorated.py --target-file=example_undecorated.py --target-function=another_func
 
-.. TODO: alternatives to decoration (for example when you don't want to modify
-    the file where your function lives).
+
+    Line #    Mem usage    Increment   Line Contents
+    ================================================
+         2                             def another_func():
+         3      8.00 MB      0.00 MB       """"""Undecorated function that allocates memory""""""
+         4     16.00 MB      8.00 MB       c = [1] * (10 ** 6)
+         5     92.00 MB     76.00 MB       d = [1] * (10 ** 7)
+         6     92.00 MB      0.00 MB       return c, d
+
+
+Note that you can either profile using the decorator (or many decorators) 
+OR with one named file and function. You cannot mix the two approaches
+and you cannot profile more than one file and function.
+
+TODO: allow multiple files and functions rather than just one (convert
+the named variables into a list internally and iterate on the list)
+
+TODO: the current named file approach would be confused if two files in 
+different directories shared the same name, and both had the same named
+function. Rather than checking named files we should check for modules
+in their namespace (e.g. rather than module1/afile.py and some_function, 
+we should check for module1.afile.some_function to remove ambiguity).
 
 =====
  API
@@ -115,7 +126,7 @@ arguments to be evaluated as ``f(*args, **kw)``. For example::
 
 
 =====================
- IPython integration
+ Ipython integration
 =====================
 After installing the module, if you use IPython, you can set up the `%mprun`
 and `%memit` magics by following these steps.
@@ -182,7 +193,7 @@ For more details, see the docstrings of the magics.
 ============================
     * Q: How accurate are the results ?
     * A: This module gets the memory consumption by querying the
-      operating system kernel about the amount of memory the current
+      operating system kernel about the ammount of memory the current
       process has allocated, which might be slightly different from
       the ammount of memory that is actually used by the Python
       interpreter. Also, because of how the garbage collector works in
","@@ -68,23 +68,34 @@ Python interpreter after that line has been executed. The third column
 with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
-Setting debugger breakpoints
-=============================
-It is possible to set breakpoints depending on the amount of memory used.
-That is, you can specify a threshold and as soon as the program uses more
-memory than what is specified in the threshold it will stop execution
-and run into the pdb debugger. To use it, you will have to decorate
-the function as done in the previous section with ``@profile`` and then
-run your script with the option ``-m memory_profiler --pdb-mmem=X``,
-where X is a number representing the memory threshold in MB. For example::
 
-    $ python -m memory_profiler --pdb-mmem=100 my_script.py
+The second usage pattern is to omit the decorator and to add command
+line options for target-file and target-function::
 
-will run ``my_script.py`` and step into the pdb debugger as soon as the code
-uses more than 100 MB in the decorated function.
+    $ python -m memory_profiler example_undecorated.py --target-file=example_undecorated.py --target-function=another_func
 
-.. TODO: alternatives to decoration (for example when you don't want to modify
-    the file where your function lives).
+
+    Line #    Mem usage    Increment   Line Contents
+    ================================================
+         2                             def another_func():
+         3      8.00 MB      0.00 MB       """"""Undecorated function that allocates memory""""""
+         4     16.00 MB      8.00 MB       c = [1] * (10 ** 6)
+         5     92.00 MB     76.00 MB       d = [1] * (10 ** 7)
+         6     92.00 MB      0.00 MB       return c, d
+
+
+Note that you can either profile using the decorator (or many decorators) 
+OR with one named file and function. You cannot mix the two approaches
+and you cannot profile more than one file and function.
+
+TODO: allow multiple files and functions rather than just one (convert
+the named variables into a list internally and iterate on the list)
+
+TODO: the current named file approach would be confused if two files in 
+different directories shared the same name, and both had the same named
+function. Rather than checking named files we should check for modules
+in their namespace (e.g. rather than module1/afile.py and some_function, 
+we should check for module1.afile.some_function to remove ambiguity).
 
 =====
  API
@@ -115,7 +126,7 @@ arguments to be evaluated as ``f(*args, **kw)``. For example::
 
 
 =====================
- IPython integration
+ Ipython integration
 =====================
 After installing the module, if you use IPython, you can set up the `%mprun`
 and `%memit` magics by following these steps.
@@ -182,7 +193,7 @@ For more details, see the docstrings of the magics.
 ============================
     * Q: How accurate are the results ?
     * A: This module gets the memory consumption by querying the
-      operating system kernel about the amount of memory the current
+      operating system kernel about the ammount of memory the current
       process has allocated, which might be slightly different from
       the ammount of memory that is actually used by the Python
       interpreter. Also, because of how the garbage collector works in
",True,README.rst,False
"@@ -0,0 +1,9 @@
+
+def another_func():
+    """"""Undecorated function that allocates memory""""""
+    c = [1] * (10 ** 6)
+    d = [1] * (10 ** 7)
+    return c, d
+
+if __name__ == '__main__':
+    another_func()
","@@ -0,0 +1,9 @@
+
+def another_func():
+    """"""Undecorated function that allocates memory""""""
+    c = [1] * (10 ** 6)
+    d = [1] * (10 ** 7)
+    return c, d
+
+if __name__ == '__main__':
+    another_func()
",True,examples/example_undecorated.py,True
"@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.18'
+__version__ = '0.17'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
@@ -16,7 +16,7 @@ try:
     def _get_memory(pid):
         process = psutil.Process(pid)
         try:
-            mem = float(process.get_memory_info()[0]) / (1024 ** 2)
+            mem = float(process.get_memory_info()[0] / (1024 ** 2))
         except psutil.AccessDenied:
             mem = -1
         return mem
@@ -76,15 +76,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
     """"""
     ret = []
 
-    if timeout is not None:
-        max_iter = timeout / interval
-    elif isinstance(proc, int):
-        # external process and no timeout
-        max_iter = 1
-    else:
-        # for a Python function wait until it finishes
-        max_iter = float('inf')
-
     if str(proc).endswith('.py'):
         filename = _find_script(proc)
         with open(filename) as f:
@@ -114,6 +105,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         else:
             main_thread = multiprocessing.Process(target=f, args=args, kwargs=kw)
         i = 0
+        if timeout is not None:
+            max_iter = timeout / interval
+        else:
+            max_iter = float('inf')
         main_thread.start()
         pid = getattr(main_thread, 'pid', os.getpid())
         while i < max_iter and main_thread.is_alive():
@@ -126,9 +121,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         # external process
         if proc == -1:
             proc = os.getpid()
-        if max_iter == -1:
-            max_iter = 1
-        for _ in range(max_iter):
+        if num == -1:
+            num = 1
+        for _ in range(num):
             ret.append(_get_memory(proc))
             time.sleep(interval)
     return ret
@@ -164,6 +159,13 @@ class LineProfiler:
         self.code_map = {}
         self.enable_count = 0
         self.max_mem = kw.get('max_mem', None)
+        self.target_file = kw.get('target_file', None)
+        self.target_function = kw.get('target_function', None)
+        if self.target_file:
+            # if we're tracking a file+function rather than using a
+            # decorator then we enable settrace for all lines of code
+            self.enable()
+
 
     def __call__(self, func):
         self.add_function(func)
@@ -247,7 +249,27 @@ class LineProfiler:
 
     def trace_memory_usage(self, frame, event, arg):
         """"""Callback for sys.settrace""""""
-        if event in ('line', 'return') and frame.f_code in self.code_map:
+
+        # if we're profiling a named file and function then
+        # check this trace event to see if it matches our pattern
+        profile_this = False
+        if self.target_file:
+            co = frame.f_code
+            func_name = co.co_name
+            func_filename = co.co_filename
+            if self.target_file in func_filename:
+                if self.target_function == func_name:
+                    if frame.f_code not in self.code_map:
+                        # if we've not yet encountered this function (and it is
+                        # the one we want to trace) then we add it to
+                        # the code_map
+                        self.code_map[frame.f_code] = {}
+                    profile_this = True
+
+        # if we've been called on our decorated function
+        # OR we've matched the named file and function
+        # then track the memory usage
+        if event in ('line', 'return') and (frame.f_code in self.code_map or profile_this):
                 lineno = frame.f_lineno
                 if event == 'return':
                     lineno += 1
@@ -258,7 +280,7 @@ class LineProfiler:
 
     def trace_max_mem(self, frame, event, arg):
         # run into PDB as soon as memory is higher than MAX_MEM
-        if event in ('line', 'return') and frame.f_code in self.code_map:
+        if event in ('line', 'return'):
             c = _get_memory(os.getpid())
             if c >= self.max_mem:
                 t = 'Current memory {0:.2f} MB exceeded the maximum '.format(c) + \
@@ -290,7 +312,12 @@ class LineProfiler:
 
     def disable(self):
         self.last_time = {}
-        sys.settrace(None)
+        if self.target_file is None:
+            # if target_file is None then we're using the decorator
+            # and it is safe to disable settrace
+            # if target_file is not None then we're running settrace
+            # on every line of code so we can't disable the trace
+            sys.settrace(None)
 
 
 def show_results(prof, stream=None):
@@ -544,6 +571,12 @@ if __name__ == '__main__':
     parser.add_option(""--pdb-mmem"", dest=""max_mem"", metavar=""MAXMEM"",
         type=""float"", action=""store"",
         help=""step into the debugger when memory exceeds MAXMEM"")
+    parser.add_option(""--target-file"", dest=""target_file"",
+        type=""str"", action=""store"", default=None,
+        help=""Traces this file (requires target-function), disables @profile tracing"")
+    parser.add_option(""--target-function"", dest=""target_function"",
+        type=""str"", action=""store"", default=None,
+        help=""Traces this function (requires target-file), disables @profile tracing"")
 
     if not sys.argv[1:]:
         parser.print_help()
@@ -551,7 +584,15 @@ if __name__ == '__main__':
 
     (options, args) = parser.parse_args()
 
-    prof = LineProfiler(max_mem=options.max_mem)
+    # check that if the user wants to memory_profile without a decorator
+    # then they've specified both of the required options
+    if options.target_file or options.target_function:
+        if not (options.target_file and options.target_function):
+            print ""Error: Both --target-file and --target-function are required""
+            raise SystemExit(1)
+
+    # hardcoded module name and function name
+    prof = LineProfiler(max_mem=options.max_mem, target_file=options.target_file, target_function=options.target_function)
     __file__ = _find_script(args[0])
     if sys.version_info[0] < 3:
         import __builtin__
","@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.18'
+__version__ = '0.17'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
@@ -16,7 +16,7 @@ try:
     def _get_memory(pid):
         process = psutil.Process(pid)
         try:
-            mem = float(process.get_memory_info()[0]) / (1024 ** 2)
+            mem = float(process.get_memory_info()[0] / (1024 ** 2))
         except psutil.AccessDenied:
             mem = -1
         return mem
@@ -76,15 +76,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
     """"""
     ret = []
 
-    if timeout is not None:
-        max_iter = timeout / interval
-    elif isinstance(proc, int):
-        # external process and no timeout
-        max_iter = 1
-    else:
-        # for a Python function wait until it finishes
-        max_iter = float('inf')
-
     if str(proc).endswith('.py'):
         filename = _find_script(proc)
         with open(filename) as f:
@@ -114,6 +105,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         else:
             main_thread = multiprocessing.Process(target=f, args=args, kwargs=kw)
         i = 0
+        if timeout is not None:
+            max_iter = timeout / interval
+        else:
+            max_iter = float('inf')
         main_thread.start()
         pid = getattr(main_thread, 'pid', os.getpid())
         while i < max_iter and main_thread.is_alive():
@@ -126,9 +121,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         # external process
         if proc == -1:
             proc = os.getpid()
-        if max_iter == -1:
-            max_iter = 1
-        for _ in range(max_iter):
+        if num == -1:
+            num = 1
+        for _ in range(num):
             ret.append(_get_memory(proc))
             time.sleep(interval)
     return ret
@@ -164,6 +159,13 @@ class LineProfiler:
         self.code_map = {}
         self.enable_count = 0
         self.max_mem = kw.get('max_mem', None)
+        self.target_file = kw.get('target_file', None)
+        self.target_function = kw.get('target_function', None)
+        if self.target_file:
+            # if we're tracking a file+function rather than using a
+            # decorator then we enable settrace for all lines of code
+            self.enable()
+
 
     def __call__(self, func):
         self.add_function(func)
@@ -247,7 +249,27 @@ class LineProfiler:
 
     def trace_memory_usage(self, frame, event, arg):
         """"""Callback for sys.settrace""""""
-        if event in ('line', 'return') and frame.f_code in self.code_map:
+
+        # if we're profiling a named file and function then
+        # check this trace event to see if it matches our pattern
+        profile_this = False
+        if self.target_file:
+            co = frame.f_code
+            func_name = co.co_name
+            func_filename = co.co_filename
+            if self.target_file in func_filename:
+                if self.target_function == func_name:
+                    if frame.f_code not in self.code_map:
+                        # if we've not yet encountered this function (and it is
+                        # the one we want to trace) then we add it to
+                        # the code_map
+                        self.code_map[frame.f_code] = {}
+                    profile_this = True
+
+        # if we've been called on our decorated function
+        # OR we've matched the named file and function
+        # then track the memory usage
+        if event in ('line', 'return') and (frame.f_code in self.code_map or profile_this):
                 lineno = frame.f_lineno
                 if event == 'return':
                     lineno += 1
@@ -258,7 +280,7 @@ class LineProfiler:
 
     def trace_max_mem(self, frame, event, arg):
         # run into PDB as soon as memory is higher than MAX_MEM
-        if event in ('line', 'return') and frame.f_code in self.code_map:
+        if event in ('line', 'return'):
             c = _get_memory(os.getpid())
             if c >= self.max_mem:
                 t = 'Current memory {0:.2f} MB exceeded the maximum '.format(c) + \
@@ -290,7 +312,12 @@ class LineProfiler:
 
     def disable(self):
         self.last_time = {}
-        sys.settrace(None)
+        if self.target_file is None:
+            # if target_file is None then we're using the decorator
+            # and it is safe to disable settrace
+            # if target_file is not None then we're running settrace
+            # on every line of code so we can't disable the trace
+            sys.settrace(None)
 
 
 def show_results(prof, stream=None):
@@ -544,6 +571,12 @@ if __name__ == '__main__':
     parser.add_option(""--pdb-mmem"", dest=""max_mem"", metavar=""MAXMEM"",
         type=""float"", action=""store"",
         help=""step into the debugger when memory exceeds MAXMEM"")
+    parser.add_option(""--target-file"", dest=""target_file"",
+        type=""str"", action=""store"", default=None,
+        help=""Traces this file (requires target-function), disables @profile tracing"")
+    parser.add_option(""--target-function"", dest=""target_function"",
+        type=""str"", action=""store"", default=None,
+        help=""Traces this function (requires target-file), disables @profile tracing"")
 
     if not sys.argv[1:]:
         parser.print_help()
@@ -551,7 +584,15 @@ if __name__ == '__main__':
 
     (options, args) = parser.parse_args()
 
-    prof = LineProfiler(max_mem=options.max_mem)
+    # check that if the user wants to memory_profile without a decorator
+    # then they've specified both of the required options
+    if options.target_file or options.target_function:
+        if not (options.target_file and options.target_function):
+            print ""Error: Both --target-file and --target-function are required""
+            raise SystemExit(1)
+
+    # hardcoded module name and function name
+    prof = LineProfiler(max_mem=options.max_mem, target_file=options.target_file, target_function=options.target_function)
     __file__ = _find_script(args[0])
     if sys.version_info[0] < 3:
         import __builtin__
",True,memory_profiler.py,True
"@@ -68,6 +68,20 @@ Python interpreter after that line has been executed. The third column
 with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
+Decorator
+=========
+
+A function decorator is also available.  Use as follows::
+
+    from memory_profiler import profile
+
+    @profile
+    def my_func():
+        a = [1] * (10 ** 6)
+        b = [2] * (2 * 10 ** 7)
+        del b
+        return a
+
 Setting debugger breakpoints
 =============================
 It is possible to set breakpoints depending on the amount of memory used.
","@@ -68,6 +68,20 @@ Python interpreter after that line has been executed. The third column
 with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
+Decorator
+=========
+
+A function decorator is also available.  Use as follows::
+
+    from memory_profiler import profile
+
+    @profile
+    def my_func():
+        a = [1] * (10 ** 6)
+        b = [2] * (2 * 10 ** 7)
+        del b
+        return a
+
 Setting debugger breakpoints
 =============================
 It is possible to set breakpoints depending on the amount of memory used.
",True,README.rst,False
"@@ -538,6 +538,15 @@ def magic_memit(self, line=''):
         print('ERROR: could not read memory usage, try with a lower interval or more iterations')
 
 
+def profile(func):
+    def wrapper(*args, **kwargs):
+        prof = LineProfiler()
+        val = prof(func)(*args, **kwargs)
+        show_results(prof)
+        return val
+    return wrapper
+
+
 if __name__ == '__main__':
     from optparse import OptionParser
     parser = OptionParser(usage=_CMD_USAGE, version=__version__)
","@@ -538,6 +538,15 @@ def magic_memit(self, line=''):
         print('ERROR: could not read memory usage, try with a lower interval or more iterations')
 
 
+def profile(func):
+    def wrapper(*args, **kwargs):
+        prof = LineProfiler()
+        val = prof(func)(*args, **kwargs)
+        show_results(prof)
+        return val
+    return wrapper
+
+
 if __name__ == '__main__':
     from optparse import OptionParser
     parser = OptionParser(usage=_CMD_USAGE, version=__version__)
",True,memory_profiler.py,True
"@@ -538,11 +538,11 @@ def magic_memit(self, line=''):
         print('ERROR: could not read memory usage, try with a lower interval or more iterations')
 
 
-def profile(func):
+def profile(func, stream=None):
     def wrapper(*args, **kwargs):
         prof = LineProfiler()
         val = prof(func)(*args, **kwargs)
-        show_results(prof)
+        show_results(prof, stream=stream)
         return val
     return wrapper
 
","@@ -538,11 +538,11 @@ def magic_memit(self, line=''):
         print('ERROR: could not read memory usage, try with a lower interval or more iterations')
 
 
-def profile(func):
+def profile(func, stream=None):
     def wrapper(*args, **kwargs):
         prof = LineProfiler()
         val = prof(func)(*args, **kwargs)
-        show_results(prof)
+        show_results(prof, stream=stream)
         return val
     return wrapper
 
",True,memory_profiler.py,True
"@@ -550,6 +550,7 @@ def profile(func, stream=None):
 if __name__ == '__main__':
     from optparse import OptionParser
     parser = OptionParser(usage=_CMD_USAGE, version=__version__)
+    parser.disable_interspersed_args()
     parser.add_option(""--pdb-mmem"", dest=""max_mem"", metavar=""MAXMEM"",
         type=""float"", action=""store"",
         help=""step into the debugger when memory exceeds MAXMEM"")
","@@ -550,6 +550,7 @@ def profile(func, stream=None):
 if __name__ == '__main__':
     from optparse import OptionParser
     parser = OptionParser(usage=_CMD_USAGE, version=__version__)
+    parser.disable_interspersed_args()
     parser.add_option(""--pdb-mmem"", dest=""max_mem"", metavar=""MAXMEM"",
         type=""float"", action=""store"",
         help=""step into the debugger when memory exceeds MAXMEM"")
",True,memory_profiler.py,True
"@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.18'
+__version__ = '0.19'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.18'
+__version__ = '0.19'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -62,7 +62,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
 
     timeout : float, optional
 
-
     run_in_place : boolean, optional. False by default
         If False fork the process and retrieve timings from a different
         process. You shouldn't need to change this unless you are affected
@@ -101,6 +100,13 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
             f, args, kw = (proc[0], proc[1], proc[2])
         else:
             raise ValueError
+
+        aspec = inspect.getargspec(f)
+        if len(aspec.args) != len(args):
+            raise ValueError(
+            'Function expects %s value(s) but %s where given'
+            % (len(aspec.args), len(args)))
+
         try:
             import multiprocessing
         except ImportError:
@@ -118,10 +124,13 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         pid = getattr(main_thread, 'pid', os.getpid())
         while i < max_iter and main_thread.is_alive():
             m = _get_memory(pid)
+            if m == -1:
+                # this means the thread has finished
+                break
             ret.append(m)
             time.sleep(interval)
             i += 1
-        main_thread.join()
+        main_thread.join(1.)
     else:
         # external process
         if proc == -1:
@@ -136,7 +145,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
 # ..
 # .. utility functions for line-by-line ..
 
-
 def _find_script(script_name):
     """""" Find the script.
 
@@ -453,12 +461,6 @@ def magic_mprun(self, parameter_s=''):
         page(output)
     print(message,)
 
-#    dump_file = opts.D[0]
-#    if dump_file:
-#        profile.dump_stats(dump_file)
-#        print '\n*** Profile stats pickled to file',\
-#              `dump_file` + '.', message
-
     text_file = opts.T[0]
     if text_file:
         pfile = open(text_file, 'w')
","@@ -62,7 +62,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
 
     timeout : float, optional
 
-
     run_in_place : boolean, optional. False by default
         If False fork the process and retrieve timings from a different
         process. You shouldn't need to change this unless you are affected
@@ -101,6 +100,13 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
             f, args, kw = (proc[0], proc[1], proc[2])
         else:
             raise ValueError
+
+        aspec = inspect.getargspec(f)
+        if len(aspec.args) != len(args):
+            raise ValueError(
+            'Function expects %s value(s) but %s where given'
+            % (len(aspec.args), len(args)))
+
         try:
             import multiprocessing
         except ImportError:
@@ -118,10 +124,13 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         pid = getattr(main_thread, 'pid', os.getpid())
         while i < max_iter and main_thread.is_alive():
             m = _get_memory(pid)
+            if m == -1:
+                # this means the thread has finished
+                break
             ret.append(m)
             time.sleep(interval)
             i += 1
-        main_thread.join()
+        main_thread.join(1.)
     else:
         # external process
         if proc == -1:
@@ -136,7 +145,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
 # ..
 # .. utility functions for line-by-line ..
 
-
 def _find_script(script_name):
     """""" Find the script.
 
@@ -453,12 +461,6 @@ def magic_mprun(self, parameter_s=''):
         page(output)
     print(message,)
 
-#    dump_file = opts.D[0]
-#    if dump_file:
-#        profile.dump_stats(dump_file)
-#        print '\n*** Profile stats pickled to file',\
-#              `dump_file` + '.', message
-
     text_file = opts.T[0]
     if text_file:
         pfile = open(text_file, 'w')
",True,memory_profiler.py,True
"@@ -53,14 +53,17 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
     Parameters
     ----------
     proc : {int, string, tuple}, optional
-        The process to monitor. Can be given by a PID, by a string
-        containing a filename or by a tuple. The tuple should contain
-        three values (f, args, kw) specifies to run the function
-        f(*args, **kw).  Set to -1 (default) for current process.
+        The process to monitor. Can be given by an integer
+        representing a PID or by a tuple representing a Python
+        function. The tuple contains three values (f, args, kw) and
+        specifies to run the function f(*args, **kw).  Set to -1
+        (default) for current process.
 
     interval : float, optional
+        Interval at which measurements are collected.
 
     timeout : float, optional
+        Maximum amount of time (in seconds) to wait before returning.
 
     run_in_place : boolean, optional. False by default
         If False fork the process and retrieve timings from a different
@@ -70,8 +73,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
 
     Returns
     -------
-    mm : list of integers, size less than num
-        memory usage, in KB
+    mem_usage : list of floating-poing values
+        memory usage, in MB. It's length is always < timeout / interval
     """"""
     ret = []
 
@@ -88,6 +91,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         filename = _find_script(proc)
         with open(filename) as f:
             proc = f.read()
+        # XXX TODO
         raise NotImplementedError
 
     if isinstance(proc, (list, tuple)):
","@@ -53,14 +53,17 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
     Parameters
     ----------
     proc : {int, string, tuple}, optional
-        The process to monitor. Can be given by a PID, by a string
-        containing a filename or by a tuple. The tuple should contain
-        three values (f, args, kw) specifies to run the function
-        f(*args, **kw).  Set to -1 (default) for current process.
+        The process to monitor. Can be given by an integer
+        representing a PID or by a tuple representing a Python
+        function. The tuple contains three values (f, args, kw) and
+        specifies to run the function f(*args, **kw).  Set to -1
+        (default) for current process.
 
     interval : float, optional
+        Interval at which measurements are collected.
 
     timeout : float, optional
+        Maximum amount of time (in seconds) to wait before returning.
 
     run_in_place : boolean, optional. False by default
         If False fork the process and retrieve timings from a different
@@ -70,8 +73,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
 
     Returns
     -------
-    mm : list of integers, size less than num
-        memory usage, in KB
+    mem_usage : list of floating-poing values
+        memory usage, in MB. It's length is always < timeout / interval
     """"""
     ret = []
 
@@ -88,6 +91,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         filename = _find_script(proc)
         with open(filename) as f:
             proc = f.read()
+        # XXX TODO
         raise NotImplementedError
 
     if isinstance(proc, (list, tuple)):
",True,memory_profiler.py,True
"@@ -79,7 +79,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
     ret = []
 
     if timeout is not None:
-        max_iter = timeout / interval
+        max_iter = int(timeout / interval)
     elif isinstance(proc, int):
         # external process and no timeout
         max_iter = 1
","@@ -79,7 +79,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
     ret = []
 
     if timeout is not None:
-        max_iter = timeout / interval
+        max_iter = int(timeout / interval)
     elif isinstance(proc, int):
         # external process and no timeout
         max_iter = 1
",True,memory_profiler.py,True
"@@ -106,6 +106,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
             raise ValueError
 
         aspec = inspect.getargspec(f)
+        n_args = len(aspec.args)
+        if aspec.defaults is not None:
+            n_args -= len(aspec.defaults)
         if len(aspec.args) != len(args):
             raise ValueError(
             'Function expects %s value(s) but %s where given'
","@@ -106,6 +106,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
             raise ValueError
 
         aspec = inspect.getargspec(f)
+        n_args = len(aspec.args)
+        if aspec.defaults is not None:
+            n_args -= len(aspec.defaults)
         if len(aspec.args) != len(args):
             raise ValueError(
             'Function expects %s value(s) but %s where given'
",True,memory_profiler.py,True
"@@ -109,10 +109,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         n_args = len(aspec.args)
         if aspec.defaults is not None:
             n_args -= len(aspec.defaults)
-        if len(aspec.args) != len(args):
+        if n_args != len(args):
             raise ValueError(
             'Function expects %s value(s) but %s where given'
-            % (len(aspec.args), len(args)))
+            % (n_args, len(args)))
 
         try:
             import multiprocessing
","@@ -109,10 +109,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         n_args = len(aspec.args)
         if aspec.defaults is not None:
             n_args -= len(aspec.defaults)
-        if len(aspec.args) != len(args):
+        if n_args != len(args):
             raise ValueError(
             'Function expects %s value(s) but %s where given'
-            % (len(aspec.args), len(args)))
+            % (n_args, len(args)))
 
         try:
             import multiprocessing
",True,memory_profiler.py,True
"@@ -45,6 +45,30 @@ except ImportError:
         raise NotImplementedError('The psutil module is required for non-unix '
                                   'platforms')
 
+try:
+    from multiprocessing import Process, Event, Queue
+except ImportError:
+    from threading import Thread, Event, Queue
+    Process = Thread
+
+class Timer(Process):
+    """"""
+    Fetch memory consumption from over a time interval
+    """"""
+
+    def __init__(self, monitor_pid, interval, event, queue, *args, **kw):
+        self.monitor_pid = monitor_pid
+        self.q = queue
+        self.interval = interval
+        self.cont = True
+        self.e = event
+        super(Timer, self).__init__(*args, **kw)
+
+    def run(self):
+        while not self.e.is_set():
+            m = _get_memory(self.monitor_pid)
+            self.q.put(m)
+            time.sleep(self.interval)
 
 def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
     """"""
@@ -87,13 +111,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         # for a Python function wait until it finishes
         max_iter = float('inf')
 
-    if str(proc).endswith('.py'):
-        filename = _find_script(proc)
-        with open(filename) as f:
-            proc = f.read()
-        # XXX TODO
-        raise NotImplementedError
-
     if isinstance(proc, (list, tuple)):
 
         if len(proc) == 1:
@@ -114,30 +131,17 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
             'Function expects %s value(s) but %s where given'
             % (n_args, len(args)))
 
-        try:
-            import multiprocessing
-        except ImportError:
-            print ('WARNING: cannot import module `multiprocessing`. Forcing to'
-                   ' run inplace.')
-            # force inplace
-            run_in_place = True
-        if run_in_place:
-            import threading
-            main_thread = threading.Thread(target=f, args=args, kwargs=kw)
-        else:
-            main_thread = multiprocessing.Process(target=f, args=args, kwargs=kw)
-        i = 0
-        main_thread.start()
-        pid = getattr(main_thread, 'pid', os.getpid())
-        while i < max_iter and main_thread.is_alive():
-            m = _get_memory(pid)
-            if m == -1:
-                # this means the thread has finished
-                break
-            ret.append(m)
-            time.sleep(interval)
-            i += 1
-        main_thread.join(1.)
+        e = Event() # this will tell Timer when to stop measuring
+        q = Queue() # this will store Timer's results
+        p = Timer(os.getpid(), interval, e, q)
+        p.start()
+        f(*args, **kw)
+        e.set()
+        p.join(5 * interval)
+        ret = []
+        while not q.empty():
+            ret.append(q.get_nowait())
+
     else:
         # external process
         if proc == -1:
","@@ -45,6 +45,30 @@ except ImportError:
         raise NotImplementedError('The psutil module is required for non-unix '
                                   'platforms')
 
+try:
+    from multiprocessing import Process, Event, Queue
+except ImportError:
+    from threading import Thread, Event, Queue
+    Process = Thread
+
+class Timer(Process):
+    """"""
+    Fetch memory consumption from over a time interval
+    """"""
+
+    def __init__(self, monitor_pid, interval, event, queue, *args, **kw):
+        self.monitor_pid = monitor_pid
+        self.q = queue
+        self.interval = interval
+        self.cont = True
+        self.e = event
+        super(Timer, self).__init__(*args, **kw)
+
+    def run(self):
+        while not self.e.is_set():
+            m = _get_memory(self.monitor_pid)
+            self.q.put(m)
+            time.sleep(self.interval)
 
 def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
     """"""
@@ -87,13 +111,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         # for a Python function wait until it finishes
         max_iter = float('inf')
 
-    if str(proc).endswith('.py'):
-        filename = _find_script(proc)
-        with open(filename) as f:
-            proc = f.read()
-        # XXX TODO
-        raise NotImplementedError
-
     if isinstance(proc, (list, tuple)):
 
         if len(proc) == 1:
@@ -114,30 +131,17 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
             'Function expects %s value(s) but %s where given'
             % (n_args, len(args)))
 
-        try:
-            import multiprocessing
-        except ImportError:
-            print ('WARNING: cannot import module `multiprocessing`. Forcing to'
-                   ' run inplace.')
-            # force inplace
-            run_in_place = True
-        if run_in_place:
-            import threading
-            main_thread = threading.Thread(target=f, args=args, kwargs=kw)
-        else:
-            main_thread = multiprocessing.Process(target=f, args=args, kwargs=kw)
-        i = 0
-        main_thread.start()
-        pid = getattr(main_thread, 'pid', os.getpid())
-        while i < max_iter and main_thread.is_alive():
-            m = _get_memory(pid)
-            if m == -1:
-                # this means the thread has finished
-                break
-            ret.append(m)
-            time.sleep(interval)
-            i += 1
-        main_thread.join(1.)
+        e = Event() # this will tell Timer when to stop measuring
+        q = Queue() # this will store Timer's results
+        p = Timer(os.getpid(), interval, e, q)
+        p.start()
+        f(*args, **kw)
+        e.set()
+        p.join(5 * interval)
+        ret = []
+        while not q.empty():
+            ret.append(q.get_nowait())
+
     else:
         # external process
         if proc == -1:
",True,memory_profiler.py,True
"@@ -106,12 +106,35 @@ uses more than 100 MB in the decorated function.
 memory_profiler exposes a number of functions to be used in third-party
 code.
 
+
+
 ``memory_usage(proc=-1, interval=.1, timeout=None)`` returns the memory usage
 over a time interval. The first argument, ``proc`` represents what
 should be monitored.  This can either be the PID of a process (not
 necessarily a Python program), a string containing some python code to
 be evaluated or a tuple ``(f, args, kw)`` containing a function and its
-arguments to be evaluated as ``f(*args, **kw)``. For example::
+arguments to be evaluated as ``f(*args, **kw)``. For example,
+
+
+    >>> from memory_profiler import memory_usage
+    >>> mem_usage = memory_usage(-1, interval=.2, timeout=1)
+    >>> print(mem_usage)
+	[7.296875, 7.296875, 7.296875, 7.296875, 7.296875]
+
+
+Here I've told memory_profiler to get the memory consumption of the
+current process over a period of 1 second with a time interval of 0.2
+seconds. As PID I've given it -1, which is a special number (PIDs are
+usually positive) that means current process, that is, I'm getting the
+memory usage of the current Python interpreter. Thus I'm getting
+around 7MB of memory usage from a plain python interpreter. If I try
+the same thing on IPython (console) I get 29MB, and if I try the same
+thing on the IPython notebook it scales up to 44MB.
+
+
+If you'd like to get the memory consumption of a Python function, then
+you should specify the function and its arguments in the tuple ``(f,
+args, kw)``. For example::
 
 
     >>> # define a simple function
@@ -125,7 +148,8 @@ arguments to be evaluated as ``f(*args, **kw)``. For example::
     >>> from memory_profiler import memory_usage
     >>> memory_usage((f, (1,), {'n' : int(1e6)}))
 
-
+This will execute the code `f(1, n=int(1e6))` and return the memory
+consumption during this execution.
 
 
 =====================
","@@ -106,12 +106,35 @@ uses more than 100 MB in the decorated function.
 memory_profiler exposes a number of functions to be used in third-party
 code.
 
+
+
 ``memory_usage(proc=-1, interval=.1, timeout=None)`` returns the memory usage
 over a time interval. The first argument, ``proc`` represents what
 should be monitored.  This can either be the PID of a process (not
 necessarily a Python program), a string containing some python code to
 be evaluated or a tuple ``(f, args, kw)`` containing a function and its
-arguments to be evaluated as ``f(*args, **kw)``. For example::
+arguments to be evaluated as ``f(*args, **kw)``. For example,
+
+
+    >>> from memory_profiler import memory_usage
+    >>> mem_usage = memory_usage(-1, interval=.2, timeout=1)
+    >>> print(mem_usage)
+	[7.296875, 7.296875, 7.296875, 7.296875, 7.296875]
+
+
+Here I've told memory_profiler to get the memory consumption of the
+current process over a period of 1 second with a time interval of 0.2
+seconds. As PID I've given it -1, which is a special number (PIDs are
+usually positive) that means current process, that is, I'm getting the
+memory usage of the current Python interpreter. Thus I'm getting
+around 7MB of memory usage from a plain python interpreter. If I try
+the same thing on IPython (console) I get 29MB, and if I try the same
+thing on the IPython notebook it scales up to 44MB.
+
+
+If you'd like to get the memory consumption of a Python function, then
+you should specify the function and its arguments in the tuple ``(f,
+args, kw)``. For example::
 
 
     >>> # define a simple function
@@ -125,7 +148,8 @@ arguments to be evaluated as ``f(*args, **kw)``. For example::
     >>> from memory_profiler import memory_usage
     >>> memory_usage((f, (1,), {'n' : int(1e6)}))
 
-
+This will execute the code `f(1, n=int(1e6))` and return the memory
+consumption during this execution.
 
 
 =====================
",True,README.rst,False
"@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.19'
+__version__ = '0.20'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.19'
+__version__ = '0.20'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -56,21 +56,24 @@ class Timer(Process):
     Fetch memory consumption from over a time interval
     """"""
 
-    def __init__(self, monitor_pid, interval, event, queue, *args, **kw):
+    def __init__(self, monitor_pid, interval, queue, *args, **kw):
         self.monitor_pid = monitor_pid
         self.q = queue
         self.interval = interval
         self.cont = True
-        self.e = event
         super(Timer, self).__init__(*args, **kw)
 
     def run(self):
-        while not self.e.is_set():
+        while self.cont:
             m = _get_memory(self.monitor_pid)
             self.q.put(m)
             time.sleep(self.interval)
 
-def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
+    def join(self, timeout=None):
+        self.cont = False
+        super(Timer, self).join(timeout=timeout)
+
+def memory_usage(proc=-1, interval=.1, timeout=None):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -89,12 +92,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
     timeout : float, optional
         Maximum amount of time (in seconds) to wait before returning.
 
-    run_in_place : boolean, optional. False by default
-        If False fork the process and retrieve timings from a different
-        process. You shouldn't need to change this unless you are affected
-        by this (http://blog.vene.ro/2012/07/04/on-why-my-memit-fails-on-osx)
-        bug.
-
     Returns
     -------
     mem_usage : list of floating-poing values
@@ -131,14 +128,12 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
             'Function expects %s value(s) but %s where given'
             % (n_args, len(args)))
 
-        e = Event() # this will tell Timer when to stop measuring
         q = Queue() # this will store Timer's results
-        p = Timer(os.getpid(), interval, e, q)
+        p = Timer(os.getpid(), interval, q)
         p.start()
+        ret = [q.get()] # wait for timer to start measuring
         f(*args, **kw)
-        e.set()
         p.join(5 * interval)
-        ret = []
         while not q.empty():
             ret.append(q.get_nowait())
 
@@ -503,10 +498,6 @@ def magic_memit(self, line=''):
     -r<R>: repeat the loop iteration <R> times and take the best result.
     Default: 1
 
-    -i: run the code in the current environment, without forking a new process.
-    This is required on some MacOS versions of Accelerate if your line contains
-    a call to `np.dot`.
-
     -t<T>: timeout after <T> seconds. Unused if `-i` is active. Default: None
 
     Examples
@@ -540,10 +531,8 @@ def magic_memit(self, line=''):
     timeout = int(getattr(opts, 't', 0))
     if timeout <= 0:
         timeout = None
-    run_in_place = hasattr(opts, 'i')
 
-    mem_usage = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout,
-        run_in_place=run_in_place)
+    mem_usage = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout)
 
     if mem_usage:
         print('maximum of %d: %f MB per loop' % (repeat, max(mem_usage)))
","@@ -56,21 +56,24 @@ class Timer(Process):
     Fetch memory consumption from over a time interval
     """"""
 
-    def __init__(self, monitor_pid, interval, event, queue, *args, **kw):
+    def __init__(self, monitor_pid, interval, queue, *args, **kw):
         self.monitor_pid = monitor_pid
         self.q = queue
         self.interval = interval
         self.cont = True
-        self.e = event
         super(Timer, self).__init__(*args, **kw)
 
     def run(self):
-        while not self.e.is_set():
+        while self.cont:
             m = _get_memory(self.monitor_pid)
             self.q.put(m)
             time.sleep(self.interval)
 
-def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
+    def join(self, timeout=None):
+        self.cont = False
+        super(Timer, self).join(timeout=timeout)
+
+def memory_usage(proc=-1, interval=.1, timeout=None):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -89,12 +92,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
     timeout : float, optional
         Maximum amount of time (in seconds) to wait before returning.
 
-    run_in_place : boolean, optional. False by default
-        If False fork the process and retrieve timings from a different
-        process. You shouldn't need to change this unless you are affected
-        by this (http://blog.vene.ro/2012/07/04/on-why-my-memit-fails-on-osx)
-        bug.
-
     Returns
     -------
     mem_usage : list of floating-poing values
@@ -131,14 +128,12 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
             'Function expects %s value(s) but %s where given'
             % (n_args, len(args)))
 
-        e = Event() # this will tell Timer when to stop measuring
         q = Queue() # this will store Timer's results
-        p = Timer(os.getpid(), interval, e, q)
+        p = Timer(os.getpid(), interval, q)
         p.start()
+        ret = [q.get()] # wait for timer to start measuring
         f(*args, **kw)
-        e.set()
         p.join(5 * interval)
-        ret = []
         while not q.empty():
             ret.append(q.get_nowait())
 
@@ -503,10 +498,6 @@ def magic_memit(self, line=''):
     -r<R>: repeat the loop iteration <R> times and take the best result.
     Default: 1
 
-    -i: run the code in the current environment, without forking a new process.
-    This is required on some MacOS versions of Accelerate if your line contains
-    a call to `np.dot`.
-
     -t<T>: timeout after <T> seconds. Unused if `-i` is active. Default: None
 
     Examples
@@ -540,10 +531,8 @@ def magic_memit(self, line=''):
     timeout = int(getattr(opts, 't', 0))
     if timeout <= 0:
         timeout = None
-    run_in_place = hasattr(opts, 'i')
 
-    mem_usage = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout,
-        run_in_place=run_in_place)
+    mem_usage = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout)
 
     if mem_usage:
         print('maximum of %d: %f MB per loop' % (repeat, max(mem_usage)))
",True,memory_profiler.py,True
"@@ -10,6 +10,13 @@ import linecache
 import inspect
 
 
+# TODO: provide alternative when multprocessing is not available
+try:
+    from multiprocessing import Process, Pipe
+except ImportError:
+    from multiprocessing.dummy import Process, Pipe
+
+
 try:
     import psutil
 
@@ -45,33 +52,28 @@ except ImportError:
         raise NotImplementedError('The psutil module is required for non-unix '
                                   'platforms')
 
-try:
-    from multiprocessing import Process, Event, Queue
-except ImportError:
-    from threading import Thread, Event, Queue
-    Process = Thread
 
 class Timer(Process):
     """"""
     Fetch memory consumption from over a time interval
     """"""
 
-    def __init__(self, monitor_pid, interval, queue, *args, **kw):
+    def __init__(self, monitor_pid, interval, pipe, *args, **kw):
         self.monitor_pid = monitor_pid
-        self.q = queue
         self.interval = interval
+        self.pipe = pipe
         self.cont = True
         super(Timer, self).__init__(*args, **kw)
 
     def run(self):
-        while self.cont:
+        m = _get_memory(self.monitor_pid)
+        timings = [m]
+        self.pipe.send(0) # we're ready
+        while not self.pipe.poll(self.interval):
             m = _get_memory(self.monitor_pid)
-            self.q.put(m)
-            time.sleep(self.interval)
+            timings.append(m)
+        self.pipe.send(timings)
 
-    def join(self, timeout=None):
-        self.cont = False
-        super(Timer, self).join(timeout=timeout)
 
 def memory_usage(proc=-1, interval=.1, timeout=None):
     """"""
@@ -128,15 +130,14 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
             'Function expects %s value(s) but %s where given'
             % (n_args, len(args)))
 
-        q = Queue() # this will store Timer's results
-        p = Timer(os.getpid(), interval, q)
+        a, b =  Pipe() # this will store Timer's results
+        p = Timer(os.getpid(), interval, a)
         p.start()
-        ret = [q.get()] # wait for timer to start measuring
+        b.recv() # wait until we start getting memory
         f(*args, **kw)
+        b.send(0) # finish timing
+        ret = b.recv()
         p.join(5 * interval)
-        while not q.empty():
-            ret.append(q.get_nowait())
-
     else:
         # external process
         if proc == -1:
","@@ -10,6 +10,13 @@ import linecache
 import inspect
 
 
+# TODO: provide alternative when multprocessing is not available
+try:
+    from multiprocessing import Process, Pipe
+except ImportError:
+    from multiprocessing.dummy import Process, Pipe
+
+
 try:
     import psutil
 
@@ -45,33 +52,28 @@ except ImportError:
         raise NotImplementedError('The psutil module is required for non-unix '
                                   'platforms')
 
-try:
-    from multiprocessing import Process, Event, Queue
-except ImportError:
-    from threading import Thread, Event, Queue
-    Process = Thread
 
 class Timer(Process):
     """"""
     Fetch memory consumption from over a time interval
     """"""
 
-    def __init__(self, monitor_pid, interval, queue, *args, **kw):
+    def __init__(self, monitor_pid, interval, pipe, *args, **kw):
         self.monitor_pid = monitor_pid
-        self.q = queue
         self.interval = interval
+        self.pipe = pipe
         self.cont = True
         super(Timer, self).__init__(*args, **kw)
 
     def run(self):
-        while self.cont:
+        m = _get_memory(self.monitor_pid)
+        timings = [m]
+        self.pipe.send(0) # we're ready
+        while not self.pipe.poll(self.interval):
             m = _get_memory(self.monitor_pid)
-            self.q.put(m)
-            time.sleep(self.interval)
+            timings.append(m)
+        self.pipe.send(timings)
 
-    def join(self, timeout=None):
-        self.cont = False
-        super(Timer, self).join(timeout=timeout)
 
 def memory_usage(proc=-1, interval=.1, timeout=None):
     """"""
@@ -128,15 +130,14 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
             'Function expects %s value(s) but %s where given'
             % (n_args, len(args)))
 
-        q = Queue() # this will store Timer's results
-        p = Timer(os.getpid(), interval, q)
+        a, b =  Pipe() # this will store Timer's results
+        p = Timer(os.getpid(), interval, a)
         p.start()
-        ret = [q.get()] # wait for timer to start measuring
+        b.recv() # wait until we start getting memory
         f(*args, **kw)
+        b.send(0) # finish timing
+        ret = b.recv()
         p.join(5 * interval)
-        while not q.empty():
-            ret.append(q.get_nowait())
-
     else:
         # external process
         if proc == -1:
",True,memory_profiler.py,True
"@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.20'
+__version__ = '0.21'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.20'
+__version__ = '0.21'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -363,8 +363,8 @@ def show_results(prof, stream=None):
                 mem = max(lines_normalized[l])
                 inc = mem - mem_old
                 mem_old = mem
-                mem = '{0:9.2f} MB'.format(mem)
-                inc = '{0:9.2f} MB'.format(inc)
+                mem = '{0:9.6f} MB'.format(mem)
+                inc = '{0:9.6f} MB'.format(inc)
             stream.write(template.format(l, mem, inc, sub_lines[i]))
         stream.write('\n\n')
 
","@@ -363,8 +363,8 @@ def show_results(prof, stream=None):
                 mem = max(lines_normalized[l])
                 inc = mem - mem_old
                 mem_old = mem
-                mem = '{0:9.2f} MB'.format(mem)
-                inc = '{0:9.2f} MB'.format(inc)
+                mem = '{0:9.6f} MB'.format(mem)
+                inc = '{0:9.6f} MB'.format(inc)
             stream.write(template.format(l, mem, inc, sub_lines[i]))
         stream.write('\n\n')
 
",True,memory_profiler.py,True
"@@ -308,7 +308,7 @@ class LineProfiler:
         sys.settrace(None)
 
 
-def show_results(prof, stream=None):
+def show_results(prof, stream=None, precision=3):
     if stream is None:
         stream = sys.stdout
     template = '{0:>6} {1:>12} {2:>12}   {3:<}'
@@ -356,6 +356,8 @@ def show_results(prof, stream=None):
 
         first_line = sorted(lines_normalized.keys())[0]
         mem_old = max(lines_normalized[first_line])
+        precision = int(precision)
+        template_mem = '{{0:{0}.{1}'.format(precision + 6, precision) + 'f} MB'
         for i, l in enumerate(linenos):
             mem = ''
             inc = ''
@@ -363,8 +365,8 @@ def show_results(prof, stream=None):
                 mem = max(lines_normalized[l])
                 inc = mem - mem_old
                 mem_old = mem
-                mem = '{0:9.6f} MB'.format(mem)
-                inc = '{0:9.6f} MB'.format(inc)
+                mem = template_mem.format(mem)
+                inc = template_mem.format(inc)
             stream.write(template.format(l, mem, inc, sub_lines[i]))
         stream.write('\n\n')
 
@@ -542,6 +544,9 @@ def magic_memit(self, line=''):
 
 
 def profile(func, stream=None):
+    """"""
+    Decorator that will run the function and print a line-by-line profile
+    """"""
     def wrapper(*args, **kwargs):
         prof = LineProfiler()
         val = prof(func)(*args, **kwargs)
@@ -557,6 +562,9 @@ if __name__ == '__main__':
     parser.add_option(""--pdb-mmem"", dest=""max_mem"", metavar=""MAXMEM"",
         type=""float"", action=""store"",
         help=""step into the debugger when memory exceeds MAXMEM"")
+    parser.add_option('--precision', dest=""precision"", type=""int"",
+        action=""store"", default=3,
+        help=""precision of memory output in number of significant digits"")
 
     if not sys.argv[1:]:
         parser.print_help()
@@ -566,14 +574,19 @@ if __name__ == '__main__':
 
     prof = LineProfiler(max_mem=options.max_mem)
     __file__ = _find_script(args[0])
-    if sys.version_info[0] < 3:
-        import __builtin__
-        __builtin__.__dict__['profile'] = prof
-        execfile(__file__, locals(), locals())
-    else:
-        import builtins
-        builtins.__dict__['profile'] = prof
-        exec(compile(open(__file__).read(), __file__, 'exec'), locals(),
-                                                               globals())
-
-    show_results(prof)
+    try:
+        if sys.version_info[0] < 3:
+            import __builtin__
+            __builtin__.__dict__['profile'] = prof
+            ns = locals()
+            ns['profile'] = prof # shadow the profile decorator defined above
+            execfile(__file__, ns, ns)
+        else:
+            import builtins
+            builtins.__dict__['profile'] = prof
+            ns = locals()
+            ns['profile'] = prof # shadow the profile decorator defined above
+            exec(compile(open(__file__).read(), __file__, 'exec'), ns,
+                                                                   globals())
+    finally:
+        show_results(prof, precision=options.precision)
","@@ -308,7 +308,7 @@ class LineProfiler:
         sys.settrace(None)
 
 
-def show_results(prof, stream=None):
+def show_results(prof, stream=None, precision=3):
     if stream is None:
         stream = sys.stdout
     template = '{0:>6} {1:>12} {2:>12}   {3:<}'
@@ -356,6 +356,8 @@ def show_results(prof, stream=None):
 
         first_line = sorted(lines_normalized.keys())[0]
         mem_old = max(lines_normalized[first_line])
+        precision = int(precision)
+        template_mem = '{{0:{0}.{1}'.format(precision + 6, precision) + 'f} MB'
         for i, l in enumerate(linenos):
             mem = ''
             inc = ''
@@ -363,8 +365,8 @@ def show_results(prof, stream=None):
                 mem = max(lines_normalized[l])
                 inc = mem - mem_old
                 mem_old = mem
-                mem = '{0:9.6f} MB'.format(mem)
-                inc = '{0:9.6f} MB'.format(inc)
+                mem = template_mem.format(mem)
+                inc = template_mem.format(inc)
             stream.write(template.format(l, mem, inc, sub_lines[i]))
         stream.write('\n\n')
 
@@ -542,6 +544,9 @@ def magic_memit(self, line=''):
 
 
 def profile(func, stream=None):
+    """"""
+    Decorator that will run the function and print a line-by-line profile
+    """"""
     def wrapper(*args, **kwargs):
         prof = LineProfiler()
         val = prof(func)(*args, **kwargs)
@@ -557,6 +562,9 @@ if __name__ == '__main__':
     parser.add_option(""--pdb-mmem"", dest=""max_mem"", metavar=""MAXMEM"",
         type=""float"", action=""store"",
         help=""step into the debugger when memory exceeds MAXMEM"")
+    parser.add_option('--precision', dest=""precision"", type=""int"",
+        action=""store"", default=3,
+        help=""precision of memory output in number of significant digits"")
 
     if not sys.argv[1:]:
         parser.print_help()
@@ -566,14 +574,19 @@ if __name__ == '__main__':
 
     prof = LineProfiler(max_mem=options.max_mem)
     __file__ = _find_script(args[0])
-    if sys.version_info[0] < 3:
-        import __builtin__
-        __builtin__.__dict__['profile'] = prof
-        execfile(__file__, locals(), locals())
-    else:
-        import builtins
-        builtins.__dict__['profile'] = prof
-        exec(compile(open(__file__).read(), __file__, 'exec'), locals(),
-                                                               globals())
-
-    show_results(prof)
+    try:
+        if sys.version_info[0] < 3:
+            import __builtin__
+            __builtin__.__dict__['profile'] = prof
+            ns = locals()
+            ns['profile'] = prof # shadow the profile decorator defined above
+            execfile(__file__, ns, ns)
+        else:
+            import builtins
+            builtins.__dict__['profile'] = prof
+            ns = locals()
+            ns['profile'] = prof # shadow the profile decorator defined above
+            exec(compile(open(__file__).read(), __file__, 'exec'), ns,
+                                                                   globals())
+    finally:
+        show_results(prof, precision=options.precision)
",True,memory_profiler.py,True
"@@ -543,6 +543,12 @@ def magic_memit(self, line=''):
         print('ERROR: could not read memory usage, try with a lower interval or more iterations')
 
 
+def load_ipython_extension(ip):
+    """"""This is called to load the module as an IPython extension.""""""
+    ip.define_magic('mprun', magic_mprun)
+    ip.define_magic('memit', magic_memit)
+
+
 def profile(func, stream=None):
     """"""
     Decorator that will run the function and print a line-by-line profile
","@@ -543,6 +543,12 @@ def magic_memit(self, line=''):
         print('ERROR: could not read memory usage, try with a lower interval or more iterations')
 
 
+def load_ipython_extension(ip):
+    """"""This is called to load the module as an IPython extension.""""""
+    ip.define_magic('mprun', magic_mprun)
+    ip.define_magic('memit', magic_memit)
+
+
 def profile(func, stream=None):
     """"""
     Decorator that will run the function and print a line-by-line profile
",True,memory_profiler.py,True
"@@ -155,46 +155,24 @@ consumption during this execution.
 =====================
  IPython integration
 =====================
-After installing the module, if you use IPython, you can set up the `%mprun`
-and `%memit` magics by following these steps.
+After installing the module, if you use IPython, you can use the `%mprun`
+and `%memit` magics.
 
-For IPython 0.10, you can install it by editing the IPython configuration
-file ~/.ipython/ipy_user_conf.py to add the following lines::
-
-    # These two lines are standard and probably already there.
-    import IPython.ipapi
-    ip = IPython.ipapi.get()
-
-    # These two are the important ones.
-    import memory_profiler
-    ip.expose_magic('mprun', memory_profiler.magic_mprun)
-    ip.expose_magic('memit', memory_profiler.magic_memit)
-
-For IPython 0.11+, you have to edit the file
-~/.ipython/extensions/memory_profiler_ext.py with the following content::
-
-    import memory_profiler
-
-    def load_ipython_extension(ip):
-        ip.define_magic('mprun', memory_profiler.magic_mprun)
-        ip.define_magic('memit', memory_profiler.magic_memit)
-
-If you don't have an IPython profile already set up, create one using the
-following command::
+For IPython 0.11+, you can use the module directly as an extension, with
+``%load_ext memory_profiler``.
 
-    $ ipython profile create
+To activate it whenever you start IPython, edit the configuration file for your
+IPython profile, ~/.ipython/profile_default/ipython_config.py, to register the
+extension like this (If you already have other extensions, just add this one to
+the list)::
 
-Then, edit the configuration file for your IPython profile,
-~/.ipython/profile_default/ipython_config.py, to register the extension like
-this (If you already have other extensions, just add this one to the list)::
-
-    c.TerminalIPythonApp.extensions = [
-        'memory_profiler_ext',
-    ]
     c.InteractiveShellApp.extensions = [
-        'memory_profiler_ext',
+        'memory_profiler',
     ]
 
+(If the config file doesn't already exist, run ``ipython profile create`` in
+a terminal.)
+
 It then can be used directly from IPython to obtain a line-by-line
 report using the `%mprun` magic command. In this case, you can skip
 the `@profile` decorator and instead use the `-f` parameter, like
@@ -215,6 +193,18 @@ Another useful magic that we define is `%memit`, which is analogous to
 
 For more details, see the docstrings of the magics.
 
+For IPython 0.10, you can install it by editing the IPython configuration
+file ~/.ipython/ipy_user_conf.py to add the following lines::
+
+    # These two lines are standard and probably already there.
+    import IPython.ipapi
+    ip = IPython.ipapi.get()
+
+    # These two are the important ones.
+    import memory_profiler
+    ip.expose_magic('mprun', memory_profiler.magic_mprun)
+    ip.expose_magic('memit', memory_profiler.magic_memit)
+
 ============================
  Frequently Asked Questions
 ============================
","@@ -155,46 +155,24 @@ consumption during this execution.
 =====================
  IPython integration
 =====================
-After installing the module, if you use IPython, you can set up the `%mprun`
-and `%memit` magics by following these steps.
+After installing the module, if you use IPython, you can use the `%mprun`
+and `%memit` magics.
 
-For IPython 0.10, you can install it by editing the IPython configuration
-file ~/.ipython/ipy_user_conf.py to add the following lines::
+For IPython 0.11+, you can use the module directly as an extension, with
+``%load_ext memory_profiler``.
 
-    # These two lines are standard and probably already there.
-    import IPython.ipapi
-    ip = IPython.ipapi.get()
+To activate it whenever you start IPython, edit the configuration file for your
+IPython profile, ~/.ipython/profile_default/ipython_config.py, to register the
+extension like this (If you already have other extensions, just add this one to
+the list)::
 
-    # These two are the important ones.
-    import memory_profiler
-    ip.expose_magic('mprun', memory_profiler.magic_mprun)
-    ip.expose_magic('memit', memory_profiler.magic_memit)
-
-For IPython 0.11+, you have to edit the file
-~/.ipython/extensions/memory_profiler_ext.py with the following content::
-
-    import memory_profiler
-
-    def load_ipython_extension(ip):
-        ip.define_magic('mprun', memory_profiler.magic_mprun)
-        ip.define_magic('memit', memory_profiler.magic_memit)
-
-If you don't have an IPython profile already set up, create one using the
-following command::
-
-    $ ipython profile create
-
-Then, edit the configuration file for your IPython profile,
-~/.ipython/profile_default/ipython_config.py, to register the extension like
-this (If you already have other extensions, just add this one to the list)::
-
-    c.TerminalIPythonApp.extensions = [
-        'memory_profiler_ext',
-    ]
     c.InteractiveShellApp.extensions = [
-        'memory_profiler_ext',
+        'memory_profiler',
     ]
 
+(If the config file doesn't already exist, run ``ipython profile create`` in
+a terminal.)
+
 It then can be used directly from IPython to obtain a line-by-line
 report using the `%mprun` magic command. In this case, you can skip
 the `@profile` decorator and instead use the `-f` parameter, like
@@ -215,6 +193,18 @@ Another useful magic that we define is `%memit`, which is analogous to
 
 For more details, see the docstrings of the magics.
 
+For IPython 0.10, you can install it by editing the IPython configuration
+file ~/.ipython/ipy_user_conf.py to add the following lines::
+
+    # These two lines are standard and probably already there.
+    import IPython.ipapi
+    ip = IPython.ipapi.get()
+
+    # These two are the important ones.
+    import memory_profiler
+    ip.expose_magic('mprun', memory_profiler.magic_mprun)
+    ip.expose_magic('memit', memory_profiler.magic_memit)
+
 ============================
  Frequently Asked Questions
 ============================
",False,README.rst,False
"@@ -260,6 +260,8 @@ cleanup.
 
 `Vlad Niculae <http://vene.ro/>`_ added the `%mprun` and `%memit` IPython magics.
 
+`Thomas Kluyver <https://github.com/takluyver>`_ added the IPython extension.
+
 
 
 =========
","@@ -260,6 +260,8 @@ cleanup.
 
 `Vlad Niculae <http://vene.ro/>`_ added the `%mprun` and `%memit` IPython magics.
 
+`Thomas Kluyver <https://github.com/takluyver>`_ added the IPython extension.
+
 
 
 =========
",True,README.rst,False
"@@ -1,4 +1,5 @@
 .idea
 dist
+build
 *.pyc
 MANIFEST
","@@ -1,4 +1,5 @@
 .idea
 dist
+build
 *.pyc
 MANIFEST
",True,.gitignore,False
"@@ -167,7 +167,7 @@ def _find_script(script_name):
         if os.path.isfile(fn):
             return fn
 
-    print >> sys.stderr, 'Could not find script {0}'.format(script_name)
+    sys.stderr.write('Could not find script {0}\n'.format(script_name))
     raise SystemExit(1)
 
 
@@ -401,7 +401,10 @@ def magic_mprun(self, parameter_s=''):
 
     -r: return the LineProfiler object after it has completed profiling.
     """"""
-    from StringIO import StringIO
+    try:
+        from StringIO import StringIO
+    except ImportError: # Python 3.x
+        from io import StringIO
 
     # Local imports to avoid hard dependency.
     from distutils.version import LooseVersion
@@ -434,16 +437,22 @@ def magic_mprun(self, parameter_s=''):
                 e.__class__.__name__, e))
 
     profile = LineProfiler()
-    map(profile, funcs)
+    for func in funcs:
+        profile(func)
+
     # Add the profiler to the builtins for @profile.
-    import __builtin__
-    if 'profile' in __builtin__.__dict__:
+    try:
+        import builtins
+    except ImportError: # Python 3x
+        import __builtin__ as builtins
+
+    if 'profile' in builtins.__dict__:
         had_profile = True
-        old_profile = __builtin__.__dict__['profile']
+        old_profile = builtins.__dict__['profile']
     else:
         had_profile = False
         old_profile = None
-    __builtin__.__dict__['profile'] = profile
+    builtins.__dict__['profile'] = profile
 
     try:
         try:
@@ -456,7 +465,7 @@ def magic_mprun(self, parameter_s=''):
                 ""profiled."")
     finally:
         if had_profile:
-            __builtin__.__dict__['profile'] = old_profile
+            builtins.__dict__['profile'] = old_profile
 
     # Trap text output.
     stdout_trap = StringIO()
","@@ -167,7 +167,7 @@ def _find_script(script_name):
         if os.path.isfile(fn):
             return fn
 
-    print >> sys.stderr, 'Could not find script {0}'.format(script_name)
+    sys.stderr.write('Could not find script {0}\n'.format(script_name))
     raise SystemExit(1)
 
 
@@ -401,7 +401,10 @@ def magic_mprun(self, parameter_s=''):
 
     -r: return the LineProfiler object after it has completed profiling.
     """"""
-    from StringIO import StringIO
+    try:
+        from StringIO import StringIO
+    except ImportError: # Python 3.x
+        from io import StringIO
 
     # Local imports to avoid hard dependency.
     from distutils.version import LooseVersion
@@ -434,16 +437,22 @@ def magic_mprun(self, parameter_s=''):
                 e.__class__.__name__, e))
 
     profile = LineProfiler()
-    map(profile, funcs)
+    for func in funcs:
+        profile(func)
+
     # Add the profiler to the builtins for @profile.
-    import __builtin__
-    if 'profile' in __builtin__.__dict__:
+    try:
+        import builtins
+    except ImportError: # Python 3x
+        import __builtin__ as builtins
+
+    if 'profile' in builtins.__dict__:
         had_profile = True
-        old_profile = __builtin__.__dict__['profile']
+        old_profile = builtins.__dict__['profile']
     else:
         had_profile = False
         old_profile = None
-    __builtin__.__dict__['profile'] = profile
+    builtins.__dict__['profile'] = profile
 
     try:
         try:
@@ -456,7 +465,7 @@ def magic_mprun(self, parameter_s=''):
                 ""profiled."")
     finally:
         if had_profile:
-            __builtin__.__dict__['profile'] = old_profile
+            builtins.__dict__['profile'] = old_profile
 
     # Trap text output.
     stdout_trap = StringIO()
",True,memory_profiler.py,True
"@@ -7,7 +7,12 @@ Intended Audience :: Science/Research
 Intended Audience :: Developers
 License :: OSI Approved
 Programming Language :: Python
+Programming Language :: Python :: 2
+Programming Language :: Python :: 2.6
+Programming Language :: Python :: 2.7
 Programming Language :: Python :: 3
+Programming Language :: Python :: 3.2
+Programming Language :: Python :: 3.3
 Topic :: Software Development
 Operating System :: POSIX
 Operating System :: Unix
","@@ -7,7 +7,12 @@ Intended Audience :: Science/Research
 Intended Audience :: Developers
 License :: OSI Approved
 Programming Language :: Python
+Programming Language :: Python :: 2
+Programming Language :: Python :: 2.6
+Programming Language :: Python :: 2.7
 Programming Language :: Python :: 3
+Programming Language :: Python :: 3.2
+Programming Language :: Python :: 3.3
 Topic :: Software Development
 Operating System :: POSIX
 Operating System :: Unix
",True,setup.py,True
"@@ -324,7 +324,7 @@ def show_results(prof, stream=None, precision=3):
         stream.write('Filename: ' + filename + '\n\n')
         if not os.path.exists(filename):
             stream.write('ERROR: Could not find file ' + filename + '\n')
-            if filename.startswith(""ipython-input""):
+            if filename.startswith(""ipython-input"") or filename.startswith(""<ipython-input""):
                 print(""NOTE: %mprun can only be used on functions defined in ""
                       ""physical files, and not in the IPython environment."")
             continue
","@@ -324,7 +324,7 @@ def show_results(prof, stream=None, precision=3):
         stream.write('Filename: ' + filename + '\n\n')
         if not os.path.exists(filename):
             stream.write('ERROR: Could not find file ' + filename + '\n')
-            if filename.startswith(""ipython-input""):
+            if filename.startswith(""ipython-input"") or filename.startswith(""<ipython-input""):
                 print(""NOTE: %mprun can only be used on functions defined in ""
                       ""physical files, and not in the IPython environment."")
             continue
",True,memory_profiler.py,True
"@@ -68,7 +68,7 @@ class Timer(Process):
     def run(self):
         m = _get_memory(self.monitor_pid)
         timings = [m]
-        self.pipe.send(0) # we're ready
+        self.pipe.send(0)  # we're ready
         while not self.pipe.poll(self.interval):
             m = _get_memory(self.monitor_pid)
             timings.append(m)
@@ -130,13 +130,13 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
             'Function expects %s value(s) but %s where given'
             % (n_args, len(args)))
 
-        a, b =  Pipe() # this will store Timer's results
-        p = Timer(os.getpid(), interval, a)
+        child_conn, parent_conn = Pipe()  # this will store Timer's results
+        p = Timer(os.getpid(), interval, child_conn)
         p.start()
-        b.recv() # wait until we start getting memory
+        parent_conn.recv()  # wait until we start getting memory
         f(*args, **kw)
-        b.send(0) # finish timing
-        ret = b.recv()
+        parent_conn.send(0)  # finish timing
+        ret = parent_conn.recv()
         p.join(5 * interval)
     else:
         # external process
@@ -160,10 +160,10 @@ def _find_script(script_name):
     if os.path.isfile(script_name):
         return script_name
     path = os.getenv('PATH', os.defpath).split(os.pathsep)
-    for dir in path:
-        if dir == '':
+    for folder in path:
+        if folder == '':
             continue
-        fn = os.path.join(dir, script_name)
+        fn = os.path.join(folder, script_name)
         if os.path.isfile(fn):
             return fn
 
@@ -221,8 +221,8 @@ class LineProfiler:
         """""" Profile a single executable statment in the main namespace.
         """"""
         import __main__
-        dict = __main__.__dict__
-        return self.runctx(cmd, dict, dict)
+        main_dict = __main__.__dict__
+        return self.runctx(cmd, main_dict, main_dict)
 
     def runctx(self, cmd, globals, locals):
         """""" Profile a single executable statement in the given namespaces.
@@ -263,11 +263,11 @@ class LineProfiler:
     def trace_memory_usage(self, frame, event, arg):
         """"""Callback for sys.settrace""""""
         if event in ('line', 'return') and frame.f_code in self.code_map:
-                lineno = frame.f_lineno
-                if event == 'return':
-                    lineno += 1
-                entry = self.code_map[frame.f_code].setdefault(lineno, [])
-                entry.append(_get_memory(os.getpid()))
+            lineno = frame.f_lineno
+            if event == 'return':
+                lineno += 1
+            entry = self.code_map[frame.f_code].setdefault(lineno, [])
+            entry.append(_get_memory(os.getpid()))
 
         return self.trace_memory_usage
 
@@ -472,9 +472,8 @@ def magic_mprun(self, parameter_s=''):
 
     text_file = opts.T[0]
     if text_file:
-        pfile = open(text_file, 'w')
-        pfile.write(output)
-        pfile.close()
+        with open(text_file, 'w') as pfile:
+            pfile.write(output)
         print('\n*** Profile printout saved to text file %s. %s' % (text_file,
                                                                     message))
 
","@@ -68,7 +68,7 @@ class Timer(Process):
     def run(self):
         m = _get_memory(self.monitor_pid)
         timings = [m]
-        self.pipe.send(0) # we're ready
+        self.pipe.send(0)  # we're ready
         while not self.pipe.poll(self.interval):
             m = _get_memory(self.monitor_pid)
             timings.append(m)
@@ -130,13 +130,13 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
             'Function expects %s value(s) but %s where given'
             % (n_args, len(args)))
 
-        a, b =  Pipe() # this will store Timer's results
-        p = Timer(os.getpid(), interval, a)
+        child_conn, parent_conn = Pipe()  # this will store Timer's results
+        p = Timer(os.getpid(), interval, child_conn)
         p.start()
-        b.recv() # wait until we start getting memory
+        parent_conn.recv()  # wait until we start getting memory
         f(*args, **kw)
-        b.send(0) # finish timing
-        ret = b.recv()
+        parent_conn.send(0)  # finish timing
+        ret = parent_conn.recv()
         p.join(5 * interval)
     else:
         # external process
@@ -160,10 +160,10 @@ def _find_script(script_name):
     if os.path.isfile(script_name):
         return script_name
     path = os.getenv('PATH', os.defpath).split(os.pathsep)
-    for dir in path:
-        if dir == '':
+    for folder in path:
+        if folder == '':
             continue
-        fn = os.path.join(dir, script_name)
+        fn = os.path.join(folder, script_name)
         if os.path.isfile(fn):
             return fn
 
@@ -221,8 +221,8 @@ class LineProfiler:
         """""" Profile a single executable statment in the main namespace.
         """"""
         import __main__
-        dict = __main__.__dict__
-        return self.runctx(cmd, dict, dict)
+        main_dict = __main__.__dict__
+        return self.runctx(cmd, main_dict, main_dict)
 
     def runctx(self, cmd, globals, locals):
         """""" Profile a single executable statement in the given namespaces.
@@ -263,11 +263,11 @@ class LineProfiler:
     def trace_memory_usage(self, frame, event, arg):
         """"""Callback for sys.settrace""""""
         if event in ('line', 'return') and frame.f_code in self.code_map:
-                lineno = frame.f_lineno
-                if event == 'return':
-                    lineno += 1
-                entry = self.code_map[frame.f_code].setdefault(lineno, [])
-                entry.append(_get_memory(os.getpid()))
+            lineno = frame.f_lineno
+            if event == 'return':
+                lineno += 1
+            entry = self.code_map[frame.f_code].setdefault(lineno, [])
+            entry.append(_get_memory(os.getpid()))
 
         return self.trace_memory_usage
 
@@ -472,9 +472,8 @@ def magic_mprun(self, parameter_s=''):
 
     text_file = opts.T[0]
     if text_file:
-        pfile = open(text_file, 'w')
-        pfile.write(output)
-        pfile.close()
+        with open(text_file, 'w') as pfile:
+            pfile.write(output)
         print('\n*** Profile printout saved to text file %s. %s' % (text_file,
                                                                     message))
 
",True,memory_profiler.py,True
"@@ -144,7 +144,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
             proc = os.getpid()
         if max_iter == -1:
             max_iter = 1
-        for _ in range(max_iter):
+        counter = 0
+        while counter < max_iter:
+            counter += 1
             ret.append(_get_memory(proc))
             time.sleep(interval)
     return ret
@@ -443,7 +445,7 @@ def magic_mprun(self, parameter_s=''):
     # Add the profiler to the builtins for @profile.
     try:
         import builtins
-    except ImportError: # Python 3x
+    except ImportError:  # Python 3x
         import __builtin__ as builtins
 
     if 'profile' in builtins.__dict__:
","@@ -144,7 +144,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
             proc = os.getpid()
         if max_iter == -1:
             max_iter = 1
-        for _ in range(max_iter):
+        counter = 0
+        while counter < max_iter:
+            counter += 1
             ret.append(_get_memory(proc))
             time.sleep(interval)
     return ret
@@ -443,7 +445,7 @@ def magic_mprun(self, parameter_s=''):
     # Add the profiler to the builtins for @profile.
     try:
         import builtins
-    except ImportError: # Python 3x
+    except ImportError:  # Python 3x
         import __builtin__ as builtins
 
     if 'profile' in builtins.__dict__:
",True,memory_profiler.py,True
"@@ -212,7 +212,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
     * A: This module gets the memory consumption by querying the
       operating system kernel about the amount of memory the current
       process has allocated, which might be slightly different from
-      the ammount of memory that is actually used by the Python
+      the amount of memory that is actually used by the Python
       interpreter. Also, because of how the garbage collector works in
       Python the result might be different between platforms and even
       between runs.
","@@ -212,7 +212,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
     * A: This module gets the memory consumption by querying the
       operating system kernel about the amount of memory the current
       process has allocated, which might be slightly different from
-      the ammount of memory that is actually used by the Python
+      the amount of memory that is actually used by the Python
       interpreter. Also, because of how the garbage collector works in
       Python the result might be different between platforms and even
       between runs.
",True,README.rst,False
"@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.21'
+__version__ = '0.24'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.21'
+__version__ = '0.24'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -8,7 +8,7 @@ import time, sys, os, pdb
 import warnings
 import linecache
 import inspect
-
+import subprocess
 
 # TODO: provide alternative when multprocessing is not available
 try:
@@ -138,6 +138,15 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
         parent_conn.send(0)  # finish timing
         ret = parent_conn.recv()
         p.join(5 * interval)
+    elif isinstance(proc, subprocess.Popen):
+        # external process
+        if max_iter == -1:
+            max_iter = 1
+        for _ in range(max_iter):
+            ret.append(_get_memory(proc.pid))
+            time.sleep(interval)
+            if proc.poll() is not None:
+                break
     else:
         # external process
         if proc == -1:
","@@ -8,7 +8,7 @@ import time, sys, os, pdb
 import warnings
 import linecache
 import inspect
-
+import subprocess
 
 # TODO: provide alternative when multprocessing is not available
 try:
@@ -138,6 +138,15 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
         parent_conn.send(0)  # finish timing
         ret = parent_conn.recv()
         p.join(5 * interval)
+    elif isinstance(proc, subprocess.Popen):
+        # external process
+        if max_iter == -1:
+            max_iter = 1
+        for _ in range(max_iter):
+            ret.append(_get_memory(proc.pid))
+            time.sleep(interval)
+            if proc.poll() is not None:
+                break
     else:
         # external process
         if proc == -1:
",True,memory_profiler.py,True
"@@ -0,0 +1,21 @@
+#! /usr/bin/env python
+import subprocess
+import memory_profiler as mp
+import sys
+
+if len(sys.argv) < 2:
+    print(""""""Memory usage monitoring
+          Usage: %s <command> <argument> ... <argument>
+
+          Output results in a file called ""profile.dat"" in the current directory.
+          This file contains the process memory consumption, in Mb (one value per
+          line). Memory is sampled twice each second.""""""
+          % sys.argv[0]
+          )
+    sys.exit(1)
+
+p = subprocess.Popen(sys.argv[1:])
+mu = mp.memory_usage(proc=p, interval=0.5)
+with open(""profile.dat"", ""w"") as f:
+    for m in mu:
+        f.write(str(m) + ""\n"")
","@@ -0,0 +1,21 @@
+#! /usr/bin/env python
+import subprocess
+import memory_profiler as mp
+import sys
+
+if len(sys.argv) < 2:
+    print(""""""Memory usage monitoring
+          Usage: %s <command> <argument> ... <argument>
+
+          Output results in a file called ""profile.dat"" in the current directory.
+          This file contains the process memory consumption, in Mb (one value per
+          line). Memory is sampled twice each second.""""""
+          % sys.argv[0]
+          )
+    sys.exit(1)
+
+p = subprocess.Popen(sys.argv[1:])
+mu = mp.memory_usage(proc=p, interval=0.5)
+with open(""profile.dat"", ""w"") as f:
+    for m in mu:
+        f.write(str(m) + ""\n"")
",True,mem_profile,False
"@@ -33,7 +33,6 @@ except ImportError:
 
     warnings.warn(""psutil module not found. memory_profiler will be slow"")
 
-    import subprocess
     if os.name == 'posix':
         def _get_memory(pid):
             # ..
@@ -139,10 +138,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
         ret = parent_conn.recv()
         p.join(5 * interval)
     elif isinstance(proc, subprocess.Popen):
-        # external process
-        if max_iter == -1:
-            max_iter = 1
-        for _ in range(max_iter):
+        # external process, launched from Python
+        while True:
             ret.append(_get_memory(proc.pid))
             time.sleep(interval)
             if proc.poll() is not None:
","@@ -33,7 +33,6 @@ except ImportError:
 
     warnings.warn(""psutil module not found. memory_profiler will be slow"")
 
-    import subprocess
     if os.name == 'posix':
         def _get_memory(pid):
             # ..
@@ -139,10 +138,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
         ret = parent_conn.recv()
         p.join(5 * interval)
     elif isinstance(proc, subprocess.Popen):
-        # external process
-        if max_iter == -1:
-            max_iter = 1
-        for _ in range(max_iter):
+        # external process, launched from Python
+        while True:
             ret.append(_get_memory(proc.pid))
             time.sleep(interval)
             if proc.poll() is not None:
",True,memory_profiler.py,True
"@@ -80,12 +80,13 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
 
     Parameters
     ----------
-    proc : {int, string, tuple}, optional
-        The process to monitor. Can be given by an integer
-        representing a PID or by a tuple representing a Python
-        function. The tuple contains three values (f, args, kw) and
-        specifies to run the function f(*args, **kw).  Set to -1
-        (default) for current process.
+    proc : {int, string, tuple, subprocess.Popen}, optional
+        The process to monitor. Can be given by an integer/string
+        representing a PID, by a Popen object or by a tuple
+        representing a Python function. The tuple contains three
+        values (f, args, kw) and specifies to run the function
+        f(*args, **kw).
+        Set to -1 (default) for current process.
 
     interval : float, optional
         Interval at which measurements are collected.
@@ -142,6 +143,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
         while True:
             ret.append(_get_memory(proc.pid))
             time.sleep(interval)
+            if timeout is not None:
+                max_iter -= 1
+                if max_iter == 0:
+                    break
             if proc.poll() is not None:
                 break
     else:
","@@ -80,12 +80,13 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
 
     Parameters
     ----------
-    proc : {int, string, tuple}, optional
-        The process to monitor. Can be given by an integer
-        representing a PID or by a tuple representing a Python
-        function. The tuple contains three values (f, args, kw) and
-        specifies to run the function f(*args, **kw).  Set to -1
-        (default) for current process.
+    proc : {int, string, tuple, subprocess.Popen}, optional
+        The process to monitor. Can be given by an integer/string
+        representing a PID, by a Popen object or by a tuple
+        representing a Python function. The tuple contains three
+        values (f, args, kw) and specifies to run the function
+        f(*args, **kw).
+        Set to -1 (default) for current process.
 
     interval : float, optional
         Interval at which measurements are collected.
@@ -142,6 +143,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
         while True:
             ret.append(_get_memory(proc.pid))
             time.sleep(interval)
+            if timeout is not None:
+                max_iter -= 1
+                if max_iter == 0:
+                    break
             if proc.poll() is not None:
                 break
     else:
",True,memory_profiler.py,True
"@@ -1,21 +0,0 @@
-#! /usr/bin/env python
-import subprocess
-import memory_profiler as mp
-import sys
-
-if len(sys.argv) < 2:
-    print(""""""Memory usage monitoring
-          Usage: %s <command> <argument> ... <argument>
-
-          Output results in a file called ""profile.dat"" in the current directory.
-          This file contains the process memory consumption, in Mb (one value per
-          line). Memory is sampled twice each second.""""""
-          % sys.argv[0]
-          )
-    sys.exit(1)
-
-p = subprocess.Popen(sys.argv[1:])
-mu = mp.memory_usage(proc=p, interval=0.5)
-with open(""profile.dat"", ""w"") as f:
-    for m in mu:
-        f.write(str(m) + ""\n"")
","@@ -1,21 +0,0 @@
-#! /usr/bin/env python
-import subprocess
-import memory_profiler as mp
-import sys
-
-if len(sys.argv) < 2:
-    print(""""""Memory usage monitoring
-          Usage: %s <command> <argument> ... <argument>
-
-          Output results in a file called ""profile.dat"" in the current directory.
-          This file contains the process memory consumption, in Mb (one value per
-          line). Memory is sampled twice each second.""""""
-          % sys.argv[0]
-          )
-    sys.exit(1)
-
-p = subprocess.Popen(sys.argv[1:])
-mu = mp.memory_usage(proc=p, interval=0.5)
-with open(""profile.dat"", ""w"") as f:
-    for m in mu:
-        f.write(str(m) + ""\n"")
",True,,False
"@@ -0,0 +1,26 @@
+#! /usr/bin/env python
+import subprocess
+import memory_profiler as mp
+import os.path as osp
+import time
+import sys
+
+if len(sys.argv) < 2:
+    print(""""""Memory usage monitoring
+Usage: %s <command> <argument> ... <argument>
+
+Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
+<YYYYMMDDhhmmss> is the date-time of the program start) in the current
+directory. This file contains the process memory consumption, in Mb (one
+value per line). Memory is sampled twice each second.""""""
+          % osp.basename(sys.argv[0])
+          )
+    sys.exit(1)
+
+outfilename = ""mprofile_%s.dat"" % time.strftime(""%Y%m%d%H%M%S"", time.localtime())
+
+p = subprocess.Popen(sys.argv[1:])
+mu = mp.memory_usage(proc=p, interval=0.5)
+with open(outfilename, ""w"") as f:
+    for m in mu:
+        f.write(str(m) + ""\n"")
","@@ -0,0 +1,26 @@
+#! /usr/bin/env python
+import subprocess
+import memory_profiler as mp
+import os.path as osp
+import time
+import sys
+
+if len(sys.argv) < 2:
+    print(""""""Memory usage monitoring
+Usage: %s <command> <argument> ... <argument>
+
+Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
+<YYYYMMDDhhmmss> is the date-time of the program start) in the current
+directory. This file contains the process memory consumption, in Mb (one
+value per line). Memory is sampled twice each second.""""""
+          % osp.basename(sys.argv[0])
+          )
+    sys.exit(1)
+
+outfilename = ""mprofile_%s.dat"" % time.strftime(""%Y%m%d%H%M%S"", time.localtime())
+
+p = subprocess.Popen(sys.argv[1:])
+mu = mp.memory_usage(proc=p, interval=0.5)
+with open(outfilename, ""w"") as f:
+    for m in mu:
+        f.write(str(m) + ""\n"")
",True,mprofile,False
"@@ -27,8 +27,9 @@ setup(
     author='Fabian Pedregosa',
     author_email='fabian@fseoane.net',
     url='http://pypi.python.org/pypi/memory_profiler',
-	py_modules=['memory_profiler'],
+    py_modules=['memory_profiler'],
+    scripts=[""mprofile""],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='Simplified BSD'
 
-)
\ No newline at end of file
+)
","@@ -27,8 +27,9 @@ setup(
     author='Fabian Pedregosa',
     author_email='fabian@fseoane.net',
     url='http://pypi.python.org/pypi/memory_profiler',
-	py_modules=['memory_profiler'],
+    py_modules=['memory_profiler'],
+    scripts=[""mprofile""],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='Simplified BSD'
 
-)
\ No newline at end of file
+)
",True,setup.py,True
"@@ -387,7 +387,7 @@ def show_results(prof, stream=None, precision=3):
 # A lprun-style %mprun magic for IPython.
 def magic_mprun(self, parameter_s=''):
     """""" Execute a statement under the line-by-line memory profiler from the
-    memory_profilser module.
+    memory_profiler module.
 
     Usage:
       %mprun -f func1 -f func2 <statement>
@@ -592,7 +592,9 @@ if __name__ == '__main__':
     parser.add_option('--precision', dest=""precision"", type=""int"",
         action=""store"", default=3,
         help=""precision of memory output in number of significant digits"")
-
+    parser.add_option(""-o"", dest=""out_filename"", type=""str"",
+                      action=""store"", default=None,
+                      help=""path to a file where results will be written"")
     if not sys.argv[1:]:
         parser.print_help()
         sys.exit(2)
@@ -616,4 +618,9 @@ if __name__ == '__main__':
             exec(compile(open(__file__).read(), __file__, 'exec'), ns,
                                                                    globals())
     finally:
-        show_results(prof, precision=options.precision)
+        if options.out_filename is not None:
+            out_file = open(options.out_filename, ""w"")
+        else:
+            out_file = sys.stdout
+
+        show_results(prof, precision=options.precision, stream=out_file)
","@@ -387,7 +387,7 @@ def show_results(prof, stream=None, precision=3):
 # A lprun-style %mprun magic for IPython.
 def magic_mprun(self, parameter_s=''):
     """""" Execute a statement under the line-by-line memory profiler from the
-    memory_profilser module.
+    memory_profiler module.
 
     Usage:
       %mprun -f func1 -f func2 <statement>
@@ -592,7 +592,9 @@ if __name__ == '__main__':
     parser.add_option('--precision', dest=""precision"", type=""int"",
         action=""store"", default=3,
         help=""precision of memory output in number of significant digits"")
-
+    parser.add_option(""-o"", dest=""out_filename"", type=""str"",
+                      action=""store"", default=None,
+                      help=""path to a file where results will be written"")
     if not sys.argv[1:]:
         parser.print_help()
         sys.exit(2)
@@ -616,4 +618,9 @@ if __name__ == '__main__':
             exec(compile(open(__file__).read(), __file__, 'exec'), ns,
                                                                    globals())
     finally:
-        show_results(prof, precision=options.precision)
+        if options.out_filename is not None:
+            out_file = open(options.out_filename, ""w"")
+        else:
+            out_file = sys.stdout
+
+        show_results(prof, precision=options.precision, stream=out_file)
",True,memory_profiler.py,True
"@@ -20,13 +20,16 @@ except ImportError:
 try:
     import psutil
 
-    def _get_memory(pid):
+    def _get_memory(pid, timestamps=False):
         process = psutil.Process(pid)
         try:
             mem = float(process.get_memory_info()[0]) / (1024 ** 2)
         except psutil.AccessDenied:
             mem = -1
-        return mem
+        if timestamps:
+            return (mem, time.time())
+        else:
+            return mem
 
 
 except ImportError:
@@ -34,7 +37,7 @@ except ImportError:
     warnings.warn(""psutil module not found. memory_profiler will be slow"")
 
     if os.name == 'posix':
-        def _get_memory(pid):
+        def _get_memory(pid, timestamps=False):
             # ..
             # .. memory usage in MB ..
             # .. this should work on both Mac and Linux ..
@@ -44,9 +47,16 @@ except ImportError:
                   stdout=subprocess.PIPE).communicate()[0].split(b'\n')
             try:
                 vsz_index = out[0].split().index(b'RSS')
-                return float(out[1].split()[vsz_index]) / 1024
+                mem = float(out[1].split()[vsz_index]) / 1024
+                if timestamps:
+                    return(mem, time.time())
+                else:
+                    return mem
             except:
-                return -1
+                if timestamps:
+                    return (-1, time.time())
+                else:
+                    return -1
     else:
         raise NotImplementedError('The psutil module is required for non-unix '
                                   'platforms')
@@ -62,19 +72,24 @@ class Timer(Process):
         self.interval = interval
         self.pipe = pipe
         self.cont = True
+        if ""timestamps"" in kw:
+            self.timestamps = kw[""timestamps""]
+            del kw[""timestamps""]
+        else:
+            self.timestamps = False
         super(Timer, self).__init__(*args, **kw)
 
     def run(self):
-        m = _get_memory(self.monitor_pid)
+        m = _get_memory(self.monitor_pid, timestamps=self.timestamps)
         timings = [m]
         self.pipe.send(0)  # we're ready
         while not self.pipe.poll(self.interval):
-            m = _get_memory(self.monitor_pid)
+            m = _get_memory(self.monitor_pid, timestamps=self.timestamps)
             timings.append(m)
         self.pipe.send(timings)
 
 
-def memory_usage(proc=-1, interval=.1, timeout=None):
+def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -131,7 +146,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
             % (n_args, len(args)))
 
         child_conn, parent_conn = Pipe()  # this will store Timer's results
-        p = Timer(os.getpid(), interval, child_conn)
+        p = Timer(os.getpid(), interval, child_conn, timestamps=timestamps)
         p.start()
         parent_conn.recv()  # wait until we start getting memory
         f(*args, **kw)
@@ -141,7 +156,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
     elif isinstance(proc, subprocess.Popen):
         # external process, launched from Python
         while True:
-            ret.append(_get_memory(proc.pid))
+            ret.append(_get_memory(proc.pid, timestamps=timestamps))
             time.sleep(interval)
             if timeout is not None:
                 max_iter -= 1
@@ -158,7 +173,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
         counter = 0
         while counter < max_iter:
             counter += 1
-            ret.append(_get_memory(proc))
+            ret.append(_get_memory(proc, timestamps=timestamps))
             time.sleep(interval)
     return ret
 
","@@ -20,13 +20,16 @@ except ImportError:
 try:
     import psutil
 
-    def _get_memory(pid):
+    def _get_memory(pid, timestamps=False):
         process = psutil.Process(pid)
         try:
             mem = float(process.get_memory_info()[0]) / (1024 ** 2)
         except psutil.AccessDenied:
             mem = -1
-        return mem
+        if timestamps:
+            return (mem, time.time())
+        else:
+            return mem
 
 
 except ImportError:
@@ -34,7 +37,7 @@ except ImportError:
     warnings.warn(""psutil module not found. memory_profiler will be slow"")
 
     if os.name == 'posix':
-        def _get_memory(pid):
+        def _get_memory(pid, timestamps=False):
             # ..
             # .. memory usage in MB ..
             # .. this should work on both Mac and Linux ..
@@ -44,9 +47,16 @@ except ImportError:
                   stdout=subprocess.PIPE).communicate()[0].split(b'\n')
             try:
                 vsz_index = out[0].split().index(b'RSS')
-                return float(out[1].split()[vsz_index]) / 1024
+                mem = float(out[1].split()[vsz_index]) / 1024
+                if timestamps:
+                    return(mem, time.time())
+                else:
+                    return mem
             except:
-                return -1
+                if timestamps:
+                    return (-1, time.time())
+                else:
+                    return -1
     else:
         raise NotImplementedError('The psutil module is required for non-unix '
                                   'platforms')
@@ -62,19 +72,24 @@ class Timer(Process):
         self.interval = interval
         self.pipe = pipe
         self.cont = True
+        if ""timestamps"" in kw:
+            self.timestamps = kw[""timestamps""]
+            del kw[""timestamps""]
+        else:
+            self.timestamps = False
         super(Timer, self).__init__(*args, **kw)
 
     def run(self):
-        m = _get_memory(self.monitor_pid)
+        m = _get_memory(self.monitor_pid, timestamps=self.timestamps)
         timings = [m]
         self.pipe.send(0)  # we're ready
         while not self.pipe.poll(self.interval):
-            m = _get_memory(self.monitor_pid)
+            m = _get_memory(self.monitor_pid, timestamps=self.timestamps)
             timings.append(m)
         self.pipe.send(timings)
 
 
-def memory_usage(proc=-1, interval=.1, timeout=None):
+def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -131,7 +146,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
             % (n_args, len(args)))
 
         child_conn, parent_conn = Pipe()  # this will store Timer's results
-        p = Timer(os.getpid(), interval, child_conn)
+        p = Timer(os.getpid(), interval, child_conn, timestamps=timestamps)
         p.start()
         parent_conn.recv()  # wait until we start getting memory
         f(*args, **kw)
@@ -141,7 +156,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
     elif isinstance(proc, subprocess.Popen):
         # external process, launched from Python
         while True:
-            ret.append(_get_memory(proc.pid))
+            ret.append(_get_memory(proc.pid, timestamps=timestamps))
             time.sleep(interval)
             if timeout is not None:
                 max_iter -= 1
@@ -158,7 +173,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
         counter = 0
         while counter < max_iter:
             counter += 1
-            ret.append(_get_memory(proc))
+            ret.append(_get_memory(proc, timestamps=timestamps))
             time.sleep(interval)
     return ret
 
",True,memory_profiler.py,True
"@@ -20,7 +20,7 @@ value per line). Memory is sampled twice each second.""""""
 outfilename = ""mprofile_%s.dat"" % time.strftime(""%Y%m%d%H%M%S"", time.localtime())
 
 p = subprocess.Popen(sys.argv[1:])
-mu = mp.memory_usage(proc=p, interval=0.5)
+mu = mp.memory_usage(proc=p, interval=0.5, timestamps=True)
 with open(outfilename, ""w"") as f:
-    for m in mu:
-        f.write(str(m) + ""\n"")
+    for m, t in mu:
+        f.write(""{0:.6f} {1:.4f}"".format(m, t) + ""\n"")
","@@ -20,7 +20,7 @@ value per line). Memory is sampled twice each second.""""""
 outfilename = ""mprofile_%s.dat"" % time.strftime(""%Y%m%d%H%M%S"", time.localtime())
 
 p = subprocess.Popen(sys.argv[1:])
-mu = mp.memory_usage(proc=p, interval=0.5)
+mu = mp.memory_usage(proc=p, interval=0.5, timestamps=True)
 with open(outfilename, ""w"") as f:
-    for m in mu:
-        f.write(str(m) + ""\n"")
+    for m, t in mu:
+        f.write(""{0:.6f} {1:.4f}"".format(m, t) + ""\n"")
",True,mprofile,False
"@@ -1,6 +1,7 @@
 # .. an example with a for loop ..
 
-@profile
+import time
+
 def test_1():
     a = [1] * (10 ** 6)
     b = [2] * (2 * 10 ** 7)
@@ -12,13 +13,15 @@ def test_1():
         del b
     return a
 
-@profile
+
 def test_2():
     a = {}
     for i in range(10000):
-        a[i] =  i + 1
+        a[i] = i + 1
     return
 
 if __name__ == '__main__':
     test_1()
+    time.sleep(1)
     test_2()
+    time.sleep(1)
","@@ -1,6 +1,7 @@
 # .. an example with a for loop ..
 
-@profile
+import time
+
 def test_1():
     a = [1] * (10 ** 6)
     b = [2] * (2 * 10 ** 7)
@@ -12,13 +13,15 @@ def test_1():
         del b
     return a
 
-@profile
+
 def test_2():
     a = {}
     for i in range(10000):
-        a[i] =  i + 1
+        a[i] = i + 1
     return
 
 if __name__ == '__main__':
     test_1()
+    time.sleep(1)
     test_2()
+    time.sleep(1)
",True,test/test_loop.py,True
"@@ -0,0 +1,24 @@
+# .. an example with a for loop ..
+
+@profile
+def test_1():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    del b
+
+    for i in range(2):
+        a = [1] * (10 ** 6)
+        b = [2] * (2 * 10 ** 7)
+        del b
+    return a
+
+@profile
+def test_2():
+    a = {}
+    for i in range(10000):
+        a[i] =  i + 1
+    return
+
+if __name__ == '__main__':
+    test_1()
+    test_2()
","@@ -0,0 +1,24 @@
+# .. an example with a for loop ..
+
+@profile
+def test_1():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    del b
+
+    for i in range(2):
+        a = [1] * (10 ** 6)
+        b = [2] * (2 * 10 ** 7)
+        del b
+    return a
+
+@profile
+def test_2():
+    a = {}
+    for i in range(10000):
+        a[i] =  i + 1
+    return
+
+if __name__ == '__main__':
+    test_1()
+    test_2()
",True,test/test_loop_decorated.py,True
"@@ -3,3 +3,4 @@ dist
 build
 *.pyc
 MANIFEST
+*~
","@@ -3,3 +3,4 @@ dist
 build
 *.pyc
 MANIFEST
+*~
",True,.gitignore,False
"@@ -0,0 +1,43 @@
+#! /usr/bin/env python
+import pylab as pl
+import sys
+import glob
+import time
+import os
+
+profiles = glob.glob(""mprofile_*.dat"")
+profiles.sort()
+
+if len(sys.argv) == 1:
+    filename = profiles[-1]
+else:
+    filename = sys.argv[1]
+    if not os.path.exists(filename):
+        try:
+            n = int(filename)
+        except ValueError:
+            print(""Input file not found: "" + filename)
+        filename = profiles[n]
+
+datetime = time.strptime(filename, ""mprofile_%Y%m%d%H%M%S.dat"")
+mdata = pl.loadtxt(filename)
+mem = mdata[:, 0]
+max_mem = mem.max()
+max_mem_ind = mem.argmax()
+sampling_period = 0.5
+t = pl.r_[:len(mem)] * sampling_period
+
+pl.figure()
+pl.plot(t, mem)
+pl.hlines(max_mem,
+          pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
+          colors=""r"", linestyles=""--"")
+pl.vlines(t[max_mem_ind],
+          pl.ylim()[0] + 0.001, pl.ylim()[1] - 0.001,
+          colors=""r"", linestyles=""--"")
+pl.xlabel(""time [s]"")
+pl.ylabel(""memory used [Mb]"")
+pl.title(time.strftime(""%d / %m / %Y - start at %H:%M:%S"", datetime))
+pl.grid()
+pl.show()
+
","@@ -0,0 +1,43 @@
+#! /usr/bin/env python
+import pylab as pl
+import sys
+import glob
+import time
+import os
+
+profiles = glob.glob(""mprofile_*.dat"")
+profiles.sort()
+
+if len(sys.argv) == 1:
+    filename = profiles[-1]
+else:
+    filename = sys.argv[1]
+    if not os.path.exists(filename):
+        try:
+            n = int(filename)
+        except ValueError:
+            print(""Input file not found: "" + filename)
+        filename = profiles[n]
+
+datetime = time.strptime(filename, ""mprofile_%Y%m%d%H%M%S.dat"")
+mdata = pl.loadtxt(filename)
+mem = mdata[:, 0]
+max_mem = mem.max()
+max_mem_ind = mem.argmax()
+sampling_period = 0.5
+t = pl.r_[:len(mem)] * sampling_period
+
+pl.figure()
+pl.plot(t, mem)
+pl.hlines(max_mem,
+          pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
+          colors=""r"", linestyles=""--"")
+pl.vlines(t[max_mem_ind],
+          pl.ylim()[0] + 0.001, pl.ylim()[1] - 0.001,
+          colors=""r"", linestyles=""--"")
+pl.xlabel(""time [s]"")
+pl.ylabel(""memory used [Mb]"")
+pl.title(time.strftime(""%d / %m / %Y - start at %H:%M:%S"", datetime))
+pl.grid()
+pl.show()
+
",True,mplot,False
"@@ -28,7 +28,7 @@ setup(
     author_email='fabian@fseoane.net',
     url='http://pypi.python.org/pypi/memory_profiler',
     py_modules=['memory_profiler'],
-    scripts=[""mprofile""],
+    scripts=[""mprofile"", ""mplot""],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='Simplified BSD'
 
","@@ -28,7 +28,7 @@ setup(
     author_email='fabian@fseoane.net',
     url='http://pypi.python.org/pypi/memory_profiler',
     py_modules=['memory_profiler'],
-    scripts=[""mprofile""],
+    scripts=[""mprofile"", ""mplot""],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='Simplified BSD'
 
",True,setup.py,True
"@@ -199,6 +199,51 @@ def _find_script(script_name):
     raise SystemExit(1)
 
 
+class TimeStamper:
+    """""" A profiler that just records start and end execution times for
+    any decorated function.
+    """"""
+    def __init__(self):
+        self.functions = {}
+
+    def __call__(self, func):
+        self.add_function(func)
+        f = self.wrap_function(func)
+        f.__module__ = func.__module__
+        f.__name__ = func.__name__
+        f.__doc__ = func.__doc__
+        f.__dict__.update(getattr(func, '__dict__', {}))
+        return f
+
+    def add_function(self, func):
+        if not func in self.functions:
+            self.functions[func] = []
+
+    def wrap_function(self, func):
+        """""" Wrap a function to timestamp it.
+        """"""
+        def f(*args, **kwds):
+            # Start time
+            timestamps = [time.time()]
+            self.functions[func].append(timestamps)
+            try:
+                result = func(*args, **kwds)
+            finally:
+                # end time
+                timestamps.append(time.time())
+            return result
+        return f
+
+    def show_results(self, stream=None):
+        if stream is None:
+            stream = sys.stdout
+
+        for func, timestamps in self.functions.iteritems():
+            function_name = ""%s.%s"" % (func.__module__, func.__name__)
+            for ts in timestamps:
+                stream.write(""%s %.4f %.4f\n"" % (function_name, ts[0], ts[1]))
+
+
 class LineProfiler:
     """""" A profiler that records the amount of memory for each line """"""
 
@@ -610,13 +655,21 @@ if __name__ == '__main__':
     parser.add_option(""-o"", dest=""out_filename"", type=""str"",
                       action=""store"", default=None,
                       help=""path to a file where results will be written"")
+    parser.add_option(""--timestamp"", dest=""timestamp"", default=False,
+                      action=""store_true"",
+                      help=""""""print timestamp instead of memory measurement for
+                      decorated functions"""""")
+
     if not sys.argv[1:]:
         parser.print_help()
         sys.exit(2)
 
     (options, args) = parser.parse_args()
 
-    prof = LineProfiler(max_mem=options.max_mem)
+    if options.timestamp:
+        prof = TimeStamper()
+    else:
+        prof = LineProfiler(max_mem=options.max_mem)
     __file__ = _find_script(args[0])
     try:
         if sys.version_info[0] < 3:
@@ -638,4 +691,7 @@ if __name__ == '__main__':
         else:
             out_file = sys.stdout
 
-        show_results(prof, precision=options.precision, stream=out_file)
+        if options.timestamp:
+            prof.show_results(stream=out_file)
+        else:
+            show_results(prof, precision=options.precision, stream=out_file)
","@@ -199,6 +199,51 @@ def _find_script(script_name):
     raise SystemExit(1)
 
 
+class TimeStamper:
+    """""" A profiler that just records start and end execution times for
+    any decorated function.
+    """"""
+    def __init__(self):
+        self.functions = {}
+
+    def __call__(self, func):
+        self.add_function(func)
+        f = self.wrap_function(func)
+        f.__module__ = func.__module__
+        f.__name__ = func.__name__
+        f.__doc__ = func.__doc__
+        f.__dict__.update(getattr(func, '__dict__', {}))
+        return f
+
+    def add_function(self, func):
+        if not func in self.functions:
+            self.functions[func] = []
+
+    def wrap_function(self, func):
+        """""" Wrap a function to timestamp it.
+        """"""
+        def f(*args, **kwds):
+            # Start time
+            timestamps = [time.time()]
+            self.functions[func].append(timestamps)
+            try:
+                result = func(*args, **kwds)
+            finally:
+                # end time
+                timestamps.append(time.time())
+            return result
+        return f
+
+    def show_results(self, stream=None):
+        if stream is None:
+            stream = sys.stdout
+
+        for func, timestamps in self.functions.iteritems():
+            function_name = ""%s.%s"" % (func.__module__, func.__name__)
+            for ts in timestamps:
+                stream.write(""%s %.4f %.4f\n"" % (function_name, ts[0], ts[1]))
+
+
 class LineProfiler:
     """""" A profiler that records the amount of memory for each line """"""
 
@@ -610,13 +655,21 @@ if __name__ == '__main__':
     parser.add_option(""-o"", dest=""out_filename"", type=""str"",
                       action=""store"", default=None,
                       help=""path to a file where results will be written"")
+    parser.add_option(""--timestamp"", dest=""timestamp"", default=False,
+                      action=""store_true"",
+                      help=""""""print timestamp instead of memory measurement for
+                      decorated functions"""""")
+
     if not sys.argv[1:]:
         parser.print_help()
         sys.exit(2)
 
     (options, args) = parser.parse_args()
 
-    prof = LineProfiler(max_mem=options.max_mem)
+    if options.timestamp:
+        prof = TimeStamper()
+    else:
+        prof = LineProfiler(max_mem=options.max_mem)
     __file__ = _find_script(args[0])
     try:
         if sys.version_info[0] < 3:
@@ -638,4 +691,7 @@ if __name__ == '__main__':
         else:
             out_file = sys.stdout
 
-        show_results(prof, precision=options.precision, stream=out_file)
+        if options.timestamp:
+            prof.show_results(stream=out_file)
+        else:
+            show_results(prof, precision=options.precision, stream=out_file)
",True,memory_profiler.py,True
"@@ -1,43 +1,89 @@
 #! /usr/bin/env python
 import pylab as pl
+import math
 import sys
 import glob
 import time
 import os
+import os.path as osp
 
-profiles = glob.glob(""mprofile_*.dat"")
+
+def read_timestamp_file(ts_filename):
+    """"""Return content of ts_filename or None, if ts_filename
+    is invalid or does not exist""""""
+    if not osp.isfile(ts_filename):
+        return None
+
+    ret = {}
+    f = open(ts_filename)
+    for l in f:
+        f_name, start, end = l.split()
+        ts = ret.get(f_name, [])
+        ts.append([float(start), float(end)])
+        ret[f_name] = ts
+    f.close()
+    return ret
+
+
+profiles = glob.glob(""mprofile_??????????????.dat"")
 profiles.sort()
 
 if len(sys.argv) == 1:
     filename = profiles[-1]
 else:
     filename = sys.argv[1]
-    if not os.path.exists(filename):
+    if not osp.exists(filename):
         try:
             n = int(filename)
         except ValueError:
             print(""Input file not found: "" + filename)
         filename = profiles[n]
 
-datetime = time.strptime(filename, ""mprofile_%Y%m%d%H%M%S.dat"")
+# Check for a timestamp file
+file_parts = osp.splitext(filename)
+ts_filename = file_parts[0] + ""_ts"" + file_parts[1]
+ts = read_timestamp_file(ts_filename)
+
 mdata = pl.loadtxt(filename)
+global_start = float(mdata[0, 1])
+
 mem = mdata[:, 0]
 max_mem = mem.max()
 max_mem_ind = mem.argmax()
 sampling_period = 0.5
 t = pl.r_[:len(mem)] * sampling_period
 
+all_colors=(""g"", ""b"", ""k"", ""r"")
+
 pl.figure()
 pl.plot(t, mem)
+
+bottom, top = pl.ylim()
+bottom += 0.001
+top -= 0.001
+
+# plot timestamps, if any
+if ts is not None:
+    func_num = 0
+    for f, exec_ts in ts.iteritems():
+        for execution in exec_ts:
+            pl.vlines([ts - global_start for ts in execution],
+                      bottom, top,
+                      colors=all_colors[func_num % len(all_colors)],
+                      label=f.split(""."")[-1])
+        func_num += 1
+    pl.legend()
+
 pl.hlines(max_mem,
           pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
           colors=""r"", linestyles=""--"")
-pl.vlines(t[max_mem_ind],
-          pl.ylim()[0] + 0.001, pl.ylim()[1] - 0.001,
+pl.vlines(t[max_mem_ind], bottom, top,
           colors=""r"", linestyles=""--"")
 pl.xlabel(""time [s]"")
 pl.ylabel(""memory used [Mb]"")
-pl.title(time.strftime(""%d / %m / %Y - start at %H:%M:%S"", datetime))
+title = time.strftime(""%d / %m / %Y - start at %H:%M:%S"", time.localtime(global_start)) \
+                          + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
+pl.title(title)
 pl.grid()
 pl.show()
 
","@@ -1,43 +1,89 @@
 #! /usr/bin/env python
 import pylab as pl
+import math
 import sys
 import glob
 import time
 import os
+import os.path as osp
 
-profiles = glob.glob(""mprofile_*.dat"")
+
+def read_timestamp_file(ts_filename):
+    """"""Return content of ts_filename or None, if ts_filename
+    is invalid or does not exist""""""
+    if not osp.isfile(ts_filename):
+        return None
+
+    ret = {}
+    f = open(ts_filename)
+    for l in f:
+        f_name, start, end = l.split()
+        ts = ret.get(f_name, [])
+        ts.append([float(start), float(end)])
+        ret[f_name] = ts
+    f.close()
+    return ret
+
+
+profiles = glob.glob(""mprofile_??????????????.dat"")
 profiles.sort()
 
 if len(sys.argv) == 1:
     filename = profiles[-1]
 else:
     filename = sys.argv[1]
-    if not os.path.exists(filename):
+    if not osp.exists(filename):
         try:
             n = int(filename)
         except ValueError:
             print(""Input file not found: "" + filename)
         filename = profiles[n]
 
-datetime = time.strptime(filename, ""mprofile_%Y%m%d%H%M%S.dat"")
+# Check for a timestamp file
+file_parts = osp.splitext(filename)
+ts_filename = file_parts[0] + ""_ts"" + file_parts[1]
+ts = read_timestamp_file(ts_filename)
+
 mdata = pl.loadtxt(filename)
+global_start = float(mdata[0, 1])
+
 mem = mdata[:, 0]
 max_mem = mem.max()
 max_mem_ind = mem.argmax()
 sampling_period = 0.5
 t = pl.r_[:len(mem)] * sampling_period
 
+all_colors=(""g"", ""b"", ""k"", ""r"")
+
 pl.figure()
 pl.plot(t, mem)
+
+bottom, top = pl.ylim()
+bottom += 0.001
+top -= 0.001
+
+# plot timestamps, if any
+if ts is not None:
+    func_num = 0
+    for f, exec_ts in ts.iteritems():
+        for execution in exec_ts:
+            pl.vlines([ts - global_start for ts in execution],
+                      bottom, top,
+                      colors=all_colors[func_num % len(all_colors)],
+                      label=f.split(""."")[-1])
+        func_num += 1
+    pl.legend()
+
 pl.hlines(max_mem,
           pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
           colors=""r"", linestyles=""--"")
-pl.vlines(t[max_mem_ind],
-          pl.ylim()[0] + 0.001, pl.ylim()[1] - 0.001,
+pl.vlines(t[max_mem_ind], bottom, top,
           colors=""r"", linestyles=""--"")
 pl.xlabel(""time [s]"")
 pl.ylabel(""memory used [Mb]"")
-pl.title(time.strftime(""%d / %m / %Y - start at %H:%M:%S"", datetime))
+title = time.strftime(""%d / %m / %Y - start at %H:%M:%S"", time.localtime(global_start)) \
+                          + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
+pl.title(title)
 pl.grid()
 pl.show()
 
",True,mplot,False
"@@ -5,22 +5,46 @@ import os.path as osp
 import time
 import sys
 
-if len(sys.argv) < 2:
-    print(""""""Memory usage monitoring
-Usage: %s <command> <argument> ... <argument>
-
-Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
-<YYYYMMDDhhmmss> is the date-time of the program start) in the current
-directory. This file contains the process memory consumption, in Mb (one
-value per line). Memory is sampled twice each second.""""""
-          % osp.basename(sys.argv[0])
-          )
+from optparse import OptionParser
+
+parser = OptionParser(version=mp.__version__)
+parser.disable_interspersed_args()
+parser.add_option(""--python"", dest=""python"", default=False,
+                  action=""store_true"",
+                  help=""""""Activates extra features when the profiled executable is
+                  a Python program (currently: function timestamping.)"""""")
+
+(options, args) = parser.parse_args()
+if len(args) == 0:
+    print(""A program to run must be provided. Use -h for help"")
     sys.exit(1)
 
-outfilename = ""mprofile_%s.dat"" % time.strftime(""%Y%m%d%H%M%S"", time.localtime())
+## if len(sys.argv) < 2:
+##     print(""""""Memory usage monitoring
+## Usage: %s <command> <argument> ... <argument>
+
+## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
+## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
+## directory. This file contains the process memory consumption, in Mb (one
+## value per line). Memory is sampled twice each second.""""""
+##           % osp.basename(sys.argv[0])
+##           )
+##     sys.exit(1)
+
+suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
+mprofile_output = ""mprofile_%s.dat"" % suffix
+
+if options.python:
+    print(""running as a Python program..."")
+    timestamp_output = ""mprofile_%s_ts.dat"" % suffix
+    if not args[0].startswith(""python""):
+        args.insert(0, ""python"")
+    args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"", ""-o"", timestamp_output)
+    p = subprocess.Popen(args)
+else:
+    p = subprocess.Popen(args)
 
-p = subprocess.Popen(sys.argv[1:])
 mu = mp.memory_usage(proc=p, interval=0.5, timestamps=True)
-with open(outfilename, ""w"") as f:
+with open(mprofile_output, ""w"") as f:
     for m, t in mu:
         f.write(""{0:.6f} {1:.4f}"".format(m, t) + ""\n"")
","@@ -5,22 +5,46 @@ import os.path as osp
 import time
 import sys
 
-if len(sys.argv) < 2:
-    print(""""""Memory usage monitoring
-Usage: %s <command> <argument> ... <argument>
+from optparse import OptionParser
 
-Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
-<YYYYMMDDhhmmss> is the date-time of the program start) in the current
-directory. This file contains the process memory consumption, in Mb (one
-value per line). Memory is sampled twice each second.""""""
-          % osp.basename(sys.argv[0])
-          )
+parser = OptionParser(version=mp.__version__)
+parser.disable_interspersed_args()
+parser.add_option(""--python"", dest=""python"", default=False,
+                  action=""store_true"",
+                  help=""""""Activates extra features when the profiled executable is
+                  a Python program (currently: function timestamping.)"""""")
+
+(options, args) = parser.parse_args()
+if len(args) == 0:
+    print(""A program to run must be provided. Use -h for help"")
     sys.exit(1)
 
-outfilename = ""mprofile_%s.dat"" % time.strftime(""%Y%m%d%H%M%S"", time.localtime())
+## if len(sys.argv) < 2:
+##     print(""""""Memory usage monitoring
+## Usage: %s <command> <argument> ... <argument>
+
+## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
+## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
+## directory. This file contains the process memory consumption, in Mb (one
+## value per line). Memory is sampled twice each second.""""""
+##           % osp.basename(sys.argv[0])
+##           )
+##     sys.exit(1)
+
+suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
+mprofile_output = ""mprofile_%s.dat"" % suffix
+
+if options.python:
+    print(""running as a Python program..."")
+    timestamp_output = ""mprofile_%s_ts.dat"" % suffix
+    if not args[0].startswith(""python""):
+        args.insert(0, ""python"")
+    args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"", ""-o"", timestamp_output)
+    p = subprocess.Popen(args)
+else:
+    p = subprocess.Popen(args)
 
-p = subprocess.Popen(sys.argv[1:])
 mu = mp.memory_usage(proc=p, interval=0.5, timestamps=True)
-with open(outfilename, ""w"") as f:
+with open(mprofile_output, ""w"") as f:
     for m, t in mu:
         f.write(""{0:.6f} {1:.4f}"".format(m, t) + ""\n"")
",False,mprofile,False
"@@ -1,9 +1,12 @@
 # .. an example with a for loop ..
 
+import time
+
 @profile
 def test_1():
     a = [1] * (10 ** 6)
     b = [2] * (2 * 10 ** 7)
+    time.sleep(0.6)
     del b
 
     for i in range(2):
@@ -15,8 +18,10 @@ def test_1():
 @profile
 def test_2():
     a = {}
+    time.sleep(0.5)
     for i in range(10000):
-        a[i] =  i + 1
+        a[i] = i + 1
+    time.sleep(0.6)
     return
 
 if __name__ == '__main__':
","@@ -1,9 +1,12 @@
 # .. an example with a for loop ..
 
+import time
+
 @profile
 def test_1():
     a = [1] * (10 ** 6)
     b = [2] * (2 * 10 ** 7)
+    time.sleep(0.6)
     del b
 
     for i in range(2):
@@ -15,8 +18,10 @@ def test_1():
 @profile
 def test_2():
     a = {}
+    time.sleep(0.5)
     for i in range(10000):
-        a[i] =  i + 1
+        a[i] = i + 1
+    time.sleep(0.6)
     return
 
 if __name__ == '__main__':
",True,test/test_loop_decorated.py,True
"@@ -0,0 +1,23 @@
+""""""This script is intended as a test case for mprofile""""""
+
+import time
+
+@profile
+def test1():
+    a = [1] * 100000
+    time.sleep(1)
+    return a
+
+@profile
+def test2(l):
+    b = [2 * n for n in l]
+    time.sleep(1)
+    del b
+
+
+if __name__ == ""__main__"":
+    time.sleep(1)
+    l = test1()
+    test2(l)
+    time.sleep(1)
+
","@@ -0,0 +1,23 @@
+""""""This script is intended as a test case for mprofile""""""
+
+import time
+
+@profile
+def test1():
+    a = [1] * 100000
+    time.sleep(1)
+    return a
+
+@profile
+def test2(l):
+    b = [2 * n for n in l]
+    time.sleep(1)
+    del b
+
+
+if __name__ == ""__main__"":
+    time.sleep(1)
+    l = test1()
+    test2(l)
+    time.sleep(1)
+
",True,test/test_mprofile.py,True
"@@ -207,6 +207,9 @@ class TimeStamper:
         self.functions = {}
 
     def __call__(self, func):
+        if not hasattr(func, ""__call__""):
+            raise ValueError(""Value must be callable"")
+
         self.add_function(func)
         f = self.wrap_function(func)
         f.__module__ = func.__module__
","@@ -207,6 +207,9 @@ class TimeStamper:
         self.functions = {}
 
     def __call__(self, func):
+        if not hasattr(func, ""__call__""):
+            raise ValueError(""Value must be callable"")
+
         self.add_function(func)
         f = self.wrap_function(func)
         f.__module__ = func.__module__
",True,memory_profiler.py,True
"@@ -1,7 +1,12 @@
 #! /usr/bin/env python
-import pylab as pl
-import math
 import sys
+
+try:
+    import pylab as pl
+except ImportError:
+    print(""matplotlib is needed for plotting."")
+    sys.exit(1)
+import math
 import glob
 import time
 import os
@@ -29,6 +34,10 @@ profiles = glob.glob(""mprofile_??????????????.dat"")
 profiles.sort()
 
 if len(sys.argv) == 1:
+    if len(profiles) == 0:
+        print(""""""No input file found. This program looks for mprofile_*.dat files,
+generated by the mprofile command."""""")
+        sys.exit(-1)
     filename = profiles[-1]
 else:
     filename = sys.argv[1]
","@@ -1,7 +1,12 @@
 #! /usr/bin/env python
-import pylab as pl
-import math
 import sys
+
+try:
+    import pylab as pl
+except ImportError:
+    print(""matplotlib is needed for plotting."")
+    sys.exit(1)
+import math
 import glob
 import time
 import os
@@ -29,6 +34,10 @@ profiles = glob.glob(""mprofile_??????????????.dat"")
 profiles.sort()
 
 if len(sys.argv) == 1:
+    if len(profiles) == 0:
+        print(""""""No input file found. This program looks for mprofile_*.dat files,
+generated by the mprofile command."""""")
+        sys.exit(-1)
     filename = profiles[-1]
 else:
     filename = sys.argv[1]
",True,mplot,False
"@@ -13,6 +13,42 @@ import os
 import os.path as osp
 
 
+def add_bracket(xloc, t, mem, color=""r"", label=None):
+    """"""Add two brackets on the memory line plot.
+
+    This function uses the current figure.
+
+    Parameters
+    ==========
+    xloc: {tuple with 2 values}
+        bracket location (on horizontal axis).
+    t, mem:
+        memory usage curve. Used to place bracket at the correct location.
+    """"""
+
+    height_ratio = 20.
+    yloc = pl.interp(xloc, t, mem)
+    vsize = (pl.ylim()[1] - pl.ylim()[0]) / height_ratio
+    hsize = (pl.xlim()[1] - pl.xlim()[0]) / (3.*height_ratio)
+
+    bracket_x = pl.asarray([hsize, 0, 0, hsize])
+    bracket_y = pl.asarray([vsize, vsize, -vsize, -vsize])
+
+    pl.plot(bracket_x + xloc[0], bracket_y + yloc[0],
+            ""-"" + color, linewidth=2, label=label)
+    pl.plot(-bracket_x + xloc[1], bracket_y + yloc[1],
+            ""-"" + color, linewidth=2 )
+
+    # TODO: use matplotlib.patches.Polygon to draw a colored background for
+    # each function.
+
+    # with maplotlib 1.2, use matplotlib.path.Path to create proper markers
+    # see http://matplotlib.org/examples/pylab_examples/marker_path.html
+    # This works with matplotlib 0.99.1
+    ## pl.plot(xloc[0], yloc[0], ""<""+color, markersize=7, label=label)
+    ## pl.plot(xloc[1], yloc[1], "">""+color, markersize=7)
+
+
 def read_timestamp_file(ts_filename):
     """"""Return content of ts_filename or None, if ts_filename
     is invalid or does not exist""""""
@@ -59,13 +95,13 @@ global_start = float(mdata[0, 1])
 mem = mdata[:, 0]
 max_mem = mem.max()
 max_mem_ind = mem.argmax()
-sampling_period = 0.5
-t = pl.r_[:len(mem)] * sampling_period
 
-all_colors=(""g"", ""b"", ""k"", ""r"")
+t = mdata[:, 1] - global_start
+
+all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
 
 pl.figure()
-pl.plot(t, mem)
+pl.plot(t, mem, ""b+-"")
 
 bottom, top = pl.ylim()
 bottom += 0.001
@@ -76,12 +112,16 @@ if ts is not None:
     func_num = 0
     for f, exec_ts in ts.iteritems():
         for execution in exec_ts:
-            pl.vlines([ts - global_start for ts in execution],
-                      bottom, top,
-                      colors=all_colors[func_num % len(all_colors)],
-                      label=f.split(""."")[-1])
+            add_bracket([ts - global_start for ts in execution], t, mem,
+                        color= all_colors[func_num % len(all_colors)],
+                        label=f.split(""."")[-1] + "" %.3fs"" % (execution[1] - execution[0]))
+            ## pl.vlines([ts - global_start for ts in execution],
+            ##           bottom, top,
+            ##           colors=all_colors[func_num % len(all_colors)],
+            ##           linestyles=""dashdot"",
+            ##           label=f.split(""."")[-1] + "" %.3fs"" % (execution[1] - execution[0]))
         func_num += 1
-    pl.legend()
+    pl.legend(loc=0)
 
 pl.hlines(max_mem,
           pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
@@ -89,7 +129,7 @@ pl.hlines(max_mem,
 pl.vlines(t[max_mem_ind], bottom, top,
           colors=""r"", linestyles=""--"")
 pl.xlabel(""time [s]"")
-pl.ylabel(""memory used [Mb]"")
+pl.ylabel(""memory used [MB]"")
 title = time.strftime(""%d / %m / %Y - start at %H:%M:%S"", time.localtime(global_start)) \
                           + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
 pl.title(title)
","@@ -13,6 +13,42 @@ import os
 import os.path as osp
 
 
+def add_bracket(xloc, t, mem, color=""r"", label=None):
+    """"""Add two brackets on the memory line plot.
+
+    This function uses the current figure.
+
+    Parameters
+    ==========
+    xloc: {tuple with 2 values}
+        bracket location (on horizontal axis).
+    t, mem:
+        memory usage curve. Used to place bracket at the correct location.
+    """"""
+
+    height_ratio = 20.
+    yloc = pl.interp(xloc, t, mem)
+    vsize = (pl.ylim()[1] - pl.ylim()[0]) / height_ratio
+    hsize = (pl.xlim()[1] - pl.xlim()[0]) / (3.*height_ratio)
+
+    bracket_x = pl.asarray([hsize, 0, 0, hsize])
+    bracket_y = pl.asarray([vsize, vsize, -vsize, -vsize])
+
+    pl.plot(bracket_x + xloc[0], bracket_y + yloc[0],
+            ""-"" + color, linewidth=2, label=label)
+    pl.plot(-bracket_x + xloc[1], bracket_y + yloc[1],
+            ""-"" + color, linewidth=2 )
+
+    # TODO: use matplotlib.patches.Polygon to draw a colored background for
+    # each function.
+
+    # with maplotlib 1.2, use matplotlib.path.Path to create proper markers
+    # see http://matplotlib.org/examples/pylab_examples/marker_path.html
+    # This works with matplotlib 0.99.1
+    ## pl.plot(xloc[0], yloc[0], ""<""+color, markersize=7, label=label)
+    ## pl.plot(xloc[1], yloc[1], "">""+color, markersize=7)
+
+
 def read_timestamp_file(ts_filename):
     """"""Return content of ts_filename or None, if ts_filename
     is invalid or does not exist""""""
@@ -59,13 +95,13 @@ global_start = float(mdata[0, 1])
 mem = mdata[:, 0]
 max_mem = mem.max()
 max_mem_ind = mem.argmax()
-sampling_period = 0.5
-t = pl.r_[:len(mem)] * sampling_period
 
-all_colors=(""g"", ""b"", ""k"", ""r"")
+t = mdata[:, 1] - global_start
+
+all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
 
 pl.figure()
-pl.plot(t, mem)
+pl.plot(t, mem, ""b+-"")
 
 bottom, top = pl.ylim()
 bottom += 0.001
@@ -76,12 +112,16 @@ if ts is not None:
     func_num = 0
     for f, exec_ts in ts.iteritems():
         for execution in exec_ts:
-            pl.vlines([ts - global_start for ts in execution],
-                      bottom, top,
-                      colors=all_colors[func_num % len(all_colors)],
-                      label=f.split(""."")[-1])
+            add_bracket([ts - global_start for ts in execution], t, mem,
+                        color= all_colors[func_num % len(all_colors)],
+                        label=f.split(""."")[-1] + "" %.3fs"" % (execution[1] - execution[0]))
+            ## pl.vlines([ts - global_start for ts in execution],
+            ##           bottom, top,
+            ##           colors=all_colors[func_num % len(all_colors)],
+            ##           linestyles=""dashdot"",
+            ##           label=f.split(""."")[-1] + "" %.3fs"" % (execution[1] - execution[0]))
         func_num += 1
-    pl.legend()
+    pl.legend(loc=0)
 
 pl.hlines(max_mem,
           pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
@@ -89,7 +129,7 @@ pl.hlines(max_mem,
 pl.vlines(t[max_mem_ind], bottom, top,
           colors=""r"", linestyles=""--"")
 pl.xlabel(""time [s]"")
-pl.ylabel(""memory used [Mb]"")
+pl.ylabel(""memory used [MB]"")
 title = time.strftime(""%d / %m / %Y - start at %H:%M:%S"", time.localtime(global_start)) \
                           + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
 pl.title(title)
",True,mplot,False
"@@ -89,13 +89,15 @@ file_parts = osp.splitext(filename)
 ts_filename = file_parts[0] + ""_ts"" + file_parts[1]
 ts = read_timestamp_file(ts_filename)
 
-mdata = pl.loadtxt(filename)
+mdata = pl.atleast_2d(pl.loadtxt(filename))
+
 global_start = float(mdata[0, 1])
 
 mem = mdata[:, 0]
 max_mem = mem.max()
 max_mem_ind = mem.argmax()
 
+
 t = mdata[:, 1] - global_start
 
 all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
","@@ -89,13 +89,15 @@ file_parts = osp.splitext(filename)
 ts_filename = file_parts[0] + ""_ts"" + file_parts[1]
 ts = read_timestamp_file(ts_filename)
 
-mdata = pl.loadtxt(filename)
+mdata = pl.atleast_2d(pl.loadtxt(filename))
+
 global_start = float(mdata[0, 1])
 
 mem = mdata[:, 0]
 max_mem = mem.max()
 max_mem_ind = mem.argmax()
 
+
 t = mdata[:, 1] - global_start
 
 all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
",True,mplot,False
"@@ -13,8 +13,13 @@ parser.add_option(""--python"", dest=""python"", default=False,
                   action=""store_true"",
                   help=""""""Activates extra features when the profiled executable is
                   a Python program (currently: function timestamping.)"""""")
+parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.5"",
+                  type=""float"", action=""store"",
+                  help=""Sampling period (in seconds)"")
 
 (options, args) = parser.parse_args()
+print(""{1}: Sampling memory every {0.interval}s"".format(options, osp.basename(sys.argv[0])))
+
 if len(args) == 0:
     print(""A program to run must be provided. Use -h for help"")
     sys.exit(1)
@@ -39,12 +44,13 @@ if options.python:
     timestamp_output = ""mprofile_%s_ts.dat"" % suffix
     if not args[0].startswith(""python""):
         args.insert(0, ""python"")
-    args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"", ""-o"", timestamp_output)
+    args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
+                 ""-o"", timestamp_output)
     p = subprocess.Popen(args)
 else:
     p = subprocess.Popen(args)
 
-mu = mp.memory_usage(proc=p, interval=0.5, timestamps=True)
+mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True)
 with open(mprofile_output, ""w"") as f:
     for m, t in mu:
         f.write(""{0:.6f} {1:.4f}"".format(m, t) + ""\n"")
","@@ -13,8 +13,13 @@ parser.add_option(""--python"", dest=""python"", default=False,
                   action=""store_true"",
                   help=""""""Activates extra features when the profiled executable is
                   a Python program (currently: function timestamping.)"""""")
+parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.5"",
+                  type=""float"", action=""store"",
+                  help=""Sampling period (in seconds)"")
 
 (options, args) = parser.parse_args()
+print(""{1}: Sampling memory every {0.interval}s"".format(options, osp.basename(sys.argv[0])))
+
 if len(args) == 0:
     print(""A program to run must be provided. Use -h for help"")
     sys.exit(1)
@@ -39,12 +44,13 @@ if options.python:
     timestamp_output = ""mprofile_%s_ts.dat"" % suffix
     if not args[0].startswith(""python""):
         args.insert(0, ""python"")
-    args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"", ""-o"", timestamp_output)
+    args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
+                 ""-o"", timestamp_output)
     p = subprocess.Popen(args)
 else:
     p = subprocess.Popen(args)
 
-mu = mp.memory_usage(proc=p, interval=0.5, timestamps=True)
+mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True)
 with open(mprofile_output, ""w"") as f:
     for m, t in mu:
         f.write(""{0:.6f} {1:.4f}"".format(m, t) + ""\n"")
",True,mprofile,False
"@@ -110,8 +110,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
         # for a Python function wait until it finishes
         max_iter = float('inf')
 
+    if hasattr(proc, '__call__'):
+        proc = (proc, (), {})
     if isinstance(proc, (list, tuple)):
-
         if len(proc) == 1:
             f, args, kw = (proc[0], (), {})
         elif len(proc) == 2:
","@@ -110,8 +110,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
         # for a Python function wait until it finishes
         max_iter = float('inf')
 
+    if hasattr(proc, '__call__'):
+        proc = (proc, (), {})
     if isinstance(proc, (list, tuple)):
-
         if len(proc) == 1:
             f, args, kw = (proc[0], (), {})
         elif len(proc) == 2:
",True,memory_profiler.py,True
"@@ -517,7 +517,7 @@ def magic_memit(self, line=''):
     """"""Measure memory usage of a Python statement
 
     Usage, in line mode:
-      %memit [-ir<R>t<T>] statement
+      %memit [-r<R>t<T>] statement
 
     Options:
     -r<R>: repeat the loop iteration <R> times and take the best result.
@@ -557,7 +557,10 @@ def magic_memit(self, line=''):
     if timeout <= 0:
         timeout = None
 
-    mem_usage = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout)
+    mem_usage = []
+    for _ in range(repeat):
+        tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout)
+        mem_usage.extend(tmp)
 
     if mem_usage:
         print('maximum of %d: %f MB per loop' % (repeat, max(mem_usage)))
","@@ -517,7 +517,7 @@ def magic_memit(self, line=''):
     """"""Measure memory usage of a Python statement
 
     Usage, in line mode:
-      %memit [-ir<R>t<T>] statement
+      %memit [-r<R>t<T>] statement
 
     Options:
     -r<R>: repeat the loop iteration <R> times and take the best result.
@@ -557,7 +557,10 @@ def magic_memit(self, line=''):
     if timeout <= 0:
         timeout = None
 
-    mem_usage = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout)
+    mem_usage = []
+    for _ in range(repeat):
+        tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout)
+        mem_usage.extend(tmp)
 
     if mem_usage:
         print('maximum of %d: %f MB per loop' % (repeat, max(mem_usage)))
",True,memory_profiler.py,True
"@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.24'
+__version__ = '0.25'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.24'
+__version__ = '0.25'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -20,10 +20,14 @@ except ImportError:
 try:
     import psutil
 
-    def _get_memory(pid, timestamps=False):
+    def _get_memory(pid, timestamps=False, include_children=False):
         process = psutil.Process(pid)
         try:
-            mem = float(process.get_memory_info()[0]) / (1024 ** 2)
+            mem = float(process.get_memory_info()[0]) / 1048576.
+            if include_children:
+                for p in process.get_children(recursive=True):
+                    mem += p.get_memory_info()[0] / 1048576.
+
         except psutil.AccessDenied:
             mem = -1
         if timestamps:
@@ -31,9 +35,7 @@ try:
         else:
             return mem
 
-
 except ImportError:
-
     warnings.warn(""psutil module not found. memory_profiler will be slow"")
 
     if os.name == 'posix':
@@ -77,19 +79,28 @@ class Timer(Process):
             del kw[""timestamps""]
         else:
             self.timestamps = False
+        if ""include_children"" in kw:
+            self.include_children = kw[""include_children""]
+            del kw[""include_children""]
+        else:
+            self.include_children = False
+
         super(Timer, self).__init__(*args, **kw)
 
     def run(self):
-        m = _get_memory(self.monitor_pid, timestamps=self.timestamps)
+        m = _get_memory(self.monitor_pid, timestamps=self.timestamps,
+                        include_children=self.include_children)
         timings = [m]
         self.pipe.send(0)  # we're ready
         while not self.pipe.poll(self.interval):
-            m = _get_memory(self.monitor_pid, timestamps=self.timestamps)
+            m = _get_memory(self.monitor_pid, timestamps=self.timestamps,
+                            include_children=self.include_children)
             timings.append(m)
         self.pipe.send(timings)
 
 
-def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False):
+def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
+                 include_children=False):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -156,7 +167,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False):
     elif isinstance(proc, subprocess.Popen):
         # external process, launched from Python
         while True:
-            ret.append(_get_memory(proc.pid, timestamps=timestamps))
+            ret.append(_get_memory(proc.pid, timestamps=timestamps,
+                                   include_children=include_children))
             time.sleep(interval)
             if timeout is not None:
                 max_iter -= 1
@@ -173,7 +185,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False):
         counter = 0
         while counter < max_iter:
             counter += 1
-            ret.append(_get_memory(proc, timestamps=timestamps))
+            ret.append(_get_memory(proc, timestamps=timestamps,
+                                   include_children=include_children))
             time.sleep(interval)
     return ret
 
","@@ -20,10 +20,14 @@ except ImportError:
 try:
     import psutil
 
-    def _get_memory(pid, timestamps=False):
+    def _get_memory(pid, timestamps=False, include_children=False):
         process = psutil.Process(pid)
         try:
-            mem = float(process.get_memory_info()[0]) / (1024 ** 2)
+            mem = float(process.get_memory_info()[0]) / 1048576.
+            if include_children:
+                for p in process.get_children(recursive=True):
+                    mem += p.get_memory_info()[0] / 1048576.
+
         except psutil.AccessDenied:
             mem = -1
         if timestamps:
@@ -31,9 +35,7 @@ try:
         else:
             return mem
 
-
 except ImportError:
-
     warnings.warn(""psutil module not found. memory_profiler will be slow"")
 
     if os.name == 'posix':
@@ -77,19 +79,28 @@ class Timer(Process):
             del kw[""timestamps""]
         else:
             self.timestamps = False
+        if ""include_children"" in kw:
+            self.include_children = kw[""include_children""]
+            del kw[""include_children""]
+        else:
+            self.include_children = False
+
         super(Timer, self).__init__(*args, **kw)
 
     def run(self):
-        m = _get_memory(self.monitor_pid, timestamps=self.timestamps)
+        m = _get_memory(self.monitor_pid, timestamps=self.timestamps,
+                        include_children=self.include_children)
         timings = [m]
         self.pipe.send(0)  # we're ready
         while not self.pipe.poll(self.interval):
-            m = _get_memory(self.monitor_pid, timestamps=self.timestamps)
+            m = _get_memory(self.monitor_pid, timestamps=self.timestamps,
+                            include_children=self.include_children)
             timings.append(m)
         self.pipe.send(timings)
 
 
-def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False):
+def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
+                 include_children=False):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -156,7 +167,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False):
     elif isinstance(proc, subprocess.Popen):
         # external process, launched from Python
         while True:
-            ret.append(_get_memory(proc.pid, timestamps=timestamps))
+            ret.append(_get_memory(proc.pid, timestamps=timestamps,
+                                   include_children=include_children))
             time.sleep(interval)
             if timeout is not None:
                 max_iter -= 1
@@ -173,7 +185,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False):
         counter = 0
         while counter < max_iter:
             counter += 1
-            ret.append(_get_memory(proc, timestamps=timestamps))
+            ret.append(_get_memory(proc, timestamps=timestamps,
+                                   include_children=include_children))
             time.sleep(interval)
     return ret
 
",True,memory_profiler.py,True
"@@ -16,6 +16,9 @@ parser.add_option(""--python"", dest=""python"", default=False,
 parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.5"",
                   type=""float"", action=""store"",
                   help=""Sampling period (in seconds)"")
+parser.add_option(""--include-children"", ""-C"", dest=""include_children"", default=False,
+                  action=""store_true"",
+                  help=""""""Monitors forked processes as well (sum up all process memory)"""""")
 
 (options, args) = parser.parse_args()
 print(""{1}: Sampling memory every {0.interval}s"".format(options, osp.basename(sys.argv[0])))
@@ -50,7 +53,8 @@ if options.python:
 else:
     p = subprocess.Popen(args)
 
-mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True)
+mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
+                     include_children=options.include_children)
 with open(mprofile_output, ""w"") as f:
     for m, t in mu:
         f.write(""{0:.6f} {1:.4f}"".format(m, t) + ""\n"")
","@@ -16,6 +16,9 @@ parser.add_option(""--python"", dest=""python"", default=False,
 parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.5"",
                   type=""float"", action=""store"",
                   help=""Sampling period (in seconds)"")
+parser.add_option(""--include-children"", ""-C"", dest=""include_children"", default=False,
+                  action=""store_true"",
+                  help=""""""Monitors forked processes as well (sum up all process memory)"""""")
 
 (options, args) = parser.parse_args()
 print(""{1}: Sampling memory every {0.interval}s"".format(options, osp.basename(sys.argv[0])))
@@ -50,7 +53,8 @@ if options.python:
 else:
     p = subprocess.Popen(args)
 
-mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True)
+mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
+                     include_children=options.include_children)
 with open(mprofile_output, ""w"") as f:
     for m, t in mu:
         f.write(""{0:.6f} {1:.4f}"".format(m, t) + ""\n"")
",True,mprofile,False
"@@ -523,7 +523,7 @@ def magic_memit(self, line=''):
     -r<R>: repeat the loop iteration <R> times and take the best result.
     Default: 1
 
-    -t<T>: timeout after <T> seconds. Unused if `-i` is active. Default: None
+    -t<T>: timeout after <T> seconds. Default: None
 
     Examples
     --------
@@ -540,16 +540,8 @@ def magic_memit(self, line=''):
       In [4]: %memit -r 10 np.empty(1e8)
       maximum of 10: 0.101562 MB per loop
 
-      In [5]: memit -t 3 while True: pass;
-      Subprocess timed out.
-      Subprocess timed out.
-      Subprocess timed out.
-      ERROR: all subprocesses exited unsuccessfully. Try again with the `-i`
-      option.
-      maximum of 1: -inf MB per loop
-
     """"""
-    opts, stmt = self.parse_options(line, 'r:t:i', posix=False, strict=False)
+    opts, stmt = self.parse_options(line, 'r:t', posix=False, strict=False)
     repeat = int(getattr(opts, 'r', 1))
     if repeat < 1:
         repeat == 1
","@@ -523,7 +523,7 @@ def magic_memit(self, line=''):
     -r<R>: repeat the loop iteration <R> times and take the best result.
     Default: 1
 
-    -t<T>: timeout after <T> seconds. Unused if `-i` is active. Default: None
+    -t<T>: timeout after <T> seconds. Default: None
 
     Examples
     --------
@@ -540,16 +540,8 @@ def magic_memit(self, line=''):
       In [4]: %memit -r 10 np.empty(1e8)
       maximum of 10: 0.101562 MB per loop
 
-      In [5]: memit -t 3 while True: pass;
-      Subprocess timed out.
-      Subprocess timed out.
-      Subprocess timed out.
-      ERROR: all subprocesses exited unsuccessfully. Try again with the `-i`
-      option.
-      maximum of 1: -inf MB per loop
-
     """"""
-    opts, stmt = self.parse_options(line, 'r:t:i', posix=False, strict=False)
+    opts, stmt = self.parse_options(line, 'r:t', posix=False, strict=False)
     repeat = int(getattr(opts, 'r', 1))
     if repeat < 1:
         repeat == 1
",True,memory_profiler.py,True
"@@ -9,6 +9,7 @@ import warnings
 import linecache
 import inspect
 import subprocess
+from copy import copy
 
 # TODO: provide alternative when multprocessing is not available
 try:
@@ -601,15 +602,15 @@ if __name__ == '__main__':
         if sys.version_info[0] < 3:
             import __builtin__
             __builtin__.__dict__['profile'] = prof
-            ns = locals()
+            ns = copy(locals())
             ns['profile'] = prof # shadow the profile decorator defined above
             execfile(__file__, ns, ns)
         else:
             import builtins
             builtins.__dict__['profile'] = prof
-            ns = locals()
+            ns = copy(locals())
             ns['profile'] = prof # shadow the profile decorator defined above
-            exec(compile(open(__file__).read(), __file__, 'exec'), ns,
-                                                                   globals())
+            exec(compile(open(__file__).read(), __file__, 'exec'),
+                 ns, copy(globals()))
     finally:
         show_results(prof, precision=options.precision)
","@@ -9,6 +9,7 @@ import warnings
 import linecache
 import inspect
 import subprocess
+from copy import copy
 
 # TODO: provide alternative when multprocessing is not available
 try:
@@ -601,15 +602,15 @@ if __name__ == '__main__':
         if sys.version_info[0] < 3:
             import __builtin__
             __builtin__.__dict__['profile'] = prof
-            ns = locals()
+            ns = copy(locals())
             ns['profile'] = prof # shadow the profile decorator defined above
             execfile(__file__, ns, ns)
         else:
             import builtins
             builtins.__dict__['profile'] = prof
-            ns = locals()
+            ns = copy(locals())
             ns['profile'] = prof # shadow the profile decorator defined above
-            exec(compile(open(__file__).read(), __file__, 'exec'), ns,
-                                                                   globals())
+            exec(compile(open(__file__).read(), __file__, 'exec'),
+                 ns, copy(globals()))
     finally:
         show_results(prof, precision=options.precision)
",True,memory_profiler.py,True
"@@ -66,75 +66,93 @@ def read_timestamp_file(ts_filename):
     return ret
 
 
-profiles = glob.glob(""mprofile_??????????????.dat"")
-profiles.sort()
-
-if len(sys.argv) == 1:
-    if len(profiles) == 0:
-        print(""""""No input file found. This program looks for mprofile_*.dat files,
-generated by the mprofile command."""""")
-        sys.exit(-1)
-    filename = profiles[-1]
-else:
-    filename = sys.argv[1]
-    if not osp.exists(filename):
-        try:
-            n = int(filename)
-        except ValueError:
-            print(""Input file not found: "" + filename)
-        filename = profiles[n]
-
-# Check for a timestamp file
-file_parts = osp.splitext(filename)
-ts_filename = file_parts[0] + ""_ts"" + file_parts[1]
-ts = read_timestamp_file(ts_filename)
-
-mdata = pl.atleast_2d(pl.loadtxt(filename))
-
-global_start = float(mdata[0, 1])
-
-mem = mdata[:, 0]
-max_mem = mem.max()
-max_mem_ind = mem.argmax()
-
-
-t = mdata[:, 1] - global_start
-
-all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
-
-pl.figure()
-pl.plot(t, mem, ""b+-"")
-
-bottom, top = pl.ylim()
-bottom += 0.001
-top -= 0.001
-
-# plot timestamps, if any
-if ts is not None:
-    func_num = 0
-    for f, exec_ts in ts.iteritems():
-        for execution in exec_ts:
-            add_bracket([ts - global_start for ts in execution], t, mem,
-                        color= all_colors[func_num % len(all_colors)],
-                        label=f.split(""."")[-1] + "" %.3fs"" % (execution[1] - execution[0]))
-            ## pl.vlines([ts - global_start for ts in execution],
-            ##           bottom, top,
-            ##           colors=all_colors[func_num % len(all_colors)],
-            ##           linestyles=""dashdot"",
-            ##           label=f.split(""."")[-1] + "" %.3fs"" % (execution[1] - execution[0]))
-        func_num += 1
-    pl.legend(loc=0)
-
-pl.hlines(max_mem,
-          pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
-          colors=""r"", linestyles=""--"")
-pl.vlines(t[max_mem_ind], bottom, top,
-          colors=""r"", linestyles=""--"")
-pl.xlabel(""time [s]"")
-pl.ylabel(""memory used [MB]"")
-title = time.strftime(""%d / %m / %Y - start at %H:%M:%S"", time.localtime(global_start)) \
-                          + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
-pl.title(title)
-pl.grid()
-pl.show()
+def plot_file(filename, index=0, timestamps=True):
+    # Check for a timestamp file
+    file_parts = osp.splitext(filename)
+    ts_filename = file_parts[0] + ""_ts"" + file_parts[1]
+    ts = read_timestamp_file(ts_filename)
+
+    mdata = pl.atleast_2d(pl.loadtxt(filename))
+
+    global_start = float(mdata[0, 1])
+
+    mem = mdata[:, 0]
+    max_mem = mem.max()
+    max_mem_ind = mem.argmax()
+
+    t = mdata[:, 1] - global_start
+
+    all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
+    mem_line_colors=('k', ""b"", ""r"")
+    mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
+                                   time.localtime(global_start)) \
+                                   + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
+
+    pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
+            label=mem_line_label)
+
+    bottom, top = pl.ylim()
+    bottom += 0.001
+    top -= 0.001
+
+    # plot timestamps, if any
+    if ts is not None and timestamps:
+        func_num = 0
+        for f, exec_ts in ts.iteritems():
+            for execution in exec_ts:
+                add_bracket([ts - global_start for ts in execution], t, mem,
+                            color= all_colors[func_num % len(all_colors)],
+                            label=f.split(""."")[-1] + "" %.3fs"" % (execution[1] - execution[0]))
+            func_num += 1
+
+    if timestamps:
+        pl.hlines(max_mem,
+                  pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
+                  colors=""r"", linestyles=""--"")
+        pl.vlines(t[max_mem_ind], bottom, top,
+                  colors=""r"", linestyles=""--"")
+
+
+if __name__ == ""__main__"":
+    profiles = glob.glob(""mprofile_??????????????.dat"")
+    profiles.sort()
+
+    print (sys.argv)
+    if len(sys.argv) == 1:
+        if len(profiles) == 0:
+            print(""""""No input file found. This program looks for mprofile_*.dat files,
+    generated by the mprofile command."""""")
+            sys.exit(-1)
+        filenames = [profiles[-1]]
+    else:
+        filenames = []
+        for arg in sys.argv[1:]:
+            if osp.exists(arg):
+                if not arg in filenames:
+                    filenames.append(arg)
+            else:
+                try:
+                    n = int(arg)
+                except ValueError:
+                    print(""Input file not found: "" + arg)
+                if not profiles[n] in filenames:
+                    filenames.append(profiles[n])
+
+    pl.figure(figsize=(14,6), dpi=90)
+    if len(filenames) > 1:
+        timestamps = False
+    else:
+        timestamps = True
+    for n, filename in enumerate(filenames):
+        plot_file(filename, index=n, timestamps=timestamps)
+    pl.xlabel(""time [s]"")
+    pl.ylabel(""memory used [MB]"")
+
+    ax = pl.gca()
+    box = ax.get_position()
+    ax.set_position([0.07, 0.1,
+                     0.55, 0.8])
+    ax.legend(loc=""upper left"", bbox_to_anchor=(1.05, 1.))
+    pl.grid()
+    pl.show()
 
","@@ -66,75 +66,93 @@ def read_timestamp_file(ts_filename):
     return ret
 
 
-profiles = glob.glob(""mprofile_??????????????.dat"")
-profiles.sort()
+def plot_file(filename, index=0, timestamps=True):
+    # Check for a timestamp file
+    file_parts = osp.splitext(filename)
+    ts_filename = file_parts[0] + ""_ts"" + file_parts[1]
+    ts = read_timestamp_file(ts_filename)
 
-if len(sys.argv) == 1:
-    if len(profiles) == 0:
-        print(""""""No input file found. This program looks for mprofile_*.dat files,
-generated by the mprofile command."""""")
-        sys.exit(-1)
-    filename = profiles[-1]
-else:
-    filename = sys.argv[1]
-    if not osp.exists(filename):
-        try:
-            n = int(filename)
-        except ValueError:
-            print(""Input file not found: "" + filename)
-        filename = profiles[n]
+    mdata = pl.atleast_2d(pl.loadtxt(filename))
 
-# Check for a timestamp file
-file_parts = osp.splitext(filename)
-ts_filename = file_parts[0] + ""_ts"" + file_parts[1]
-ts = read_timestamp_file(ts_filename)
+    global_start = float(mdata[0, 1])
 
-mdata = pl.atleast_2d(pl.loadtxt(filename))
+    mem = mdata[:, 0]
+    max_mem = mem.max()
+    max_mem_ind = mem.argmax()
 
-global_start = float(mdata[0, 1])
+    t = mdata[:, 1] - global_start
 
-mem = mdata[:, 0]
-max_mem = mem.max()
-max_mem_ind = mem.argmax()
+    all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
+    mem_line_colors=('k', ""b"", ""r"")
+    mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
+                                   time.localtime(global_start)) \
+                                   + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
+
+    pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
+            label=mem_line_label)
+
+    bottom, top = pl.ylim()
+    bottom += 0.001
+    top -= 0.001
+
+    # plot timestamps, if any
+    if ts is not None and timestamps:
+        func_num = 0
+        for f, exec_ts in ts.iteritems():
+            for execution in exec_ts:
+                add_bracket([ts - global_start for ts in execution], t, mem,
+                            color= all_colors[func_num % len(all_colors)],
+                            label=f.split(""."")[-1] + "" %.3fs"" % (execution[1] - execution[0]))
+            func_num += 1
+
+    if timestamps:
+        pl.hlines(max_mem,
+                  pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
+                  colors=""r"", linestyles=""--"")
+        pl.vlines(t[max_mem_ind], bottom, top,
+                  colors=""r"", linestyles=""--"")
 
 
-t = mdata[:, 1] - global_start
+if __name__ == ""__main__"":
+    profiles = glob.glob(""mprofile_??????????????.dat"")
+    profiles.sort()
 
-all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
+    print (sys.argv)
+    if len(sys.argv) == 1:
+        if len(profiles) == 0:
+            print(""""""No input file found. This program looks for mprofile_*.dat files,
+    generated by the mprofile command."""""")
+            sys.exit(-1)
+        filenames = [profiles[-1]]
+    else:
+        filenames = []
+        for arg in sys.argv[1:]:
+            if osp.exists(arg):
+                if not arg in filenames:
+                    filenames.append(arg)
+            else:
+                try:
+                    n = int(arg)
+                except ValueError:
+                    print(""Input file not found: "" + arg)
+                if not profiles[n] in filenames:
+                    filenames.append(profiles[n])
 
-pl.figure()
-pl.plot(t, mem, ""b+-"")
+    pl.figure(figsize=(14,6), dpi=90)
+    if len(filenames) > 1:
+        timestamps = False
+    else:
+        timestamps = True
+    for n, filename in enumerate(filenames):
+        plot_file(filename, index=n, timestamps=timestamps)
+    pl.xlabel(""time [s]"")
+    pl.ylabel(""memory used [MB]"")
 
-bottom, top = pl.ylim()
-bottom += 0.001
-top -= 0.001
-
-# plot timestamps, if any
-if ts is not None:
-    func_num = 0
-    for f, exec_ts in ts.iteritems():
-        for execution in exec_ts:
-            add_bracket([ts - global_start for ts in execution], t, mem,
-                        color= all_colors[func_num % len(all_colors)],
-                        label=f.split(""."")[-1] + "" %.3fs"" % (execution[1] - execution[0]))
-            ## pl.vlines([ts - global_start for ts in execution],
-            ##           bottom, top,
-            ##           colors=all_colors[func_num % len(all_colors)],
-            ##           linestyles=""dashdot"",
-            ##           label=f.split(""."")[-1] + "" %.3fs"" % (execution[1] - execution[0]))
-        func_num += 1
-    pl.legend(loc=0)
-
-pl.hlines(max_mem,
-          pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
-          colors=""r"", linestyles=""--"")
-pl.vlines(t[max_mem_ind], bottom, top,
-          colors=""r"", linestyles=""--"")
-pl.xlabel(""time [s]"")
-pl.ylabel(""memory used [MB]"")
-title = time.strftime(""%d / %m / %Y - start at %H:%M:%S"", time.localtime(global_start)) \
-                          + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
-pl.title(title)
-pl.grid()
-pl.show()
+    ax = pl.gca()
+    box = ax.get_position()
+    ax.set_position([0.07, 0.1,
+                     0.55, 0.8])
+    ax.legend(loc=""upper left"", bbox_to_anchor=(1.05, 1.))
+    pl.grid()
+    pl.show()
 
",False,mplot,False
"@@ -1,11 +1,10 @@
 =================
  Memory Profiler
 =================
+
 This is a python module for monitoring memory consumption of a process
 as well as line-by-line analysis of memory consumption for python
-programs.
-
-It's a pure python module and has the `psutil
+programs. It is a pure python module and has the `psutil
 <http://pypi.python.org/pypi/psutil>`_ module as optional (but highly
 recommended) dependencies.
 
@@ -25,10 +24,15 @@ To install from source, download the package, extract and type::
 =======
  Usage
 =======
+
 The line-by-line profiler is used much in the same way of the
-line_profiler: you must first decorate the function you would like to
-profile with ``@profile``. In this example, we create a simple function
-``my_func`` that allocates lists ``a``, ``b`` and then deletes ``b``::
+`line_profiler <https://pypi.python.org/pypi/line_profiler/>`_: first
+decorate the function you would like to profile with ``@profile`` and
+then run the script with a special script (in this case with specific
+arguments to the Python interpreter). 
+
+In the following example, we create a simple function ``my_func`` that
+allocates lists ``a``, ``b`` and then deletes ``b``::
 
 
     @profile
","@@ -1,11 +1,10 @@
 =================
  Memory Profiler
 =================
+
 This is a python module for monitoring memory consumption of a process
 as well as line-by-line analysis of memory consumption for python
-programs.
-
-It's a pure python module and has the `psutil
+programs. It is a pure python module and has the `psutil
 <http://pypi.python.org/pypi/psutil>`_ module as optional (but highly
 recommended) dependencies.
 
@@ -25,10 +24,15 @@ To install from source, download the package, extract and type::
 =======
  Usage
 =======
+
 The line-by-line profiler is used much in the same way of the
-line_profiler: you must first decorate the function you would like to
-profile with ``@profile``. In this example, we create a simple function
-``my_func`` that allocates lists ``a``, ``b`` and then deletes ``b``::
+`line_profiler <https://pypi.python.org/pypi/line_profiler/>`_: first
+decorate the function you would like to profile with ``@profile`` and
+then run the script with a special script (in this case with specific
+arguments to the Python interpreter). 
+
+In the following example, we create a simple function ``my_func`` that
+allocates lists ``a``, ``b`` and then deletes ``b``::
 
 
     @profile
",True,README.rst,False
"@@ -0,0 +1,120 @@
+#! /usr/bin/env python
+
+import glob
+import os
+import os.path as osp
+import sys
+import re
+
+from optparse import OptionParser
+
+import memory_profiler as mp
+
+
+def print_usage():
+    print(""Usage: %s <command> <options> <arguments>""
+          % osp.basename(sys.argv[0]))
+
+def get_action():
+    """"""Pop first argument, check it is a valid action.""""""
+    all_actions = (""rm"",)
+    if len(sys.argv) <= 1:
+        print_usage()
+        sys.exit(1)
+    if not sys.argv[1] in all_actions:
+        print(""Valid actions are: "" + "" "".join(all_actions))
+        sys.exit(1)
+
+    return sys.argv.pop(1)
+
+
+def get_profile_filenames(args):
+    """"""Return list of profile filenames.
+
+    Parameters
+    ==========
+    args (list)
+        list of filename or integer. An integer is the index of the
+        profile in the list of existing profiles. 0 is the oldest,
+        -1 in the more recent.
+        Non-existing files cause a ValueError exception to be thrown.
+
+    Returns
+    =======
+    filenames (list)
+        list of existing memory profile filenames. It is guaranteed
+        that an given file name will not appear twice in this list.
+    """"""
+    profiles = glob.glob(""mprofile_??????????????.dat"")
+    profiles.sort()
+
+    filenames = []
+
+    for arg in args:
+        if arg == ""--"":  # workaround
+            continue
+        try:
+            index = int(arg)
+        except ValueError:
+            index = None
+        if index is not None:
+            try:
+                filename = profiles[index]
+            except IndexError:
+                raise ValueError(""Invalid index (non-existing file): %s"" % arg)
+
+            if filename not in filenames:
+                filenames.append(filename)
+        else:
+            if osp.isfile(arg):
+                if arg not in filenames:
+                    filenames.append(arg)
+            elif osp.isdir(arg):
+                raise ValueError(""Path %s is a directory"" % arg)
+            else:
+                raise ValueError(""File %s not found"" % arg)
+
+    # Add timestamp files, if any
+    for filename in reversed(filenames):
+        parts = osp.splitext(filename)
+        timestamp_file = parts[0] + ""_ts"" + parts[1]
+        if osp.isfile(timestamp_file) and timestamp_file not in filenames:
+            filenames.append(timestamp_file)
+
+    return filenames
+
+
+def rm_action():
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
+                      action=""store_true"",
+                      help=""""""Show what will be done, without actually doing it."""""")
+
+    (options, args) = parser.parse_args()
+
+    if len(args) == 0:
+        print(""A profile to remove must be provided (number or filename)"")
+        sys.exit(1)
+
+    filenames = get_profile_filenames(args)
+    if options.dry_run:
+        print(""Files to be removed: "")
+        for filename in filenames:
+            print(filename)
+    else:
+        for filename in filenames:
+            os.remove(filename)
+
+
+if __name__ == ""__main__"":
+    # Workaround for optparse limitation: insert -- before first negative number found.
+    negint = re.compile(""-[0-9]+"")
+    for n, arg in enumerate(sys.argv):
+        if negint.match(arg):
+            sys.argv.insert(n, ""--"")
+            break
+    actions = {""rm"": rm_action}
+    actions[get_action()]()
+
+
","@@ -0,0 +1,120 @@
+#! /usr/bin/env python
+
+import glob
+import os
+import os.path as osp
+import sys
+import re
+
+from optparse import OptionParser
+
+import memory_profiler as mp
+
+
+def print_usage():
+    print(""Usage: %s <command> <options> <arguments>""
+          % osp.basename(sys.argv[0]))
+
+def get_action():
+    """"""Pop first argument, check it is a valid action.""""""
+    all_actions = (""rm"",)
+    if len(sys.argv) <= 1:
+        print_usage()
+        sys.exit(1)
+    if not sys.argv[1] in all_actions:
+        print(""Valid actions are: "" + "" "".join(all_actions))
+        sys.exit(1)
+
+    return sys.argv.pop(1)
+
+
+def get_profile_filenames(args):
+    """"""Return list of profile filenames.
+
+    Parameters
+    ==========
+    args (list)
+        list of filename or integer. An integer is the index of the
+        profile in the list of existing profiles. 0 is the oldest,
+        -1 in the more recent.
+        Non-existing files cause a ValueError exception to be thrown.
+
+    Returns
+    =======
+    filenames (list)
+        list of existing memory profile filenames. It is guaranteed
+        that an given file name will not appear twice in this list.
+    """"""
+    profiles = glob.glob(""mprofile_??????????????.dat"")
+    profiles.sort()
+
+    filenames = []
+
+    for arg in args:
+        if arg == ""--"":  # workaround
+            continue
+        try:
+            index = int(arg)
+        except ValueError:
+            index = None
+        if index is not None:
+            try:
+                filename = profiles[index]
+            except IndexError:
+                raise ValueError(""Invalid index (non-existing file): %s"" % arg)
+
+            if filename not in filenames:
+                filenames.append(filename)
+        else:
+            if osp.isfile(arg):
+                if arg not in filenames:
+                    filenames.append(arg)
+            elif osp.isdir(arg):
+                raise ValueError(""Path %s is a directory"" % arg)
+            else:
+                raise ValueError(""File %s not found"" % arg)
+
+    # Add timestamp files, if any
+    for filename in reversed(filenames):
+        parts = osp.splitext(filename)
+        timestamp_file = parts[0] + ""_ts"" + parts[1]
+        if osp.isfile(timestamp_file) and timestamp_file not in filenames:
+            filenames.append(timestamp_file)
+
+    return filenames
+
+
+def rm_action():
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
+                      action=""store_true"",
+                      help=""""""Show what will be done, without actually doing it."""""")
+
+    (options, args) = parser.parse_args()
+
+    if len(args) == 0:
+        print(""A profile to remove must be provided (number or filename)"")
+        sys.exit(1)
+
+    filenames = get_profile_filenames(args)
+    if options.dry_run:
+        print(""Files to be removed: "")
+        for filename in filenames:
+            print(filename)
+    else:
+        for filename in filenames:
+            os.remove(filename)
+
+
+if __name__ == ""__main__"":
+    # Workaround for optparse limitation: insert -- before first negative number found.
+    negint = re.compile(""-[0-9]+"")
+    for n, arg in enumerate(sys.argv):
+        if negint.match(arg):
+            sys.argv.insert(n, ""--"")
+            break
+    actions = {""rm"": rm_action}
+    actions[get_action()]()
+
+
",True,maction,False
"@@ -117,7 +117,6 @@ if __name__ == ""__main__"":
     profiles = glob.glob(""mprofile_??????????????.dat"")
     profiles.sort()
 
-    print (sys.argv)
     if len(sys.argv) == 1:
         if len(profiles) == 0:
             print(""""""No input file found. This program looks for mprofile_*.dat files,
","@@ -117,7 +117,6 @@ if __name__ == ""__main__"":
     profiles = glob.glob(""mprofile_??????????????.dat"")
     profiles.sort()
 
-    print (sys.argv)
     if len(sys.argv) == 1:
         if len(profiles) == 0:
             print(""""""No input file found. This program looks for mprofile_*.dat files,
",True,mplot,False
"@@ -595,6 +595,7 @@ if __name__ == '__main__':
         sys.exit(2)
 
     (options, args) = parser.parse_args()
+    del sys.argv[0]         # Hide ""memory_profiler.py"" from argument list
 
     prof = LineProfiler(max_mem=options.max_mem)
     __file__ = _find_script(args[0])
","@@ -595,6 +595,7 @@ if __name__ == '__main__':
         sys.exit(2)
 
     (options, args) = parser.parse_args()
+    del sys.argv[0]         # Hide ""memory_profiler.py"" from argument list
 
     prof = LineProfiler(max_mem=options.max_mem)
     __file__ = _find_script(args[0])
",True,memory_profiler.py,True
"@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.25'
+__version__ = '0.26'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.25'
+__version__ = '0.26'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -214,6 +214,19 @@ def _find_script(script_name):
     raise SystemExit(1)
 
 
+class _TimeStamperCM(object):
+    """"""Time-stamping context manager.""""""
+
+    def __init__(self, timestamps):
+        self._timestamps = timestamps
+
+    def __enter__(self):
+        self._timestamps.append(time.time())
+
+    def __exit__(self, *args):
+        self._timestamps.append(time.time())
+
+
 class TimeStamper:
     """""" A profiler that just records start and end execution times for
     any decorated function.
@@ -233,6 +246,19 @@ class TimeStamper:
         f.__dict__.update(getattr(func, '__dict__', {}))
         return f
 
+    def timestamp(self, name=""<block>""):
+        """"""Returns a context manager for timestamping a block of code.""""""
+        # Make a fake function
+        func = lambda x: x
+        func.__module__ = """"
+        func.__name__ = name
+        self.add_function(func)
+        timestamps = []
+        self.functions[func].append(timestamps)
+        # A new object is required each time, since there can be several
+        # nested context managers.
+        return _TimeStamperCM(timestamps)
+
     def add_function(self, func):
         if not func in self.functions:
             self.functions[func] = []
@@ -309,7 +335,7 @@ class LineProfiler:
         return f
 
     def run(self, cmd):
-        """""" Profile a single executable statment in the main namespace.
+        """""" Profile a single executable statement in the main namespace.
         """"""
         import __main__
         main_dict = __main__.__dict__
","@@ -214,6 +214,19 @@ def _find_script(script_name):
     raise SystemExit(1)
 
 
+class _TimeStamperCM(object):
+    """"""Time-stamping context manager.""""""
+
+    def __init__(self, timestamps):
+        self._timestamps = timestamps
+
+    def __enter__(self):
+        self._timestamps.append(time.time())
+
+    def __exit__(self, *args):
+        self._timestamps.append(time.time())
+
+
 class TimeStamper:
     """""" A profiler that just records start and end execution times for
     any decorated function.
@@ -233,6 +246,19 @@ class TimeStamper:
         f.__dict__.update(getattr(func, '__dict__', {}))
         return f
 
+    def timestamp(self, name=""<block>""):
+        """"""Returns a context manager for timestamping a block of code.""""""
+        # Make a fake function
+        func = lambda x: x
+        func.__module__ = """"
+        func.__name__ = name
+        self.add_function(func)
+        timestamps = []
+        self.functions[func].append(timestamps)
+        # A new object is required each time, since there can be several
+        # nested context managers.
+        return _TimeStamperCM(timestamps)
+
     def add_function(self, func):
         if not func in self.functions:
             self.functions[func] = []
@@ -309,7 +335,7 @@ class LineProfiler:
         return f
 
     def run(self, cmd):
-        """""" Profile a single executable statment in the main namespace.
+        """""" Profile a single executable statement in the main namespace.
         """"""
         import __main__
         main_dict = __main__.__dict__
",True,memory_profiler.py,True
"@@ -0,0 +1,23 @@
+import numpy as np
+import scipy.signal
+
+
+#@profile
+def create_data():
+    ret = []
+    for n in xrange(70):
+        ret.append(np.random.randn(1, 70, 71, 72))
+    return ret
+
+
+#@profile
+def process_data(data):
+    data = np.concatenate(data)
+    detrended = scipy.signal.detrend(data, axis=0)
+    return detrended
+
+
+if __name__ == ""__main__"":
+    data1 = create_data()
+    data2 = process_data(data1)
+    print (data2.shape)
","@@ -0,0 +1,23 @@
+import numpy as np
+import scipy.signal
+
+
+#@profile
+def create_data():
+    ret = []
+    for n in xrange(70):
+        ret.append(np.random.randn(1, 70, 71, 72))
+    return ret
+
+
+#@profile
+def process_data(data):
+    data = np.concatenate(data)
+    detrended = scipy.signal.detrend(data, axis=0)
+    return detrended
+
+
+if __name__ == ""__main__"":
+    data1 = create_data()
+    data2 = process_data(data1)
+    print (data2.shape)
",True,examples/numpy_example.py,True
"@@ -0,0 +1,7 @@
+
+.PHONY: test
+
+test:
+	python -m memory_profiler test/test_func.py
+	python -m memory_profiler test/test_loop.py
+	python -m memory_profiler test/test_with.py
\ No newline at end of file
","@@ -0,0 +1,7 @@
+
+.PHONY: test
+
+test:
+	python -m memory_profiler test/test_func.py
+	python -m memory_profiler test/test_loop.py
+	python -m memory_profiler test/test_with.py
\ No newline at end of file
",True,Makefile,False
"@@ -17,25 +17,45 @@ try:
 except ImportError:
     from multiprocessing.dummy import Process, Pipe
 
+_TWO_20 = float(2 ** 20)
 
+has_psutil = False
+has_resource = False
+
+# .. get available packages ..
 try:
     import psutil
+    has_psutil = True
+except ImportError:
+    pass
+
+try:
+    import resource
+    has_resource = True
+except ImportError:
+    pass
+
+
+def _get_memory(pid):
 
-    def _get_memory(pid):
+    # .. fastests but just works for current process ..
+    # .. and only available on unix ..
+    if pid == -1 and has_resource:
+        mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / (_TWO_20)
+        return mem
+
+    # .. good compromise but requires psutil ..
+    if has_psutil:
         process = psutil.Process(pid)
         try:
-            mem = float(process.get_memory_info()[0]) / (1024 ** 2)
+            mem = process.get_memory_info()[0] / (_TWO_20)
         except psutil.AccessDenied:
             mem = -1
         return mem
 
-
-except ImportError:
-
-    warnings.warn(""psutil module not found. memory_profiler will be slow"")
-
+    # .. scary stuff ..
     if os.name == 'posix':
-        def _get_memory(pid):
+            warnings.warn(""psutil module not found. memory_profiler will be slow"")
             # ..
             # .. memory usage in MB ..
             # .. this should work on both Mac and Linux ..
@@ -133,7 +153,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
             % (n_args, len(args)))
 
         child_conn, parent_conn = Pipe()  # this will store Timer's results
-        p = Timer(os.getpid(), interval, child_conn)
+        p = Timer(-1, interval, child_conn)
         p.start()
         parent_conn.recv()  # wait until we start getting memory
         f(*args, **kw)
@@ -153,8 +173,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
                 break
     else:
         # external process
-        if proc == -1:
-            proc = os.getpid()
         if max_iter == -1:
             max_iter = 1
         counter = 0
@@ -282,14 +300,14 @@ class LineProfiler:
             if event == 'return':
                 lineno += 1
             entry = self.code_map[frame.f_code].setdefault(lineno, [])
-            entry.append(_get_memory(os.getpid()))
+            entry.append(_get_memory(-1))
 
         return self.trace_memory_usage
 
     def trace_max_mem(self, frame, event, arg):
         # run into PDB as soon as memory is higher than MAX_MEM
         if event in ('line', 'return') and frame.f_code in self.code_map:
-            c = _get_memory(os.getpid())
+            c = _get_memory(-1)
             if c >= self.max_mem:
                 t = 'Current memory {0:.2f} MB exceeded the maximum '.format(c) + \
                     'of {0:.2f} MB\n'.format(self.max_mem)
","@@ -17,25 +17,45 @@ try:
 except ImportError:
     from multiprocessing.dummy import Process, Pipe
 
+_TWO_20 = float(2 ** 20)
 
+has_psutil = False
+has_resource = False
+
+# .. get available packages ..
 try:
     import psutil
+    has_psutil = True
+except ImportError:
+    pass
 
-    def _get_memory(pid):
+try:
+    import resource
+    has_resource = True
+except ImportError:
+    pass
+
+
+def _get_memory(pid):
+
+    # .. fastests but just works for current process ..
+    # .. and only available on unix ..
+    if pid == -1 and has_resource:
+        mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / (_TWO_20)
+        return mem
+
+    # .. good compromise but requires psutil ..
+    if has_psutil:
         process = psutil.Process(pid)
         try:
-            mem = float(process.get_memory_info()[0]) / (1024 ** 2)
+            mem = process.get_memory_info()[0] / (_TWO_20)
         except psutil.AccessDenied:
             mem = -1
         return mem
 
-
-except ImportError:
-
-    warnings.warn(""psutil module not found. memory_profiler will be slow"")
-
+    # .. scary stuff ..
     if os.name == 'posix':
-        def _get_memory(pid):
+            warnings.warn(""psutil module not found. memory_profiler will be slow"")
             # ..
             # .. memory usage in MB ..
             # .. this should work on both Mac and Linux ..
@@ -133,7 +153,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
             % (n_args, len(args)))
 
         child_conn, parent_conn = Pipe()  # this will store Timer's results
-        p = Timer(os.getpid(), interval, child_conn)
+        p = Timer(-1, interval, child_conn)
         p.start()
         parent_conn.recv()  # wait until we start getting memory
         f(*args, **kw)
@@ -153,8 +173,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
                 break
     else:
         # external process
-        if proc == -1:
-            proc = os.getpid()
         if max_iter == -1:
             max_iter = 1
         counter = 0
@@ -282,14 +300,14 @@ class LineProfiler:
             if event == 'return':
                 lineno += 1
             entry = self.code_map[frame.f_code].setdefault(lineno, [])
-            entry.append(_get_memory(os.getpid()))
+            entry.append(_get_memory(-1))
 
         return self.trace_memory_usage
 
     def trace_max_mem(self, frame, event, arg):
         # run into PDB as soon as memory is higher than MAX_MEM
         if event in ('line', 'return') and frame.f_code in self.code_map:
-            c = _get_memory(os.getpid())
+            c = _get_memory(-1)
             if c >= self.max_mem:
                 t = 'Current memory {0:.2f} MB exceeded the maximum '.format(c) + \
                     'of {0:.2f} MB\n'.format(self.max_mem)
",False,memory_profiler.py,True
"@@ -1 +0,0 @@
-__author__ = 'fabian'
","@@ -1 +0,0 @@
-__author__ = 'fabian'
",True,,False
"@@ -4,4 +4,6 @@
 test:
 	python -m memory_profiler test/test_func.py
 	python -m memory_profiler test/test_loop.py
-	python -m memory_profiler test/test_with.py
\ No newline at end of file
+	python -m memory_profiler test/test_as.py
+	python -m memory_profiler test/test_global.py
+	python test/test_import.py
\ No newline at end of file
","@@ -4,4 +4,6 @@
 test:
 	python -m memory_profiler test/test_func.py
 	python -m memory_profiler test/test_loop.py
-	python -m memory_profiler test/test_with.py
\ No newline at end of file
+	python -m memory_profiler test/test_as.py
+	python -m memory_profiler test/test_global.py
+	python test/test_import.py
\ No newline at end of file
",True,Makefile,False
"@@ -2,6 +2,8 @@
 
 __version__ = '0.26'
 
+_clean_globals = globals()
+
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
 import time, sys, os, pdb
@@ -619,17 +621,12 @@ if __name__ == '__main__':
     __file__ = _find_script(args[0])
     try:
         if sys.version_info[0] < 3:
-            import __builtin__
-            __builtin__.__dict__['profile'] = prof
-            ns = copy(locals())
+            ns = copy(_clean_globals)
             ns['profile'] = prof # shadow the profile decorator defined above
             execfile(__file__, ns, ns)
         else:
-            import builtins
-            builtins.__dict__['profile'] = prof
-            ns = copy(locals())
+            ns = copy(_clean_globals)
             ns['profile'] = prof # shadow the profile decorator defined above
-            exec(compile(open(__file__).read(), __file__, 'exec'),
-                 ns, copy(globals()))
+            exec(compile(open(__file__).read(), __file__, 'exec'), ns, ns)
     finally:
         show_results(prof, precision=options.precision)
","@@ -2,6 +2,8 @@
 
 __version__ = '0.26'
 
+_clean_globals = globals()
+
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
 import time, sys, os, pdb
@@ -619,17 +621,12 @@ if __name__ == '__main__':
     __file__ = _find_script(args[0])
     try:
         if sys.version_info[0] < 3:
-            import __builtin__
-            __builtin__.__dict__['profile'] = prof
-            ns = copy(locals())
+            ns = copy(_clean_globals)
             ns['profile'] = prof # shadow the profile decorator defined above
             execfile(__file__, ns, ns)
         else:
-            import builtins
-            builtins.__dict__['profile'] = prof
-            ns = copy(locals())
+            ns = copy(_clean_globals)
             ns['profile'] = prof # shadow the profile decorator defined above
-            exec(compile(open(__file__).read(), __file__, 'exec'),
-                 ns, copy(globals()))
+            exec(compile(open(__file__).read(), __file__, 'exec'), ns, ns)
     finally:
         show_results(prof, precision=options.precision)
",True,memory_profiler.py,True
"@@ -0,0 +1,9 @@
+import math
+
+@profile
+def f():
+    o = math.sqrt(2013)
+    return o
+
+if __name__ == '__main__':
+	f()
\ No newline at end of file
","@@ -0,0 +1,9 @@
+import math
+
+@profile
+def f():
+    o = math.sqrt(2013)
+    return o
+
+if __name__ == '__main__':
+	f()
\ No newline at end of file
",True,test/test_as.py,True
"@@ -0,0 +1,4 @@
+options = None
+
+
+# test for dc0c8aa60b5960d240b0dcea270efa1e5a314a2c
","@@ -0,0 +1,4 @@
+options = None
+
+
+# test for dc0c8aa60b5960d240b0dcea270efa1e5a314a2c
",True,test/test_global.py,True
"@@ -0,0 +1,11 @@
+from memory_profiler import profile
+
+@profile
+def my_func():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    del b
+    return a
+
+if __name__ == '__main__':
+	my_func()
\ No newline at end of file
","@@ -0,0 +1,11 @@
+from memory_profiler import profile
+
+@profile
+def my_func():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    del b
+    return a
+
+if __name__ == '__main__':
+	my_func()
\ No newline at end of file
",True,test/test_import.py,True
"@@ -2,7 +2,8 @@
 
 __version__ = '0.26'
 
-_clean_globals = globals()
+# .. we'll use this to pass it to the child script ..
+_clean_globals = globals().copy()
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -2,7 +2,8 @@
 
 __version__ = '0.26'
 
-_clean_globals = globals()
+# .. we'll use this to pass it to the child script ..
+_clean_globals = globals().copy()
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -1,10 +1,10 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.26'
-
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
+__version__ = '0.26'
+
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
 import time, sys, os, pdb
","@@ -1,10 +1,10 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.26'
-
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
+__version__ = '0.26'
+
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
 import time, sys, os, pdb
",True,memory_profiler.py,True
"@@ -43,9 +43,12 @@ def _get_memory(pid):
 
     # .. fastests but just works for current process ..
     # .. and only available on unix ..
-    if pid == -1 and has_resource:
-        mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / (_TWO_20)
-        return mem
+    if pid == -1:
+        if has_resource:
+            mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / (_TWO_20)
+            return mem
+        else:
+            pid = os.getpid()
 
     # .. good compromise but requires psutil ..
     if has_psutil:
","@@ -43,9 +43,12 @@ def _get_memory(pid):
 
     # .. fastests but just works for current process ..
     # .. and only available on unix ..
-    if pid == -1 and has_resource:
-        mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / (_TWO_20)
-        return mem
+    if pid == -1:
+        if has_resource:
+            mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / (_TWO_20)
+            return mem
+        else:
+            pid = os.getpid()
 
     # .. good compromise but requires psutil ..
     if has_psutil:
",True,memory_profiler.py,True
"@@ -45,7 +45,7 @@ def _get_memory(pid):
     # .. and only available on unix ..
     if pid == -1:
         if has_resource:
-            mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / (_TWO_20)
+            mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / 1024.
             return mem
         else:
             pid = os.getpid()
","@@ -45,7 +45,7 @@ def _get_memory(pid):
     # .. and only available on unix ..
     if pid == -1:
         if has_resource:
-            mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / (_TWO_20)
+            mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / 1024.
             return mem
         else:
             pid = os.getpid()
",True,memory_profiler.py,True
"@@ -1,9 +1,10 @@
+PYTHON ?= python
 
 .PHONY: test
 
 test:
-	python -m memory_profiler test/test_func.py
-	python -m memory_profiler test/test_loop.py
-	python -m memory_profiler test/test_as.py
-	python -m memory_profiler test/test_global.py
-	python test/test_import.py
\ No newline at end of file
+	$(PYTHON) -m memory_profiler test/test_func.py
+	$(PYTHON) -m memory_profiler test/test_loop.py
+	$(PYTHON) -m memory_profiler test/test_as.py
+	$(PYTHON) -m memory_profiler test/test_global.py
+	$(PYTHON) test/test_import.py
\ No newline at end of file
","@@ -1,9 +1,10 @@
+PYTHON ?= python
 
 .PHONY: test
 
 test:
-	python -m memory_profiler test/test_func.py
-	python -m memory_profiler test/test_loop.py
-	python -m memory_profiler test/test_as.py
-	python -m memory_profiler test/test_global.py
-	python test/test_import.py
\ No newline at end of file
+	$(PYTHON) -m memory_profiler test/test_func.py
+	$(PYTHON) -m memory_profiler test/test_loop.py
+	$(PYTHON) -m memory_profiler test/test_as.py
+	$(PYTHON) -m memory_profiler test/test_global.py
+	$(PYTHON) test/test_import.py
\ No newline at end of file
",True,Makefile,False
"@@ -0,0 +1,7 @@
+Some information on the internals of this package.
+
+Tests
+-----
+`make test` is the closest thing to tests on this package. It executes some
+example code and prints the information. If you don't see any exceptions nor 
+any strange output then the tests suite ""has succeeded"".
","@@ -0,0 +1,7 @@
+Some information on the internals of this package.
+
+Tests
+-----
+`make test` is the closest thing to tests on this package. It executes some
+example code and prints the information. If you don't see any exceptions nor 
+any strange output then the tests suite ""has succeeded"".
",True,README_DEV.rst,False
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
-__version__ = '0.26'
+__version__ = '0.26-git'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
-__version__ = '0.26'
+__version__ = '0.26-git'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -41,8 +41,7 @@ except ImportError:
 
 def _get_memory(pid):
 
-    # .. fastests but just works for current process ..
-    # .. and only available on unix ..
+    # .. only for current process and only on unix..
     if pid == -1:
         if has_resource:
             mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / 1024.
@@ -50,7 +49,7 @@ def _get_memory(pid):
         else:
             pid = os.getpid()
 
-    # .. good compromise but requires psutil ..
+    # .. cross-platform but but requires psutil ..
     if has_psutil:
         process = psutil.Process(pid)
         try:
@@ -273,16 +272,6 @@ class LineProfiler:
             self.disable_by_count()
         return self
 
-    def runcall(self, func, *args, **kw):
-        """""" Profile a single function call.
-        """"""
-        # XXX where is this used ? can be removed ?
-        self.enable_by_count()
-        try:
-            return func(*args, **kw)
-        finally:
-            self.disable_by_count()
-
     def enable_by_count(self):
         """""" Enable the profiler if it hasn't been enabled before.
         """"""
","@@ -41,8 +41,7 @@ except ImportError:
 
 def _get_memory(pid):
 
-    # .. fastests but just works for current process ..
-    # .. and only available on unix ..
+    # .. only for current process and only on unix..
     if pid == -1:
         if has_resource:
             mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / 1024.
@@ -50,7 +49,7 @@ def _get_memory(pid):
         else:
             pid = os.getpid()
 
-    # .. good compromise but requires psutil ..
+    # .. cross-platform but but requires psutil ..
     if has_psutil:
         process = psutil.Process(pid)
         try:
@@ -273,16 +272,6 @@ class LineProfiler:
             self.disable_by_count()
         return self
 
-    def runcall(self, func, *args, **kw):
-        """""" Profile a single function call.
-        """"""
-        # XXX where is this used ? can be removed ?
-        self.enable_by_count()
-        try:
-            return func(*args, **kw)
-        finally:
-            self.disable_by_count()
-
     def enable_by_count(self):
         """""" Enable the profiler if it hasn't been enabled before.
         """"""
",True,memory_profiler.py,True
"@@ -20,6 +20,11 @@ try:
 except ImportError:
     from multiprocessing.dummy import Process, Pipe
 
+try:
+    xrange
+except NameError:
+    xrange = range
+
 _TWO_20 = float(2 ** 20)
 
 has_psutil = False
@@ -564,7 +569,7 @@ def magic_memit(self, line=''):
         timeout = None
 
     mem_usage = []
-    for _ in range(repeat):
+    for _ in xrange(repeat):
         tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout)
         mem_usage.extend(tmp)
 
","@@ -20,6 +20,11 @@ try:
 except ImportError:
     from multiprocessing.dummy import Process, Pipe
 
+try:
+    xrange
+except NameError:
+    xrange = range
+
 _TWO_20 = float(2 ** 20)
 
 has_psutil = False
@@ -564,7 +569,7 @@ def magic_memit(self, line=''):
         timeout = None
 
     mem_usage = []
-    for _ in range(repeat):
+    for _ in xrange(repeat):
         tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout)
         mem_usage.extend(tmp)
 
",True,memory_profiler.py,True
"@@ -20,11 +20,6 @@ try:
 except ImportError:
     from multiprocessing.dummy import Process, Pipe
 
-try:
-    xrange
-except NameError:
-    xrange = range
-
 _TWO_20 = float(2 ** 20)
 
 has_psutil = False
@@ -569,7 +564,9 @@ def magic_memit(self, line=''):
         timeout = None
 
     mem_usage = []
-    for _ in xrange(repeat):
+    counter = 0
+    while counter < repeat:
+        counter += 1
         tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout)
         mem_usage.extend(tmp)
 
","@@ -20,11 +20,6 @@ try:
 except ImportError:
     from multiprocessing.dummy import Process, Pipe
 
-try:
-    xrange
-except NameError:
-    xrange = range
-
 _TWO_20 = float(2 ** 20)
 
 has_psutil = False
@@ -569,7 +564,9 @@ def magic_memit(self, line=''):
         timeout = None
 
     mem_usage = []
-    for _ in xrange(repeat):
+    counter = 0
+    while counter < repeat:
+        counter += 1
         tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout)
         mem_usage.extend(tmp)
 
",True,memory_profiler.py,True
"@@ -231,7 +231,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
  Support, bugs & wish list
 ===========================
 For support, please ask your question on `stack overflow
-<http://stackoverflow.com/>`_ and add the *profiling* tag.
+<http://stackoverflow.com/>`_ and add the *memory-profiler* tag.
 Send issues, proposals, etc. to `github's issue tracker
 <https://github.com/fabianp/memory_profiler/issues>`_ .
 
","@@ -231,7 +231,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
  Support, bugs & wish list
 ===========================
 For support, please ask your question on `stack overflow
-<http://stackoverflow.com/>`_ and add the *profiling* tag.
+<http://stackoverflow.com/>`_ and add the *memory-profiler* tag.
 Send issues, proposals, etc. to `github's issue tracker
 <https://github.com/fabianp/memory_profiler/issues>`_ .
 
",True,README.rst,False
"@@ -231,7 +231,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
  Support, bugs & wish list
 ===========================
 For support, please ask your question on `stack overflow
-<http://stackoverflow.com/>`_ and add the *memory-profiler* tag.
+<http://stackoverflow.com/>`_ and add the *memory-profiling* tag.
 Send issues, proposals, etc. to `github's issue tracker
 <https://github.com/fabianp/memory_profiler/issues>`_ .
 
","@@ -231,7 +231,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
  Support, bugs & wish list
 ===========================
 For support, please ask your question on `stack overflow
-<http://stackoverflow.com/>`_ and add the *memory-profiler* tag.
+<http://stackoverflow.com/>`_ and add the *memory-profiling* tag.
 Send issues, proposals, etc. to `github's issue tracker
 <https://github.com/fabianp/memory_profiler/issues>`_ .
 
",True,README.rst,False
"@@ -221,10 +221,10 @@ class _TimeStamperCM(object):
         self._timestamps = timestamps
 
     def __enter__(self):
-        self._timestamps.append(time.time())
+        self._timestamps.append(_get_memory(os.getpid(), timestamps=True))
 
     def __exit__(self, *args):
-        self._timestamps.append(time.time())
+        self._timestamps.append(_get_memory(os.getpid(), timestamps=True))
 
 
 class TimeStamper:
@@ -268,13 +268,13 @@ class TimeStamper:
         """"""
         def f(*args, **kwds):
             # Start time
-            timestamps = [time.time()]
+            timestamps = [_get_memory(os.getpid(), timestamps=True)]
             self.functions[func].append(timestamps)
             try:
                 result = func(*args, **kwds)
             finally:
                 # end time
-                timestamps.append(time.time())
+                timestamps.append(_get_memory(os.getpid(), timestamps=True))
             return result
         return f
 
@@ -285,7 +285,9 @@ class TimeStamper:
         for func, timestamps in self.functions.iteritems():
             function_name = ""%s.%s"" % (func.__module__, func.__name__)
             for ts in timestamps:
-                stream.write(""%s %.4f %.4f\n"" % (function_name, ts[0], ts[1]))
+                stream.write(""%s %.4f %.4f %.4f %.4f\n"" % (
+                    (function_name,) + ts[0] + ts[1]))
+                ## stream.write(""%s %.4f %.4f\n"" % (function_name, ts[0], ts[1]))
 
 
 class LineProfiler:
","@@ -221,10 +221,10 @@ class _TimeStamperCM(object):
         self._timestamps = timestamps
 
     def __enter__(self):
-        self._timestamps.append(time.time())
+        self._timestamps.append(_get_memory(os.getpid(), timestamps=True))
 
     def __exit__(self, *args):
-        self._timestamps.append(time.time())
+        self._timestamps.append(_get_memory(os.getpid(), timestamps=True))
 
 
 class TimeStamper:
@@ -268,13 +268,13 @@ class TimeStamper:
         """"""
         def f(*args, **kwds):
             # Start time
-            timestamps = [time.time()]
+            timestamps = [_get_memory(os.getpid(), timestamps=True)]
             self.functions[func].append(timestamps)
             try:
                 result = func(*args, **kwds)
             finally:
                 # end time
-                timestamps.append(time.time())
+                timestamps.append(_get_memory(os.getpid(), timestamps=True))
             return result
         return f
 
@@ -285,7 +285,9 @@ class TimeStamper:
         for func, timestamps in self.functions.iteritems():
             function_name = ""%s.%s"" % (func.__module__, func.__name__)
             for ts in timestamps:
-                stream.write(""%s %.4f %.4f\n"" % (function_name, ts[0], ts[1]))
+                stream.write(""%s %.4f %.4f %.4f %.4f\n"" % (
+                    (function_name,) + ts[0] + ts[1]))
+                ## stream.write(""%s %.4f %.4f\n"" % (function_name, ts[0], ts[1]))
 
 
 class LineProfiler:
",True,memory_profiler.py,True
"@@ -13,30 +13,31 @@ import os
 import os.path as osp
 
 
-def add_bracket(xloc, t, mem, color=""r"", label=None):
+def add_bracket(xloc, yloc, xshift=0, color=""r"", label=None):
     """"""Add two brackets on the memory line plot.
 
     This function uses the current figure.
 
     Parameters
     ==========
-    xloc: {tuple with 2 values}
-        bracket location (on horizontal axis).
-    t, mem:
-        memory usage curve. Used to place bracket at the correct location.
+    xloc: tuple with 2 values
+        brackets location (on horizontal axis).
+    yloc: tuple with 2 values
+        brackets location (on vertical axis)
+    xshift: float
+        value to subtract to xloc.
     """"""
 
     height_ratio = 20.
-    yloc = pl.interp(xloc, t, mem)
     vsize = (pl.ylim()[1] - pl.ylim()[0]) / height_ratio
     hsize = (pl.xlim()[1] - pl.xlim()[0]) / (3.*height_ratio)
 
     bracket_x = pl.asarray([hsize, 0, 0, hsize])
     bracket_y = pl.asarray([vsize, vsize, -vsize, -vsize])
 
-    pl.plot(bracket_x + xloc[0], bracket_y + yloc[0],
+    pl.plot(bracket_x + xloc[0] - xshift, bracket_y + yloc[0],
             ""-"" + color, linewidth=2, label=label)
-    pl.plot(-bracket_x + xloc[1], bracket_y + yloc[1],
+    pl.plot(-bracket_x + xloc[1] - xshift, bracket_y + yloc[1],
             ""-"" + color, linewidth=2 )
 
     # TODO: use matplotlib.patches.Polygon to draw a colored background for
@@ -58,9 +59,9 @@ def read_timestamp_file(ts_filename):
     ret = {}
     f = open(ts_filename)
     for l in f:
-        f_name, start, end = l.split()
+        f_name, mem_start, start, mem_end, end = l.split()
         ts = ret.get(f_name, [])
-        ts.append([float(start), float(end)])
+        ts.append([float(start), float(end), float(mem_start), float(mem_end)])
         ret[f_name] = ts
     f.close()
     return ret
@@ -100,7 +101,7 @@ def plot_file(filename, index=0, timestamps=True):
         func_num = 0
         for f, exec_ts in ts.iteritems():
             for execution in exec_ts:
-                add_bracket([ts - global_start for ts in execution], t, mem,
+                add_bracket(execution[:2], execution[2:], xshift=global_start,
                             color= all_colors[func_num % len(all_colors)],
                             label=f.split(""."")[-1] + "" %.3fs"" % (execution[1] - execution[0]))
             func_num += 1
","@@ -13,30 +13,31 @@ import os
 import os.path as osp
 
 
-def add_bracket(xloc, t, mem, color=""r"", label=None):
+def add_bracket(xloc, yloc, xshift=0, color=""r"", label=None):
     """"""Add two brackets on the memory line plot.
 
     This function uses the current figure.
 
     Parameters
     ==========
-    xloc: {tuple with 2 values}
-        bracket location (on horizontal axis).
-    t, mem:
-        memory usage curve. Used to place bracket at the correct location.
+    xloc: tuple with 2 values
+        brackets location (on horizontal axis).
+    yloc: tuple with 2 values
+        brackets location (on vertical axis)
+    xshift: float
+        value to subtract to xloc.
     """"""
 
     height_ratio = 20.
-    yloc = pl.interp(xloc, t, mem)
     vsize = (pl.ylim()[1] - pl.ylim()[0]) / height_ratio
     hsize = (pl.xlim()[1] - pl.xlim()[0]) / (3.*height_ratio)
 
     bracket_x = pl.asarray([hsize, 0, 0, hsize])
     bracket_y = pl.asarray([vsize, vsize, -vsize, -vsize])
 
-    pl.plot(bracket_x + xloc[0], bracket_y + yloc[0],
+    pl.plot(bracket_x + xloc[0] - xshift, bracket_y + yloc[0],
             ""-"" + color, linewidth=2, label=label)
-    pl.plot(-bracket_x + xloc[1], bracket_y + yloc[1],
+    pl.plot(-bracket_x + xloc[1] - xshift, bracket_y + yloc[1],
             ""-"" + color, linewidth=2 )
 
     # TODO: use matplotlib.patches.Polygon to draw a colored background for
@@ -58,9 +59,9 @@ def read_timestamp_file(ts_filename):
     ret = {}
     f = open(ts_filename)
     for l in f:
-        f_name, start, end = l.split()
+        f_name, mem_start, start, mem_end, end = l.split()
         ts = ret.get(f_name, [])
-        ts.append([float(start), float(end)])
+        ts.append([float(start), float(end), float(mem_start), float(mem_end)])
         ret[f_name] = ts
     f.close()
     return ret
@@ -100,7 +101,7 @@ def plot_file(filename, index=0, timestamps=True):
         func_num = 0
         for f, exec_ts in ts.iteritems():
             for execution in exec_ts:
-                add_bracket([ts - global_start for ts in execution], t, mem,
+                add_bracket(execution[:2], execution[2:], xshift=global_start,
                             color= all_colors[func_num % len(all_colors)],
                             label=f.split(""."")[-1] + "" %.3fs"" % (execution[1] - execution[0]))
             func_num += 1
",True,mplot,False
"@@ -5,6 +5,7 @@ import os
 import os.path as osp
 import sys
 import re
+import copy
 
 from optparse import OptionParser
 
@@ -17,7 +18,7 @@ def print_usage():
 
 def get_action():
     """"""Pop first argument, check it is a valid action.""""""
-    all_actions = (""rm"",)
+    all_actions = (""rm"", ""clean"")
     if len(sys.argv) <= 1:
         print_usage()
         sys.exit(1)
@@ -48,31 +49,32 @@ def get_profile_filenames(args):
     profiles = glob.glob(""mprofile_??????????????.dat"")
     profiles.sort()
 
-    filenames = []
-
-    for arg in args:
-        if arg == ""--"":  # workaround
-            continue
-        try:
-            index = int(arg)
-        except ValueError:
-            index = None
-        if index is not None:
+    if args is ""all"":
+        filenames = copy.copy(profiles)
+    else:
+        for arg in args:
+            if arg == ""--"":  # workaround
+                continue
             try:
-                filename = profiles[index]
-            except IndexError:
-                raise ValueError(""Invalid index (non-existing file): %s"" % arg)
-
-            if filename not in filenames:
-                filenames.append(filename)
-        else:
-            if osp.isfile(arg):
-                if arg not in filenames:
-                    filenames.append(arg)
-            elif osp.isdir(arg):
-                raise ValueError(""Path %s is a directory"" % arg)
+                index = int(arg)
+            except ValueError:
+                index = None
+            if index is not None:
+                try:
+                    filename = profiles[index]
+                except IndexError:
+                    raise ValueError(""Invalid index (non-existing file): %s"" % arg)
+
+                if filename not in filenames:
+                    filenames.append(filename)
             else:
-                raise ValueError(""File %s not found"" % arg)
+                if osp.isfile(arg):
+                    if arg not in filenames:
+                        filenames.append(arg)
+                elif osp.isdir(arg):
+                    raise ValueError(""Path %s is a directory"" % arg)
+                else:
+                    raise ValueError(""File %s not found"" % arg)
 
     # Add timestamp files, if any
     for filename in reversed(filenames):
@@ -107,6 +109,30 @@ def rm_action():
             os.remove(filename)
 
 
+def clean_action():
+    """"""Remove every profile file in current directory.""""""
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
+                      action=""store_true"",
+                      help=""""""Show what will be done, without actually doing it."""""")
+
+    (options, args) = parser.parse_args()
+
+    if len(args) > 0:
+        print(""This command takes no argument."")
+        sys.exit(1)
+
+    filenames = get_profile_filenames(""all"")
+    if options.dry_run:
+        print(""Files to be removed: "")
+        for filename in filenames:
+            print(filename)
+    else:
+        for filename in filenames:
+            os.remove(filename)
+
+
 if __name__ == ""__main__"":
     # Workaround for optparse limitation: insert -- before first negative number found.
     negint = re.compile(""-[0-9]+"")
@@ -114,7 +140,7 @@ if __name__ == ""__main__"":
         if negint.match(arg):
             sys.argv.insert(n, ""--"")
             break
-    actions = {""rm"": rm_action}
+    actions = {""rm"": rm_action, ""clean"": clean_action}
     actions[get_action()]()
 
 
","@@ -5,6 +5,7 @@ import os
 import os.path as osp
 import sys
 import re
+import copy
 
 from optparse import OptionParser
 
@@ -17,7 +18,7 @@ def print_usage():
 
 def get_action():
     """"""Pop first argument, check it is a valid action.""""""
-    all_actions = (""rm"",)
+    all_actions = (""rm"", ""clean"")
     if len(sys.argv) <= 1:
         print_usage()
         sys.exit(1)
@@ -48,31 +49,32 @@ def get_profile_filenames(args):
     profiles = glob.glob(""mprofile_??????????????.dat"")
     profiles.sort()
 
-    filenames = []
-
-    for arg in args:
-        if arg == ""--"":  # workaround
-            continue
-        try:
-            index = int(arg)
-        except ValueError:
-            index = None
-        if index is not None:
+    if args is ""all"":
+        filenames = copy.copy(profiles)
+    else:
+        for arg in args:
+            if arg == ""--"":  # workaround
+                continue
             try:
-                filename = profiles[index]
-            except IndexError:
-                raise ValueError(""Invalid index (non-existing file): %s"" % arg)
+                index = int(arg)
+            except ValueError:
+                index = None
+            if index is not None:
+                try:
+                    filename = profiles[index]
+                except IndexError:
+                    raise ValueError(""Invalid index (non-existing file): %s"" % arg)
 
-            if filename not in filenames:
-                filenames.append(filename)
-        else:
-            if osp.isfile(arg):
-                if arg not in filenames:
-                    filenames.append(arg)
-            elif osp.isdir(arg):
-                raise ValueError(""Path %s is a directory"" % arg)
+                if filename not in filenames:
+                    filenames.append(filename)
             else:
-                raise ValueError(""File %s not found"" % arg)
+                if osp.isfile(arg):
+                    if arg not in filenames:
+                        filenames.append(arg)
+                elif osp.isdir(arg):
+                    raise ValueError(""Path %s is a directory"" % arg)
+                else:
+                    raise ValueError(""File %s not found"" % arg)
 
     # Add timestamp files, if any
     for filename in reversed(filenames):
@@ -107,6 +109,30 @@ def rm_action():
             os.remove(filename)
 
 
+def clean_action():
+    """"""Remove every profile file in current directory.""""""
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
+                      action=""store_true"",
+                      help=""""""Show what will be done, without actually doing it."""""")
+
+    (options, args) = parser.parse_args()
+
+    if len(args) > 0:
+        print(""This command takes no argument."")
+        sys.exit(1)
+
+    filenames = get_profile_filenames(""all"")
+    if options.dry_run:
+        print(""Files to be removed: "")
+        for filename in filenames:
+            print(filename)
+    else:
+        for filename in filenames:
+            os.remove(filename)
+
+
 if __name__ == ""__main__"":
     # Workaround for optparse limitation: insert -- before first negative number found.
     negint = re.compile(""-[0-9]+"")
@@ -114,7 +140,7 @@ if __name__ == ""__main__"":
         if negint.match(arg):
             sys.argv.insert(n, ""--"")
             break
-    actions = {""rm"": rm_action}
+    actions = {""rm"": rm_action, ""clean"": clean_action}
     actions[get_action()]()
 
 
",False,maction,False
"@@ -59,7 +59,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
             mem = process.get_memory_info()[0] / (_TWO_20)
             if include_children:
                 for p in process.get_children(recursive=True):
-                    mem += p.get_memory_info()[0] / (_TWO_20).
+                    mem += p.get_memory_info()[0] / (_TWO_20)
         except psutil.AccessDenied:
             mem = -1
         if timestamps:
","@@ -59,7 +59,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
             mem = process.get_memory_info()[0] / (_TWO_20)
             if include_children:
                 for p in process.get_children(recursive=True):
-                    mem += p.get_memory_info()[0] / (_TWO_20).
+                    mem += p.get_memory_info()[0] / (_TWO_20)
         except psutil.AccessDenied:
             mem = -1
         if timestamps:
",True,memory_profiler.py,True
"@@ -248,6 +248,11 @@ Latest sources are available from github:
 
     https://github.com/fabianp/memory_profiler
 
+===============================
+Projects using memory_profiler
+===============================
+
+`Benchy <https://github.com/python-recsys/benchy>`_
 
 =========
  Authors
","@@ -248,6 +248,11 @@ Latest sources are available from github:
 
     https://github.com/fabianp/memory_profiler
 
+===============================
+Projects using memory_profiler
+===============================
+
+`Benchy <https://github.com/python-recsys/benchy>`_
 
 =========
  Authors
",True,README.rst,False
"@@ -616,10 +616,18 @@ if __name__ == '__main__':
     __file__ = _find_script(args[0])
     try:
         if sys.version_info[0] < 3:
+            # we need to ovewrite the builtins to have profile
+            # globally defined (global variables is not enought
+            # for all cases, e.g. a script that imports another
+            # script where @profile is used)
+            import __builtin__
+            __builtin__.__dict__['profile'] = prof
             ns = copy(_clean_globals)
             ns['profile'] = prof # shadow the profile decorator defined above
             execfile(__file__, ns, ns)
         else:
+            import builtins
+            builtins.__dict__['profile'] = prof
             ns = copy(_clean_globals)
             ns['profile'] = prof # shadow the profile decorator defined above
             exec(compile(open(__file__).read(), __file__, 'exec'), ns, ns)
","@@ -616,10 +616,18 @@ if __name__ == '__main__':
     __file__ = _find_script(args[0])
     try:
         if sys.version_info[0] < 3:
+            # we need to ovewrite the builtins to have profile
+            # globally defined (global variables is not enought
+            # for all cases, e.g. a script that imports another
+            # script where @profile is used)
+            import __builtin__
+            __builtin__.__dict__['profile'] = prof
             ns = copy(_clean_globals)
             ns['profile'] = prof # shadow the profile decorator defined above
             execfile(__file__, ns, ns)
         else:
+            import builtins
+            builtins.__dict__['profile'] = prof
             ns = copy(_clean_globals)
             ns['profile'] = prof # shadow the profile decorator defined above
             exec(compile(open(__file__).read(), __file__, 'exec'), ns, ns)
",True,memory_profiler.py,True
"@@ -312,9 +312,8 @@ class TimeStamper:
         for func, timestamps in self.functions.iteritems():
             function_name = ""%s.%s"" % (func.__module__, func.__name__)
             for ts in timestamps:
-                stream.write(""%s %.4f %.4f %.4f %.4f\n"" % (
+                stream.write(""FUNC %s %.4f %.4f %.4f %.4f\n"" % (
                     (function_name,) + ts[0] + ts[1]))
-                ## stream.write(""%s %.4f %.4f\n"" % (function_name, ts[0], ts[1]))
 
 
 class LineProfiler:
@@ -751,7 +750,7 @@ if __name__ == '__main__':
             exec(compile(open(__file__).read(), __file__, 'exec'), ns, ns)
     finally:
         if options.out_filename is not None:
-            out_file = open(options.out_filename, ""w"")
+            out_file = open(options.out_filename, ""a"")
         else:
             out_file = sys.stdout
 
","@@ -312,9 +312,8 @@ class TimeStamper:
         for func, timestamps in self.functions.iteritems():
             function_name = ""%s.%s"" % (func.__module__, func.__name__)
             for ts in timestamps:
-                stream.write(""%s %.4f %.4f %.4f %.4f\n"" % (
+                stream.write(""FUNC %s %.4f %.4f %.4f %.4f\n"" % (
                     (function_name,) + ts[0] + ts[1]))
-                ## stream.write(""%s %.4f %.4f\n"" % (function_name, ts[0], ts[1]))
 
 
 class LineProfiler:
@@ -751,7 +750,7 @@ if __name__ == '__main__':
             exec(compile(open(__file__).read(), __file__, 'exec'), ns, ns)
     finally:
         if options.out_filename is not None:
-            out_file = open(options.out_filename, ""w"")
+            out_file = open(options.out_filename, ""a"")
         else:
             out_file = sys.stdout
 
",True,memory_profiler.py,True
"@@ -6,6 +6,8 @@ try:
 except ImportError:
     print(""matplotlib is needed for plotting."")
     sys.exit(1)
+
+import numpy as np
 import math
 import glob
 import time
@@ -13,7 +15,7 @@ import os
 import os.path as osp
 
 
-def add_bracket(xloc, yloc, xshift=0, color=""r"", label=None):
+def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
     """"""Add two brackets on the memory line plot.
 
     This function uses the current figure.
@@ -50,38 +52,42 @@ def add_bracket(xloc, yloc, xshift=0, color=""r"", label=None):
     ## pl.plot(xloc[1], yloc[1], "">""+color, markersize=7)
 
 
-def read_timestamp_file(ts_filename):
-    """"""Return content of ts_filename or None, if ts_filename
-    is invalid or does not exist""""""
-    if not osp.isfile(ts_filename):
-        return None
-
+def read_mprofile_file(filename):
     ret = {}
-    f = open(ts_filename)
+    mdata = []
+    f = open(filename, ""r"")
     for l in f:
-        f_name, mem_start, start, mem_end, end = l.split()
-        ts = ret.get(f_name, [])
-        ts.append([float(start), float(end), float(mem_start), float(mem_end)])
-        ret[f_name] = ts
+        fields = l.split()
+        if fields[0] == ""MEM"":
+            # mem, timestamp
+            mdata.append((fields[1], fields[2]))
+
+        elif fields[0] == ""FUNC"":
+            f_name, mem_start, start, mem_end, end = fields[1:]
+            ts = ret.get(f_name, [])
+            ts.append([float(start), float(end), float(mem_start), float(mem_end)])
+            ret[f_name] = ts
+
+        else:
+            pass
     f.close()
-    return ret
 
+    mdata = np.asarray(mdata,
+                       dtype=[(""mem"", np.float), (""timestamp"", np.float)])
+    return mdata, ret
 
-def plot_file(filename, index=0, timestamps=True):
-    # Check for a timestamp file
-    file_parts = osp.splitext(filename)
-    ts_filename = file_parts[0] + ""_ts"" + file_parts[1]
-    ts = read_timestamp_file(ts_filename)
 
-    mdata = pl.atleast_2d(pl.loadtxt(filename))
 
-    global_start = float(mdata[0, 1])
+def plot_file(filename, index=0, timestamps=True):
+    mdata, ts = read_mprofile_file(filename)
+
+    global_start = float(mdata[""timestamp""][0])
 
-    mem = mdata[:, 0]
+    mem = mdata[""mem""]
     max_mem = mem.max()
     max_mem_ind = mem.argmax()
 
-    t = mdata[:, 1] - global_start
+    t = mdata[""timestamp""] - global_start
 
     all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
     mem_line_colors=('k', ""b"", ""r"")
@@ -97,13 +103,14 @@ def plot_file(filename, index=0, timestamps=True):
     top -= 0.001
 
     # plot timestamps, if any
-    if ts is not None and timestamps:
+    if len(ts) > 0 and timestamps:
         func_num = 0
         for f, exec_ts in ts.iteritems():
             for execution in exec_ts:
-                add_bracket(execution[:2], execution[2:], xshift=global_start,
-                            color= all_colors[func_num % len(all_colors)],
-                            label=f.split(""."")[-1] + "" %.3fs"" % (execution[1] - execution[0]))
+                add_brackets(execution[:2], execution[2:], xshift=global_start,
+                             color= all_colors[func_num % len(all_colors)],
+                             label=f.split(""."")[-1]
+                             + "" %.3fs"" % (execution[1] - execution[0]))
             func_num += 1
 
     if timestamps:
@@ -120,8 +127,8 @@ if __name__ == ""__main__"":
 
     if len(sys.argv) == 1:
         if len(profiles) == 0:
-            print(""""""No input file found. This program looks for mprofile_*.dat files,
-    generated by the mprofile command."""""")
+            print(""No input file found. \nThis program looks for ""
+                  ""mprofile_*.dat files, generated by the mprofile command."")
             sys.exit(-1)
         filenames = [profiles[-1]]
     else:
@@ -138,7 +145,7 @@ if __name__ == ""__main__"":
                 if not profiles[n] in filenames:
                     filenames.append(profiles[n])
 
-    pl.figure(figsize=(14,6), dpi=90)
+    pl.figure(figsize=(14, 6), dpi=90)
     if len(filenames) > 1:
         timestamps = False
     else:
","@@ -6,6 +6,8 @@ try:
 except ImportError:
     print(""matplotlib is needed for plotting."")
     sys.exit(1)
+
+import numpy as np
 import math
 import glob
 import time
@@ -13,7 +15,7 @@ import os
 import os.path as osp
 
 
-def add_bracket(xloc, yloc, xshift=0, color=""r"", label=None):
+def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
     """"""Add two brackets on the memory line plot.
 
     This function uses the current figure.
@@ -50,38 +52,42 @@ def add_bracket(xloc, yloc, xshift=0, color=""r"", label=None):
     ## pl.plot(xloc[1], yloc[1], "">""+color, markersize=7)
 
 
-def read_timestamp_file(ts_filename):
-    """"""Return content of ts_filename or None, if ts_filename
-    is invalid or does not exist""""""
-    if not osp.isfile(ts_filename):
-        return None
-
+def read_mprofile_file(filename):
     ret = {}
-    f = open(ts_filename)
+    mdata = []
+    f = open(filename, ""r"")
     for l in f:
-        f_name, mem_start, start, mem_end, end = l.split()
-        ts = ret.get(f_name, [])
-        ts.append([float(start), float(end), float(mem_start), float(mem_end)])
-        ret[f_name] = ts
+        fields = l.split()
+        if fields[0] == ""MEM"":
+            # mem, timestamp
+            mdata.append((fields[1], fields[2]))
+
+        elif fields[0] == ""FUNC"":
+            f_name, mem_start, start, mem_end, end = fields[1:]
+            ts = ret.get(f_name, [])
+            ts.append([float(start), float(end), float(mem_start), float(mem_end)])
+            ret[f_name] = ts
+
+        else:
+            pass
     f.close()
-    return ret
+
+    mdata = np.asarray(mdata,
+                       dtype=[(""mem"", np.float), (""timestamp"", np.float)])
+    return mdata, ret
+
 
 
 def plot_file(filename, index=0, timestamps=True):
-    # Check for a timestamp file
-    file_parts = osp.splitext(filename)
-    ts_filename = file_parts[0] + ""_ts"" + file_parts[1]
-    ts = read_timestamp_file(ts_filename)
+    mdata, ts = read_mprofile_file(filename)
 
-    mdata = pl.atleast_2d(pl.loadtxt(filename))
+    global_start = float(mdata[""timestamp""][0])
 
-    global_start = float(mdata[0, 1])
-
-    mem = mdata[:, 0]
+    mem = mdata[""mem""]
     max_mem = mem.max()
     max_mem_ind = mem.argmax()
 
-    t = mdata[:, 1] - global_start
+    t = mdata[""timestamp""] - global_start
 
     all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
     mem_line_colors=('k', ""b"", ""r"")
@@ -97,13 +103,14 @@ def plot_file(filename, index=0, timestamps=True):
     top -= 0.001
 
     # plot timestamps, if any
-    if ts is not None and timestamps:
+    if len(ts) > 0 and timestamps:
         func_num = 0
         for f, exec_ts in ts.iteritems():
             for execution in exec_ts:
-                add_bracket(execution[:2], execution[2:], xshift=global_start,
-                            color= all_colors[func_num % len(all_colors)],
-                            label=f.split(""."")[-1] + "" %.3fs"" % (execution[1] - execution[0]))
+                add_brackets(execution[:2], execution[2:], xshift=global_start,
+                             color= all_colors[func_num % len(all_colors)],
+                             label=f.split(""."")[-1]
+                             + "" %.3fs"" % (execution[1] - execution[0]))
             func_num += 1
 
     if timestamps:
@@ -120,8 +127,8 @@ if __name__ == ""__main__"":
 
     if len(sys.argv) == 1:
         if len(profiles) == 0:
-            print(""""""No input file found. This program looks for mprofile_*.dat files,
-    generated by the mprofile command."""""")
+            print(""No input file found. \nThis program looks for ""
+                  ""mprofile_*.dat files, generated by the mprofile command."")
             sys.exit(-1)
         filenames = [profiles[-1]]
     else:
@@ -138,7 +145,7 @@ if __name__ == ""__main__"":
                 if not profiles[n] in filenames:
                     filenames.append(profiles[n])
 
-    pl.figure(figsize=(14,6), dpi=90)
+    pl.figure(figsize=(14, 6), dpi=90)
     if len(filenames) > 1:
         timestamps = False
     else:
",False,mplot,False
"@@ -44,17 +44,17 @@ mprofile_output = ""mprofile_%s.dat"" % suffix
 
 if options.python:
     print(""running as a Python program..."")
-    timestamp_output = ""mprofile_%s_ts.dat"" % suffix
+#    timestamp_output = ""mprofile_%s_ts.dat"" % suffix
     if not args[0].startswith(""python""):
         args.insert(0, ""python"")
     args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
-                 ""-o"", timestamp_output)
+                 ""-o"", mprofile_output)
     p = subprocess.Popen(args)
 else:
     p = subprocess.Popen(args)
 
 mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
                      include_children=options.include_children)
-with open(mprofile_output, ""w"") as f:
+with open(mprofile_output, ""a"") as f:
     for m, t in mu:
-        f.write(""{0:.6f} {1:.4f}"".format(m, t) + ""\n"")
+        f.write(""MEM {0:.6f} {1:.4f}"".format(m, t) + ""\n"")
","@@ -44,17 +44,17 @@ mprofile_output = ""mprofile_%s.dat"" % suffix
 
 if options.python:
     print(""running as a Python program..."")
-    timestamp_output = ""mprofile_%s_ts.dat"" % suffix
+#    timestamp_output = ""mprofile_%s_ts.dat"" % suffix
     if not args[0].startswith(""python""):
         args.insert(0, ""python"")
     args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
-                 ""-o"", timestamp_output)
+                 ""-o"", mprofile_output)
     p = subprocess.Popen(args)
 else:
     p = subprocess.Popen(args)
 
 mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
                      include_children=options.include_children)
-with open(mprofile_output, ""w"") as f:
+with open(mprofile_output, ""a"") as f:
     for m, t in mu:
-        f.write(""{0:.6f} {1:.4f}"".format(m, t) + ""\n"")
+        f.write(""MEM {0:.6f} {1:.4f}"".format(m, t) + ""\n"")
",True,mprofile,False
"@@ -18,7 +18,7 @@ def print_usage():
 
 def get_action():
     """"""Pop first argument, check it is a valid action.""""""
-    all_actions = (""rm"", ""clean"")
+    all_actions = (""rm"", ""clean"", ""list"")
     if len(sys.argv) <= 1:
         print_usage()
         sys.exit(1)
@@ -52,6 +52,7 @@ def get_profile_filenames(args):
     if args is ""all"":
         filenames = copy.copy(profiles)
     else:
+        filenames = []
         for arg in args:
             if arg == ""--"":  # workaround
                 continue
@@ -86,6 +87,26 @@ def get_profile_filenames(args):
     return filenames
 
 
+def list_action():
+    """"""Display existing profiles, with indices.""""""
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+
+    (options, args) = parser.parse_args()
+
+    if len(args) > 0:
+        print(""This command takes no argument."")
+        sys.exit(1)
+
+    filenames = get_profile_filenames(""all"")
+    for n, filename in enumerate(filenames):
+        ts = osp.splitext(filename)[0].split('_')[-1]
+        print(""{index} {filename} {hour}:{min}:{sec} {day}/{month}/{year}""
+              .format(index=n, filename=filename,
+                      year=ts[:4], month=ts[4:6], day=ts[6:8],
+                      hour=ts[8:10], min=ts[10:12], sec=ts[12:14]))
+
+
 def rm_action():
     parser = OptionParser(version=mp.__version__)
     parser.disable_interspersed_args()
@@ -140,7 +161,9 @@ if __name__ == ""__main__"":
         if negint.match(arg):
             sys.argv.insert(n, ""--"")
             break
-    actions = {""rm"": rm_action, ""clean"": clean_action}
+    actions = {""rm"": rm_action,
+               ""clean"": clean_action,
+               ""list"": list_action}
     actions[get_action()]()
 
 
","@@ -18,7 +18,7 @@ def print_usage():
 
 def get_action():
     """"""Pop first argument, check it is a valid action.""""""
-    all_actions = (""rm"", ""clean"")
+    all_actions = (""rm"", ""clean"", ""list"")
     if len(sys.argv) <= 1:
         print_usage()
         sys.exit(1)
@@ -52,6 +52,7 @@ def get_profile_filenames(args):
     if args is ""all"":
         filenames = copy.copy(profiles)
     else:
+        filenames = []
         for arg in args:
             if arg == ""--"":  # workaround
                 continue
@@ -86,6 +87,26 @@ def get_profile_filenames(args):
     return filenames
 
 
+def list_action():
+    """"""Display existing profiles, with indices.""""""
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+
+    (options, args) = parser.parse_args()
+
+    if len(args) > 0:
+        print(""This command takes no argument."")
+        sys.exit(1)
+
+    filenames = get_profile_filenames(""all"")
+    for n, filename in enumerate(filenames):
+        ts = osp.splitext(filename)[0].split('_')[-1]
+        print(""{index} {filename} {hour}:{min}:{sec} {day}/{month}/{year}""
+              .format(index=n, filename=filename,
+                      year=ts[:4], month=ts[4:6], day=ts[6:8],
+                      hour=ts[8:10], min=ts[10:12], sec=ts[12:14]))
+
+
 def rm_action():
     parser = OptionParser(version=mp.__version__)
     parser.disable_interspersed_args()
@@ -140,7 +161,9 @@ if __name__ == ""__main__"":
         if negint.match(arg):
             sys.argv.insert(n, ""--"")
             break
-    actions = {""rm"": rm_action, ""clean"": clean_action}
+    actions = {""rm"": rm_action,
+               ""clean"": clean_action,
+               ""list"": list_action}
     actions[get_action()]()
 
 
",True,maction,False
"@@ -37,6 +37,9 @@ def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
     bracket_x = pl.asarray([hsize, 0, 0, hsize])
     bracket_y = pl.asarray([vsize, vsize, -vsize, -vsize])
 
+    # Matplotlib workaround: labels starting with _ aren't displayed
+    if label[0] == '_':
+        label = ' ' + label
     pl.plot(bracket_x + xloc[0] - xshift, bracket_y + yloc[0],
             ""-"" + color, linewidth=2, label=label)
     pl.plot(-bracket_x + xloc[1] - xshift, bracket_y + yloc[1],
","@@ -37,6 +37,9 @@ def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
     bracket_x = pl.asarray([hsize, 0, 0, hsize])
     bracket_y = pl.asarray([vsize, vsize, -vsize, -vsize])
 
+    # Matplotlib workaround: labels starting with _ aren't displayed
+    if label[0] == '_':
+        label = ' ' + label
     pl.plot(bracket_x + xloc[0] - xshift, bracket_y + yloc[0],
             ""-"" + color, linewidth=2, label=label)
     pl.plot(-bracket_x + xloc[1] - xshift, bracket_y + yloc[1],
",True,mplot,False
"@@ -610,7 +610,7 @@ if __name__ == '__main__':
         sys.exit(2)
 
     (options, args) = parser.parse_args()
-    del sys.argv[0]         # Hide ""memory_profiler.py"" from argument list
+    sys.argv[:] = args  # Remove every memory_profiler arguments
 
     prof = LineProfiler(max_mem=options.max_mem)
     __file__ = _find_script(args[0])
","@@ -610,7 +610,7 @@ if __name__ == '__main__':
         sys.exit(2)
 
     (options, args) = parser.parse_args()
-    del sys.argv[0]         # Hide ""memory_profiler.py"" from argument list
+    sys.argv[:] = args  # Remove every memory_profiler arguments
 
     prof = LineProfiler(max_mem=options.max_mem)
     __file__ = _find_script(args[0])
",True,memory_profiler.py,True
"@@ -271,6 +271,8 @@ cleanup.
 
 `Thomas Kluyver <https://github.com/takluyver>`_ added the IPython extension.
 
+Philippe Gervais made several enhacements and bug fixes.
+
 
 
 =========
","@@ -271,6 +271,8 @@ cleanup.
 
 `Thomas Kluyver <https://github.com/takluyver>`_ added the IPython extension.
 
+Philippe Gervais made several enhacements and bug fixes.
+
 
 
 =========
",True,README.rst,False
"@@ -83,24 +83,31 @@ class Timer(Process):
     Fetch memory consumption from over a time interval
     """"""
 
-    def __init__(self, monitor_pid, interval, pipe, *args, **kw):
+    def __init__(self, monitor_pid, interval, pipe, max_usage=False, *args, **kw):
         self.monitor_pid = monitor_pid
         self.interval = interval
         self.pipe = pipe
         self.cont = True
+        self.max_usage = max_usage
         super(Timer, self).__init__(*args, **kw)
 
     def run(self):
         m = _get_memory(self.monitor_pid)
-        timings = [m]
+        if not self.max_usage:
+            timings = [m]
+        else:
+            timings = m 
         self.pipe.send(0)  # we're ready
         while not self.pipe.poll(self.interval):
             m = _get_memory(self.monitor_pid)
-            timings.append(m)
+            if not self.max_usage:
+                timings.append(m)
+            else:
+                timings = max([m,timings])
         self.pipe.send(timings)
 
 
-def memory_usage(proc=-1, interval=.1, timeout=None):
+def memory_usage(proc=-1, interval=.1, timeout=None, max_usage=False, retval=False):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -119,13 +126,25 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
 
     timeout : float, optional
         Maximum amount of time (in seconds) to wait before returning.
+        
+    max_usage: bool, optional
+        Only return the maximum memory usage (default False)
+        
+    retval: bool, optional
+        For profiling python functions. Save the return value of the profiled
+        function. Return value of memory_usage becomes a tuple:
+        (mem_usage, retval)
 
     Returns
     -------
     mem_usage : list of floating-poing values
         memory usage, in MB. It's length is always < timeout / interval
     """"""
-    ret = []
+    
+    if not max_usage:
+        ret = []
+    else:
+        ret = -1
 
     if timeout is not None:
         max_iter = int(timeout / interval)
@@ -158,17 +177,22 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
             % (n_args, len(args)))
 
         child_conn, parent_conn = Pipe()  # this will store Timer's results
-        p = Timer(-1, interval, child_conn)
+        p = Timer(-1, interval, child_conn,max_usage)
         p.start()
         parent_conn.recv()  # wait until we start getting memory
-        f(*args, **kw)
+        returned = f(*args, **kw)
         parent_conn.send(0)  # finish timing
         ret = parent_conn.recv()
+        if retval:
+            ret = ret,returned
         p.join(5 * interval)
     elif isinstance(proc, subprocess.Popen):
         # external process, launched from Python
         while True:
-            ret.append(_get_memory(proc.pid))
+            if not max_usage:
+                ret.append(_get_memory(proc.pid))
+            else:
+                ret = max([ret,_get_memory(proc.pid)])
             time.sleep(interval)
             if timeout is not None:
                 max_iter -= 1
@@ -183,7 +207,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
         counter = 0
         while counter < max_iter:
             counter += 1
-            ret.append(_get_memory(proc))
+            if not max_usage:
+                ret.append(_get_memory(proc.pid))
+            else:
+                ret = max([ret,_get_memory(proc.pid)])
             time.sleep(interval)
     return ret
 
","@@ -83,24 +83,31 @@ class Timer(Process):
     Fetch memory consumption from over a time interval
     """"""
 
-    def __init__(self, monitor_pid, interval, pipe, *args, **kw):
+    def __init__(self, monitor_pid, interval, pipe, max_usage=False, *args, **kw):
         self.monitor_pid = monitor_pid
         self.interval = interval
         self.pipe = pipe
         self.cont = True
+        self.max_usage = max_usage
         super(Timer, self).__init__(*args, **kw)
 
     def run(self):
         m = _get_memory(self.monitor_pid)
-        timings = [m]
+        if not self.max_usage:
+            timings = [m]
+        else:
+            timings = m 
         self.pipe.send(0)  # we're ready
         while not self.pipe.poll(self.interval):
             m = _get_memory(self.monitor_pid)
-            timings.append(m)
+            if not self.max_usage:
+                timings.append(m)
+            else:
+                timings = max([m,timings])
         self.pipe.send(timings)
 
 
-def memory_usage(proc=-1, interval=.1, timeout=None):
+def memory_usage(proc=-1, interval=.1, timeout=None, max_usage=False, retval=False):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -119,13 +126,25 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
 
     timeout : float, optional
         Maximum amount of time (in seconds) to wait before returning.
+        
+    max_usage: bool, optional
+        Only return the maximum memory usage (default False)
+        
+    retval: bool, optional
+        For profiling python functions. Save the return value of the profiled
+        function. Return value of memory_usage becomes a tuple:
+        (mem_usage, retval)
 
     Returns
     -------
     mem_usage : list of floating-poing values
         memory usage, in MB. It's length is always < timeout / interval
     """"""
-    ret = []
+    
+    if not max_usage:
+        ret = []
+    else:
+        ret = -1
 
     if timeout is not None:
         max_iter = int(timeout / interval)
@@ -158,17 +177,22 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
             % (n_args, len(args)))
 
         child_conn, parent_conn = Pipe()  # this will store Timer's results
-        p = Timer(-1, interval, child_conn)
+        p = Timer(-1, interval, child_conn,max_usage)
         p.start()
         parent_conn.recv()  # wait until we start getting memory
-        f(*args, **kw)
+        returned = f(*args, **kw)
         parent_conn.send(0)  # finish timing
         ret = parent_conn.recv()
+        if retval:
+            ret = ret,returned
         p.join(5 * interval)
     elif isinstance(proc, subprocess.Popen):
         # external process, launched from Python
         while True:
-            ret.append(_get_memory(proc.pid))
+            if not max_usage:
+                ret.append(_get_memory(proc.pid))
+            else:
+                ret = max([ret,_get_memory(proc.pid)])
             time.sleep(interval)
             if timeout is not None:
                 max_iter -= 1
@@ -183,7 +207,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
         counter = 0
         while counter < max_iter:
             counter += 1
-            ret.append(_get_memory(proc))
+            if not max_usage:
+                ret.append(_get_memory(proc.pid))
+            else:
+                ret = max([ret,_get_memory(proc.pid)])
             time.sleep(interval)
     return ret
 
",True,memory_profiler.py,True
"@@ -139,6 +139,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, max_usage=False, retval=Fal
     -------
     mem_usage : list of floating-poing values
         memory usage, in MB. It's length is always < timeout / interval
+    ret : return value of the profiled function
+        Only returned if retval is set to True
     """"""
     
     if not max_usage:
@@ -177,7 +179,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, max_usage=False, retval=Fal
             % (n_args, len(args)))
 
         child_conn, parent_conn = Pipe()  # this will store Timer's results
-        p = Timer(-1, interval, child_conn,max_usage)
+        p = Timer(os.getpid(), interval, child_conn,max_usage)
         p.start()
         parent_conn.recv()  # wait until we start getting memory
         returned = f(*args, **kw)
@@ -208,9 +210,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, max_usage=False, retval=Fal
         while counter < max_iter:
             counter += 1
             if not max_usage:
-                ret.append(_get_memory(proc.pid))
+                ret.append(_get_memory(proc))
             else:
-                ret = max([ret,_get_memory(proc.pid)])
+                ret = max([ret,_get_memory(proc)])
             time.sleep(interval)
     return ret
 
","@@ -139,6 +139,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, max_usage=False, retval=Fal
     -------
     mem_usage : list of floating-poing values
         memory usage, in MB. It's length is always < timeout / interval
+    ret : return value of the profiled function
+        Only returned if retval is set to True
     """"""
     
     if not max_usage:
@@ -177,7 +179,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, max_usage=False, retval=Fal
             % (n_args, len(args)))
 
         child_conn, parent_conn = Pipe()  # this will store Timer's results
-        p = Timer(-1, interval, child_conn,max_usage)
+        p = Timer(os.getpid(), interval, child_conn,max_usage)
         p.start()
         parent_conn.recv()  # wait until we start getting memory
         returned = f(*args, **kw)
@@ -208,9 +210,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, max_usage=False, retval=Fal
         while counter < max_iter:
             counter += 1
             if not max_usage:
-                ret.append(_get_memory(proc.pid))
+                ret.append(_get_memory(proc))
             else:
-                ret = max([ret,_get_memory(proc.pid)])
+                ret = max([ret,_get_memory(proc)])
             time.sleep(interval)
     return ret
 
",True,memory_profiler.py,True
"@@ -38,13 +38,18 @@ try:
 except ImportError:
     pass
 
+# divide resource.getrusage() by rusage_denom to get MB
+rusage_denom = 1024.
+if sys.platform == 'darwin':
+    # ... it seems that in OSX the output is different units ...
+    rusage_denom = rusage_denom * rusage_denom
 
 def _get_memory(pid):
 
     # .. only for current process and only on unix..
     if pid == -1:
         if has_resource:
-            mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / 1024.
+            mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / rusage_denom
             return mem
         else:
             pid = os.getpid()
","@@ -38,13 +38,18 @@ try:
 except ImportError:
     pass
 
+# divide resource.getrusage() by rusage_denom to get MB
+rusage_denom = 1024.
+if sys.platform == 'darwin':
+    # ... it seems that in OSX the output is different units ...
+    rusage_denom = rusage_denom * rusage_denom
 
 def _get_memory(pid):
 
     # .. only for current process and only on unix..
     if pid == -1:
         if has_resource:
-            mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / 1024.
+            mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / rusage_denom
             return mem
         else:
             pid = os.getpid()
",True,memory_profiler.py,True
"@@ -2,6 +2,13 @@
 
 @profile
 def test_1():
+    a = {}
+    for i in range(10000):
+        a[i] =  i + 1
+    return
+
+@profile
+def test_2():
     a = [1] * (10 ** 6)
     b = [2] * (2 * 10 ** 7)
     del b
@@ -12,13 +19,6 @@ def test_1():
         del b
     return a
 
-@profile
-def test_2():
-    a = {}
-    for i in range(10000):
-        a[i] =  i + 1
-    return
-
 if __name__ == '__main__':
     test_1()
     test_2()
","@@ -2,6 +2,13 @@
 
 @profile
 def test_1():
+    a = {}
+    for i in range(10000):
+        a[i] =  i + 1
+    return
+
+@profile
+def test_2():
     a = [1] * (10 ** 6)
     b = [2] * (2 * 10 ** 7)
     del b
@@ -12,13 +19,6 @@ def test_1():
         del b
     return a
 
-@profile
-def test_2():
-    a = {}
-    for i in range(10000):
-        a[i] =  i + 1
-    return
-
 if __name__ == '__main__':
     test_1()
     test_2()
",True,test/test_loop.py,True
"@@ -48,7 +48,9 @@ def _get_memory(pid):
 
     # .. only for current process and only on unix..
     if pid == -1:
-        if has_resource:
+        # .. seems to get wrong measurements on some cases, see ..
+        # .. https://github.com/fabianp/memory_profiler/issues/52 ..
+        if False: #has_resource:
             mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / rusage_denom
             return mem
         else:
","@@ -48,7 +48,9 @@ def _get_memory(pid):
 
     # .. only for current process and only on unix..
     if pid == -1:
-        if has_resource:
+        # .. seems to get wrong measurements on some cases, see ..
+        # .. https://github.com/fabianp/memory_profiler/issues/52 ..
+        if False: #has_resource:
             mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / rusage_denom
             return mem
         else:
",True,memory_profiler.py,True
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
-__version__ = '0.26-git'
+__version__ = '0.27'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
-__version__ = '0.26-git'
+__version__ = '0.27'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -29,7 +29,7 @@ The line-by-line profiler is used much in the same way of the
 `line_profiler <https://pypi.python.org/pypi/line_profiler/>`_: first
 decorate the function you would like to profile with ``@profile`` and
 then run the script with a special script (in this case with specific
-arguments to the Python interpreter). 
+arguments to the Python interpreter).
 
 In the following example, we create a simple function ``my_func`` that
 allocates lists ``a``, ``b`` and then deletes ``b``::
@@ -163,7 +163,7 @@ After installing the module, if you use IPython, you can use the `%mprun`
 and `%memit` magics.
 
 For IPython 0.11+, you can use the module directly as an extension, with
-``%load_ext memory_profiler``.
+``%load_ext memory_profiler``
 
 To activate it whenever you start IPython, edit the configuration file for your
 IPython profile, ~/.ipython/profile_default/ipython_config.py, to register the
","@@ -29,7 +29,7 @@ The line-by-line profiler is used much in the same way of the
 `line_profiler <https://pypi.python.org/pypi/line_profiler/>`_: first
 decorate the function you would like to profile with ``@profile`` and
 then run the script with a special script (in this case with specific
-arguments to the Python interpreter). 
+arguments to the Python interpreter).
 
 In the following example, we create a simple function ``my_func`` that
 allocates lists ``a``, ``b`` and then deletes ``b``::
@@ -163,7 +163,7 @@ After installing the module, if you use IPython, you can use the `%mprun`
 and `%memit` magics.
 
 For IPython 0.11+, you can use the module directly as an extension, with
-``%load_ext memory_profiler``.
+``%load_ext memory_profiler``
 
 To activate it whenever you start IPython, edit the configuration file for your
 IPython profile, ~/.ipython/profile_default/ipython_config.py, to register the
",True,README.rst,False
"@@ -103,7 +103,7 @@ class Timer(Process):
         if not self.max_usage:
             timings = [m]
         else:
-            timings = m 
+            timings = m
         self.pipe.send(0)  # we're ready
         while not self.pipe.poll(self.interval):
             m = _get_memory(self.monitor_pid)
@@ -133,10 +133,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, max_usage=False, retval=Fal
 
     timeout : float, optional
         Maximum amount of time (in seconds) to wait before returning.
-        
+
     max_usage: bool, optional
         Only return the maximum memory usage (default False)
-        
+
     retval: bool, optional
         For profiling python functions. Save the return value of the profiled
         function. Return value of memory_usage becomes a tuple:
@@ -149,7 +149,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, max_usage=False, retval=Fal
     ret : return value of the profiled function
         Only returned if retval is set to True
     """"""
-    
+
     if not max_usage:
         ret = []
     else:
@@ -567,7 +567,7 @@ def magic_memit(self, line=''):
     """"""Measure memory usage of a Python statement
 
     Usage, in line mode:
-      %memit [-r<R>t<T>] statement
+      %memit [-r<R>t<T>i<I>] statement
 
     Options:
     -r<R>: repeat the loop iteration <R> times and take the best result.
@@ -575,6 +575,9 @@ def magic_memit(self, line=''):
 
     -t<T>: timeout after <T> seconds. Default: None
 
+    -i<I>: Get time information at an interval of I times per second.
+        Defaults to 0.1 so that there is ten measurements per second.
+
     Examples
     --------
     ::
@@ -591,19 +594,21 @@ def magic_memit(self, line=''):
       maximum of 10: 0.101562 MB per loop
 
     """"""
-    opts, stmt = self.parse_options(line, 'r:t', posix=False, strict=False)
+    opts, stmt = self.parse_options(line, 'r:t:i:', posix=False, strict=False)
     repeat = int(getattr(opts, 'r', 1))
     if repeat < 1:
         repeat == 1
     timeout = int(getattr(opts, 't', 0))
     if timeout <= 0:
         timeout = None
+    interval = float(getattr(opts, 'i', 0.1))
 
     mem_usage = []
     counter = 0
     while counter < repeat:
         counter += 1
-        tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout)
+        tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
+                           timeout=timeout, interval=interval)
         mem_usage.extend(tmp)
 
     if mem_usage:
","@@ -103,7 +103,7 @@ class Timer(Process):
         if not self.max_usage:
             timings = [m]
         else:
-            timings = m 
+            timings = m
         self.pipe.send(0)  # we're ready
         while not self.pipe.poll(self.interval):
             m = _get_memory(self.monitor_pid)
@@ -133,10 +133,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, max_usage=False, retval=Fal
 
     timeout : float, optional
         Maximum amount of time (in seconds) to wait before returning.
-        
+
     max_usage: bool, optional
         Only return the maximum memory usage (default False)
-        
+
     retval: bool, optional
         For profiling python functions. Save the return value of the profiled
         function. Return value of memory_usage becomes a tuple:
@@ -149,7 +149,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, max_usage=False, retval=Fal
     ret : return value of the profiled function
         Only returned if retval is set to True
     """"""
-    
+
     if not max_usage:
         ret = []
     else:
@@ -567,7 +567,7 @@ def magic_memit(self, line=''):
     """"""Measure memory usage of a Python statement
 
     Usage, in line mode:
-      %memit [-r<R>t<T>] statement
+      %memit [-r<R>t<T>i<I>] statement
 
     Options:
     -r<R>: repeat the loop iteration <R> times and take the best result.
@@ -575,6 +575,9 @@ def magic_memit(self, line=''):
 
     -t<T>: timeout after <T> seconds. Default: None
 
+    -i<I>: Get time information at an interval of I times per second.
+        Defaults to 0.1 so that there is ten measurements per second.
+
     Examples
     --------
     ::
@@ -591,19 +594,21 @@ def magic_memit(self, line=''):
       maximum of 10: 0.101562 MB per loop
 
     """"""
-    opts, stmt = self.parse_options(line, 'r:t', posix=False, strict=False)
+    opts, stmt = self.parse_options(line, 'r:t:i:', posix=False, strict=False)
     repeat = int(getattr(opts, 'r', 1))
     if repeat < 1:
         repeat == 1
     timeout = int(getattr(opts, 't', 0))
     if timeout <= 0:
         timeout = None
+    interval = float(getattr(opts, 'i', 0.1))
 
     mem_usage = []
     counter = 0
     while counter < repeat:
         counter += 1
-        tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout)
+        tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
+                           timeout=timeout, interval=interval)
         mem_usage.extend(tmp)
 
     if mem_usage:
",True,memory_profiler.py,True
"@@ -108,6 +108,7 @@ def list_action():
 
 
 def rm_action():
+    """"""TODO: merge with clean_action (@pgervais)""""""
     parser = OptionParser(version=mp.__version__)
     parser.disable_interspersed_args()
     parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
","@@ -108,6 +108,7 @@ def list_action():
 
 
 def rm_action():
+    """"""TODO: merge with clean_action (@pgervais)""""""
     parser = OptionParser(version=mp.__version__)
     parser.disable_interspersed_args()
     parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
",True,maction,False
"@@ -27,10 +27,6 @@ if len(args) == 0:
     print(""A program to run must be provided. Use -h for help"")
     sys.exit(1)
 
-## if len(sys.argv) < 2:
-##     print(""""""Memory usage monitoring
-## Usage: %s <command> <argument> ... <argument>
-
 ## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
 ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
 ## directory. This file contains the process memory consumption, in Mb (one
@@ -44,7 +40,6 @@ mprofile_output = ""mprofile_%s.dat"" % suffix
 
 if options.python:
     print(""running as a Python program..."")
-#    timestamp_output = ""mprofile_%s_ts.dat"" % suffix
     if not args[0].startswith(""python""):
         args.insert(0, ""python"")
     args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
","@@ -27,10 +27,6 @@ if len(args) == 0:
     print(""A program to run must be provided. Use -h for help"")
     sys.exit(1)
 
-## if len(sys.argv) < 2:
-##     print(""""""Memory usage monitoring
-## Usage: %s <command> <argument> ... <argument>
-
 ## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
 ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
 ## directory. This file contains the process memory consumption, in Mb (one
@@ -44,7 +40,6 @@ mprofile_output = ""mprofile_%s.dat"" % suffix
 
 if options.python:
     print(""running as a Python program..."")
-#    timestamp_output = ""mprofile_%s_ts.dat"" % suffix
     if not args[0].startswith(""python""):
         args.insert(0, ""python"")
     args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
",True,mprof,False
"@@ -28,7 +28,7 @@ setup(
     author_email='fabian@fseoane.net',
     url='http://pypi.python.org/pypi/memory_profiler',
     py_modules=['memory_profiler'],
-    scripts=[""mprofile"", ""mplot""],
+    scripts=['mprof'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='Simplified BSD'
 
","@@ -28,7 +28,7 @@ setup(
     author_email='fabian@fseoane.net',
     url='http://pypi.python.org/pypi/memory_profiler',
     py_modules=['memory_profiler'],
-    scripts=[""mprofile"", ""mplot""],
+    scripts=['mprof'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='Simplified BSD'
 
",True,setup.py,True
"@@ -74,7 +74,6 @@ the code that has been profiled.
 
 Decorator
 =========
-
 A function decorator is also available.  Use as follows::
 
     from memory_profiler import profile
@@ -86,6 +85,16 @@ A function decorator is also available.  Use as follows::
         del b
         return a
 
+In this case the script can be run without specifying ``-m
+memory_profiler`` in the command line.
+
+Executing external scripts
+==========================
+Sometimes it is useful to have full memory usage reports as a function of
+time (not line-by-line) of external processess (be it Python scripts or not).
+In this case the executable ``mprof`` might be useful. To use it
+
+
 Setting debugger breakpoints
 =============================
 It is possible to set breakpoints depending on the amount of memory used.
","@@ -74,7 +74,6 @@ the code that has been profiled.
 
 Decorator
 =========
-
 A function decorator is also available.  Use as follows::
 
     from memory_profiler import profile
@@ -86,6 +85,16 @@ A function decorator is also available.  Use as follows::
         del b
         return a
 
+In this case the script can be run without specifying ``-m
+memory_profiler`` in the command line.
+
+Executing external scripts
+==========================
+Sometimes it is useful to have full memory usage reports as a function of
+time (not line-by-line) of external processess (be it Python scripts or not).
+In this case the executable ``mprof`` might be useful. To use it
+
+
 Setting debugger breakpoints
 =============================
 It is possible to set breakpoints depending on the amount of memory used.
",True,README.rst,False
"@@ -1,170 +0,0 @@
-#! /usr/bin/env python
-
-import glob
-import os
-import os.path as osp
-import sys
-import re
-import copy
-
-from optparse import OptionParser
-
-import memory_profiler as mp
-
-
-def print_usage():
-    print(""Usage: %s <command> <options> <arguments>""
-          % osp.basename(sys.argv[0]))
-
-def get_action():
-    """"""Pop first argument, check it is a valid action.""""""
-    all_actions = (""rm"", ""clean"", ""list"")
-    if len(sys.argv) <= 1:
-        print_usage()
-        sys.exit(1)
-    if not sys.argv[1] in all_actions:
-        print(""Valid actions are: "" + "" "".join(all_actions))
-        sys.exit(1)
-
-    return sys.argv.pop(1)
-
-
-def get_profile_filenames(args):
-    """"""Return list of profile filenames.
-
-    Parameters
-    ==========
-    args (list)
-        list of filename or integer. An integer is the index of the
-        profile in the list of existing profiles. 0 is the oldest,
-        -1 in the more recent.
-        Non-existing files cause a ValueError exception to be thrown.
-
-    Returns
-    =======
-    filenames (list)
-        list of existing memory profile filenames. It is guaranteed
-        that an given file name will not appear twice in this list.
-    """"""
-    profiles = glob.glob(""mprofile_??????????????.dat"")
-    profiles.sort()
-
-    if args is ""all"":
-        filenames = copy.copy(profiles)
-    else:
-        filenames = []
-        for arg in args:
-            if arg == ""--"":  # workaround
-                continue
-            try:
-                index = int(arg)
-            except ValueError:
-                index = None
-            if index is not None:
-                try:
-                    filename = profiles[index]
-                except IndexError:
-                    raise ValueError(""Invalid index (non-existing file): %s"" % arg)
-
-                if filename not in filenames:
-                    filenames.append(filename)
-            else:
-                if osp.isfile(arg):
-                    if arg not in filenames:
-                        filenames.append(arg)
-                elif osp.isdir(arg):
-                    raise ValueError(""Path %s is a directory"" % arg)
-                else:
-                    raise ValueError(""File %s not found"" % arg)
-
-    # Add timestamp files, if any
-    for filename in reversed(filenames):
-        parts = osp.splitext(filename)
-        timestamp_file = parts[0] + ""_ts"" + parts[1]
-        if osp.isfile(timestamp_file) and timestamp_file not in filenames:
-            filenames.append(timestamp_file)
-
-    return filenames
-
-
-def list_action():
-    """"""Display existing profiles, with indices.""""""
-    parser = OptionParser(version=mp.__version__)
-    parser.disable_interspersed_args()
-
-    (options, args) = parser.parse_args()
-
-    if len(args) > 0:
-        print(""This command takes no argument."")
-        sys.exit(1)
-
-    filenames = get_profile_filenames(""all"")
-    for n, filename in enumerate(filenames):
-        ts = osp.splitext(filename)[0].split('_')[-1]
-        print(""{index} {filename} {hour}:{min}:{sec} {day}/{month}/{year}""
-              .format(index=n, filename=filename,
-                      year=ts[:4], month=ts[4:6], day=ts[6:8],
-                      hour=ts[8:10], min=ts[10:12], sec=ts[12:14]))
-
-
-def rm_action():
-    """"""TODO: merge with clean_action (@pgervais)""""""
-    parser = OptionParser(version=mp.__version__)
-    parser.disable_interspersed_args()
-    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
-                      action=""store_true"",
-                      help=""""""Show what will be done, without actually doing it."""""")
-
-    (options, args) = parser.parse_args()
-
-    if len(args) == 0:
-        print(""A profile to remove must be provided (number or filename)"")
-        sys.exit(1)
-
-    filenames = get_profile_filenames(args)
-    if options.dry_run:
-        print(""Files to be removed: "")
-        for filename in filenames:
-            print(filename)
-    else:
-        for filename in filenames:
-            os.remove(filename)
-
-
-def clean_action():
-    """"""Remove every profile file in current directory.""""""
-    parser = OptionParser(version=mp.__version__)
-    parser.disable_interspersed_args()
-    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
-                      action=""store_true"",
-                      help=""""""Show what will be done, without actually doing it."""""")
-
-    (options, args) = parser.parse_args()
-
-    if len(args) > 0:
-        print(""This command takes no argument."")
-        sys.exit(1)
-
-    filenames = get_profile_filenames(""all"")
-    if options.dry_run:
-        print(""Files to be removed: "")
-        for filename in filenames:
-            print(filename)
-    else:
-        for filename in filenames:
-            os.remove(filename)
-
-
-if __name__ == ""__main__"":
-    # Workaround for optparse limitation: insert -- before first negative number found.
-    negint = re.compile(""-[0-9]+"")
-    for n, arg in enumerate(sys.argv):
-        if negint.match(arg):
-            sys.argv.insert(n, ""--"")
-            break
-    actions = {""rm"": rm_action,
-               ""clean"": clean_action,
-               ""list"": list_action}
-    actions[get_action()]()
-
-
","@@ -1,170 +0,0 @@
-#! /usr/bin/env python
-
-import glob
-import os
-import os.path as osp
-import sys
-import re
-import copy
-
-from optparse import OptionParser
-
-import memory_profiler as mp
-
-
-def print_usage():
-    print(""Usage: %s <command> <options> <arguments>""
-          % osp.basename(sys.argv[0]))
-
-def get_action():
-    """"""Pop first argument, check it is a valid action.""""""
-    all_actions = (""rm"", ""clean"", ""list"")
-    if len(sys.argv) <= 1:
-        print_usage()
-        sys.exit(1)
-    if not sys.argv[1] in all_actions:
-        print(""Valid actions are: "" + "" "".join(all_actions))
-        sys.exit(1)
-
-    return sys.argv.pop(1)
-
-
-def get_profile_filenames(args):
-    """"""Return list of profile filenames.
-
-    Parameters
-    ==========
-    args (list)
-        list of filename or integer. An integer is the index of the
-        profile in the list of existing profiles. 0 is the oldest,
-        -1 in the more recent.
-        Non-existing files cause a ValueError exception to be thrown.
-
-    Returns
-    =======
-    filenames (list)
-        list of existing memory profile filenames. It is guaranteed
-        that an given file name will not appear twice in this list.
-    """"""
-    profiles = glob.glob(""mprofile_??????????????.dat"")
-    profiles.sort()
-
-    if args is ""all"":
-        filenames = copy.copy(profiles)
-    else:
-        filenames = []
-        for arg in args:
-            if arg == ""--"":  # workaround
-                continue
-            try:
-                index = int(arg)
-            except ValueError:
-                index = None
-            if index is not None:
-                try:
-                    filename = profiles[index]
-                except IndexError:
-                    raise ValueError(""Invalid index (non-existing file): %s"" % arg)
-
-                if filename not in filenames:
-                    filenames.append(filename)
-            else:
-                if osp.isfile(arg):
-                    if arg not in filenames:
-                        filenames.append(arg)
-                elif osp.isdir(arg):
-                    raise ValueError(""Path %s is a directory"" % arg)
-                else:
-                    raise ValueError(""File %s not found"" % arg)
-
-    # Add timestamp files, if any
-    for filename in reversed(filenames):
-        parts = osp.splitext(filename)
-        timestamp_file = parts[0] + ""_ts"" + parts[1]
-        if osp.isfile(timestamp_file) and timestamp_file not in filenames:
-            filenames.append(timestamp_file)
-
-    return filenames
-
-
-def list_action():
-    """"""Display existing profiles, with indices.""""""
-    parser = OptionParser(version=mp.__version__)
-    parser.disable_interspersed_args()
-
-    (options, args) = parser.parse_args()
-
-    if len(args) > 0:
-        print(""This command takes no argument."")
-        sys.exit(1)
-
-    filenames = get_profile_filenames(""all"")
-    for n, filename in enumerate(filenames):
-        ts = osp.splitext(filename)[0].split('_')[-1]
-        print(""{index} {filename} {hour}:{min}:{sec} {day}/{month}/{year}""
-              .format(index=n, filename=filename,
-                      year=ts[:4], month=ts[4:6], day=ts[6:8],
-                      hour=ts[8:10], min=ts[10:12], sec=ts[12:14]))
-
-
-def rm_action():
-    """"""TODO: merge with clean_action (@pgervais)""""""
-    parser = OptionParser(version=mp.__version__)
-    parser.disable_interspersed_args()
-    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
-                      action=""store_true"",
-                      help=""""""Show what will be done, without actually doing it."""""")
-
-    (options, args) = parser.parse_args()
-
-    if len(args) == 0:
-        print(""A profile to remove must be provided (number or filename)"")
-        sys.exit(1)
-
-    filenames = get_profile_filenames(args)
-    if options.dry_run:
-        print(""Files to be removed: "")
-        for filename in filenames:
-            print(filename)
-    else:
-        for filename in filenames:
-            os.remove(filename)
-
-
-def clean_action():
-    """"""Remove every profile file in current directory.""""""
-    parser = OptionParser(version=mp.__version__)
-    parser.disable_interspersed_args()
-    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
-                      action=""store_true"",
-                      help=""""""Show what will be done, without actually doing it."""""")
-
-    (options, args) = parser.parse_args()
-
-    if len(args) > 0:
-        print(""This command takes no argument."")
-        sys.exit(1)
-
-    filenames = get_profile_filenames(""all"")
-    if options.dry_run:
-        print(""Files to be removed: "")
-        for filename in filenames:
-            print(filename)
-    else:
-        for filename in filenames:
-            os.remove(filename)
-
-
-if __name__ == ""__main__"":
-    # Workaround for optparse limitation: insert -- before first negative number found.
-    negint = re.compile(""-[0-9]+"")
-    for n, arg in enumerate(sys.argv):
-        if negint.match(arg):
-            sys.argv.insert(n, ""--"")
-            break
-    actions = {""rm"": rm_action,
-               ""clean"": clean_action,
-               ""list"": list_action}
-    actions[get_action()]()
-
-
",True,,False
"@@ -1,55 +1,221 @@
 #! /usr/bin/env python
-import subprocess
-import memory_profiler as mp
+
+import glob
+import os
 import os.path as osp
-import time
 import sys
+import re
+import copy
 
 from optparse import OptionParser
 
-parser = OptionParser(version=mp.__version__)
-parser.disable_interspersed_args()
-parser.add_option(""--python"", dest=""python"", default=False,
-                  action=""store_true"",
-                  help=""""""Activates extra features when the profiled executable is
-                  a Python program (currently: function timestamping.)"""""")
-parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.5"",
-                  type=""float"", action=""store"",
-                  help=""Sampling period (in seconds)"")
-parser.add_option(""--include-children"", ""-C"", dest=""include_children"", default=False,
-                  action=""store_true"",
-                  help=""""""Monitors forked processes as well (sum up all process memory)"""""")
-
-(options, args) = parser.parse_args()
-print(""{1}: Sampling memory every {0.interval}s"".format(options, osp.basename(sys.argv[0])))
-
-if len(args) == 0:
-    print(""A program to run must be provided. Use -h for help"")
-    sys.exit(1)
-
-## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
-## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
-## directory. This file contains the process memory consumption, in Mb (one
-## value per line). Memory is sampled twice each second.""""""
-##           % osp.basename(sys.argv[0])
-##           )
-##     sys.exit(1)
-
-suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
-mprofile_output = ""mprofile_%s.dat"" % suffix
-
-if options.python:
-    print(""running as a Python program..."")
-    if not args[0].startswith(""python""):
-        args.insert(0, ""python"")
-    args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
-                 ""-o"", mprofile_output)
-    p = subprocess.Popen(args)
-else:
-    p = subprocess.Popen(args)
-
-mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
-                     include_children=options.include_children)
-with open(mprofile_output, ""a"") as f:
-    for m, t in mu:
-        f.write(""MEM {0:.6f} {1:.4f}"".format(m, t) + ""\n"")
+import memory_profiler as mp
+
+
+def print_usage():
+    print(""Usage: %s <command> <options> <arguments>""
+          % osp.basename(sys.argv[0]))
+
+def get_action():
+    """"""Pop first argument, check it is a valid action.""""""
+    all_actions = (""run"", ""rm"", ""clean"", ""list"")
+    if len(sys.argv) <= 1:
+        print_usage()
+        sys.exit(1)
+    if not sys.argv[1] in all_actions:
+        print(""Valid actions are: "" + "" "".join(all_actions))
+        sys.exit(1)
+
+    return sys.argv.pop(1)
+
+
+def get_profile_filenames(args):
+    """"""Return list of profile filenames.
+
+    Parameters
+    ==========
+    args (list)
+        list of filename or integer. An integer is the index of the
+        profile in the list of existing profiles. 0 is the oldest,
+        -1 in the more recent.
+        Non-existing files cause a ValueError exception to be thrown.
+
+    Returns
+    =======
+    filenames (list)
+        list of existing memory profile filenames. It is guaranteed
+        that an given file name will not appear twice in this list.
+    """"""
+    profiles = glob.glob(""mprofile_??????????????.dat"")
+    profiles.sort()
+
+    if args is ""all"":
+        filenames = copy.copy(profiles)
+    else:
+        filenames = []
+        for arg in args:
+            if arg == ""--"":  # workaround
+                continue
+            try:
+                index = int(arg)
+            except ValueError:
+                index = None
+            if index is not None:
+                try:
+                    filename = profiles[index]
+                except IndexError:
+                    raise ValueError(""Invalid index (non-existing file): %s"" % arg)
+
+                if filename not in filenames:
+                    filenames.append(filename)
+            else:
+                if osp.isfile(arg):
+                    if arg not in filenames:
+                        filenames.append(arg)
+                elif osp.isdir(arg):
+                    raise ValueError(""Path %s is a directory"" % arg)
+                else:
+                    raise ValueError(""File %s not found"" % arg)
+
+    # Add timestamp files, if any
+    for filename in reversed(filenames):
+        parts = osp.splitext(filename)
+        timestamp_file = parts[0] + ""_ts"" + parts[1]
+        if osp.isfile(timestamp_file) and timestamp_file not in filenames:
+            filenames.append(timestamp_file)
+
+    return filenames
+
+
+def list_action():
+    """"""Display existing profiles, with indices.""""""
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+
+    (options, args) = parser.parse_args()
+
+    if len(args) > 0:
+        print(""This command takes no argument."")
+        sys.exit(1)
+
+    filenames = get_profile_filenames(""all"")
+    for n, filename in enumerate(filenames):
+        ts = osp.splitext(filename)[0].split('_')[-1]
+        print(""{index} {filename} {hour}:{min}:{sec} {day}/{month}/{year}""
+              .format(index=n, filename=filename,
+                      year=ts[:4], month=ts[4:6], day=ts[6:8],
+                      hour=ts[8:10], min=ts[10:12], sec=ts[12:14]))
+
+
+def rm_action():
+    """"""TODO: merge with clean_action (@pgervais)""""""
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
+                      action=""store_true"",
+                      help=""""""Show what will be done, without actually doing it."""""")
+
+    (options, args) = parser.parse_args()
+
+    if len(args) == 0:
+        print(""A profile to remove must be provided (number or filename)"")
+        sys.exit(1)
+
+    filenames = get_profile_filenames(args)
+    if options.dry_run:
+        print(""Files to be removed: "")
+        for filename in filenames:
+            print(filename)
+    else:
+        for filename in filenames:
+            os.remove(filename)
+
+
+def clean_action():
+    """"""Remove every profile file in current directory.""""""
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
+                      action=""store_true"",
+                      help=""""""Show what will be done, without actually doing it."""""")
+
+    (options, args) = parser.parse_args()
+
+    if len(args) > 0:
+        print(""This command takes no argument."")
+        sys.exit(1)
+
+    filenames = get_profile_filenames(""all"")
+    if options.dry_run:
+        print(""Files to be removed: "")
+        for filename in filenames:
+            print(filename)
+    else:
+        for filename in filenames:
+            os.remove(filename)
+
+
+
+def run_action():
+    import time, subprocess
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+    parser.add_option(""--python"", dest=""python"", default=False,
+                      action=""store_true"",
+                      help=""""""Activates extra features when the profiled executable is
+                      a Python program (currently: function timestamping.)"""""")
+    parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.5"",
+                      type=""float"", action=""store"",
+                      help=""Sampling period (in seconds)"")
+    parser.add_option(""--include-children"", ""-C"", dest=""include_children"", default=False,
+                      action=""store_true"",
+                      help=""""""Monitors forked processes as well (sum up all process memory)"""""")
+
+    (options, args) = parser.parse_args()
+    print(""{1}: Sampling memory every {0.interval}s"".format(options, osp.basename(sys.argv[0])))
+
+    if len(args) == 0:
+        print(""A program to run must be provided. Use -h for help"")
+        sys.exit(1)
+
+    ## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
+    ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
+    ## directory. This file contains the process memory consumption, in Mb (one
+    ## value per line). Memory is sampled twice each second.""""""
+    ##           % osp.basename(sys.argv[0])
+    ##           )
+    ##     sys.exit(1)
+
+    suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
+    mprofile_output = ""mprofile_%s.dat"" % suffix
+
+    if options.python:
+        print(""running as a Python program..."")
+        if not args[0].startswith(""python""):
+            args.insert(0, ""python"")
+        args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
+                     ""-o"", mprofile_output)
+        p = subprocess.Popen(args)
+    else:
+        p = subprocess.Popen(args)
+
+    mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
+                         include_children=options.include_children)
+    with open(mprofile_output, ""a"") as f:
+        for m, t in mu:
+            f.write(""MEM {0:.6f} {1:.4f}"".format(m, t) + ""\n"")
+
+if __name__ == ""__main__"":
+    # Workaround for optparse limitation: insert -- before first negative number found.
+    negint = re.compile(""-[0-9]+"")
+    for n, arg in enumerate(sys.argv):
+        if negint.match(arg):
+            sys.argv.insert(n, ""--"")
+            break
+    actions = {""rm"": rm_action,
+               ""clean"": clean_action,
+               ""list"": list_action,
+               ""run"" : run_action}
+    actions[get_action()]()
+
+
","@@ -1,55 +1,221 @@
 #! /usr/bin/env python
-import subprocess
-import memory_profiler as mp
+
+import glob
+import os
 import os.path as osp
-import time
 import sys
+import re
+import copy
 
 from optparse import OptionParser
 
-parser = OptionParser(version=mp.__version__)
-parser.disable_interspersed_args()
-parser.add_option(""--python"", dest=""python"", default=False,
-                  action=""store_true"",
-                  help=""""""Activates extra features when the profiled executable is
-                  a Python program (currently: function timestamping.)"""""")
-parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.5"",
-                  type=""float"", action=""store"",
-                  help=""Sampling period (in seconds)"")
-parser.add_option(""--include-children"", ""-C"", dest=""include_children"", default=False,
-                  action=""store_true"",
-                  help=""""""Monitors forked processes as well (sum up all process memory)"""""")
+import memory_profiler as mp
 
-(options, args) = parser.parse_args()
-print(""{1}: Sampling memory every {0.interval}s"".format(options, osp.basename(sys.argv[0])))
 
-if len(args) == 0:
-    print(""A program to run must be provided. Use -h for help"")
-    sys.exit(1)
+def print_usage():
+    print(""Usage: %s <command> <options> <arguments>""
+          % osp.basename(sys.argv[0]))
 
-## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
-## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
-## directory. This file contains the process memory consumption, in Mb (one
-## value per line). Memory is sampled twice each second.""""""
-##           % osp.basename(sys.argv[0])
-##           )
-##     sys.exit(1)
+def get_action():
+    """"""Pop first argument, check it is a valid action.""""""
+    all_actions = (""run"", ""rm"", ""clean"", ""list"")
+    if len(sys.argv) <= 1:
+        print_usage()
+        sys.exit(1)
+    if not sys.argv[1] in all_actions:
+        print(""Valid actions are: "" + "" "".join(all_actions))
+        sys.exit(1)
 
-suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
-mprofile_output = ""mprofile_%s.dat"" % suffix
+    return sys.argv.pop(1)
+
+
+def get_profile_filenames(args):
+    """"""Return list of profile filenames.
+
+    Parameters
+    ==========
+    args (list)
+        list of filename or integer. An integer is the index of the
+        profile in the list of existing profiles. 0 is the oldest,
+        -1 in the more recent.
+        Non-existing files cause a ValueError exception to be thrown.
+
+    Returns
+    =======
+    filenames (list)
+        list of existing memory profile filenames. It is guaranteed
+        that an given file name will not appear twice in this list.
+    """"""
+    profiles = glob.glob(""mprofile_??????????????.dat"")
+    profiles.sort()
+
+    if args is ""all"":
+        filenames = copy.copy(profiles)
+    else:
+        filenames = []
+        for arg in args:
+            if arg == ""--"":  # workaround
+                continue
+            try:
+                index = int(arg)
+            except ValueError:
+                index = None
+            if index is not None:
+                try:
+                    filename = profiles[index]
+                except IndexError:
+                    raise ValueError(""Invalid index (non-existing file): %s"" % arg)
+
+                if filename not in filenames:
+                    filenames.append(filename)
+            else:
+                if osp.isfile(arg):
+                    if arg not in filenames:
+                        filenames.append(arg)
+                elif osp.isdir(arg):
+                    raise ValueError(""Path %s is a directory"" % arg)
+                else:
+                    raise ValueError(""File %s not found"" % arg)
+
+    # Add timestamp files, if any
+    for filename in reversed(filenames):
+        parts = osp.splitext(filename)
+        timestamp_file = parts[0] + ""_ts"" + parts[1]
+        if osp.isfile(timestamp_file) and timestamp_file not in filenames:
+            filenames.append(timestamp_file)
+
+    return filenames
+
+
+def list_action():
+    """"""Display existing profiles, with indices.""""""
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+
+    (options, args) = parser.parse_args()
+
+    if len(args) > 0:
+        print(""This command takes no argument."")
+        sys.exit(1)
+
+    filenames = get_profile_filenames(""all"")
+    for n, filename in enumerate(filenames):
+        ts = osp.splitext(filename)[0].split('_')[-1]
+        print(""{index} {filename} {hour}:{min}:{sec} {day}/{month}/{year}""
+              .format(index=n, filename=filename,
+                      year=ts[:4], month=ts[4:6], day=ts[6:8],
+                      hour=ts[8:10], min=ts[10:12], sec=ts[12:14]))
+
+
+def rm_action():
+    """"""TODO: merge with clean_action (@pgervais)""""""
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
+                      action=""store_true"",
+                      help=""""""Show what will be done, without actually doing it."""""")
+
+    (options, args) = parser.parse_args()
+
+    if len(args) == 0:
+        print(""A profile to remove must be provided (number or filename)"")
+        sys.exit(1)
+
+    filenames = get_profile_filenames(args)
+    if options.dry_run:
+        print(""Files to be removed: "")
+        for filename in filenames:
+            print(filename)
+    else:
+        for filename in filenames:
+            os.remove(filename)
+
+
+def clean_action():
+    """"""Remove every profile file in current directory.""""""
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
+                      action=""store_true"",
+                      help=""""""Show what will be done, without actually doing it."""""")
+
+    (options, args) = parser.parse_args()
+
+    if len(args) > 0:
+        print(""This command takes no argument."")
+        sys.exit(1)
+
+    filenames = get_profile_filenames(""all"")
+    if options.dry_run:
+        print(""Files to be removed: "")
+        for filename in filenames:
+            print(filename)
+    else:
+        for filename in filenames:
+            os.remove(filename)
+
+
+
+def run_action():
+    import time, subprocess
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+    parser.add_option(""--python"", dest=""python"", default=False,
+                      action=""store_true"",
+                      help=""""""Activates extra features when the profiled executable is
+                      a Python program (currently: function timestamping.)"""""")
+    parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.5"",
+                      type=""float"", action=""store"",
+                      help=""Sampling period (in seconds)"")
+    parser.add_option(""--include-children"", ""-C"", dest=""include_children"", default=False,
+                      action=""store_true"",
+                      help=""""""Monitors forked processes as well (sum up all process memory)"""""")
+
+    (options, args) = parser.parse_args()
+    print(""{1}: Sampling memory every {0.interval}s"".format(options, osp.basename(sys.argv[0])))
+
+    if len(args) == 0:
+        print(""A program to run must be provided. Use -h for help"")
+        sys.exit(1)
+
+    ## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
+    ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
+    ## directory. This file contains the process memory consumption, in Mb (one
+    ## value per line). Memory is sampled twice each second.""""""
+    ##           % osp.basename(sys.argv[0])
+    ##           )
+    ##     sys.exit(1)
+
+    suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
+    mprofile_output = ""mprofile_%s.dat"" % suffix
+
+    if options.python:
+        print(""running as a Python program..."")
+        if not args[0].startswith(""python""):
+            args.insert(0, ""python"")
+        args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
+                     ""-o"", mprofile_output)
+        p = subprocess.Popen(args)
+    else:
+        p = subprocess.Popen(args)
+
+    mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
+                         include_children=options.include_children)
+    with open(mprofile_output, ""a"") as f:
+        for m, t in mu:
+            f.write(""MEM {0:.6f} {1:.4f}"".format(m, t) + ""\n"")
+
+if __name__ == ""__main__"":
+    # Workaround for optparse limitation: insert -- before first negative number found.
+    negint = re.compile(""-[0-9]+"")
+    for n, arg in enumerate(sys.argv):
+        if negint.match(arg):
+            sys.argv.insert(n, ""--"")
+            break
+    actions = {""rm"": rm_action,
+               ""clean"": clean_action,
+               ""list"": list_action,
+               ""run"" : run_action}
+    actions[get_action()]()
 
-if options.python:
-    print(""running as a Python program..."")
-    if not args[0].startswith(""python""):
-        args.insert(0, ""python"")
-    args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
-                 ""-o"", mprofile_output)
-    p = subprocess.Popen(args)
-else:
-    p = subprocess.Popen(args)
 
-mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
-                     include_children=options.include_children)
-with open(mprofile_output, ""a"") as f:
-    for m, t in mu:
-        f.write(""MEM {0:.6f} {1:.4f}"".format(m, t) + ""\n"")
",False,mprof,False
"@@ -92,8 +92,11 @@ Executing external scripts
 ==========================
 Sometimes it is useful to have full memory usage reports as a function of
 time (not line-by-line) of external processess (be it Python scripts or not).
-In this case the executable ``mprof`` might be useful. To use it
+In this case the executable ``mprof`` might be useful. To use it like::
 
+    ./mprof run --python name_of_script.py
+
+TODO: make it work without the --python option.
 
 Setting debugger breakpoints
 =============================
","@@ -92,8 +92,11 @@ Executing external scripts
 ==========================
 Sometimes it is useful to have full memory usage reports as a function of
 time (not line-by-line) of external processess (be it Python scripts or not).
-In this case the executable ``mprof`` might be useful. To use it
+In this case the executable ``mprof`` might be useful. To use it like::
 
+    ./mprof run --python name_of_script.py
+
+TODO: make it work without the --python option.
 
 Setting debugger breakpoints
 =============================
",True,README.rst,False
"@@ -1,168 +0,0 @@
-#! /usr/bin/env python
-import sys
-
-try:
-    import pylab as pl
-except ImportError:
-    print(""matplotlib is needed for plotting."")
-    sys.exit(1)
-
-import numpy as np
-import math
-import glob
-import time
-import os
-import os.path as osp
-
-
-def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
-    """"""Add two brackets on the memory line plot.
-
-    This function uses the current figure.
-
-    Parameters
-    ==========
-    xloc: tuple with 2 values
-        brackets location (on horizontal axis).
-    yloc: tuple with 2 values
-        brackets location (on vertical axis)
-    xshift: float
-        value to subtract to xloc.
-    """"""
-
-    height_ratio = 20.
-    vsize = (pl.ylim()[1] - pl.ylim()[0]) / height_ratio
-    hsize = (pl.xlim()[1] - pl.xlim()[0]) / (3.*height_ratio)
-
-    bracket_x = pl.asarray([hsize, 0, 0, hsize])
-    bracket_y = pl.asarray([vsize, vsize, -vsize, -vsize])
-
-    # Matplotlib workaround: labels starting with _ aren't displayed
-    if label[0] == '_':
-        label = ' ' + label
-    pl.plot(bracket_x + xloc[0] - xshift, bracket_y + yloc[0],
-            ""-"" + color, linewidth=2, label=label)
-    pl.plot(-bracket_x + xloc[1] - xshift, bracket_y + yloc[1],
-            ""-"" + color, linewidth=2 )
-
-    # TODO: use matplotlib.patches.Polygon to draw a colored background for
-    # each function.
-
-    # with maplotlib 1.2, use matplotlib.path.Path to create proper markers
-    # see http://matplotlib.org/examples/pylab_examples/marker_path.html
-    # This works with matplotlib 0.99.1
-    ## pl.plot(xloc[0], yloc[0], ""<""+color, markersize=7, label=label)
-    ## pl.plot(xloc[1], yloc[1], "">""+color, markersize=7)
-
-
-def read_mprofile_file(filename):
-    ret = {}
-    mdata = []
-    f = open(filename, ""r"")
-    for l in f:
-        fields = l.split()
-        if fields[0] == ""MEM"":
-            # mem, timestamp
-            mdata.append((fields[1], fields[2]))
-
-        elif fields[0] == ""FUNC"":
-            f_name, mem_start, start, mem_end, end = fields[1:]
-            ts = ret.get(f_name, [])
-            ts.append([float(start), float(end), float(mem_start), float(mem_end)])
-            ret[f_name] = ts
-
-        else:
-            pass
-    f.close()
-
-    mdata = np.asarray(mdata,
-                       dtype=[(""mem"", np.float), (""timestamp"", np.float)])
-    return mdata, ret
-
-
-
-def plot_file(filename, index=0, timestamps=True):
-    mdata, ts = read_mprofile_file(filename)
-
-    global_start = float(mdata[""timestamp""][0])
-
-    mem = mdata[""mem""]
-    max_mem = mem.max()
-    max_mem_ind = mem.argmax()
-
-    t = mdata[""timestamp""] - global_start
-
-    all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
-    mem_line_colors=('k', ""b"", ""r"")
-    mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
-                                   time.localtime(global_start)) \
-                                   + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
-
-    pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
-            label=mem_line_label)
-
-    bottom, top = pl.ylim()
-    bottom += 0.001
-    top -= 0.001
-
-    # plot timestamps, if any
-    if len(ts) > 0 and timestamps:
-        func_num = 0
-        for f, exec_ts in ts.iteritems():
-            for execution in exec_ts:
-                add_brackets(execution[:2], execution[2:], xshift=global_start,
-                             color= all_colors[func_num % len(all_colors)],
-                             label=f.split(""."")[-1]
-                             + "" %.3fs"" % (execution[1] - execution[0]))
-            func_num += 1
-
-    if timestamps:
-        pl.hlines(max_mem,
-                  pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
-                  colors=""r"", linestyles=""--"")
-        pl.vlines(t[max_mem_ind], bottom, top,
-                  colors=""r"", linestyles=""--"")
-
-
-if __name__ == ""__main__"":
-    profiles = glob.glob(""mprofile_??????????????.dat"")
-    profiles.sort()
-
-    if len(sys.argv) == 1:
-        if len(profiles) == 0:
-            print(""No input file found. \nThis program looks for ""
-                  ""mprofile_*.dat files, generated by the mprofile command."")
-            sys.exit(-1)
-        filenames = [profiles[-1]]
-    else:
-        filenames = []
-        for arg in sys.argv[1:]:
-            if osp.exists(arg):
-                if not arg in filenames:
-                    filenames.append(arg)
-            else:
-                try:
-                    n = int(arg)
-                except ValueError:
-                    print(""Input file not found: "" + arg)
-                if not profiles[n] in filenames:
-                    filenames.append(profiles[n])
-
-    pl.figure(figsize=(14, 6), dpi=90)
-    if len(filenames) > 1:
-        timestamps = False
-    else:
-        timestamps = True
-    for n, filename in enumerate(filenames):
-        plot_file(filename, index=n, timestamps=timestamps)
-    pl.xlabel(""time [s]"")
-    pl.ylabel(""memory used [MB]"")
-
-    ax = pl.gca()
-    box = ax.get_position()
-    ax.set_position([0.07, 0.1,
-                     0.55, 0.8])
-    ax.legend(loc=""upper left"", bbox_to_anchor=(1.05, 1.))
-    pl.grid()
-    pl.show()
-
","@@ -1,168 +0,0 @@
-#! /usr/bin/env python
-import sys
-
-try:
-    import pylab as pl
-except ImportError:
-    print(""matplotlib is needed for plotting."")
-    sys.exit(1)
-
-import numpy as np
-import math
-import glob
-import time
-import os
-import os.path as osp
-
-
-def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
-    """"""Add two brackets on the memory line plot.
-
-    This function uses the current figure.
-
-    Parameters
-    ==========
-    xloc: tuple with 2 values
-        brackets location (on horizontal axis).
-    yloc: tuple with 2 values
-        brackets location (on vertical axis)
-    xshift: float
-        value to subtract to xloc.
-    """"""
-
-    height_ratio = 20.
-    vsize = (pl.ylim()[1] - pl.ylim()[0]) / height_ratio
-    hsize = (pl.xlim()[1] - pl.xlim()[0]) / (3.*height_ratio)
-
-    bracket_x = pl.asarray([hsize, 0, 0, hsize])
-    bracket_y = pl.asarray([vsize, vsize, -vsize, -vsize])
-
-    # Matplotlib workaround: labels starting with _ aren't displayed
-    if label[0] == '_':
-        label = ' ' + label
-    pl.plot(bracket_x + xloc[0] - xshift, bracket_y + yloc[0],
-            ""-"" + color, linewidth=2, label=label)
-    pl.plot(-bracket_x + xloc[1] - xshift, bracket_y + yloc[1],
-            ""-"" + color, linewidth=2 )
-
-    # TODO: use matplotlib.patches.Polygon to draw a colored background for
-    # each function.
-
-    # with maplotlib 1.2, use matplotlib.path.Path to create proper markers
-    # see http://matplotlib.org/examples/pylab_examples/marker_path.html
-    # This works with matplotlib 0.99.1
-    ## pl.plot(xloc[0], yloc[0], ""<""+color, markersize=7, label=label)
-    ## pl.plot(xloc[1], yloc[1], "">""+color, markersize=7)
-
-
-def read_mprofile_file(filename):
-    ret = {}
-    mdata = []
-    f = open(filename, ""r"")
-    for l in f:
-        fields = l.split()
-        if fields[0] == ""MEM"":
-            # mem, timestamp
-            mdata.append((fields[1], fields[2]))
-
-        elif fields[0] == ""FUNC"":
-            f_name, mem_start, start, mem_end, end = fields[1:]
-            ts = ret.get(f_name, [])
-            ts.append([float(start), float(end), float(mem_start), float(mem_end)])
-            ret[f_name] = ts
-
-        else:
-            pass
-    f.close()
-
-    mdata = np.asarray(mdata,
-                       dtype=[(""mem"", np.float), (""timestamp"", np.float)])
-    return mdata, ret
-
-
-
-def plot_file(filename, index=0, timestamps=True):
-    mdata, ts = read_mprofile_file(filename)
-
-    global_start = float(mdata[""timestamp""][0])
-
-    mem = mdata[""mem""]
-    max_mem = mem.max()
-    max_mem_ind = mem.argmax()
-
-    t = mdata[""timestamp""] - global_start
-
-    all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
-    mem_line_colors=('k', ""b"", ""r"")
-    mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
-                                   time.localtime(global_start)) \
-                                   + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
-
-    pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
-            label=mem_line_label)
-
-    bottom, top = pl.ylim()
-    bottom += 0.001
-    top -= 0.001
-
-    # plot timestamps, if any
-    if len(ts) > 0 and timestamps:
-        func_num = 0
-        for f, exec_ts in ts.iteritems():
-            for execution in exec_ts:
-                add_brackets(execution[:2], execution[2:], xshift=global_start,
-                             color= all_colors[func_num % len(all_colors)],
-                             label=f.split(""."")[-1]
-                             + "" %.3fs"" % (execution[1] - execution[0]))
-            func_num += 1
-
-    if timestamps:
-        pl.hlines(max_mem,
-                  pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
-                  colors=""r"", linestyles=""--"")
-        pl.vlines(t[max_mem_ind], bottom, top,
-                  colors=""r"", linestyles=""--"")
-
-
-if __name__ == ""__main__"":
-    profiles = glob.glob(""mprofile_??????????????.dat"")
-    profiles.sort()
-
-    if len(sys.argv) == 1:
-        if len(profiles) == 0:
-            print(""No input file found. \nThis program looks for ""
-                  ""mprofile_*.dat files, generated by the mprofile command."")
-            sys.exit(-1)
-        filenames = [profiles[-1]]
-    else:
-        filenames = []
-        for arg in sys.argv[1:]:
-            if osp.exists(arg):
-                if not arg in filenames:
-                    filenames.append(arg)
-            else:
-                try:
-                    n = int(arg)
-                except ValueError:
-                    print(""Input file not found: "" + arg)
-                if not profiles[n] in filenames:
-                    filenames.append(profiles[n])
-
-    pl.figure(figsize=(14, 6), dpi=90)
-    if len(filenames) > 1:
-        timestamps = False
-    else:
-        timestamps = True
-    for n, filename in enumerate(filenames):
-        plot_file(filename, index=n, timestamps=timestamps)
-    pl.xlabel(""time [s]"")
-    pl.ylabel(""memory used [MB]"")
-
-    ax = pl.gca()
-    box = ax.get_position()
-    ax.set_position([0.07, 0.1,
-                     0.55, 0.8])
-    ax.legend(loc=""upper left"", bbox_to_anchor=(1.05, 1.))
-    pl.grid()
-    pl.show()
-
",True,,False
"@@ -6,6 +6,8 @@ import os.path as osp
 import sys
 import re
 import copy
+import time
+import math
 
 from optparse import OptionParser
 
@@ -18,7 +20,7 @@ def print_usage():
 
 def get_action():
     """"""Pop first argument, check it is a valid action.""""""
-    all_actions = (""run"", ""rm"", ""clean"", ""list"")
+    all_actions = (""run"", ""rm"", ""clean"", ""list"", ""plot"")
     if len(sys.argv) <= 1:
         print_usage()
         sys.exit(1)
@@ -164,7 +166,7 @@ def run_action():
                       action=""store_true"",
                       help=""""""Activates extra features when the profiled executable is
                       a Python program (currently: function timestamping.)"""""")
-    parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.5"",
+    parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.1"",
                       type=""float"", action=""store"",
                       help=""Sampling period (in seconds)"")
     parser.add_option(""--include-children"", ""-C"", dest=""include_children"", default=False,
@@ -205,6 +207,177 @@ def run_action():
         for m, t in mu:
             f.write(""MEM {0:.6f} {1:.4f}"".format(m, t) + ""\n"")
 
+
+
+def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
+    """"""Add two brackets on the memory line plot.
+
+    This function uses the current figure.
+
+    Parameters
+    ==========
+    xloc: tuple with 2 values
+        brackets location (on horizontal axis).
+    yloc: tuple with 2 values
+        brackets location (on vertical axis)
+    xshift: float
+        value to subtract to xloc.
+    """"""
+    try:
+        import pylab as pl
+    except ImportError:
+        print(""matplotlib is needed for plotting."")
+        sys.exit(1)
+    height_ratio = 20.
+    vsize = (pl.ylim()[1] - pl.ylim()[0]) / height_ratio
+    hsize = (pl.xlim()[1] - pl.xlim()[0]) / (3.*height_ratio)
+
+    bracket_x = pl.asarray([hsize, 0, 0, hsize])
+    bracket_y = pl.asarray([vsize, vsize, -vsize, -vsize])
+
+    # Matplotlib workaround: labels starting with _ aren't displayed
+    if label[0] == '_':
+        label = ' ' + label
+    pl.plot(bracket_x + xloc[0] - xshift, bracket_y + yloc[0],
+            ""-"" + color, linewidth=2, label=label)
+    pl.plot(-bracket_x + xloc[1] - xshift, bracket_y + yloc[1],
+            ""-"" + color, linewidth=2 )
+
+    # TODO: use matplotlib.patches.Polygon to draw a colored background for
+    # each function.
+
+    # with maplotlib 1.2, use matplotlib.path.Path to create proper markers
+    # see http://matplotlib.org/examples/pylab_examples/marker_path.html
+    # This works with matplotlib 0.99.1
+    ## pl.plot(xloc[0], yloc[0], ""<""+color, markersize=7, label=label)
+    ## pl.plot(xloc[1], yloc[1], "">""+color, markersize=7)
+
+
+def read_mprofile_file(filename):
+    # TODO: would be nice to do without numpy
+
+    import numpy as np
+    ret = {}
+    mdata = []
+    f = open(filename, ""r"")
+    for l in f:
+        fields = l.split()
+        if fields[0] == ""MEM"":
+            # mem, timestamp
+            mdata.append((fields[1], fields[2]))
+
+        elif fields[0] == ""FUNC"":
+            f_name, mem_start, start, mem_end, end = fields[1:]
+            ts = ret.get(f_name, [])
+            ts.append([float(start), float(end), float(mem_start), float(mem_end)])
+            ret[f_name] = ts
+
+        else:
+            pass
+    f.close()
+
+    mdata = np.asarray(mdata,
+                       dtype=[(""mem"", np.float), (""timestamp"", np.float)])
+    return mdata, ret
+
+
+
+def plot_file(filename, index=0, timestamps=True):
+    try:
+        import pylab as pl
+    except ImportError:
+        print(""matplotlib is needed for plotting."")
+        sys.exit(1)
+
+    mdata, ts = read_mprofile_file(filename)
+
+    global_start = float(mdata[""timestamp""][0])
+
+    mem = mdata[""mem""]
+    max_mem = mem.max()
+    max_mem_ind = mem.argmax()
+
+    t = mdata[""timestamp""] - global_start
+
+    all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
+    mem_line_colors=('k', ""b"", ""r"")
+    mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
+                                   time.localtime(global_start)) \
+                                   + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
+
+    pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
+            label=mem_line_label)
+
+    bottom, top = pl.ylim()
+    bottom += 0.001
+    top -= 0.001
+
+    # plot timestamps, if any
+    if len(ts) > 0 and timestamps:
+        func_num = 0
+        for f, exec_ts in ts.iteritems():
+            for execution in exec_ts:
+                add_brackets(execution[:2], execution[2:], xshift=global_start,
+                             color= all_colors[func_num % len(all_colors)],
+                             label=f.split(""."")[-1]
+                             + "" %.3fs"" % (execution[1] - execution[0]))
+            func_num += 1
+
+    if timestamps:
+        pl.hlines(max_mem,
+                  pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
+                  colors=""r"", linestyles=""--"")
+        pl.vlines(t[max_mem_ind], bottom, top,
+                  colors=""r"", linestyles=""--"")
+
+def plot_action():
+    try:
+        import pylab as pl
+    except ImportError:
+        print(""matplotlib is needed for plotting."")
+        sys.exit(1)
+
+    profiles = glob.glob(""mprofile_??????????????.dat"")
+    profiles.sort()
+
+    if len(sys.argv) == 1:
+        if len(profiles) == 0:
+            print(""No input file found. \nThis program looks for ""
+                  ""mprofile_*.dat files, generated by the mprofile command."")
+            sys.exit(-1)
+        filenames = [profiles[-1]]
+    else:
+        filenames = []
+        for arg in sys.argv[1:]:
+            if osp.exists(arg):
+                if not arg in filenames:
+                    filenames.append(arg)
+            else:
+                try:
+                    n = int(arg)
+                except ValueError:
+                    print(""Input file not found: "" + arg)
+                if not profiles[n] in filenames:
+                    filenames.append(profiles[n])
+
+    pl.figure(figsize=(14, 6), dpi=90)
+    if len(filenames) > 1:
+        timestamps = False
+    else:
+        timestamps = True
+    for n, filename in enumerate(filenames):
+        plot_file(filename, index=n, timestamps=timestamps)
+    pl.xlabel(""time [s]"")
+    pl.ylabel(""memory used [MB]"")
+
+    ax = pl.gca()
+    box = ax.get_position()
+    ax.set_position([0.07, 0.1,
+                     0.55, 0.8])
+    ax.legend(loc=""upper left"", bbox_to_anchor=(1.05, 1.))
+    pl.grid()
+    pl.show()
+
 if __name__ == ""__main__"":
     # Workaround for optparse limitation: insert -- before first negative number found.
     negint = re.compile(""-[0-9]+"")
@@ -215,7 +388,6 @@ if __name__ == ""__main__"":
     actions = {""rm"": rm_action,
                ""clean"": clean_action,
                ""list"": list_action,
-               ""run"" : run_action}
+               ""run"": run_action,
+               ""plot"": plot_action}
     actions[get_action()]()
-
-
","@@ -6,6 +6,8 @@ import os.path as osp
 import sys
 import re
 import copy
+import time
+import math
 
 from optparse import OptionParser
 
@@ -18,7 +20,7 @@ def print_usage():
 
 def get_action():
     """"""Pop first argument, check it is a valid action.""""""
-    all_actions = (""run"", ""rm"", ""clean"", ""list"")
+    all_actions = (""run"", ""rm"", ""clean"", ""list"", ""plot"")
     if len(sys.argv) <= 1:
         print_usage()
         sys.exit(1)
@@ -164,7 +166,7 @@ def run_action():
                       action=""store_true"",
                       help=""""""Activates extra features when the profiled executable is
                       a Python program (currently: function timestamping.)"""""")
-    parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.5"",
+    parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.1"",
                       type=""float"", action=""store"",
                       help=""Sampling period (in seconds)"")
     parser.add_option(""--include-children"", ""-C"", dest=""include_children"", default=False,
@@ -205,6 +207,177 @@ def run_action():
         for m, t in mu:
             f.write(""MEM {0:.6f} {1:.4f}"".format(m, t) + ""\n"")
 
+
+
+def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
+    """"""Add two brackets on the memory line plot.
+
+    This function uses the current figure.
+
+    Parameters
+    ==========
+    xloc: tuple with 2 values
+        brackets location (on horizontal axis).
+    yloc: tuple with 2 values
+        brackets location (on vertical axis)
+    xshift: float
+        value to subtract to xloc.
+    """"""
+    try:
+        import pylab as pl
+    except ImportError:
+        print(""matplotlib is needed for plotting."")
+        sys.exit(1)
+    height_ratio = 20.
+    vsize = (pl.ylim()[1] - pl.ylim()[0]) / height_ratio
+    hsize = (pl.xlim()[1] - pl.xlim()[0]) / (3.*height_ratio)
+
+    bracket_x = pl.asarray([hsize, 0, 0, hsize])
+    bracket_y = pl.asarray([vsize, vsize, -vsize, -vsize])
+
+    # Matplotlib workaround: labels starting with _ aren't displayed
+    if label[0] == '_':
+        label = ' ' + label
+    pl.plot(bracket_x + xloc[0] - xshift, bracket_y + yloc[0],
+            ""-"" + color, linewidth=2, label=label)
+    pl.plot(-bracket_x + xloc[1] - xshift, bracket_y + yloc[1],
+            ""-"" + color, linewidth=2 )
+
+    # TODO: use matplotlib.patches.Polygon to draw a colored background for
+    # each function.
+
+    # with maplotlib 1.2, use matplotlib.path.Path to create proper markers
+    # see http://matplotlib.org/examples/pylab_examples/marker_path.html
+    # This works with matplotlib 0.99.1
+    ## pl.plot(xloc[0], yloc[0], ""<""+color, markersize=7, label=label)
+    ## pl.plot(xloc[1], yloc[1], "">""+color, markersize=7)
+
+
+def read_mprofile_file(filename):
+    # TODO: would be nice to do without numpy
+
+    import numpy as np
+    ret = {}
+    mdata = []
+    f = open(filename, ""r"")
+    for l in f:
+        fields = l.split()
+        if fields[0] == ""MEM"":
+            # mem, timestamp
+            mdata.append((fields[1], fields[2]))
+
+        elif fields[0] == ""FUNC"":
+            f_name, mem_start, start, mem_end, end = fields[1:]
+            ts = ret.get(f_name, [])
+            ts.append([float(start), float(end), float(mem_start), float(mem_end)])
+            ret[f_name] = ts
+
+        else:
+            pass
+    f.close()
+
+    mdata = np.asarray(mdata,
+                       dtype=[(""mem"", np.float), (""timestamp"", np.float)])
+    return mdata, ret
+
+
+
+def plot_file(filename, index=0, timestamps=True):
+    try:
+        import pylab as pl
+    except ImportError:
+        print(""matplotlib is needed for plotting."")
+        sys.exit(1)
+
+    mdata, ts = read_mprofile_file(filename)
+
+    global_start = float(mdata[""timestamp""][0])
+
+    mem = mdata[""mem""]
+    max_mem = mem.max()
+    max_mem_ind = mem.argmax()
+
+    t = mdata[""timestamp""] - global_start
+
+    all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
+    mem_line_colors=('k', ""b"", ""r"")
+    mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
+                                   time.localtime(global_start)) \
+                                   + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
+
+    pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
+            label=mem_line_label)
+
+    bottom, top = pl.ylim()
+    bottom += 0.001
+    top -= 0.001
+
+    # plot timestamps, if any
+    if len(ts) > 0 and timestamps:
+        func_num = 0
+        for f, exec_ts in ts.iteritems():
+            for execution in exec_ts:
+                add_brackets(execution[:2], execution[2:], xshift=global_start,
+                             color= all_colors[func_num % len(all_colors)],
+                             label=f.split(""."")[-1]
+                             + "" %.3fs"" % (execution[1] - execution[0]))
+            func_num += 1
+
+    if timestamps:
+        pl.hlines(max_mem,
+                  pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
+                  colors=""r"", linestyles=""--"")
+        pl.vlines(t[max_mem_ind], bottom, top,
+                  colors=""r"", linestyles=""--"")
+
+def plot_action():
+    try:
+        import pylab as pl
+    except ImportError:
+        print(""matplotlib is needed for plotting."")
+        sys.exit(1)
+
+    profiles = glob.glob(""mprofile_??????????????.dat"")
+    profiles.sort()
+
+    if len(sys.argv) == 1:
+        if len(profiles) == 0:
+            print(""No input file found. \nThis program looks for ""
+                  ""mprofile_*.dat files, generated by the mprofile command."")
+            sys.exit(-1)
+        filenames = [profiles[-1]]
+    else:
+        filenames = []
+        for arg in sys.argv[1:]:
+            if osp.exists(arg):
+                if not arg in filenames:
+                    filenames.append(arg)
+            else:
+                try:
+                    n = int(arg)
+                except ValueError:
+                    print(""Input file not found: "" + arg)
+                if not profiles[n] in filenames:
+                    filenames.append(profiles[n])
+
+    pl.figure(figsize=(14, 6), dpi=90)
+    if len(filenames) > 1:
+        timestamps = False
+    else:
+        timestamps = True
+    for n, filename in enumerate(filenames):
+        plot_file(filename, index=n, timestamps=timestamps)
+    pl.xlabel(""time [s]"")
+    pl.ylabel(""memory used [MB]"")
+
+    ax = pl.gca()
+    box = ax.get_position()
+    ax.set_position([0.07, 0.1,
+                     0.55, 0.8])
+    ax.legend(loc=""upper left"", bbox_to_anchor=(1.05, 1.))
+    pl.grid()
+    pl.show()
+
 if __name__ == ""__main__"":
     # Workaround for optparse limitation: insert -- before first negative number found.
     negint = re.compile(""-[0-9]+"")
@@ -215,7 +388,6 @@ if __name__ == ""__main__"":
     actions = {""rm"": rm_action,
                ""clean"": clean_action,
                ""list"": list_action,
-               ""run"" : run_action}
+               ""run"": run_action,
+               ""plot"": plot_action}
     actions[get_action()]()
-
-
",True,mprof,False
"@@ -67,12 +67,13 @@ def _get_memory(pid, timestamps=False, include_children=False):
             if include_children:
                 for p in process.get_children(recursive=True):
                     mem += p.get_memory_info()[0] / (_TWO_20)
+            if timestamps:
+                return (mem, time.time())
+            else:
+                return mem
         except psutil.AccessDenied:
-            mem = -1
-        if timestamps:
-            return (mem, time.time())
-        else:
-            return mem
+            pass
+            # continue and try to get this from ps
 
     # .. scary stuff ..
     if os.name == 'posix':
","@@ -67,12 +67,13 @@ def _get_memory(pid, timestamps=False, include_children=False):
             if include_children:
                 for p in process.get_children(recursive=True):
                     mem += p.get_memory_info()[0] / (_TWO_20)
+            if timestamps:
+                return (mem, time.time())
+            else:
+                return mem
         except psutil.AccessDenied:
-            mem = -1
-        if timestamps:
-            return (mem, time.time())
-        else:
-            return mem
+            pass
+            # continue and try to get this from ps
 
     # .. scary stuff ..
     if os.name == 'posix':
",True,memory_profiler.py,True
"@@ -7,7 +7,10 @@ __version__ = '0.27'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
-import time, sys, os, pdb
+import time
+import sys
+import os
+import pdb
 import warnings
 import linecache
 import inspect
@@ -44,14 +47,16 @@ if sys.platform == 'darwin':
     # ... it seems that in OSX the output is different units ...
     rusage_denom = rusage_denom * rusage_denom
 
+
 def _get_memory(pid, timestamps=False, include_children=False):
 
     # .. only for current process and only on unix..
     if pid == -1:
         # .. seems to get wrong measurements on some cases, see ..
         # .. https://github.com/fabianp/memory_profiler/issues/52 ..
-        if False: #has_resource:
-            mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / rusage_denom
+        if False:  # has_resource:
+            mem = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss /
+                   rusage_denom)
             if timestamps:
                 return (mem, time.time())
             else:
@@ -77,25 +82,25 @@ def _get_memory(pid, timestamps=False, include_children=False):
 
     # .. scary stuff ..
     if os.name == 'posix':
-            warnings.warn(""psutil module not found. memory_profiler will be slow"")
-            # ..
-            # .. memory usage in MB ..
-            # .. this should work on both Mac and Linux ..
-            # .. subprocess.check_output appeared in 2.7, using Popen ..
-            # .. for backwards compatibility ..
-            out = subprocess.Popen(['ps', 'v', '-p', str(pid)],
-                  stdout=subprocess.PIPE).communicate()[0].split(b'\n')
-            try:
-                vsz_index = out[0].split().index(b'RSS')
-                mem = float(out[1].split()[vsz_index]) / 1024
-                if timestamps:
-                    return(mem, time.time())
-                else:
-                    return mem
-            except:
-                if timestamps:
-                    return (-1, time.time())
-                else:
+        warnings.warn(""psutil module not found. memory_profiler will be slow"")
+        # ..
+        # .. memory usage in MB ..
+        # .. this should work on both Mac and Linux ..
+        # .. subprocess.check_output appeared in 2.7, using Popen ..
+        # .. for backwards compatibility ..
+        out = subprocess.Popen(['ps', 'v', '-p', str(pid)],
+              stdout=subprocess.PIPE).communicate()[0].split(b'\n')
+        try:
+            vsz_index = out[0].split().index(b'RSS')
+            mem = float(out[1].split()[vsz_index]) / 1024
+            if timestamps:
+                return(mem, time.time())
+            else:
+                return mem
+        except:
+            if timestamps:
+                return (-1, time.time())
+            else:
                     return -1
     else:
         raise NotImplementedError('The psutil module is required for non-unix '
@@ -106,8 +111,8 @@ class Timer(Process):
     """"""
     Fetch memory consumption from over a time interval
     """"""
-
-    def __init__(self, monitor_pid, interval, pipe, max_usage=False, *args, **kw):
+    def __init__(self, monitor_pid, interval, pipe, max_usage=False,
+                 *args, **kw):
         self.monitor_pid = monitor_pid
         self.interval = interval
         self.pipe = pipe
@@ -213,9 +218,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         if aspec.defaults is not None:
             n_args -= len(aspec.defaults)
         if n_args != len(args):
-            raise ValueError(
-                'Function expects %s value(s) but %s where given'
-                % (n_args, len(args)))
+            raise ValueError('Function expects %s value(s) but %s where given'
+                             % (n_args, len(args)))
 
         child_conn, parent_conn = Pipe()  # this will store Timer's results
         p = Timer(os.getpid(), interval, child_conn, timestamps=timestamps,
@@ -266,6 +270,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 # ..
 # .. utility functions for line-by-line ..
 
+
 def _find_script(script_name):
     """""" Find the script.
 
@@ -275,7 +280,7 @@ def _find_script(script_name):
         return script_name
     path = os.getenv('PATH', os.defpath).split(os.pathsep)
     for folder in path:
-        if folder == '':
+        if not folder:
             continue
         fn = os.path.join(folder, script_name)
         if os.path.isfile(fn):
@@ -387,7 +392,7 @@ class LineProfiler:
         except AttributeError:
             import warnings
             warnings.warn(""Could not extract a code object for the object %r""
-                          % (func,))
+                          % func)
             return
         if code not in self.code_map:
             self.code_map[code] = {}
@@ -455,8 +460,8 @@ class LineProfiler:
         if event in ('line', 'return') and frame.f_code in self.code_map:
             c = _get_memory(-1)
             if c >= self.max_mem:
-                t = 'Current memory {0:.2f} MB exceeded the maximum '.format(c) + \
-                    'of {0:.2f} MB\n'.format(self.max_mem)
+                t = ('Current memory {0:.2f} MB exceeded the maximum'
+                     ''.format(c) + 'of {0:.2f} MB\n'.format(self.max_mem))
                 sys.stdout.write(t)
                 sys.stdout.write('Stepping into the debugger \n')
                 frame.f_lineno -= 2
@@ -503,7 +508,8 @@ def show_results(prof, stream=None, precision=3):
         stream.write('Filename: ' + filename + '\n\n')
         if not os.path.exists(filename):
             stream.write('ERROR: Could not find file ' + filename + '\n')
-            if filename.startswith(""ipython-input"") or filename.startswith(""<ipython-input""):
+            if any([filename.startswith(k) for k in
+                    (""ipython-input"", ""<ipython-input"")]):
                 print(""NOTE: %mprun can only be used on functions defined in ""
                       ""physical files, and not in the IPython environment."")
             continue
@@ -582,7 +588,7 @@ def magic_mprun(self, parameter_s=''):
     """"""
     try:
         from StringIO import StringIO
-    except ImportError: # Python 3.x
+    except ImportError:  # Python 3.x
         from io import StringIO
 
     # Local imports to avoid hard dependency.
@@ -678,6 +684,8 @@ def _func_exec(stmt, ns):
     exec(stmt, ns)
 
 # a timeit-style %memit magic for IPython
+
+
 def magic_memit(self, line=''):
     """"""Measure memory usage of a Python statement
 
@@ -729,7 +737,8 @@ def magic_memit(self, line=''):
     if mem_usage:
         print('maximum of %d: %f MB per loop' % (repeat, max(mem_usage)))
     else:
-        print('ERROR: could not read memory usage, try with a lower interval or more iterations')
+        print('ERROR: could not read memory usage, try with a lower interval '
+              'or more iterations')
 
 
 def load_ipython_extension(ip):
@@ -789,13 +798,13 @@ if __name__ == '__main__':
             import __builtin__
             __builtin__.__dict__['profile'] = prof
             ns = copy(_clean_globals)
-            ns['profile'] = prof # shadow the profile decorator defined above
+            ns['profile'] = prof  # shadow the profile decorator defined above
             execfile(__file__, ns, ns)
         else:
             import builtins
             builtins.__dict__['profile'] = prof
             ns = copy(_clean_globals)
-            ns['profile'] = prof # shadow the profile decorator defined above
+            ns['profile'] = prof  # shadow the profile decorator defined above
             exec(compile(open(__file__).read(), __file__, 'exec'), ns, ns)
     finally:
         if options.out_filename is not None:
","@@ -7,7 +7,10 @@ __version__ = '0.27'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
-import time, sys, os, pdb
+import time
+import sys
+import os
+import pdb
 import warnings
 import linecache
 import inspect
@@ -44,14 +47,16 @@ if sys.platform == 'darwin':
     # ... it seems that in OSX the output is different units ...
     rusage_denom = rusage_denom * rusage_denom
 
+
 def _get_memory(pid, timestamps=False, include_children=False):
 
     # .. only for current process and only on unix..
     if pid == -1:
         # .. seems to get wrong measurements on some cases, see ..
         # .. https://github.com/fabianp/memory_profiler/issues/52 ..
-        if False: #has_resource:
-            mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / rusage_denom
+        if False:  # has_resource:
+            mem = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss /
+                   rusage_denom)
             if timestamps:
                 return (mem, time.time())
             else:
@@ -77,25 +82,25 @@ def _get_memory(pid, timestamps=False, include_children=False):
 
     # .. scary stuff ..
     if os.name == 'posix':
-            warnings.warn(""psutil module not found. memory_profiler will be slow"")
-            # ..
-            # .. memory usage in MB ..
-            # .. this should work on both Mac and Linux ..
-            # .. subprocess.check_output appeared in 2.7, using Popen ..
-            # .. for backwards compatibility ..
-            out = subprocess.Popen(['ps', 'v', '-p', str(pid)],
-                  stdout=subprocess.PIPE).communicate()[0].split(b'\n')
-            try:
-                vsz_index = out[0].split().index(b'RSS')
-                mem = float(out[1].split()[vsz_index]) / 1024
-                if timestamps:
-                    return(mem, time.time())
-                else:
-                    return mem
-            except:
-                if timestamps:
-                    return (-1, time.time())
-                else:
+        warnings.warn(""psutil module not found. memory_profiler will be slow"")
+        # ..
+        # .. memory usage in MB ..
+        # .. this should work on both Mac and Linux ..
+        # .. subprocess.check_output appeared in 2.7, using Popen ..
+        # .. for backwards compatibility ..
+        out = subprocess.Popen(['ps', 'v', '-p', str(pid)],
+              stdout=subprocess.PIPE).communicate()[0].split(b'\n')
+        try:
+            vsz_index = out[0].split().index(b'RSS')
+            mem = float(out[1].split()[vsz_index]) / 1024
+            if timestamps:
+                return(mem, time.time())
+            else:
+                return mem
+        except:
+            if timestamps:
+                return (-1, time.time())
+            else:
                     return -1
     else:
         raise NotImplementedError('The psutil module is required for non-unix '
@@ -106,8 +111,8 @@ class Timer(Process):
     """"""
     Fetch memory consumption from over a time interval
     """"""
-
-    def __init__(self, monitor_pid, interval, pipe, max_usage=False, *args, **kw):
+    def __init__(self, monitor_pid, interval, pipe, max_usage=False,
+                 *args, **kw):
         self.monitor_pid = monitor_pid
         self.interval = interval
         self.pipe = pipe
@@ -213,9 +218,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         if aspec.defaults is not None:
             n_args -= len(aspec.defaults)
         if n_args != len(args):
-            raise ValueError(
-                'Function expects %s value(s) but %s where given'
-                % (n_args, len(args)))
+            raise ValueError('Function expects %s value(s) but %s where given'
+                             % (n_args, len(args)))
 
         child_conn, parent_conn = Pipe()  # this will store Timer's results
         p = Timer(os.getpid(), interval, child_conn, timestamps=timestamps,
@@ -266,6 +270,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 # ..
 # .. utility functions for line-by-line ..
 
+
 def _find_script(script_name):
     """""" Find the script.
 
@@ -275,7 +280,7 @@ def _find_script(script_name):
         return script_name
     path = os.getenv('PATH', os.defpath).split(os.pathsep)
     for folder in path:
-        if folder == '':
+        if not folder:
             continue
         fn = os.path.join(folder, script_name)
         if os.path.isfile(fn):
@@ -387,7 +392,7 @@ class LineProfiler:
         except AttributeError:
             import warnings
             warnings.warn(""Could not extract a code object for the object %r""
-                          % (func,))
+                          % func)
             return
         if code not in self.code_map:
             self.code_map[code] = {}
@@ -455,8 +460,8 @@ class LineProfiler:
         if event in ('line', 'return') and frame.f_code in self.code_map:
             c = _get_memory(-1)
             if c >= self.max_mem:
-                t = 'Current memory {0:.2f} MB exceeded the maximum '.format(c) + \
-                    'of {0:.2f} MB\n'.format(self.max_mem)
+                t = ('Current memory {0:.2f} MB exceeded the maximum'
+                     ''.format(c) + 'of {0:.2f} MB\n'.format(self.max_mem))
                 sys.stdout.write(t)
                 sys.stdout.write('Stepping into the debugger \n')
                 frame.f_lineno -= 2
@@ -503,7 +508,8 @@ def show_results(prof, stream=None, precision=3):
         stream.write('Filename: ' + filename + '\n\n')
         if not os.path.exists(filename):
             stream.write('ERROR: Could not find file ' + filename + '\n')
-            if filename.startswith(""ipython-input"") or filename.startswith(""<ipython-input""):
+            if any([filename.startswith(k) for k in
+                    (""ipython-input"", ""<ipython-input"")]):
                 print(""NOTE: %mprun can only be used on functions defined in ""
                       ""physical files, and not in the IPython environment."")
             continue
@@ -582,7 +588,7 @@ def magic_mprun(self, parameter_s=''):
     """"""
     try:
         from StringIO import StringIO
-    except ImportError: # Python 3.x
+    except ImportError:  # Python 3.x
         from io import StringIO
 
     # Local imports to avoid hard dependency.
@@ -678,6 +684,8 @@ def _func_exec(stmt, ns):
     exec(stmt, ns)
 
 # a timeit-style %memit magic for IPython
+
+
 def magic_memit(self, line=''):
     """"""Measure memory usage of a Python statement
 
@@ -729,7 +737,8 @@ def magic_memit(self, line=''):
     if mem_usage:
         print('maximum of %d: %f MB per loop' % (repeat, max(mem_usage)))
     else:
-        print('ERROR: could not read memory usage, try with a lower interval or more iterations')
+        print('ERROR: could not read memory usage, try with a lower interval '
+              'or more iterations')
 
 
 def load_ipython_extension(ip):
@@ -789,13 +798,13 @@ if __name__ == '__main__':
             import __builtin__
             __builtin__.__dict__['profile'] = prof
             ns = copy(_clean_globals)
-            ns['profile'] = prof # shadow the profile decorator defined above
+            ns['profile'] = prof  # shadow the profile decorator defined above
             execfile(__file__, ns, ns)
         else:
             import builtins
             builtins.__dict__['profile'] = prof
             ns = copy(_clean_globals)
-            ns['profile'] = prof # shadow the profile decorator defined above
+            ns['profile'] = prof  # shadow the profile decorator defined above
             exec(compile(open(__file__).read(), __file__, 'exec'), ns, ns)
     finally:
         if options.out_filename is not None:
",True,memory_profiler.py,True
"@@ -169,12 +169,13 @@ def run_action():
     parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.1"",
                       type=""float"", action=""store"",
                       help=""Sampling period (in seconds)"")
-    parser.add_option(""--include-children"", ""-C"", dest=""include_children"", default=False,
-                      action=""store_true"",
+    parser.add_option(""--include-children"", ""-C"", dest=""include_children"",
+                      default=False, action=""store_true"",
                       help=""""""Monitors forked processes as well (sum up all process memory)"""""")
 
     (options, args) = parser.parse_args()
-    print(""{1}: Sampling memory every {0.interval}s"".format(options, osp.basename(sys.argv[0])))
+    print(""{1}: Sampling memory every {0.interval}s"".format(
+        options, osp.basename(sys.argv[0])))
 
     if len(args) == 0:
         print(""A program to run must be provided. Use -h for help"")
@@ -184,9 +185,6 @@ def run_action():
     ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
     ## directory. This file contains the process memory consumption, in Mb (one
     ## value per line). Memory is sampled twice each second.""""""
-    ##           % osp.basename(sys.argv[0])
-    ##           )
-    ##     sys.exit(1)
 
     suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
     mprofile_output = ""mprofile_%s.dat"" % suffix
@@ -348,7 +346,7 @@ def plot_action():
         filenames = [profiles[-1]]
     else:
         filenames = []
-        for arg in sys.argv[1:]:
+        for arg in sys.argv[2:]:
             if osp.exists(arg):
                 if not arg in filenames:
                     filenames.append(arg)
","@@ -169,12 +169,13 @@ def run_action():
     parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.1"",
                       type=""float"", action=""store"",
                       help=""Sampling period (in seconds)"")
-    parser.add_option(""--include-children"", ""-C"", dest=""include_children"", default=False,
-                      action=""store_true"",
+    parser.add_option(""--include-children"", ""-C"", dest=""include_children"",
+                      default=False, action=""store_true"",
                       help=""""""Monitors forked processes as well (sum up all process memory)"""""")
 
     (options, args) = parser.parse_args()
-    print(""{1}: Sampling memory every {0.interval}s"".format(options, osp.basename(sys.argv[0])))
+    print(""{1}: Sampling memory every {0.interval}s"".format(
+        options, osp.basename(sys.argv[0])))
 
     if len(args) == 0:
         print(""A program to run must be provided. Use -h for help"")
@@ -184,9 +185,6 @@ def run_action():
     ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
     ## directory. This file contains the process memory consumption, in Mb (one
     ## value per line). Memory is sampled twice each second.""""""
-    ##           % osp.basename(sys.argv[0])
-    ##           )
-    ##     sys.exit(1)
 
     suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
     mprofile_output = ""mprofile_%s.dat"" % suffix
@@ -348,7 +346,7 @@ def plot_action():
         filenames = [profiles[-1]]
     else:
         filenames = []
-        for arg in sys.argv[1:]:
+        for arg in sys.argv[2:]:
             if osp.exists(arg):
                 if not arg in filenames:
                     filenames.append(arg)
",True,mprof,False
"@@ -26,7 +26,6 @@ except ImportError:
 _TWO_20 = float(2 ** 20)
 
 has_psutil = False
-has_resource = False
 
 # .. get available packages ..
 try:
@@ -35,43 +34,21 @@ try:
 except ImportError:
     pass
 
-try:
-    import resource
-    has_resource = True
-except ImportError:
-    pass
-
-# divide resource.getrusage() by rusage_denom to get MB
-rusage_denom = 1024.
-if sys.platform == 'darwin':
-    # ... it seems that in OSX the output is different units ...
-    rusage_denom = rusage_denom * rusage_denom
-
 
 def _get_memory(pid, timestamps=False, include_children=False):
 
     # .. only for current process and only on unix..
     if pid == -1:
-        # .. seems to get wrong measurements on some cases, see ..
-        # .. https://github.com/fabianp/memory_profiler/issues/52 ..
-        if False:  # has_resource:
-            mem = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss /
-                   rusage_denom)
-            if timestamps:
-                return (mem, time.time())
-            else:
-                return mem
-        else:
-            pid = os.getpid()
+        pid = os.getpid()
 
     # .. cross-platform but but requires psutil ..
     if has_psutil:
         process = psutil.Process(pid)
         try:
-            mem = process.get_memory_info()[0] / (_TWO_20)
+            mem = process.get_memory_info()[0] / _TWO_20
             if include_children:
                 for p in process.get_children(recursive=True):
-                    mem += p.get_memory_info()[0] / (_TWO_20)
+                    mem += p.get_memory_info()[0] / _TWO_20
             if timestamps:
                 return (mem, time.time())
             else:
","@@ -26,7 +26,6 @@ except ImportError:
 _TWO_20 = float(2 ** 20)
 
 has_psutil = False
-has_resource = False
 
 # .. get available packages ..
 try:
@@ -35,43 +34,21 @@ try:
 except ImportError:
     pass
 
-try:
-    import resource
-    has_resource = True
-except ImportError:
-    pass
-
-# divide resource.getrusage() by rusage_denom to get MB
-rusage_denom = 1024.
-if sys.platform == 'darwin':
-    # ... it seems that in OSX the output is different units ...
-    rusage_denom = rusage_denom * rusage_denom
-
 
 def _get_memory(pid, timestamps=False, include_children=False):
 
     # .. only for current process and only on unix..
     if pid == -1:
-        # .. seems to get wrong measurements on some cases, see ..
-        # .. https://github.com/fabianp/memory_profiler/issues/52 ..
-        if False:  # has_resource:
-            mem = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss /
-                   rusage_denom)
-            if timestamps:
-                return (mem, time.time())
-            else:
-                return mem
-        else:
-            pid = os.getpid()
+        pid = os.getpid()
 
     # .. cross-platform but but requires psutil ..
     if has_psutil:
         process = psutil.Process(pid)
         try:
-            mem = process.get_memory_info()[0] / (_TWO_20)
+            mem = process.get_memory_info()[0] / _TWO_20
             if include_children:
                 for p in process.get_children(recursive=True):
-                    mem += p.get_memory_info()[0] / (_TWO_20)
+                    mem += p.get_memory_info()[0] / _TWO_20
             if timestamps:
                 return (mem, time.time())
             else:
",True,memory_profiler.py,True
"@@ -91,12 +91,57 @@ memory_profiler`` in the command line.
 Executing external scripts
 ==========================
 Sometimes it is useful to have full memory usage reports as a function of
-time (not line-by-line) of external processess (be it Python scripts or not).
-In this case the executable ``mprof`` might be useful. To use it like::
+time (not line-by-line) of external processes (be it Python scripts or not).
+In this case the executable ``mprof`` might be useful. Use it like::
 
-    ./mprof run --python name_of_script.py
+    mprof run <executable>
+    mprof plot
 
-TODO: make it work without the --python option.
+The first line run the executable and record memory usage along time,
+in a file written in the current directory.
+Once it's done, a graph plot can be obtained using the second line.
+The recorded file contains a timestamps, that allows for several
+profiles to be kept at the same time.
+
+Help on each `mprof` subcommand can be obtained with the `-h` flag,
+e.g. `mprof run -h`.
+
+In the case of a Python script, using the previous command does not
+give you any information on which function is executed at a given
+time. Depending on the case, it can be difficult to identify the part
+of the code that is causing the highest memory usage. 
+
+Adding the `profile` decorator to a function and running the Python
+script with 
+
+    mprof run --python <script>
+
+will record timestamps when entering/leaving the profiled function,
+and plot them on the graph afterward. 
+An example output can be found 
+`here <https://github.com/scikit-learn/scikit-learn/pull/2248>`_
+
+It is also possible to timestamp a portion of code using a context
+manager like this::
+
+    def my_func():
+        a = [1] * (10 ** 6)
+        with profile.timestamp(""b_computation""):
+            b = [2] * (2 * 10 ** 7)
+        del b
+        return a
+
+the string provided in the call will be displayed in the plot.
+
+The available commands for `mprof` are: 
+
+  - ``mprof run``: running an executable, recording memory usage  
+  - ``mprof plot``: plotting one the recorded memory usage (by default,
+    the last one)
+  - ``mprof list``: listing all recorded memory usage files in a
+    user-friendly way.
+  - ``mprof clean``: removing all recorded memory usage files.
+  - ``mprof rm``: removing specific recorded memory usage files
 
 Setting debugger breakpoints
 =============================
","@@ -91,12 +91,57 @@ memory_profiler`` in the command line.
 Executing external scripts
 ==========================
 Sometimes it is useful to have full memory usage reports as a function of
-time (not line-by-line) of external processess (be it Python scripts or not).
-In this case the executable ``mprof`` might be useful. To use it like::
+time (not line-by-line) of external processes (be it Python scripts or not).
+In this case the executable ``mprof`` might be useful. Use it like::
 
-    ./mprof run --python name_of_script.py
+    mprof run <executable>
+    mprof plot
 
-TODO: make it work without the --python option.
+The first line run the executable and record memory usage along time,
+in a file written in the current directory.
+Once it's done, a graph plot can be obtained using the second line.
+The recorded file contains a timestamps, that allows for several
+profiles to be kept at the same time.
+
+Help on each `mprof` subcommand can be obtained with the `-h` flag,
+e.g. `mprof run -h`.
+
+In the case of a Python script, using the previous command does not
+give you any information on which function is executed at a given
+time. Depending on the case, it can be difficult to identify the part
+of the code that is causing the highest memory usage. 
+
+Adding the `profile` decorator to a function and running the Python
+script with 
+
+    mprof run --python <script>
+
+will record timestamps when entering/leaving the profiled function,
+and plot them on the graph afterward. 
+An example output can be found 
+`here <https://github.com/scikit-learn/scikit-learn/pull/2248>`_
+
+It is also possible to timestamp a portion of code using a context
+manager like this::
+
+    def my_func():
+        a = [1] * (10 ** 6)
+        with profile.timestamp(""b_computation""):
+            b = [2] * (2 * 10 ** 7)
+        del b
+        return a
+
+the string provided in the call will be displayed in the plot.
+
+The available commands for `mprof` are: 
+
+  - ``mprof run``: running an executable, recording memory usage  
+  - ``mprof plot``: plotting one the recorded memory usage (by default,
+    the last one)
+  - ``mprof list``: listing all recorded memory usage files in a
+    user-friendly way.
+  - ``mprof clean``: removing all recorded memory usage files.
+  - ``mprof rm``: removing specific recorded memory usage files
 
 Setting debugger breakpoints
 =============================
",True,README.rst,False
"@@ -328,8 +328,8 @@ cleanup.
 
 `Thomas Kluyver <https://github.com/takluyver>`_ added the IPython extension.
 
-Philippe Gervais made several enhacements and bug fixes.
-
+`Philippe Gervais <https://github.com/pgervais>`_ created the 'mprof'
+script and fixed bugs. 
 
 
 =========
","@@ -328,8 +328,8 @@ cleanup.
 
 `Thomas Kluyver <https://github.com/takluyver>`_ added the IPython extension.
 
-Philippe Gervais made several enhacements and bug fixes.
-
+`Philippe Gervais <https://github.com/pgervais>`_ created the 'mprof'
+script and fixed bugs. 
 
 
 =========
",True,README.rst,False
"@@ -1,4 +1,4 @@
-#! /usr/bin/env python
+#!/usr/bin/env python
 
 import glob
 import os
","@@ -1,4 +1,4 @@
-#! /usr/bin/env python
+#!/usr/bin/env python
 
 import glob
 import os
",True,mprof,False
"@@ -189,6 +189,9 @@ def run_action():
     suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
     mprofile_output = ""mprofile_%s.dat"" % suffix
 
+    # .. TODO: more than one script as argument ? ..
+    if args[0].endswith('.py'):
+        options.python = True
     if options.python:
         print(""running as a Python program..."")
         if not args[0].startswith(""python""):
","@@ -189,6 +189,9 @@ def run_action():
     suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
     mprofile_output = ""mprofile_%s.dat"" % suffix
 
+    # .. TODO: more than one script as argument ? ..
+    if args[0].endswith('.py'):
+        options.python = True
     if options.python:
         print(""running as a Python program..."")
         if not args[0].startswith(""python""):
",True,mprof,False
"@@ -166,6 +166,10 @@ def run_action():
                       action=""store_true"",
                       help=""""""Activates extra features when the profiled executable is
                       a Python program (currently: function timestamping.)"""""")
+    parser.add_option(""--nopython"", dest=""nopython"", default=False,
+                      action=""store_true"",
+                      help=""""""Disables extra features when the profiled executable is
+                      a Python program (currently: function timestamping.)"""""")
     parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.1"",
                       type=""float"", action=""store"",
                       help=""Sampling period (in seconds)"")
@@ -190,7 +194,7 @@ def run_action():
     mprofile_output = ""mprofile_%s.dat"" % suffix
 
     # .. TODO: more than one script as argument ? ..
-    if args[0].endswith('.py'):
+    if args[0].endswith('.py') and not options.nopython:
         options.python = True
     if options.python:
         print(""running as a Python program..."")
","@@ -166,6 +166,10 @@ def run_action():
                       action=""store_true"",
                       help=""""""Activates extra features when the profiled executable is
                       a Python program (currently: function timestamping.)"""""")
+    parser.add_option(""--nopython"", dest=""nopython"", default=False,
+                      action=""store_true"",
+                      help=""""""Disables extra features when the profiled executable is
+                      a Python program (currently: function timestamping.)"""""")
     parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.1"",
                       type=""float"", action=""store"",
                       help=""Sampling period (in seconds)"")
@@ -190,7 +194,7 @@ def run_action():
     mprofile_output = ""mprofile_%s.dat"" % suffix
 
     # .. TODO: more than one script as argument ? ..
-    if args[0].endswith('.py'):
+    if args[0].endswith('.py') and not options.nopython:
         options.python = True
     if options.python:
         print(""running as a Python program..."")
",True,mprof,False
"@@ -2,7 +2,7 @@ import numpy as np
 import scipy.signal
 
 
-#@profile
+@profile
 def create_data():
     ret = []
     for n in xrange(70):
@@ -10,7 +10,7 @@ def create_data():
     return ret
 
 
-#@profile
+@profile
 def process_data(data):
     data = np.concatenate(data)
     detrended = scipy.signal.detrend(data, axis=0)
@@ -20,4 +20,3 @@ def process_data(data):
 if __name__ == ""__main__"":
     data1 = create_data()
     data2 = process_data(data1)
-    print (data2.shape)
","@@ -2,7 +2,7 @@ import numpy as np
 import scipy.signal
 
 
-#@profile
+@profile
 def create_data():
     ret = []
     for n in xrange(70):
@@ -10,7 +10,7 @@ def create_data():
     return ret
 
 
-#@profile
+@profile
 def process_data(data):
     data = np.concatenate(data)
     detrended = scipy.signal.detrend(data, axis=0)
@@ -20,4 +20,3 @@ def process_data(data):
 if __name__ == ""__main__"":
     data1 = create_data()
     data2 = process_data(data1)
-    print (data2.shape)
",True,examples/numpy_example.py,True
"@@ -61,7 +61,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
     if os.name == 'posix':
         warnings.warn(""psutil module not found. memory_profiler will be slow"")
         # ..
-        # .. memory usage in MB ..
+        # .. memory usage in MiB ..
         # .. this should work on both Mac and Linux ..
         # .. subprocess.check_output appeared in 2.7, using Popen ..
         # .. for backwards compatibility ..
@@ -159,7 +159,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     Returns
     -------
     mem_usage : list of floating-poing values
-        memory usage, in MB. It's length is always < timeout / interval
+        memory usage, in MiB. It's length is always < timeout / interval
     ret : return value of the profiled function
         Only returned if retval is set to True
     """"""
@@ -437,8 +437,8 @@ class LineProfiler:
         if event in ('line', 'return') and frame.f_code in self.code_map:
             c = _get_memory(-1)
             if c >= self.max_mem:
-                t = ('Current memory {0:.2f} MB exceeded the maximum'
-                     ''.format(c) + 'of {0:.2f} MB\n'.format(self.max_mem))
+                t = ('Current memory {0:.2f} MiB exceeded the maximum'
+                     ''.format(c) + 'of {0:.2f} MiB\n'.format(self.max_mem))
                 sys.stdout.write(t)
                 sys.stdout.write('Stepping into the debugger \n')
                 frame.f_lineno -= 2
@@ -519,7 +519,7 @@ def show_results(prof, stream=None, precision=3):
         first_line = sorted(lines_normalized.keys())[0]
         mem_old = max(lines_normalized[first_line])
         precision = int(precision)
-        template_mem = '{{0:{0}.{1}'.format(precision + 6, precision) + 'f} MB'
+        template_mem = '{{0:{0}.{1}'.format(precision + 6, precision) + 'f} MiB'
         for i, l in enumerate(linenos):
             mem = ''
             inc = ''
@@ -685,13 +685,13 @@ def magic_memit(self, line=''):
       In [1]: import numpy as np
 
       In [2]: %memit np.zeros(1e7)
-      maximum of 1: 76.402344 MB per loop
+      maximum of 1: 76.402344 MiB per loop
 
       In [3]: %memit np.ones(1e6)
-      maximum of 1: 7.820312 MB per loop
+      maximum of 1: 7.820312 MiB per loop
 
       In [4]: %memit -r 10 np.empty(1e8)
-      maximum of 10: 0.101562 MB per loop
+      maximum of 10: 0.101562 MiB per loop
 
     """"""
     opts, stmt = self.parse_options(line, 'r:t:i:', posix=False, strict=False)
@@ -712,7 +712,7 @@ def magic_memit(self, line=''):
         mem_usage.extend(tmp)
 
     if mem_usage:
-        print('maximum of %d: %f MB per loop' % (repeat, max(mem_usage)))
+        print('maximum of %d: %f MiB per loop' % (repeat, max(mem_usage)))
     else:
         print('ERROR: could not read memory usage, try with a lower interval '
               'or more iterations')
","@@ -61,7 +61,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
     if os.name == 'posix':
         warnings.warn(""psutil module not found. memory_profiler will be slow"")
         # ..
-        # .. memory usage in MB ..
+        # .. memory usage in MiB ..
         # .. this should work on both Mac and Linux ..
         # .. subprocess.check_output appeared in 2.7, using Popen ..
         # .. for backwards compatibility ..
@@ -159,7 +159,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     Returns
     -------
     mem_usage : list of floating-poing values
-        memory usage, in MB. It's length is always < timeout / interval
+        memory usage, in MiB. It's length is always < timeout / interval
     ret : return value of the profiled function
         Only returned if retval is set to True
     """"""
@@ -437,8 +437,8 @@ class LineProfiler:
         if event in ('line', 'return') and frame.f_code in self.code_map:
             c = _get_memory(-1)
             if c >= self.max_mem:
-                t = ('Current memory {0:.2f} MB exceeded the maximum'
-                     ''.format(c) + 'of {0:.2f} MB\n'.format(self.max_mem))
+                t = ('Current memory {0:.2f} MiB exceeded the maximum'
+                     ''.format(c) + 'of {0:.2f} MiB\n'.format(self.max_mem))
                 sys.stdout.write(t)
                 sys.stdout.write('Stepping into the debugger \n')
                 frame.f_lineno -= 2
@@ -519,7 +519,7 @@ def show_results(prof, stream=None, precision=3):
         first_line = sorted(lines_normalized.keys())[0]
         mem_old = max(lines_normalized[first_line])
         precision = int(precision)
-        template_mem = '{{0:{0}.{1}'.format(precision + 6, precision) + 'f} MB'
+        template_mem = '{{0:{0}.{1}'.format(precision + 6, precision) + 'f} MiB'
         for i, l in enumerate(linenos):
             mem = ''
             inc = ''
@@ -685,13 +685,13 @@ def magic_memit(self, line=''):
       In [1]: import numpy as np
 
       In [2]: %memit np.zeros(1e7)
-      maximum of 1: 76.402344 MB per loop
+      maximum of 1: 76.402344 MiB per loop
 
       In [3]: %memit np.ones(1e6)
-      maximum of 1: 7.820312 MB per loop
+      maximum of 1: 7.820312 MiB per loop
 
       In [4]: %memit -r 10 np.empty(1e8)
-      maximum of 10: 0.101562 MB per loop
+      maximum of 10: 0.101562 MiB per loop
 
     """"""
     opts, stmt = self.parse_options(line, 'r:t:i:', posix=False, strict=False)
@@ -712,7 +712,7 @@ def magic_memit(self, line=''):
         mem_usage.extend(tmp)
 
     if mem_usage:
-        print('maximum of %d: %f MB per loop' % (repeat, max(mem_usage)))
+        print('maximum of %d: %f MiB per loop' % (repeat, max(mem_usage)))
     else:
         print('ERROR: could not read memory usage, try with a lower interval '
               'or more iterations')
",True,memory_profiler.py,True
"@@ -372,8 +372,8 @@ def plot_action():
         timestamps = True
     for n, filename in enumerate(filenames):
         plot_file(filename, index=n, timestamps=timestamps)
-    pl.xlabel(""time [s]"")
-    pl.ylabel(""memory used [MB]"")
+    pl.xlabel(""time (in seconds)"")
+    pl.ylabel(""memory used (in MiB)"")
 
     ax = pl.gca()
     box = ax.get_position()
","@@ -372,8 +372,8 @@ def plot_action():
         timestamps = True
     for n, filename in enumerate(filenames):
         plot_file(filename, index=n, timestamps=timestamps)
-    pl.xlabel(""time [s]"")
-    pl.ylabel(""memory used [MB]"")
+    pl.xlabel(""time (in seconds)"")
+    pl.ylabel(""memory used (in MiB)"")
 
     ax = pl.gca()
     box = ax.get_position()
",True,mprof,False
"@@ -469,7 +469,7 @@ class LineProfiler:
         sys.settrace(None)
 
 
-def show_results(prof, stream=None, precision=3):
+def show_results(prof, stream=None, precision=1):
     if stream is None:
         stream = sys.stdout
     template = '{0:>6} {1:>12} {2:>12}   {3:<}'
@@ -519,7 +519,7 @@ def show_results(prof, stream=None, precision=3):
         first_line = sorted(lines_normalized.keys())[0]
         mem_old = max(lines_normalized[first_line])
         precision = int(precision)
-        template_mem = '{{0:{0}.{1}'.format(precision + 6, precision) + 'f} MiB'
+        template_mem = '{{0:{0}.{1}'.format(precision + 4, precision) + 'f} MiB'
         for i, l in enumerate(linenos):
             mem = ''
             inc = ''
","@@ -469,7 +469,7 @@ class LineProfiler:
         sys.settrace(None)
 
 
-def show_results(prof, stream=None, precision=3):
+def show_results(prof, stream=None, precision=1):
     if stream is None:
         stream = sys.stdout
     template = '{0:>6} {1:>12} {2:>12}   {3:<}'
@@ -519,7 +519,7 @@ def show_results(prof, stream=None, precision=3):
         first_line = sorted(lines_normalized.keys())[0]
         mem_old = max(lines_normalized[first_line])
         precision = int(precision)
-        template_mem = '{{0:{0}.{1}'.format(precision + 6, precision) + 'f} MiB'
+        template_mem = '{{0:{0}.{1}'.format(precision + 4, precision) + 'f} MiB'
         for i, l in enumerate(linenos):
             mem = ''
             inc = ''
",True,memory_profiler.py,True
"@@ -335,6 +335,7 @@ def plot_file(filename, index=0, timestamps=True):
         pl.vlines(t[max_mem_ind], bottom, top,
                   colors=""r"", linestyles=""--"")
 
+
 def plot_action():
     try:
         import pylab as pl
@@ -342,18 +343,26 @@ def plot_action():
         print(""matplotlib is needed for plotting."")
         sys.exit(1)
 
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+    parser.add_option(""--title"", ""-t"", dest=""title"", default="""",
+                      type=""str"", action=""store"",
+                      help=""String shown as plot title"")
+    (options, args) = parser.parse_args()
+
     profiles = glob.glob(""mprofile_??????????????.dat"")
     profiles.sort()
 
-    if len(sys.argv) == 1:
+    if len(args) == 0:
         if len(profiles) == 0:
             print(""No input file found. \nThis program looks for ""
-                  ""mprofile_*.dat files, generated by the mprofile command."")
+                  ""mprofile_*.dat files, generated by the ""
+                  ""'mprof run' command."")
             sys.exit(-1)
         filenames = [profiles[-1]]
     else:
         filenames = []
-        for arg in sys.argv[2:]:
+        for arg in args:
             if osp.exists(arg):
                 if not arg in filenames:
                     filenames.append(arg)
@@ -374,7 +383,7 @@ def plot_action():
         plot_file(filename, index=n, timestamps=timestamps)
     pl.xlabel(""time (in seconds)"")
     pl.ylabel(""memory used (in MiB)"")
-
+    pl.title(options.title)
     ax = pl.gca()
     box = ax.get_position()
     ax.set_position([0.07, 0.1,
@@ -384,7 +393,8 @@ def plot_action():
     pl.show()
 
 if __name__ == ""__main__"":
-    # Workaround for optparse limitation: insert -- before first negative number found.
+    # Workaround for optparse limitation: insert -- before first negative
+    # number found.
     negint = re.compile(""-[0-9]+"")
     for n, arg in enumerate(sys.argv):
         if negint.match(arg):
","@@ -335,6 +335,7 @@ def plot_file(filename, index=0, timestamps=True):
         pl.vlines(t[max_mem_ind], bottom, top,
                   colors=""r"", linestyles=""--"")
 
+
 def plot_action():
     try:
         import pylab as pl
@@ -342,18 +343,26 @@ def plot_action():
         print(""matplotlib is needed for plotting."")
         sys.exit(1)
 
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+    parser.add_option(""--title"", ""-t"", dest=""title"", default="""",
+                      type=""str"", action=""store"",
+                      help=""String shown as plot title"")
+    (options, args) = parser.parse_args()
+
     profiles = glob.glob(""mprofile_??????????????.dat"")
     profiles.sort()
 
-    if len(sys.argv) == 1:
+    if len(args) == 0:
         if len(profiles) == 0:
             print(""No input file found. \nThis program looks for ""
-                  ""mprofile_*.dat files, generated by the mprofile command."")
+                  ""mprofile_*.dat files, generated by the ""
+                  ""'mprof run' command."")
             sys.exit(-1)
         filenames = [profiles[-1]]
     else:
         filenames = []
-        for arg in sys.argv[2:]:
+        for arg in args:
             if osp.exists(arg):
                 if not arg in filenames:
                     filenames.append(arg)
@@ -374,7 +383,7 @@ def plot_action():
         plot_file(filename, index=n, timestamps=timestamps)
     pl.xlabel(""time (in seconds)"")
     pl.ylabel(""memory used (in MiB)"")
-
+    pl.title(options.title)
     ax = pl.gca()
     box = ax.get_position()
     ax.set_position([0.07, 0.1,
@@ -384,7 +393,8 @@ def plot_action():
     pl.show()
 
 if __name__ == ""__main__"":
-    # Workaround for optparse limitation: insert -- before first negative number found.
+    # Workaround for optparse limitation: insert -- before first negative
+    # number found.
     negint = re.compile(""-[0-9]+"")
     for n, arg in enumerate(sys.argv):
         if negint.match(arg):
",True,mprof,False
"@@ -259,31 +259,46 @@ def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
 
 
 def read_mprofile_file(filename):
-    # TODO: would be nice to do without numpy
+    """"""Read an mprofile file and return its content.
 
-    import numpy as np
-    ret = {}
-    mdata = []
+    Returns
+    =======
+    content: dict
+        Keys:
+
+        - ""mem_usage"": (list) memory usage values, in MiB
+        - ""timestamp"": (list) time instant for each memory usage value, in
+            second
+        - ""func_timestamp"": (dict) for each function, timestamps and memory
+            usage upon entering and exiting.
+    """"""
+#    import numpy as np
+    func_ts = {}
+    mem_usage = []
+    timestamp = []
     f = open(filename, ""r"")
     for l in f:
         fields = l.split()
         if fields[0] == ""MEM"":
             # mem, timestamp
-            mdata.append((fields[1], fields[2]))
+            mem_usage.append(float(fields[1]))
+            timestamp.append(float(fields[2]))
 
         elif fields[0] == ""FUNC"":
             f_name, mem_start, start, mem_end, end = fields[1:]
-            ts = ret.get(f_name, [])
-            ts.append([float(start), float(end), float(mem_start), float(mem_end)])
-            ret[f_name] = ts
+            ts = func_ts.get(f_name, [])
+            ts.append([float(start), float(end),
+                       float(mem_start), float(mem_end)])
+            func_ts[f_name] = ts
 
         else:
             pass
     f.close()
 
-    mdata = np.asarray(mdata,
-                       dtype=[(""mem"", np.float), (""timestamp"", np.float)])
-    return mdata, ret
+    ## mdata = np.asarray(mdata,
+    ##                    dtype=[(""mem"", np.float), (""timestamp"", np.float)])
+    return {""mem_usage"": mem_usage, ""timestamp"": timestamp,
+            ""func_timestamp"": func_ts}
 
 
 
@@ -293,16 +308,16 @@ def plot_file(filename, index=0, timestamps=True):
     except ImportError:
         print(""matplotlib is needed for plotting."")
         sys.exit(1)
+    import numpy as np  # pylab requires numpy anyway
+    mprofile = read_mprofile_file(filename)
 
-    mdata, ts = read_mprofile_file(filename)
-
-    global_start = float(mdata[""timestamp""][0])
+    global_start = float(mprofile[""timestamp""][0])
 
-    mem = mdata[""mem""]
+    mem = np.asarray(mprofile[""mem_usage""])
     max_mem = mem.max()
     max_mem_ind = mem.argmax()
 
-    t = mdata[""timestamp""] - global_start
+    t = np.asarray(mprofile[""timestamp""]) - global_start
 
     all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
     mem_line_colors=('k', ""b"", ""r"")
@@ -318,6 +333,7 @@ def plot_file(filename, index=0, timestamps=True):
     top -= 0.001
 
     # plot timestamps, if any
+    ts = mprofile['func_timestamp']
     if len(ts) > 0 and timestamps:
         func_num = 0
         for f, exec_ts in ts.iteritems():
","@@ -259,31 +259,46 @@ def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
 
 
 def read_mprofile_file(filename):
-    # TODO: would be nice to do without numpy
+    """"""Read an mprofile file and return its content.
 
-    import numpy as np
-    ret = {}
-    mdata = []
+    Returns
+    =======
+    content: dict
+        Keys:
+
+        - ""mem_usage"": (list) memory usage values, in MiB
+        - ""timestamp"": (list) time instant for each memory usage value, in
+            second
+        - ""func_timestamp"": (dict) for each function, timestamps and memory
+            usage upon entering and exiting.
+    """"""
+#    import numpy as np
+    func_ts = {}
+    mem_usage = []
+    timestamp = []
     f = open(filename, ""r"")
     for l in f:
         fields = l.split()
         if fields[0] == ""MEM"":
             # mem, timestamp
-            mdata.append((fields[1], fields[2]))
+            mem_usage.append(float(fields[1]))
+            timestamp.append(float(fields[2]))
 
         elif fields[0] == ""FUNC"":
             f_name, mem_start, start, mem_end, end = fields[1:]
-            ts = ret.get(f_name, [])
-            ts.append([float(start), float(end), float(mem_start), float(mem_end)])
-            ret[f_name] = ts
+            ts = func_ts.get(f_name, [])
+            ts.append([float(start), float(end),
+                       float(mem_start), float(mem_end)])
+            func_ts[f_name] = ts
 
         else:
             pass
     f.close()
 
-    mdata = np.asarray(mdata,
-                       dtype=[(""mem"", np.float), (""timestamp"", np.float)])
-    return mdata, ret
+    ## mdata = np.asarray(mdata,
+    ##                    dtype=[(""mem"", np.float), (""timestamp"", np.float)])
+    return {""mem_usage"": mem_usage, ""timestamp"": timestamp,
+            ""func_timestamp"": func_ts}
 
 
 
@@ -293,16 +308,16 @@ def plot_file(filename, index=0, timestamps=True):
     except ImportError:
         print(""matplotlib is needed for plotting."")
         sys.exit(1)
+    import numpy as np  # pylab requires numpy anyway
+    mprofile = read_mprofile_file(filename)
 
-    mdata, ts = read_mprofile_file(filename)
+    global_start = float(mprofile[""timestamp""][0])
 
-    global_start = float(mdata[""timestamp""][0])
-
-    mem = mdata[""mem""]
+    mem = np.asarray(mprofile[""mem_usage""])
     max_mem = mem.max()
     max_mem_ind = mem.argmax()
 
-    t = mdata[""timestamp""] - global_start
+    t = np.asarray(mprofile[""timestamp""]) - global_start
 
     all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
     mem_line_colors=('k', ""b"", ""r"")
@@ -318,6 +333,7 @@ def plot_file(filename, index=0, timestamps=True):
     top -= 0.001
 
     # plot timestamps, if any
+    ts = mprofile['func_timestamp']
     if len(ts) > 0 and timestamps:
         func_num = 0
         for f, exec_ts in ts.iteritems():
",False,mprof,False
"@@ -272,7 +272,6 @@ def read_mprofile_file(filename):
         - ""func_timestamp"": (dict) for each function, timestamps and memory
             usage upon entering and exiting.
     """"""
-#    import numpy as np
     func_ts = {}
     mem_usage = []
     timestamp = []
@@ -295,10 +294,8 @@ def read_mprofile_file(filename):
             pass
     f.close()
 
-    ## mdata = np.asarray(mdata,
-    ##                    dtype=[(""mem"", np.float), (""timestamp"", np.float)])
     return {""mem_usage"": mem_usage, ""timestamp"": timestamp,
-            ""func_timestamp"": func_ts}
+            ""func_timestamp"": func_ts, 'filename': filename}
 
 
 
@@ -311,6 +308,14 @@ def plot_file(filename, index=0, timestamps=True):
     import numpy as np  # pylab requires numpy anyway
     mprofile = read_mprofile_file(filename)
 
+    if len(mprofile['timestamp']) == 0:
+        print('** No memory usage values have been found in the profile '
+              'file.**\nFile path: {0}\n'
+              'File may be empty or invalid.\n'
+              'It can be deleted with ""mprof rm {0}""'.format(
+              mprofile['filename']))
+        sys.exit(0)
+
     global_start = float(mprofile[""timestamp""][0])
 
     mem = np.asarray(mprofile[""mem_usage""])
","@@ -272,7 +272,6 @@ def read_mprofile_file(filename):
         - ""func_timestamp"": (dict) for each function, timestamps and memory
             usage upon entering and exiting.
     """"""
-#    import numpy as np
     func_ts = {}
     mem_usage = []
     timestamp = []
@@ -295,10 +294,8 @@ def read_mprofile_file(filename):
             pass
     f.close()
 
-    ## mdata = np.asarray(mdata,
-    ##                    dtype=[(""mem"", np.float), (""timestamp"", np.float)])
     return {""mem_usage"": mem_usage, ""timestamp"": timestamp,
-            ""func_timestamp"": func_ts}
+            ""func_timestamp"": func_ts, 'filename': filename}
 
 
 
@@ -311,6 +308,14 @@ def plot_file(filename, index=0, timestamps=True):
     import numpy as np  # pylab requires numpy anyway
     mprofile = read_mprofile_file(filename)
 
+    if len(mprofile['timestamp']) == 0:
+        print('** No memory usage values have been found in the profile '
+              'file.**\nFile path: {0}\n'
+              'File may be empty or invalid.\n'
+              'It can be deleted with ""mprof rm {0}""'.format(
+              mprofile['filename']))
+        sys.exit(0)
+
     global_start = float(mprofile[""timestamp""][0])
 
     mem = np.asarray(mprofile[""mem_usage""])
",True,mprof,False
"@@ -157,6 +157,12 @@ def clean_action():
             os.remove(filename)
 
 
+def get_cmd_line(args):
+    """"""Given a set or arguments, compute command-line.""""""
+    blanks = set(' \t')
+    args = [s if blanks.isdisjoint(s) else ""'"" + s + ""'"" for s in args]
+    return ' '.join(args)
+
 
 def run_action():
     import time, subprocess
@@ -200,15 +206,18 @@ def run_action():
         print(""running as a Python program..."")
         if not args[0].startswith(""python""):
             args.insert(0, ""python"")
+        cmd_line = get_cmd_line(args)
         args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
                      ""-o"", mprofile_output)
         p = subprocess.Popen(args)
     else:
+        cmd_line = get_cmd_line(args)
         p = subprocess.Popen(args)
 
-    mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
-                         include_children=options.include_children)
     with open(mprofile_output, ""a"") as f:
+        f.write(""CMDLINE {0}\n"".format(cmd_line))
+        mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
+                         include_children=options.include_children)
         for m, t in mu:
             f.write(""MEM {0:.6f} {1:.4f}"".format(m, t) + ""\n"")
 
@@ -271,31 +280,38 @@ def read_mprofile_file(filename):
             second
         - ""func_timestamp"": (dict) for each function, timestamps and memory
             usage upon entering and exiting.
+        - 'cmd_line': (str) command-line ran for this profile.
     """"""
     func_ts = {}
     mem_usage = []
     timestamp = []
+    cmd_line = None
     f = open(filename, ""r"")
     for l in f:
-        fields = l.split()
-        if fields[0] == ""MEM"":
+        field, value = l.split(' ', 1)
+        if field == ""MEM"":
             # mem, timestamp
-            mem_usage.append(float(fields[1]))
-            timestamp.append(float(fields[2]))
+            values = value.split(' ')
+            mem_usage.append(float(values[0]))
+            timestamp.append(float(values[1]))
 
-        elif fields[0] == ""FUNC"":
-            f_name, mem_start, start, mem_end, end = fields[1:]
+        elif field == ""FUNC"":
+            values = value.split(' ')
+            f_name, mem_start, start, mem_end, end = values[:5]
             ts = func_ts.get(f_name, [])
             ts.append([float(start), float(end),
                        float(mem_start), float(mem_end)])
             func_ts[f_name] = ts
 
+        elif field == ""CMDLINE"":
+            cmd_line = value
         else:
             pass
     f.close()
 
     return {""mem_usage"": mem_usage, ""timestamp"": timestamp,
-            ""func_timestamp"": func_ts, 'filename': filename}
+            ""func_timestamp"": func_ts, 'filename': filename,
+            'cmd_line': cmd_line}
 
 
 
@@ -355,6 +371,7 @@ def plot_file(filename, index=0, timestamps=True):
                   colors=""r"", linestyles=""--"")
         pl.vlines(t[max_mem_ind], bottom, top,
                   colors=""r"", linestyles=""--"")
+    return mprofile
 
 
 def plot_action():
@@ -366,7 +383,7 @@ def plot_action():
 
     parser = OptionParser(version=mp.__version__)
     parser.disable_interspersed_args()
-    parser.add_option(""--title"", ""-t"", dest=""title"", default="""",
+    parser.add_option(""--title"", ""-t"", dest=""title"", default=None,
                       type=""str"", action=""store"",
                       help=""String shown as plot title"")
     (options, args) = parser.parse_args()
@@ -401,10 +418,16 @@ def plot_action():
     else:
         timestamps = True
     for n, filename in enumerate(filenames):
-        plot_file(filename, index=n, timestamps=timestamps)
+        mprofile = plot_file(filename, index=n, timestamps=timestamps)
     pl.xlabel(""time (in seconds)"")
     pl.ylabel(""memory used (in MiB)"")
-    pl.title(options.title)
+
+    if options.title is None and len(filenames) == 1:
+        pl.title(mprofile['cmd_line'])
+    else:
+        if options.title is not None:
+            pl.title(options.title)
+
     ax = pl.gca()
     box = ax.get_position()
     ax.set_position([0.07, 0.1,
","@@ -157,6 +157,12 @@ def clean_action():
             os.remove(filename)
 
 
+def get_cmd_line(args):
+    """"""Given a set or arguments, compute command-line.""""""
+    blanks = set(' \t')
+    args = [s if blanks.isdisjoint(s) else ""'"" + s + ""'"" for s in args]
+    return ' '.join(args)
+
 
 def run_action():
     import time, subprocess
@@ -200,15 +206,18 @@ def run_action():
         print(""running as a Python program..."")
         if not args[0].startswith(""python""):
             args.insert(0, ""python"")
+        cmd_line = get_cmd_line(args)
         args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
                      ""-o"", mprofile_output)
         p = subprocess.Popen(args)
     else:
+        cmd_line = get_cmd_line(args)
         p = subprocess.Popen(args)
 
-    mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
-                         include_children=options.include_children)
     with open(mprofile_output, ""a"") as f:
+        f.write(""CMDLINE {0}\n"".format(cmd_line))
+        mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
+                         include_children=options.include_children)
         for m, t in mu:
             f.write(""MEM {0:.6f} {1:.4f}"".format(m, t) + ""\n"")
 
@@ -271,31 +280,38 @@ def read_mprofile_file(filename):
             second
         - ""func_timestamp"": (dict) for each function, timestamps and memory
             usage upon entering and exiting.
+        - 'cmd_line': (str) command-line ran for this profile.
     """"""
     func_ts = {}
     mem_usage = []
     timestamp = []
+    cmd_line = None
     f = open(filename, ""r"")
     for l in f:
-        fields = l.split()
-        if fields[0] == ""MEM"":
+        field, value = l.split(' ', 1)
+        if field == ""MEM"":
             # mem, timestamp
-            mem_usage.append(float(fields[1]))
-            timestamp.append(float(fields[2]))
+            values = value.split(' ')
+            mem_usage.append(float(values[0]))
+            timestamp.append(float(values[1]))
 
-        elif fields[0] == ""FUNC"":
-            f_name, mem_start, start, mem_end, end = fields[1:]
+        elif field == ""FUNC"":
+            values = value.split(' ')
+            f_name, mem_start, start, mem_end, end = values[:5]
             ts = func_ts.get(f_name, [])
             ts.append([float(start), float(end),
                        float(mem_start), float(mem_end)])
             func_ts[f_name] = ts
 
+        elif field == ""CMDLINE"":
+            cmd_line = value
         else:
             pass
     f.close()
 
     return {""mem_usage"": mem_usage, ""timestamp"": timestamp,
-            ""func_timestamp"": func_ts, 'filename': filename}
+            ""func_timestamp"": func_ts, 'filename': filename,
+            'cmd_line': cmd_line}
 
 
 
@@ -355,6 +371,7 @@ def plot_file(filename, index=0, timestamps=True):
                   colors=""r"", linestyles=""--"")
         pl.vlines(t[max_mem_ind], bottom, top,
                   colors=""r"", linestyles=""--"")
+    return mprofile
 
 
 def plot_action():
@@ -366,7 +383,7 @@ def plot_action():
 
     parser = OptionParser(version=mp.__version__)
     parser.disable_interspersed_args()
-    parser.add_option(""--title"", ""-t"", dest=""title"", default="""",
+    parser.add_option(""--title"", ""-t"", dest=""title"", default=None,
                       type=""str"", action=""store"",
                       help=""String shown as plot title"")
     (options, args) = parser.parse_args()
@@ -401,10 +418,16 @@ def plot_action():
     else:
         timestamps = True
     for n, filename in enumerate(filenames):
-        plot_file(filename, index=n, timestamps=timestamps)
+        mprofile = plot_file(filename, index=n, timestamps=timestamps)
     pl.xlabel(""time (in seconds)"")
     pl.ylabel(""memory used (in MiB)"")
-    pl.title(options.title)
+
+    if options.title is None and len(filenames) == 1:
+        pl.title(mprofile['cmd_line'])
+    else:
+        if options.title is not None:
+            pl.title(options.title)
+
     ax = pl.gca()
     box = ax.get_position()
     ax.set_position([0.07, 0.1,
",True,mprof,False
"@@ -332,14 +332,30 @@ def plot_file(filename, index=0, timestamps=True):
               mprofile['filename']))
         sys.exit(0)
 
-    global_start = float(mprofile[""timestamp""][0])
+    # Merge function timestamps and memory usage together
+    ts = mprofile['func_timestamp']
+    t = mprofile['timestamp']
+    mem = mprofile['mem_usage']
+
+    if len(ts) > 0:
+        for values in ts.itervalues():
+            for v in values:
+                t.extend(v[:2])
+                mem.extend(v[2:4])
+
+    mem = np.asarray(mem)
+    t = np.asarray(t)
+    ind = t.argsort()
+    mem = mem[ind]
+    t = t[ind]
+
+    # Plot curves
+    global_start = float(t[0])
+    t = t - global_start
 
-    mem = np.asarray(mprofile[""mem_usage""])
     max_mem = mem.max()
     max_mem_ind = mem.argmax()
 
-    t = np.asarray(mprofile[""timestamp""]) - global_start
-
     all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
     mem_line_colors=('k', ""b"", ""r"")
     mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
@@ -354,7 +370,6 @@ def plot_file(filename, index=0, timestamps=True):
     top -= 0.001
 
     # plot timestamps, if any
-    ts = mprofile['func_timestamp']
     if len(ts) > 0 and timestamps:
         func_num = 0
         for f, exec_ts in ts.iteritems():
@@ -386,6 +401,9 @@ def plot_action():
     parser.add_option(""--title"", ""-t"", dest=""title"", default=None,
                       type=""str"", action=""store"",
                       help=""String shown as plot title"")
+    parser.add_option(""--no-function-ts"", ""-n"", dest=""no_timestamps"",
+                      default=False, action=""store_true"",
+                      help=""Do not display function timestamps on plot."")
     (options, args) = parser.parse_args()
 
     profiles = glob.glob(""mprofile_??????????????.dat"")
@@ -413,7 +431,7 @@ def plot_action():
                     filenames.append(profiles[n])
 
     pl.figure(figsize=(14, 6), dpi=90)
-    if len(filenames) > 1:
+    if len(filenames) > 1 or options.no_timestamps:
         timestamps = False
     else:
         timestamps = True
","@@ -332,14 +332,30 @@ def plot_file(filename, index=0, timestamps=True):
               mprofile['filename']))
         sys.exit(0)
 
-    global_start = float(mprofile[""timestamp""][0])
+    # Merge function timestamps and memory usage together
+    ts = mprofile['func_timestamp']
+    t = mprofile['timestamp']
+    mem = mprofile['mem_usage']
+
+    if len(ts) > 0:
+        for values in ts.itervalues():
+            for v in values:
+                t.extend(v[:2])
+                mem.extend(v[2:4])
+
+    mem = np.asarray(mem)
+    t = np.asarray(t)
+    ind = t.argsort()
+    mem = mem[ind]
+    t = t[ind]
+
+    # Plot curves
+    global_start = float(t[0])
+    t = t - global_start
 
-    mem = np.asarray(mprofile[""mem_usage""])
     max_mem = mem.max()
     max_mem_ind = mem.argmax()
 
-    t = np.asarray(mprofile[""timestamp""]) - global_start
-
     all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
     mem_line_colors=('k', ""b"", ""r"")
     mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
@@ -354,7 +370,6 @@ def plot_file(filename, index=0, timestamps=True):
     top -= 0.001
 
     # plot timestamps, if any
-    ts = mprofile['func_timestamp']
     if len(ts) > 0 and timestamps:
         func_num = 0
         for f, exec_ts in ts.iteritems():
@@ -386,6 +401,9 @@ def plot_action():
     parser.add_option(""--title"", ""-t"", dest=""title"", default=None,
                       type=""str"", action=""store"",
                       help=""String shown as plot title"")
+    parser.add_option(""--no-function-ts"", ""-n"", dest=""no_timestamps"",
+                      default=False, action=""store_true"",
+                      help=""Do not display function timestamps on plot."")
     (options, args) = parser.parse_args()
 
     profiles = glob.glob(""mprofile_??????????????.dat"")
@@ -413,7 +431,7 @@ def plot_action():
                     filenames.append(profiles[n])
 
     pl.figure(figsize=(14, 6), dpi=90)
-    if len(filenames) > 1:
+    if len(filenames) > 1 or options.no_timestamps:
         timestamps = False
     else:
         timestamps = True
",True,mprof,False
"@@ -128,7 +128,8 @@ class Timer(Process):
 
 
 def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
-                 include_children=False, max_usage=False, retval=False):
+                 include_children=False, max_usage=False, retval=False,
+                 stream=None):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -148,14 +149,23 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     timeout : float, optional
         Maximum amount of time (in seconds) to wait before returning.
 
-    max_usage: bool, optional
+    max_usage : bool, optional
         Only return the maximum memory usage (default False)
 
-    retval: bool, optional
+    retval : bool, optional
         For profiling python functions. Save the return value of the profiled
         function. Return value of memory_usage becomes a tuple:
         (mem_usage, retval)
 
+    timestamps : bool, optional
+        if True, timestamps of memory usage measurement are collected as well.
+
+    stream : File
+        if stream is a File opened with write access, then results are written
+        to this file instead of stored in memory and returned at the end of
+        the subprocess. Useful for long-running processes.
+        Implies timestamps=True.
+
     Returns
     -------
     mem_usage : list of floating-poing values
@@ -164,6 +174,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         Only returned if retval is set to True
     """"""
 
+    if stream is not None:
+        timestamps = True
+
     if not max_usage:
         ret = []
     else:
@@ -211,15 +224,25 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         p.join(5 * interval)
     elif isinstance(proc, subprocess.Popen):
         # external process, launched from Python
+        line_count = 0
         while True:
             if not max_usage:
-                ret.append(_get_memory(proc.pid, timestamps=timestamps,
-                                       include_children=include_children))
+                mem_usage = _get_memory(proc.pid, timestamps=timestamps,
+                                        include_children=include_children)
+                if stream:
+                    stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
+                else:
+                    ret.append(mem_usage)
             else:
                 ret = max([ret,
                            _get_memory(proc.pid,
                                        include_children=include_children)])
             time.sleep(interval)
+            line_count += 1
+            # flush every 50 lines. Make 'tail -f' usable on profile file
+            if line_count > 50:
+                line_count = 0
+                stream.flush()
             if timeout is not None:
                 max_iter -= 1
                 if max_iter == 0:
@@ -234,14 +257,23 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         while counter < max_iter:
             counter += 1
             if not max_usage:
-                ret.append(_get_memory(proc, timestamps=timestamps,
-                                       include_children=include_children))
+                mem_usage = _get_memory(proc, timestamps=timestamps,
+                                        include_children=include_children)
+                if stream:
+                    stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
+                else:
+                    ret.append(mem_usage)
             else:
                 ret = max([ret,
                            _get_memory(proc, include_children=include_children)
                            ])
 
             time.sleep(interval)
+            # Flush every 50 lines.
+            if counter % 50 == 0:
+                stream.flush()
+    if stream:
+        return None
     return ret
 
 # ..
","@@ -128,7 +128,8 @@ class Timer(Process):
 
 
 def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
-                 include_children=False, max_usage=False, retval=False):
+                 include_children=False, max_usage=False, retval=False,
+                 stream=None):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -148,14 +149,23 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     timeout : float, optional
         Maximum amount of time (in seconds) to wait before returning.
 
-    max_usage: bool, optional
+    max_usage : bool, optional
         Only return the maximum memory usage (default False)
 
-    retval: bool, optional
+    retval : bool, optional
         For profiling python functions. Save the return value of the profiled
         function. Return value of memory_usage becomes a tuple:
         (mem_usage, retval)
 
+    timestamps : bool, optional
+        if True, timestamps of memory usage measurement are collected as well.
+
+    stream : File
+        if stream is a File opened with write access, then results are written
+        to this file instead of stored in memory and returned at the end of
+        the subprocess. Useful for long-running processes.
+        Implies timestamps=True.
+
     Returns
     -------
     mem_usage : list of floating-poing values
@@ -164,6 +174,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         Only returned if retval is set to True
     """"""
 
+    if stream is not None:
+        timestamps = True
+
     if not max_usage:
         ret = []
     else:
@@ -211,15 +224,25 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         p.join(5 * interval)
     elif isinstance(proc, subprocess.Popen):
         # external process, launched from Python
+        line_count = 0
         while True:
             if not max_usage:
-                ret.append(_get_memory(proc.pid, timestamps=timestamps,
-                                       include_children=include_children))
+                mem_usage = _get_memory(proc.pid, timestamps=timestamps,
+                                        include_children=include_children)
+                if stream:
+                    stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
+                else:
+                    ret.append(mem_usage)
             else:
                 ret = max([ret,
                            _get_memory(proc.pid,
                                        include_children=include_children)])
             time.sleep(interval)
+            line_count += 1
+            # flush every 50 lines. Make 'tail -f' usable on profile file
+            if line_count > 50:
+                line_count = 0
+                stream.flush()
             if timeout is not None:
                 max_iter -= 1
                 if max_iter == 0:
@@ -234,14 +257,23 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         while counter < max_iter:
             counter += 1
             if not max_usage:
-                ret.append(_get_memory(proc, timestamps=timestamps,
-                                       include_children=include_children))
+                mem_usage = _get_memory(proc, timestamps=timestamps,
+                                        include_children=include_children)
+                if stream:
+                    stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
+                else:
+                    ret.append(mem_usage)
             else:
                 ret = max([ret,
                            _get_memory(proc, include_children=include_children)
                            ])
 
             time.sleep(interval)
+            # Flush every 50 lines.
+            if counter % 50 == 0:
+                stream.flush()
+    if stream:
+        return None
     return ret
 
 # ..
",True,memory_profiler.py,True
"@@ -206,12 +206,9 @@ def run_action():
     else:
         p = subprocess.Popen(args)
 
-    mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
-                         include_children=options.include_children)
     with open(mprofile_output, ""a"") as f:
-        for m, t in mu:
-            f.write(""MEM {0:.6f} {1:.4f}"".format(m, t) + ""\n"")
-
+        mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
+                        include_children=options.include_children, stream=f)
 
 
 def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
","@@ -206,12 +206,9 @@ def run_action():
     else:
         p = subprocess.Popen(args)
 
-    mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
-                         include_children=options.include_children)
     with open(mprofile_output, ""a"") as f:
-        for m, t in mu:
-            f.write(""MEM {0:.6f} {1:.4f}"".format(m, t) + ""\n"")
-
+        mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
+                        include_children=options.include_children, stream=f)
 
 
 def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
",True,mprof,False
"@@ -314,7 +314,8 @@ Projects using memory_profiler
 =========
  Authors
 =========
-This module was written by `Fabian Pedregosa <http://fseoane.net>`_
+This module was written by `Fabian Pedregosa <http://fseoane.net>`_ 
+and `Philippe Gervais <https://github.com/pgervais>`_
 inspired by Robert Kern's `line profiler
 <http://packages.python.org/line_profiler/>`_.
 
@@ -328,9 +329,6 @@ cleanup.
 
 `Thomas Kluyver <https://github.com/takluyver>`_ added the IPython extension.
 
-`Philippe Gervais <https://github.com/pgervais>`_ created the 'mprof'
-script and fixed bugs. 
-
 
 =========
  License
","@@ -314,7 +314,8 @@ Projects using memory_profiler
 =========
  Authors
 =========
-This module was written by `Fabian Pedregosa <http://fseoane.net>`_
+This module was written by `Fabian Pedregosa <http://fseoane.net>`_ 
+and `Philippe Gervais <https://github.com/pgervais>`_
 inspired by Robert Kern's `line profiler
 <http://packages.python.org/line_profiler/>`_.
 
@@ -328,9 +329,6 @@ cleanup.
 
 `Thomas Kluyver <https://github.com/takluyver>`_ added the IPython extension.
 
-`Philippe Gervais <https://github.com/pgervais>`_ created the 'mprof'
-script and fixed bugs. 
-
 
 =========
  License
",True,README.rst,False
"@@ -229,7 +229,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             if not max_usage:
                 mem_usage = _get_memory(proc.pid, timestamps=timestamps,
                                         include_children=include_children)
-                if stream:
+                if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
                 else:
                     ret.append(mem_usage)
@@ -242,7 +242,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             # flush every 50 lines. Make 'tail -f' usable on profile file
             if line_count > 50:
                 line_count = 0
-                stream.flush()
+                if stream is not None:
+                    stream.flush()
             if timeout is not None:
                 max_iter -= 1
                 if max_iter == 0:
@@ -259,7 +260,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             if not max_usage:
                 mem_usage = _get_memory(proc, timestamps=timestamps,
                                         include_children=include_children)
-                if stream:
+                if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
                 else:
                     ret.append(mem_usage)
@@ -270,7 +271,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
             time.sleep(interval)
             # Flush every 50 lines.
-            if counter % 50 == 0:
+            if counter % 50 == 0 and stream is not None:
                 stream.flush()
     if stream:
         return None
","@@ -229,7 +229,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             if not max_usage:
                 mem_usage = _get_memory(proc.pid, timestamps=timestamps,
                                         include_children=include_children)
-                if stream:
+                if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
                 else:
                     ret.append(mem_usage)
@@ -242,7 +242,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             # flush every 50 lines. Make 'tail -f' usable on profile file
             if line_count > 50:
                 line_count = 0
-                stream.flush()
+                if stream is not None:
+                    stream.flush()
             if timeout is not None:
                 max_iter -= 1
                 if max_iter == 0:
@@ -259,7 +260,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             if not max_usage:
                 mem_usage = _get_memory(proc, timestamps=timestamps,
                                         include_children=include_children)
-                if stream:
+                if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
                 else:
                     ret.append(mem_usage)
@@ -270,7 +271,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
             time.sleep(interval)
             # Flush every 50 lines.
-            if counter % 50 == 0:
+            if counter % 50 == 0 and stream is not None:
                 stream.flush()
     if stream:
         return None
",True,memory_profiler.py,True
"@@ -216,10 +216,8 @@ def run_action():
 
     with open(mprofile_output, ""a"") as f:
         f.write(""CMDLINE {0}\n"".format(cmd_line))
-        mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
-                         include_children=options.include_children)
-        for m, t in mu:
-            f.write(""MEM {0:.6f} {1:.4f}"".format(m, t) + ""\n"")
+        mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
+                         include_children=options.include_children, stream=f)
 
 
 def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
","@@ -216,10 +216,8 @@ def run_action():
 
     with open(mprofile_output, ""a"") as f:
         f.write(""CMDLINE {0}\n"".format(cmd_line))
-        mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
-                         include_children=options.include_children)
-        for m, t in mu:
-            f.write(""MEM {0:.6f} {1:.4f}"".format(m, t) + ""\n"")
+        mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
+                         include_children=options.include_children, stream=f)
 
 
 def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
",True,mprof,False
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
-__version__ = '0.27'
+__version__ = '0.28'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
-__version__ = '0.27'
+__version__ = '0.28'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -379,10 +379,10 @@ class LineProfiler:
     """""" A profiler that records the amount of memory for each line """"""
 
     def __init__(self, **kw):
-        self.functions = list()
         self.code_map = {}
         self.enable_count = 0
         self.max_mem = kw.get('max_mem', None)
+        self.prevline = None        
 
     def __call__(self, func):
         self.add_function(func)
@@ -406,7 +406,6 @@ class LineProfiler:
             return
         if code not in self.code_map:
             self.code_map[code] = {}
-            self.functions.append(func)
 
     def wrap_function(self, func):
         """""" Wrap a function to profile it.
@@ -456,13 +455,12 @@ class LineProfiler:
 
     def trace_memory_usage(self, frame, event, arg):
         """"""Callback for sys.settrace""""""
-        if event in ('line', 'return') and frame.f_code in self.code_map:
-            lineno = frame.f_lineno
-            if event == 'return':
-                lineno += 1
-            entry = self.code_map[frame.f_code].setdefault(lineno, [])
-            entry.append(_get_memory(-1))
-
+        if event in ('call', 'line', 'return') and frame.f_code in self.code_map:
+            if event != 'call':
+                # ""call"" event just saves the lineno but not the memory
+                mem = _get_memory(-1)                
+                self.code_map[frame.f_code][self.prevline] = mem
+            self.prevline = frame.f_lineno
         return self.trace_memory_usage
 
     def trace_max_mem(self, frame, event, arg):
@@ -525,44 +523,26 @@ def show_results(prof, stream=None, precision=1):
             continue
         all_lines = linecache.getlines(filename)
         sub_lines = inspect.getblock(all_lines[code.co_firstlineno - 1:])
-        linenos = range(code.co_firstlineno, code.co_firstlineno +
-                        len(sub_lines))
-        lines_normalized = {}
-
+        linenos = range(code.co_firstlineno,
+                        code.co_firstlineno + len(sub_lines))
+        
         header = template.format('Line #', 'Mem usage', 'Increment',
                                  'Line Contents')
         stream.write(header + '\n')
         stream.write('=' * len(header) + '\n')
-        # move everything one frame up
-        keys = sorted(lines.keys())
-
-        k_old = keys[0] - 1
-        lines_normalized[keys[0] - 1] = lines[keys[0]]
-        for i in range(1, len(lines_normalized[keys[0] - 1])):
-            lines_normalized[keys[0] - 1][i] = -1.
-        k = keys.pop(0)
-        while keys:
-            lines_normalized[k] = lines[keys[0]]
-            for i in range(len(lines_normalized[k_old]),
-                           len(lines_normalized[k])):
-                lines_normalized[k][i] = -1.
-            k_old = k
-            k = keys.pop(0)
-
-        first_line = sorted(lines_normalized.keys())[0]
-        mem_old = max(lines_normalized[first_line])
-        precision = int(precision)
+
+        mem_old = lines[min(lines.keys())]        
         template_mem = '{{0:{0}.{1}'.format(precision + 4, precision) + 'f} MiB'
-        for i, l in enumerate(linenos):
+        for line in linenos:
             mem = ''
             inc = ''
-            if l in lines_normalized:
-                mem = max(lines_normalized[l])
+            if line in lines:
+                mem = lines[line]
                 inc = mem - mem_old
                 mem_old = mem
                 mem = template_mem.format(mem)
                 inc = template_mem.format(inc)
-            stream.write(template.format(l, mem, inc, sub_lines[i]))
+            stream.write(template.format(line, mem, inc, all_lines[line - 1]))
         stream.write('\n\n')
 
 
","@@ -379,10 +379,10 @@ class LineProfiler:
     """""" A profiler that records the amount of memory for each line """"""
 
     def __init__(self, **kw):
-        self.functions = list()
         self.code_map = {}
         self.enable_count = 0
         self.max_mem = kw.get('max_mem', None)
+        self.prevline = None        
 
     def __call__(self, func):
         self.add_function(func)
@@ -406,7 +406,6 @@ class LineProfiler:
             return
         if code not in self.code_map:
             self.code_map[code] = {}
-            self.functions.append(func)
 
     def wrap_function(self, func):
         """""" Wrap a function to profile it.
@@ -456,13 +455,12 @@ class LineProfiler:
 
     def trace_memory_usage(self, frame, event, arg):
         """"""Callback for sys.settrace""""""
-        if event in ('line', 'return') and frame.f_code in self.code_map:
-            lineno = frame.f_lineno
-            if event == 'return':
-                lineno += 1
-            entry = self.code_map[frame.f_code].setdefault(lineno, [])
-            entry.append(_get_memory(-1))
-
+        if event in ('call', 'line', 'return') and frame.f_code in self.code_map:
+            if event != 'call':
+                # ""call"" event just saves the lineno but not the memory
+                mem = _get_memory(-1)                
+                self.code_map[frame.f_code][self.prevline] = mem
+            self.prevline = frame.f_lineno
         return self.trace_memory_usage
 
     def trace_max_mem(self, frame, event, arg):
@@ -525,44 +523,26 @@ def show_results(prof, stream=None, precision=1):
             continue
         all_lines = linecache.getlines(filename)
         sub_lines = inspect.getblock(all_lines[code.co_firstlineno - 1:])
-        linenos = range(code.co_firstlineno, code.co_firstlineno +
-                        len(sub_lines))
-        lines_normalized = {}
-
+        linenos = range(code.co_firstlineno,
+                        code.co_firstlineno + len(sub_lines))
+        
         header = template.format('Line #', 'Mem usage', 'Increment',
                                  'Line Contents')
         stream.write(header + '\n')
         stream.write('=' * len(header) + '\n')
-        # move everything one frame up
-        keys = sorted(lines.keys())
 
-        k_old = keys[0] - 1
-        lines_normalized[keys[0] - 1] = lines[keys[0]]
-        for i in range(1, len(lines_normalized[keys[0] - 1])):
-            lines_normalized[keys[0] - 1][i] = -1.
-        k = keys.pop(0)
-        while keys:
-            lines_normalized[k] = lines[keys[0]]
-            for i in range(len(lines_normalized[k_old]),
-                           len(lines_normalized[k])):
-                lines_normalized[k][i] = -1.
-            k_old = k
-            k = keys.pop(0)
-
-        first_line = sorted(lines_normalized.keys())[0]
-        mem_old = max(lines_normalized[first_line])
-        precision = int(precision)
+        mem_old = lines[min(lines.keys())]        
         template_mem = '{{0:{0}.{1}'.format(precision + 4, precision) + 'f} MiB'
-        for i, l in enumerate(linenos):
+        for line in linenos:
             mem = ''
             inc = ''
-            if l in lines_normalized:
-                mem = max(lines_normalized[l])
+            if line in lines:
+                mem = lines[line]
                 inc = mem - mem_old
                 mem_old = mem
                 mem = template_mem.format(mem)
                 inc = template_mem.format(inc)
-            stream.write(template.format(l, mem, inc, sub_lines[i]))
+            stream.write(template.format(line, mem, inc, all_lines[line - 1]))
         stream.write('\n\n')
 
 
",False,memory_profiler.py,True
"@@ -458,8 +458,10 @@ class LineProfiler:
         if event in ('call', 'line', 'return') and frame.f_code in self.code_map:
             if event != 'call':
                 # ""call"" event just saves the lineno but not the memory
-                mem = _get_memory(-1)                
-                self.code_map[frame.f_code][self.prevline] = mem
+                mem = _get_memory(-1)
+                # if there is already a measurement for that line get the max
+                old_mem = self.code_map[frame.f_code].get(self.prevline, 0)
+                self.code_map[frame.f_code][self.prevline] = max(mem, old_mem)
             self.prevline = frame.f_lineno
         return self.trace_memory_usage
 
","@@ -458,8 +458,10 @@ class LineProfiler:
         if event in ('call', 'line', 'return') and frame.f_code in self.code_map:
             if event != 'call':
                 # ""call"" event just saves the lineno but not the memory
-                mem = _get_memory(-1)                
-                self.code_map[frame.f_code][self.prevline] = mem
+                mem = _get_memory(-1)
+                # if there is already a measurement for that line get the max
+                old_mem = self.code_map[frame.f_code].get(self.prevline, 0)
+                self.code_map[frame.f_code][self.prevline] = max(mem, old_mem)
             self.prevline = frame.f_lineno
         return self.trace_memory_usage
 
",True,memory_profiler.py,True
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
-__version__ = '0.28'
+__version__ = '0.29'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
-__version__ = '0.28'
+__version__ = '0.29'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -66,7 +66,8 @@ def _get_memory(pid, timestamps=False, include_children=False):
         # .. subprocess.check_output appeared in 2.7, using Popen ..
         # .. for backwards compatibility ..
         out = subprocess.Popen(['ps', 'v', '-p', str(pid)],
-              stdout=subprocess.PIPE).communicate()[0].split(b'\n')
+                               stdout=subprocess.PIPE
+                               ).communicate()[0].split(b'\n')
         try:
             vsz_index = out[0].split().index(b'RSS')
             mem = float(out[1].split()[vsz_index]) / 1024
@@ -375,14 +376,14 @@ class TimeStamper:
                     (function_name,) + ts[0] + ts[1]))
 
 
-class LineProfiler:
+class LineProfiler(object):
     """""" A profiler that records the amount of memory for each line """"""
 
     def __init__(self, **kw):
         self.code_map = {}
         self.enable_count = 0
         self.max_mem = kw.get('max_mem', None)
-        self.prevline = None        
+        self.prevline = None
 
     def __call__(self, func):
         self.add_function(func)
@@ -455,7 +456,8 @@ class LineProfiler:
 
     def trace_memory_usage(self, frame, event, arg):
         """"""Callback for sys.settrace""""""
-        if event in ('call', 'line', 'return') and frame.f_code in self.code_map:
+        if (event in ('call', 'line', 'return')
+                and frame.f_code in self.code_map):
             if event != 'call':
                 # ""call"" event just saves the lineno but not the memory
                 mem = _get_memory(-1)
@@ -527,14 +529,15 @@ def show_results(prof, stream=None, precision=1):
         sub_lines = inspect.getblock(all_lines[code.co_firstlineno - 1:])
         linenos = range(code.co_firstlineno,
                         code.co_firstlineno + len(sub_lines))
-        
+
         header = template.format('Line #', 'Mem usage', 'Increment',
                                  'Line Contents')
         stream.write(header + '\n')
         stream.write('=' * len(header) + '\n')
 
-        mem_old = lines[min(lines.keys())]        
-        template_mem = '{{0:{0}.{1}'.format(precision + 4, precision) + 'f} MiB'
+        mem_old = lines[min(lines.keys())]
+        float_format = '{0}.{1}f'.format(precision + 4, precision)
+        template_mem = '{{0:' + float_format + '} MiB'
         for line in linenos:
             mem = ''
             inc = ''
@@ -611,7 +614,7 @@ def magic_mprun(self, parameter_s=''):
             funcs.append(eval(name, global_ns, local_ns))
         except Exception as e:
             raise UsageError('Could not find function %r.\n%s: %s' % (name,
-                e.__class__.__name__, e))
+                             e.__class__.__name__, e))
 
     profile = LineProfiler()
     for func in funcs:
@@ -639,7 +642,7 @@ def magic_mprun(self, parameter_s=''):
             message = ""*** SystemExit exception caught in code being profiled.""
         except KeyboardInterrupt:
             message = (""*** KeyboardInterrupt exception caught in code being ""
-                ""profiled."")
+                       ""profiled."")
     finally:
         if had_profile:
             builtins.__dict__['profile'] = old_profile
@@ -755,10 +758,12 @@ if __name__ == '__main__':
     from optparse import OptionParser
     parser = OptionParser(usage=_CMD_USAGE, version=__version__)
     parser.disable_interspersed_args()
-    parser.add_option(""--pdb-mmem"", dest=""max_mem"", metavar=""MAXMEM"",
+    parser.add_option(
+        ""--pdb-mmem"", dest=""max_mem"", metavar=""MAXMEM"",
         type=""float"", action=""store"",
         help=""step into the debugger when memory exceeds MAXMEM"")
-    parser.add_option('--precision', dest=""precision"", type=""int"",
+    parser.add_option(
+        '--precision', dest=""precision"", type=""int"",
         action=""store"", default=3,
         help=""precision of memory output in number of significant digits"")
     parser.add_option(""-o"", dest=""out_filename"", type=""str"",
@@ -784,7 +789,7 @@ if __name__ == '__main__':
     try:
         if sys.version_info[0] < 3:
             # we need to ovewrite the builtins to have profile
-            # globally defined (global variables is not enought
+            # globally defined (global variables is not enough
             # for all cases, e.g. a script that imports another
             # script where @profile is used)
             import __builtin__
","@@ -66,7 +66,8 @@ def _get_memory(pid, timestamps=False, include_children=False):
         # .. subprocess.check_output appeared in 2.7, using Popen ..
         # .. for backwards compatibility ..
         out = subprocess.Popen(['ps', 'v', '-p', str(pid)],
-              stdout=subprocess.PIPE).communicate()[0].split(b'\n')
+                               stdout=subprocess.PIPE
+                               ).communicate()[0].split(b'\n')
         try:
             vsz_index = out[0].split().index(b'RSS')
             mem = float(out[1].split()[vsz_index]) / 1024
@@ -375,14 +376,14 @@ class TimeStamper:
                     (function_name,) + ts[0] + ts[1]))
 
 
-class LineProfiler:
+class LineProfiler(object):
     """""" A profiler that records the amount of memory for each line """"""
 
     def __init__(self, **kw):
         self.code_map = {}
         self.enable_count = 0
         self.max_mem = kw.get('max_mem', None)
-        self.prevline = None        
+        self.prevline = None
 
     def __call__(self, func):
         self.add_function(func)
@@ -455,7 +456,8 @@ class LineProfiler:
 
     def trace_memory_usage(self, frame, event, arg):
         """"""Callback for sys.settrace""""""
-        if event in ('call', 'line', 'return') and frame.f_code in self.code_map:
+        if (event in ('call', 'line', 'return')
+                and frame.f_code in self.code_map):
             if event != 'call':
                 # ""call"" event just saves the lineno but not the memory
                 mem = _get_memory(-1)
@@ -527,14 +529,15 @@ def show_results(prof, stream=None, precision=1):
         sub_lines = inspect.getblock(all_lines[code.co_firstlineno - 1:])
         linenos = range(code.co_firstlineno,
                         code.co_firstlineno + len(sub_lines))
-        
+
         header = template.format('Line #', 'Mem usage', 'Increment',
                                  'Line Contents')
         stream.write(header + '\n')
         stream.write('=' * len(header) + '\n')
 
-        mem_old = lines[min(lines.keys())]        
-        template_mem = '{{0:{0}.{1}'.format(precision + 4, precision) + 'f} MiB'
+        mem_old = lines[min(lines.keys())]
+        float_format = '{0}.{1}f'.format(precision + 4, precision)
+        template_mem = '{{0:' + float_format + '} MiB'
         for line in linenos:
             mem = ''
             inc = ''
@@ -611,7 +614,7 @@ def magic_mprun(self, parameter_s=''):
             funcs.append(eval(name, global_ns, local_ns))
         except Exception as e:
             raise UsageError('Could not find function %r.\n%s: %s' % (name,
-                e.__class__.__name__, e))
+                             e.__class__.__name__, e))
 
     profile = LineProfiler()
     for func in funcs:
@@ -639,7 +642,7 @@ def magic_mprun(self, parameter_s=''):
             message = ""*** SystemExit exception caught in code being profiled.""
         except KeyboardInterrupt:
             message = (""*** KeyboardInterrupt exception caught in code being ""
-                ""profiled."")
+                       ""profiled."")
     finally:
         if had_profile:
             builtins.__dict__['profile'] = old_profile
@@ -755,10 +758,12 @@ if __name__ == '__main__':
     from optparse import OptionParser
     parser = OptionParser(usage=_CMD_USAGE, version=__version__)
     parser.disable_interspersed_args()
-    parser.add_option(""--pdb-mmem"", dest=""max_mem"", metavar=""MAXMEM"",
+    parser.add_option(
+        ""--pdb-mmem"", dest=""max_mem"", metavar=""MAXMEM"",
         type=""float"", action=""store"",
         help=""step into the debugger when memory exceeds MAXMEM"")
-    parser.add_option('--precision', dest=""precision"", type=""int"",
+    parser.add_option(
+        '--precision', dest=""precision"", type=""int"",
         action=""store"", default=3,
         help=""precision of memory output in number of significant digits"")
     parser.add_option(""-o"", dest=""out_filename"", type=""str"",
@@ -784,7 +789,7 @@ if __name__ == '__main__':
     try:
         if sys.version_info[0] < 3:
             # we need to ovewrite the builtins to have profile
-            # globally defined (global variables is not enought
+            # globally defined (global variables is not enough
             # for all cases, e.g. a script that imports another
             # script where @profile is used)
             import __builtin__
",True,memory_profiler.py,True
"@@ -85,7 +85,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
                                   'platforms')
 
 
-class Timer(Process):
+class MemTimer(Process):
     """"""
     Fetch memory consumption from over a time interval
     """"""
@@ -108,7 +108,7 @@ class Timer(Process):
         else:
             self.include_children = False
 
-        super(Timer, self).__init__(*args, **kw)
+        super(MemTimer, self).__init__(*args, **kw)
 
     def run(self):
         m = _get_memory(self.monitor_pid, timestamps=self.timestamps,
@@ -212,8 +212,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             raise ValueError('Function expects %s value(s) but %s where given'
                              % (n_args, len(args)))
 
-        child_conn, parent_conn = Pipe()  # this will store Timer's results
-        p = Timer(os.getpid(), interval, child_conn, timestamps=timestamps,
+        child_conn, parent_conn = Pipe()  # this will store MemTimer's results
+        p = MemTimer(os.getpid(), interval, child_conn, timestamps=timestamps,
                   max_usage=max_usage)
         p.start()
         parent_conn.recv()  # wait until we start getting memory
@@ -424,6 +424,7 @@ class LineProfiler(object):
     def run(self, cmd):
         """""" Profile a single executable statement in the main namespace.
         """"""
+        # TODO: can this be removed ?
         import __main__
         main_dict = __main__.__dict__
         return self.runctx(cmd, main_dict, main_dict)
@@ -721,16 +722,16 @@ def magic_memit(self, line=''):
         timeout = None
     interval = float(getattr(opts, 'i', 0.1))
 
-    mem_usage = []
+    mem_usage = 0.
     counter = 0
     while counter < repeat:
         counter += 1
         tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
-                           timeout=timeout, interval=interval)
-        mem_usage.extend(tmp)
+                           timeout=timeout, interval=interval, max_usage=True)
+        mem_usage = max(mem_usage, tmp)
 
     if mem_usage:
-        print('maximum of %d: %f MiB per loop' % (repeat, max(mem_usage)))
+        print('maximum of %d: %f MiB per loop' % (repeat, mem_usage))
     else:
         print('ERROR: could not read memory usage, try with a lower interval '
               'or more iterations')
","@@ -85,7 +85,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
                                   'platforms')
 
 
-class Timer(Process):
+class MemTimer(Process):
     """"""
     Fetch memory consumption from over a time interval
     """"""
@@ -108,7 +108,7 @@ class Timer(Process):
         else:
             self.include_children = False
 
-        super(Timer, self).__init__(*args, **kw)
+        super(MemTimer, self).__init__(*args, **kw)
 
     def run(self):
         m = _get_memory(self.monitor_pid, timestamps=self.timestamps,
@@ -212,8 +212,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             raise ValueError('Function expects %s value(s) but %s where given'
                              % (n_args, len(args)))
 
-        child_conn, parent_conn = Pipe()  # this will store Timer's results
-        p = Timer(os.getpid(), interval, child_conn, timestamps=timestamps,
+        child_conn, parent_conn = Pipe()  # this will store MemTimer's results
+        p = MemTimer(os.getpid(), interval, child_conn, timestamps=timestamps,
                   max_usage=max_usage)
         p.start()
         parent_conn.recv()  # wait until we start getting memory
@@ -424,6 +424,7 @@ class LineProfiler(object):
     def run(self, cmd):
         """""" Profile a single executable statement in the main namespace.
         """"""
+        # TODO: can this be removed ?
         import __main__
         main_dict = __main__.__dict__
         return self.runctx(cmd, main_dict, main_dict)
@@ -721,16 +722,16 @@ def magic_memit(self, line=''):
         timeout = None
     interval = float(getattr(opts, 'i', 0.1))
 
-    mem_usage = []
+    mem_usage = 0.
     counter = 0
     while counter < repeat:
         counter += 1
         tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
-                           timeout=timeout, interval=interval)
-        mem_usage.extend(tmp)
+                           timeout=timeout, interval=interval, max_usage=True)
+        mem_usage = max(mem_usage, tmp)
 
     if mem_usage:
-        print('maximum of %d: %f MiB per loop' % (repeat, max(mem_usage)))
+        print('maximum of %d: %f MiB per loop' % (repeat, mem_usage))
     else:
         print('ERROR: could not read memory usage, try with a lower interval '
               'or more iterations')
",True,memory_profiler.py,True
"@@ -96,6 +96,7 @@ class MemTimer(Process):
         self.pipe = pipe
         self.cont = True
         self.max_usage = max_usage
+        self.n_measurements = 1
 
         if ""timestamps"" in kw:
             self.timestamps = kw[""timestamps""]
@@ -107,25 +108,31 @@ class MemTimer(Process):
             del kw[""include_children""]
         else:
             self.include_children = False
-
+        # get baseline memory usage
+        self.mem_usage = [
+            _get_memory(self.monitor_pid, timestamps=self.timestamps,
+                        include_children=self.include_children)]
         super(MemTimer, self).__init__(*args, **kw)
 
+
     def run(self):
-        m = _get_memory(self.monitor_pid, timestamps=self.timestamps,
-                        include_children=self.include_children)
-        if not self.max_usage:
-            timings = [m]
-        else:
-            timings = m
         self.pipe.send(0)  # we're ready
-        while not self.pipe.poll(self.interval):
-            m = _get_memory(self.monitor_pid, timestamps=self.timestamps,
+        stop = False
+        while True:
+            cur_mem = _get_memory(self.monitor_pid, timestamps=self.timestamps,
                             include_children=self.include_children)
             if not self.max_usage:
-                timings.append(m)
+                self.mem_usage.append(cur_mem)
             else:
-                timings = max([m, timings])
-        self.pipe.send(timings)
+                self.mem_usage[0] = max(cur_mem, self.mem_usage[0])
+            self.n_measurements += 1
+            if stop:
+                break
+            stop = self.pipe.poll(self.interval)
+            # do one more iteration
+
+        self.pipe.send(self.mem_usage)
+        self.pipe.send(self.n_measurements)
 
 
 def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
@@ -171,6 +178,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     -------
     mem_usage : list of floating-poing values
         memory usage, in MiB. It's length is always < timeout / interval
+        if max_usage is given, returns the two elements maximum memory and
+        number of measurements effectuated
     ret : return value of the profiled function
         Only returned if retval is set to True
     """"""
@@ -212,17 +221,22 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             raise ValueError('Function expects %s value(s) but %s where given'
                              % (n_args, len(args)))
 
-        child_conn, parent_conn = Pipe()  # this will store MemTimer's results
-        p = MemTimer(os.getpid(), interval, child_conn, timestamps=timestamps,
-                  max_usage=max_usage)
-        p.start()
-        parent_conn.recv()  # wait until we start getting memory
-        returned = f(*args, **kw)
-        parent_conn.send(0)  # finish timing
-        ret = parent_conn.recv()
-        if retval:
-            ret = ret, returned
-        p.join(5 * interval)
+        while True:
+            child_conn, parent_conn = Pipe()  # this will store MemTimer's results
+            p = MemTimer(os.getpid(), interval, child_conn, timestamps=timestamps,
+                      max_usage=max_usage)
+            p.start()
+            parent_conn.recv()  # wait until we start getting memory
+            returned = f(*args, **kw)
+            parent_conn.send(0)  # finish timing
+            ret = parent_conn.recv()
+            n_measurements = parent_conn.recv()
+            if retval:
+                ret = ret, returned
+            p.join(5 * interval)
+            if n_measurements > 4 or interval < 1e-6:
+                break
+            interval /= 10.
     elif isinstance(proc, subprocess.Popen):
         # external process, launched from Python
         line_count = 0
@@ -722,16 +736,23 @@ def magic_memit(self, line=''):
         timeout = None
     interval = float(getattr(opts, 'i', 0.1))
 
-    mem_usage = 0.
+    # I've noticed we get less noisier measurements if we run
+    # a garbage collection first
+    import gc
+    gc.collect()
+
+    mem_usage = 0
     counter = 0
+    baseline = memory_usage()[0]
     while counter < repeat:
         counter += 1
         tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
                            timeout=timeout, interval=interval, max_usage=True)
-        mem_usage = max(mem_usage, tmp)
+        mem_usage = max(mem_usage, tmp[0])
 
     if mem_usage:
-        print('maximum of %d: %f MiB per loop' % (repeat, mem_usage))
+        print('peak memory: %.02f MiB, increment: %.02f MiB' %
+              (mem_usage, mem_usage - baseline))
     else:
         print('ERROR: could not read memory usage, try with a lower interval '
               'or more iterations')
","@@ -96,6 +96,7 @@ class MemTimer(Process):
         self.pipe = pipe
         self.cont = True
         self.max_usage = max_usage
+        self.n_measurements = 1
 
         if ""timestamps"" in kw:
             self.timestamps = kw[""timestamps""]
@@ -107,25 +108,31 @@ class MemTimer(Process):
             del kw[""include_children""]
         else:
             self.include_children = False
-
+        # get baseline memory usage
+        self.mem_usage = [
+            _get_memory(self.monitor_pid, timestamps=self.timestamps,
+                        include_children=self.include_children)]
         super(MemTimer, self).__init__(*args, **kw)
 
+
     def run(self):
-        m = _get_memory(self.monitor_pid, timestamps=self.timestamps,
-                        include_children=self.include_children)
-        if not self.max_usage:
-            timings = [m]
-        else:
-            timings = m
         self.pipe.send(0)  # we're ready
-        while not self.pipe.poll(self.interval):
-            m = _get_memory(self.monitor_pid, timestamps=self.timestamps,
+        stop = False
+        while True:
+            cur_mem = _get_memory(self.monitor_pid, timestamps=self.timestamps,
                             include_children=self.include_children)
             if not self.max_usage:
-                timings.append(m)
+                self.mem_usage.append(cur_mem)
             else:
-                timings = max([m, timings])
-        self.pipe.send(timings)
+                self.mem_usage[0] = max(cur_mem, self.mem_usage[0])
+            self.n_measurements += 1
+            if stop:
+                break
+            stop = self.pipe.poll(self.interval)
+            # do one more iteration
+
+        self.pipe.send(self.mem_usage)
+        self.pipe.send(self.n_measurements)
 
 
 def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
@@ -171,6 +178,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     -------
     mem_usage : list of floating-poing values
         memory usage, in MiB. It's length is always < timeout / interval
+        if max_usage is given, returns the two elements maximum memory and
+        number of measurements effectuated
     ret : return value of the profiled function
         Only returned if retval is set to True
     """"""
@@ -212,17 +221,22 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             raise ValueError('Function expects %s value(s) but %s where given'
                              % (n_args, len(args)))
 
-        child_conn, parent_conn = Pipe()  # this will store MemTimer's results
-        p = MemTimer(os.getpid(), interval, child_conn, timestamps=timestamps,
-                  max_usage=max_usage)
-        p.start()
-        parent_conn.recv()  # wait until we start getting memory
-        returned = f(*args, **kw)
-        parent_conn.send(0)  # finish timing
-        ret = parent_conn.recv()
-        if retval:
-            ret = ret, returned
-        p.join(5 * interval)
+        while True:
+            child_conn, parent_conn = Pipe()  # this will store MemTimer's results
+            p = MemTimer(os.getpid(), interval, child_conn, timestamps=timestamps,
+                      max_usage=max_usage)
+            p.start()
+            parent_conn.recv()  # wait until we start getting memory
+            returned = f(*args, **kw)
+            parent_conn.send(0)  # finish timing
+            ret = parent_conn.recv()
+            n_measurements = parent_conn.recv()
+            if retval:
+                ret = ret, returned
+            p.join(5 * interval)
+            if n_measurements > 4 or interval < 1e-6:
+                break
+            interval /= 10.
     elif isinstance(proc, subprocess.Popen):
         # external process, launched from Python
         line_count = 0
@@ -722,16 +736,23 @@ def magic_memit(self, line=''):
         timeout = None
     interval = float(getattr(opts, 'i', 0.1))
 
-    mem_usage = 0.
+    # I've noticed we get less noisier measurements if we run
+    # a garbage collection first
+    import gc
+    gc.collect()
+
+    mem_usage = 0
     counter = 0
+    baseline = memory_usage()[0]
     while counter < repeat:
         counter += 1
         tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
                            timeout=timeout, interval=interval, max_usage=True)
-        mem_usage = max(mem_usage, tmp)
+        mem_usage = max(mem_usage, tmp[0])
 
     if mem_usage:
-        print('maximum of %d: %f MiB per loop' % (repeat, mem_usage))
+        print('peak memory: %.02f MiB, increment: %.02f MiB' %
+              (mem_usage, mem_usage - baseline))
     else:
         print('ERROR: could not read memory usage, try with a lower interval '
               'or more iterations')
",True,memory_profiler.py,True
"@@ -552,7 +552,7 @@ def show_results(prof, stream=None, precision=1):
 
         mem_old = lines[min(lines.keys())]
         float_format = '{0}.{1}f'.format(precision + 4, precision)
-        template_mem = '{{0:' + float_format + '} MiB'
+        template_mem = '{0:' + float_format + '} MiB'
         for line in linenos:
             mem = ''
             inc = ''
","@@ -552,7 +552,7 @@ def show_results(prof, stream=None, precision=1):
 
         mem_old = lines[min(lines.keys())]
         float_format = '{0}.{1}f'.format(precision + 4, precision)
-        template_mem = '{{0:' + float_format + '} MiB'
+        template_mem = '{0:' + float_format + '} MiB'
         for line in linenos:
             mem = ''
             inc = ''
",True,memory_profiler.py,True
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
-__version__ = '0.29'
+__version__ = '0.30'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
-__version__ = '0.29'
+__version__ = '0.30'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -480,6 +480,10 @@ class LineProfiler(object):
                 old_mem = self.code_map[frame.f_code].get(self.prevline, 0)
                 self.code_map[frame.f_code][self.prevline] = max(mem, old_mem)
             self.prevline = frame.f_lineno
+
+        if self._original_trace_function is not None:
+            (self._original_trace_function)(frame, event, arg)
+
         return self.trace_memory_usage
 
     def trace_max_mem(self, frame, event, arg):
@@ -500,6 +504,9 @@ class LineProfiler(object):
                 p.botframe = None
                 return p.trace_dispatch
 
+        if self._original_trace_function is not None:
+            (self._original_trace_function)(frame, event, arg)
+
         return self.trace_max_mem
 
     def __enter__(self):
@@ -509,6 +516,7 @@ class LineProfiler(object):
         self.disable_by_count()
 
     def enable(self):
+        self._original_trace_function = sys.gettrace()
         if self.max_mem is not None:
             sys.settrace(self.trace_max_mem)
         else:
@@ -516,7 +524,7 @@ class LineProfiler(object):
 
     def disable(self):
         self.last_time = {}
-        sys.settrace(None)
+        sys.settrace(self._original_trace_function)
 
 
 def show_results(prof, stream=None, precision=1):
","@@ -480,6 +480,10 @@ class LineProfiler(object):
                 old_mem = self.code_map[frame.f_code].get(self.prevline, 0)
                 self.code_map[frame.f_code][self.prevline] = max(mem, old_mem)
             self.prevline = frame.f_lineno
+
+        if self._original_trace_function is not None:
+            (self._original_trace_function)(frame, event, arg)
+
         return self.trace_memory_usage
 
     def trace_max_mem(self, frame, event, arg):
@@ -500,6 +504,9 @@ class LineProfiler(object):
                 p.botframe = None
                 return p.trace_dispatch
 
+        if self._original_trace_function is not None:
+            (self._original_trace_function)(frame, event, arg)
+
         return self.trace_max_mem
 
     def __enter__(self):
@@ -509,6 +516,7 @@ class LineProfiler(object):
         self.disable_by_count()
 
     def enable(self):
+        self._original_trace_function = sys.gettrace()
         if self.max_mem is not None:
             sys.settrace(self.trace_max_mem)
         else:
@@ -516,7 +524,7 @@ class LineProfiler(object):
 
     def disable(self):
         self.last_time = {}
-        sys.settrace(None)
+        sys.settrace(self._original_trace_function)
 
 
 def show_results(prof, stream=None, precision=1):
",True,memory_profiler.py,True
"@@ -7,4 +7,5 @@ test:
 	$(PYTHON) -m memory_profiler test/test_loop.py
 	$(PYTHON) -m memory_profiler test/test_as.py
 	$(PYTHON) -m memory_profiler test/test_global.py
-	$(PYTHON) test/test_import.py
\ No newline at end of file
+	$(PYTHON) test/test_import.py
+	$(PYTHON) test/test_memory_usage.py
","@@ -7,4 +7,5 @@ test:
 	$(PYTHON) -m memory_profiler test/test_loop.py
 	$(PYTHON) -m memory_profiler test/test_as.py
 	$(PYTHON) -m memory_profiler test/test_global.py
-	$(PYTHON) test/test_import.py
\ No newline at end of file
+	$(PYTHON) test/test_import.py
+	$(PYTHON) test/test_memory_usage.py
",True,Makefile,False
"@@ -213,14 +213,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         else:
             raise ValueError
 
-        aspec = inspect.getargspec(f)
-        n_args = len(aspec.args)
-        if aspec.defaults is not None:
-            n_args -= len(aspec.defaults)
-        if n_args != len(args):
-            raise ValueError('Function expects %s value(s) but %s where given'
-                             % (n_args, len(args)))
-
         while True:
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
             p = MemTimer(os.getpid(), interval, child_conn, timestamps=timestamps,
","@@ -213,14 +213,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         else:
             raise ValueError
 
-        aspec = inspect.getargspec(f)
-        n_args = len(aspec.args)
-        if aspec.defaults is not None:
-            n_args -= len(aspec.defaults)
-        if n_args != len(args):
-            raise ValueError('Function expects %s value(s) but %s where given'
-                             % (n_args, len(args)))
-
         while True:
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
             p = MemTimer(os.getpid(), interval, child_conn, timestamps=timestamps,
",True,memory_profiler.py,True
"@@ -1,5 +1,6 @@
 from memory_profiler import profile
 
+
 @profile
 def my_func():
     a = [1] * (10 ** 6)
@@ -8,4 +9,4 @@ def my_func():
     return a
 
 if __name__ == '__main__':
-	my_func()
\ No newline at end of file
+    my_func()
","@@ -1,5 +1,6 @@
 from memory_profiler import profile
 
+
 @profile
 def my_func():
     a = [1] * (10 ** 6)
@@ -8,4 +9,4 @@ def my_func():
     return a
 
 if __name__ == '__main__':
-	my_func()
\ No newline at end of file
+    my_func()
",True,test/test_import.py,True
"@@ -0,0 +1,15 @@
+from memory_profiler import memory_usage
+
+
+def some_func(*args, **kwargs):
+    return args, kwargs
+
+
+def test_memory_usage():
+    # Check that memory_usage works with functions with star args.
+    mem, ret = memory_usage((some_func, (1, 2), dict(a=1)), retval=True)
+    assert ret[0] == (1, 2)
+    assert ret[1] == dict(a=1)
+
+if __name__ == ""__main__"":
+    test_memory_usage()
","@@ -0,0 +1,15 @@
+from memory_profiler import memory_usage
+
+
+def some_func(*args, **kwargs):
+    return args, kwargs
+
+
+def test_memory_usage():
+    # Check that memory_usage works with functions with star args.
+    mem, ret = memory_usage((some_func, (1, 2), dict(a=1)), retval=True)
+    assert ret[0] == (1, 2)
+    assert ret[1] == dict(a=1)
+
+if __name__ == ""__main__"":
+    test_memory_usage()
",True,test/test_memory_usage.py,True
"@@ -375,7 +375,7 @@ class TimeStamper:
         if stream is None:
             stream = sys.stdout
 
-        for func, timestamps in self.functions.iteritems():
+        for func, timestamps in self.functions.items():
             function_name = ""%s.%s"" % (func.__module__, func.__name__)
             for ts in timestamps:
                 stream.write(""FUNC %s %.4f %.4f %.4f %.4f\n"" % (
","@@ -375,7 +375,7 @@ class TimeStamper:
         if stream is None:
             stream = sys.stdout
 
-        for func, timestamps in self.functions.iteritems():
+        for func, timestamps in self.functions.items():
             function_name = ""%s.%s"" % (func.__module__, func.__name__)
             for ts in timestamps:
                 stream.write(""FUNC %s %.4f %.4f %.4f %.4f\n"" % (
",True,memory_profiler.py,True
"@@ -335,7 +335,7 @@ def plot_file(filename, index=0, timestamps=True):
     mem = mprofile['mem_usage']
 
     if len(ts) > 0:
-        for values in ts.itervalues():
+        for values in ts.values():
             for v in values:
                 t.extend(v[:2])
                 mem.extend(v[2:4])
@@ -369,7 +369,7 @@ def plot_file(filename, index=0, timestamps=True):
     # plot timestamps, if any
     if len(ts) > 0 and timestamps:
         func_num = 0
-        for f, exec_ts in ts.iteritems():
+        for f, exec_ts in ts.items():
             for execution in exec_ts:
                 add_brackets(execution[:2], execution[2:], xshift=global_start,
                              color= all_colors[func_num % len(all_colors)],
","@@ -335,7 +335,7 @@ def plot_file(filename, index=0, timestamps=True):
     mem = mprofile['mem_usage']
 
     if len(ts) > 0:
-        for values in ts.itervalues():
+        for values in ts.values():
             for v in values:
                 t.extend(v[:2])
                 mem.extend(v[2:4])
@@ -369,7 +369,7 @@ def plot_file(filename, index=0, timestamps=True):
     # plot timestamps, if any
     if len(ts) > 0 and timestamps:
         func_num = 0
-        for f, exec_ts in ts.iteritems():
+        for f, exec_ts in ts.items():
             for execution in exec_ts:
                 add_brackets(execution[:2], execution[2:], xshift=global_start,
                              color= all_colors[func_num % len(all_colors)],
",True,mprof,False
"@@ -400,6 +400,13 @@ class LineProfiler(object):
         f.__dict__.update(getattr(func, '__dict__', {}))
         return f
 
+    def add_code(self, code, toplevel_code=None):
+        if code not in self.code_map:
+            self.code_map[code] = {}
+
+            for subcode in filter(inspect.iscode, code.co_consts):
+                self.add_code(subcode)
+
     def add_function(self, func):
         """""" Record line profiling information for the given Python function.
         """"""
@@ -410,9 +417,8 @@ class LineProfiler(object):
             import warnings
             warnings.warn(""Could not extract a code object for the object %r""
                           % func)
-            return
-        if code not in self.code_map:
-            self.code_map[code] = {}
+        else:
+            self.add_code(code)
 
     def wrap_function(self, func):
         """""" Wrap a function to profile it.
","@@ -400,6 +400,13 @@ class LineProfiler(object):
         f.__dict__.update(getattr(func, '__dict__', {}))
         return f
 
+    def add_code(self, code, toplevel_code=None):
+        if code not in self.code_map:
+            self.code_map[code] = {}
+
+            for subcode in filter(inspect.iscode, code.co_consts):
+                self.add_code(subcode)
+
     def add_function(self, func):
         """""" Record line profiling information for the given Python function.
         """"""
@@ -410,9 +417,8 @@ class LineProfiler(object):
             import warnings
             warnings.warn(""Could not extract a code object for the object %r""
                           % func)
-            return
-        if code not in self.code_map:
-            self.code_map[code] = {}
+        else:
+            self.add_code(code)
 
     def wrap_function(self, func):
         """""" Wrap a function to profile it.
",True,memory_profiler.py,True
"@@ -0,0 +1,29 @@
+# .. an example with a for loop ..
+
+import time
+
+@profile
+def test_1():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    del b
+
+    def test_2():
+        a = [1] * (10 ** 6)
+        b = [2] * (2 * 10 ** 7)
+        del b
+
+        return a
+
+    return test_2
+
+
+if __name__ == '__main__':
+    profile.enable_by_count()
+
+    test_2 = test_1()
+    time.sleep(1)
+    test_2()
+    time.sleep(1)
+
+    profile.disable_by_count()
","@@ -0,0 +1,29 @@
+# .. an example with a for loop ..
+
+import time
+
+@profile
+def test_1():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    del b
+
+    def test_2():
+        a = [1] * (10 ** 6)
+        b = [2] * (2 * 10 ** 7)
+        del b
+
+        return a
+
+    return test_2
+
+
+if __name__ == '__main__':
+    profile.enable_by_count()
+
+    test_2 = test_1()
+    time.sleep(1)
+    test_2()
+    time.sleep(1)
+
+    profile.disable_by_count()
",True,test/test_nested.py,True
"@@ -58,7 +58,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
             # continue and try to get this from ps
 
     # .. scary stuff ..
-    if os.name == 'posix':
+    elif os.name == 'posix':
         warnings.warn(""psutil module not found. memory_profiler will be slow"")
         # ..
         # .. memory usage in MiB ..
@@ -216,7 +216,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         while True:
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
             p = MemTimer(os.getpid(), interval, child_conn, timestamps=timestamps,
-                      max_usage=max_usage)
+                      max_usage=max_usage, include_children=include_children)
             p.start()
             parent_conn.recv()  # wait until we start getting memory
             returned = f(*args, **kw)
","@@ -58,7 +58,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
             # continue and try to get this from ps
 
     # .. scary stuff ..
-    if os.name == 'posix':
+    elif os.name == 'posix':
         warnings.warn(""psutil module not found. memory_profiler will be slow"")
         # ..
         # .. memory usage in MiB ..
@@ -216,7 +216,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         while True:
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
             p = MemTimer(os.getpid(), interval, child_conn, timestamps=timestamps,
-                      max_usage=max_usage)
+                      max_usage=max_usage, include_children=include_children)
             p.start()
             parent_conn.recv()  # wait until we start getting memory
             returned = f(*args, **kw)
",True,memory_profiler.py,True
"@@ -58,7 +58,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
             # continue and try to get this from ps
 
     # .. scary stuff ..
-    elif os.name == 'posix':
+    if os.name == 'posix':
         warnings.warn(""psutil module not found. memory_profiler will be slow"")
         # ..
         # .. memory usage in MiB ..
","@@ -58,7 +58,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
             # continue and try to get this from ps
 
     # .. scary stuff ..
-    elif os.name == 'posix':
+    if os.name == 'posix':
         warnings.warn(""psutil module not found. memory_profiler will be slow"")
         # ..
         # .. memory usage in MiB ..
",True,memory_profiler.py,True
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
-__version__ = '0.30'
+__version__ = '0.31'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
-__version__ = '0.30'
+__version__ = '0.31'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -445,9 +445,12 @@ def plot_action():
 
     ax = pl.gca()
     box = ax.get_position()
-    ax.set_position([0.07, 0.1,
-                     0.55, 0.8])
-    ax.legend(loc=""upper left"", bbox_to_anchor=(1.05, 1.))
+    # IAN FIX
+    #ax.set_position([0.07, 0.1,
+    #                 0.55, 0.8])
+    #ax.legend(loc=""upper left"", bbox_to_anchor=(1.05, 1.))
+    leg = ax.legend(loc='best', fancybox=True)
+    leg.get_frame().set_alpha(0.5)  # make the legend partially transparent
     pl.grid()
     pl.show()
 
","@@ -445,9 +445,12 @@ def plot_action():
 
     ax = pl.gca()
     box = ax.get_position()
-    ax.set_position([0.07, 0.1,
-                     0.55, 0.8])
-    ax.legend(loc=""upper left"", bbox_to_anchor=(1.05, 1.))
+    # IAN FIX
+    #ax.set_position([0.07, 0.1,
+    #                 0.55, 0.8])
+    #ax.legend(loc=""upper left"", bbox_to_anchor=(1.05, 1.))
+    leg = ax.legend(loc='best', fancybox=True)
+    leg.get_frame().set_alpha(0.5)  # make the legend partially transparent
     pl.grid()
     pl.show()
 
",True,mprof,False
"@@ -444,13 +444,10 @@ def plot_action():
             pl.title(options.title)
 
     ax = pl.gca()
-    box = ax.get_position()
-    # IAN FIX
-    #ax.set_position([0.07, 0.1,
-    #                 0.55, 0.8])
-    #ax.legend(loc=""upper left"", bbox_to_anchor=(1.05, 1.))
+    # place legend within the plot, make partially transparent in
+    # case it obscures part of the lineplot
     leg = ax.legend(loc='best', fancybox=True)
-    leg.get_frame().set_alpha(0.5)  # make the legend partially transparent
+    leg.get_frame().set_alpha(0.5)
     pl.grid()
     pl.show()
 
","@@ -444,13 +444,10 @@ def plot_action():
             pl.title(options.title)
 
     ax = pl.gca()
-    box = ax.get_position()
-    # IAN FIX
-    #ax.set_position([0.07, 0.1,
-    #                 0.55, 0.8])
-    #ax.legend(loc=""upper left"", bbox_to_anchor=(1.05, 1.))
+    # place legend within the plot, make partially transparent in
+    # case it obscures part of the lineplot
     leg = ax.legend(loc='best', fancybox=True)
-    leg.get_frame().set_alpha(0.5)  # make the legend partially transparent
+    leg.get_frame().set_alpha(0.5)
     pl.grid()
     pl.show()
 
",True,mprof,False
"@@ -390,6 +390,7 @@ class LineProfiler(object):
         self.enable_count = 0
         self.max_mem = kw.get('max_mem', None)
         self.prevline = None
+        self.include_children = kw.get('include_children', False)
 
     def __call__(self, func):
         self.add_function(func)
@@ -467,7 +468,7 @@ class LineProfiler(object):
                 and frame.f_code in self.code_map):
             if event != 'call':
                 # ""call"" event just saves the lineno but not the memory
-                mem = _get_memory(-1)
+                mem = _get_memory(-1, include_children=self.include_children)
                 # if there is already a measurement for that line get the max
                 old_mem = self.code_map[frame.f_code].get(self.prevline, 0)
                 self.code_map[frame.f_code][self.prevline] = max(mem, old_mem)
@@ -595,6 +596,8 @@ def magic_mprun(self, parameter_s=''):
     side-by-side out to a text file.
 
     -r: return the LineProfiler object after it has completed profiling.
+
+    -c: If present, add the memory usage of any children process to the report.
     """"""
     try:
         from StringIO import StringIO
@@ -617,7 +620,7 @@ def magic_mprun(self, parameter_s=''):
     # Escape quote markers.
     opts_def = Struct(T=[''], f=[])
     parameter_s = parameter_s.replace('""', r'\""').replace(""'"", r""\'"")
-    opts, arg_str = self.parse_options(parameter_s, 'rf:T:', list_all=True)
+    opts, arg_str = self.parse_options(parameter_s, 'rf:T:c', list_all=True)
     opts.merge(opts_def)
     global_ns = self.shell.user_global_ns
     local_ns = self.shell.user_ns
@@ -631,7 +634,8 @@ def magic_mprun(self, parameter_s=''):
             raise UsageError('Could not find function %r.\n%s: %s' % (name,
                              e.__class__.__name__, e))
 
-    profile = LineProfiler()
+    include_children = bool(getattr(opts, 'c', False))
+    profile = LineProfiler(include_children=include_children)
     for func in funcs:
         profile(func)
 
@@ -711,6 +715,8 @@ def magic_memit(self, line=''):
     -i<I>: Get time information at an interval of I times per second.
         Defaults to 0.1 so that there is ten measurements per second.
 
+    -c: If present, add the memory usage of any children process to the report.
+
     Examples
     --------
     ::
@@ -727,7 +733,7 @@ def magic_memit(self, line=''):
       maximum of 10: 0.101562 MiB per loop
 
     """"""
-    opts, stmt = self.parse_options(line, 'r:t:i:', posix=False, strict=False)
+    opts, stmt = self.parse_options(line, 'r:t:i:c', posix=False, strict=False)
     repeat = int(getattr(opts, 'r', 1))
     if repeat < 1:
         repeat == 1
@@ -735,6 +741,7 @@ def magic_memit(self, line=''):
     if timeout <= 0:
         timeout = None
     interval = float(getattr(opts, 'i', 0.1))
+    include_children = bool(getattr(opts, 'c', False))
 
     # I've noticed we get less noisier measurements if we run
     # a garbage collection first
@@ -747,7 +754,8 @@ def magic_memit(self, line=''):
     while counter < repeat:
         counter += 1
         tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
-                           timeout=timeout, interval=interval, max_usage=True)
+                           timeout=timeout, interval=interval, max_usage=True,
+                           include_children=include_children)
         mem_usage = max(mem_usage, tmp[0])
 
     if mem_usage:
","@@ -390,6 +390,7 @@ class LineProfiler(object):
         self.enable_count = 0
         self.max_mem = kw.get('max_mem', None)
         self.prevline = None
+        self.include_children = kw.get('include_children', False)
 
     def __call__(self, func):
         self.add_function(func)
@@ -467,7 +468,7 @@ class LineProfiler(object):
                 and frame.f_code in self.code_map):
             if event != 'call':
                 # ""call"" event just saves the lineno but not the memory
-                mem = _get_memory(-1)
+                mem = _get_memory(-1, include_children=self.include_children)
                 # if there is already a measurement for that line get the max
                 old_mem = self.code_map[frame.f_code].get(self.prevline, 0)
                 self.code_map[frame.f_code][self.prevline] = max(mem, old_mem)
@@ -595,6 +596,8 @@ def magic_mprun(self, parameter_s=''):
     side-by-side out to a text file.
 
     -r: return the LineProfiler object after it has completed profiling.
+
+    -c: If present, add the memory usage of any children process to the report.
     """"""
     try:
         from StringIO import StringIO
@@ -617,7 +620,7 @@ def magic_mprun(self, parameter_s=''):
     # Escape quote markers.
     opts_def = Struct(T=[''], f=[])
     parameter_s = parameter_s.replace('""', r'\""').replace(""'"", r""\'"")
-    opts, arg_str = self.parse_options(parameter_s, 'rf:T:', list_all=True)
+    opts, arg_str = self.parse_options(parameter_s, 'rf:T:c', list_all=True)
     opts.merge(opts_def)
     global_ns = self.shell.user_global_ns
     local_ns = self.shell.user_ns
@@ -631,7 +634,8 @@ def magic_mprun(self, parameter_s=''):
             raise UsageError('Could not find function %r.\n%s: %s' % (name,
                              e.__class__.__name__, e))
 
-    profile = LineProfiler()
+    include_children = bool(getattr(opts, 'c', False))
+    profile = LineProfiler(include_children=include_children)
     for func in funcs:
         profile(func)
 
@@ -711,6 +715,8 @@ def magic_memit(self, line=''):
     -i<I>: Get time information at an interval of I times per second.
         Defaults to 0.1 so that there is ten measurements per second.
 
+    -c: If present, add the memory usage of any children process to the report.
+
     Examples
     --------
     ::
@@ -727,7 +733,7 @@ def magic_memit(self, line=''):
       maximum of 10: 0.101562 MiB per loop
 
     """"""
-    opts, stmt = self.parse_options(line, 'r:t:i:', posix=False, strict=False)
+    opts, stmt = self.parse_options(line, 'r:t:i:c', posix=False, strict=False)
     repeat = int(getattr(opts, 'r', 1))
     if repeat < 1:
         repeat == 1
@@ -735,6 +741,7 @@ def magic_memit(self, line=''):
     if timeout <= 0:
         timeout = None
     interval = float(getattr(opts, 'i', 0.1))
+    include_children = bool(getattr(opts, 'c', False))
 
     # I've noticed we get less noisier measurements if we run
     # a garbage collection first
@@ -747,7 +754,8 @@ def magic_memit(self, line=''):
     while counter < repeat:
         counter += 1
         tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
-                           timeout=timeout, interval=interval, max_usage=True)
+                           timeout=timeout, interval=interval, max_usage=True,
+                           include_children=include_children)
         mem_usage = max(mem_usage, tmp[0])
 
     if mem_usage:
",True,memory_profiler.py,True
"@@ -407,7 +407,6 @@ class LineProfiler(object):
             # func_code does not exist in Python3
             code = func.__code__
         except AttributeError:
-            import warnings
             warnings.warn(""Could not extract a code object for the object %r""
                           % func)
             return
","@@ -407,7 +407,6 @@ class LineProfiler(object):
             # func_code does not exist in Python3
             code = func.__code__
         except AttributeError:
-            import warnings
             warnings.warn(""Could not extract a code object for the object %r""
                           % func)
             return
",True,memory_profiler.py,True
"@@ -6,4 +6,4 @@ def f():
     return o
 
 if __name__ == '__main__':
-	f()
\ No newline at end of file
+    f()
","@@ -6,4 +6,4 @@ def f():
     return o
 
 if __name__ == '__main__':
-	f()
\ No newline at end of file
+    f()
",True,test/test_as.py,True
"@@ -59,6 +59,10 @@ def _get_memory(pid, timestamps=False, include_children=False):
 
     # .. scary stuff ..
     if os.name == 'posix':
+        if include_children:
+            raise NotImplementedError('The psutil module is required when to'
+                                      ' monitor memory usage of children'
+                                      ' processes')
         warnings.warn(""psutil module not found. memory_profiler will be slow"")
         # ..
         # .. memory usage in MiB ..
","@@ -59,6 +59,10 @@ def _get_memory(pid, timestamps=False, include_children=False):
 
     # .. scary stuff ..
     if os.name == 'posix':
+        if include_children:
+            raise NotImplementedError('The psutil module is required when to'
+                                      ' monitor memory usage of children'
+                                      ' processes')
         warnings.warn(""psutil module not found. memory_profiler will be slow"")
         # ..
         # .. memory usage in MiB ..
",True,memory_profiler.py,True
"@@ -187,7 +187,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     ret : return value of the profiled function
         Only returned if retval is set to True
     """"""
-
     if stream is not None:
         timestamps = True
 
@@ -638,7 +637,7 @@ def magic_mprun(self, parameter_s=''):
             raise UsageError('Could not find function %r.\n%s: %s' % (name,
                              e.__class__.__name__, e))
 
-    include_children = bool(getattr(opts, 'c', False))
+    include_children = 'c' in opts
     profile = LineProfiler(include_children=include_children)
     for func in funcs:
         profile(func)
@@ -745,7 +744,7 @@ def magic_memit(self, line=''):
     if timeout <= 0:
         timeout = None
     interval = float(getattr(opts, 'i', 0.1))
-    include_children = bool(getattr(opts, 'c', False))
+    include_children = 'c' in opts
 
     # I've noticed we get less noisier measurements if we run
     # a garbage collection first
","@@ -187,7 +187,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     ret : return value of the profiled function
         Only returned if retval is set to True
     """"""
-
     if stream is not None:
         timestamps = True
 
@@ -638,7 +637,7 @@ def magic_mprun(self, parameter_s=''):
             raise UsageError('Could not find function %r.\n%s: %s' % (name,
                              e.__class__.__name__, e))
 
-    include_children = bool(getattr(opts, 'c', False))
+    include_children = 'c' in opts
     profile = LineProfiler(include_children=include_children)
     for func in funcs:
         profile(func)
@@ -745,7 +744,7 @@ def magic_memit(self, line=''):
     if timeout <= 0:
         timeout = None
     interval = float(getattr(opts, 'i', 0.1))
-    include_children = bool(getattr(opts, 'c', False))
+    include_children = 'c' in opts
 
     # I've noticed we get less noisier measurements if we run
     # a garbage collection first
",True,memory_profiler.py,True
"@@ -524,7 +524,6 @@ class LineProfiler(object):
             sys.settrace(self.trace_memory_usage)
 
     def disable(self):
-        self.last_time = {}
         sys.settrace(self._original_trace_function)
 
 
","@@ -524,7 +524,6 @@ class LineProfiler(object):
             sys.settrace(self.trace_memory_usage)
 
     def disable(self):
-        self.last_time = {}
         sys.settrace(self._original_trace_function)
 
 
",True,memory_profiler.py,True
"@@ -45,10 +45,10 @@ def _get_memory(pid, timestamps=False, include_children=False):
     if has_psutil:
         process = psutil.Process(pid)
         try:
-            mem = process.get_memory_info()[0] / _TWO_20
+            mem = process.memory_info()[0] / _TWO_20
             if include_children:
                 for p in process.get_children(recursive=True):
-                    mem += p.get_memory_info()[0] / _TWO_20
+                    mem += p.memory_info()[0] / _TWO_20
             if timestamps:
                 return (mem, time.time())
             else:
","@@ -45,10 +45,10 @@ def _get_memory(pid, timestamps=False, include_children=False):
     if has_psutil:
         process = psutil.Process(pid)
         try:
-            mem = process.get_memory_info()[0] / _TWO_20
+            mem = process.memory_info()[0] / _TWO_20
             if include_children:
                 for p in process.get_children(recursive=True):
-                    mem += p.get_memory_info()[0] / _TWO_20
+                    mem += p.memory_info()[0] / _TWO_20
             if timestamps:
                 return (mem, time.time())
             else:
",True,memory_profiler.py,True
"@@ -45,10 +45,12 @@ def _get_memory(pid, timestamps=False, include_children=False):
     if has_psutil:
         process = psutil.Process(pid)
         try:
-            mem = process.memory_info()[0] / _TWO_20
+            mem_info = getattr(process, 'memory_info', process.get_memory_info)
+            mem = mem_info()[0] / _TWO_20
             if include_children:
                 for p in process.get_children(recursive=True):
-                    mem += p.memory_info()[0] / _TWO_20
+                    mem_info = getattr(p, 'memory_info', p.get_memory_info)
+                    mem += mem_info()[0] / _TWO_20
             if timestamps:
                 return (mem, time.time())
             else:
","@@ -45,10 +45,12 @@ def _get_memory(pid, timestamps=False, include_children=False):
     if has_psutil:
         process = psutil.Process(pid)
         try:
-            mem = process.memory_info()[0] / _TWO_20
+            mem_info = getattr(process, 'memory_info', process.get_memory_info)
+            mem = mem_info()[0] / _TWO_20
             if include_children:
                 for p in process.get_children(recursive=True):
-                    mem += p.memory_info()[0] / _TWO_20
+                    mem_info = getattr(p, 'memory_info', p.get_memory_info)
+                    mem += mem_info()[0] / _TWO_20
             if timestamps:
                 return (mem, time.time())
             else:
",True,memory_profiler.py,True
"@@ -7,5 +7,7 @@ test:
 	$(PYTHON) -m memory_profiler test/test_loop.py
 	$(PYTHON) -m memory_profiler test/test_as.py
 	$(PYTHON) -m memory_profiler test/test_global.py
+	$(PYTHON) -m memory_profiler test/test_precision_command_line.py
 	$(PYTHON) test/test_import.py
 	$(PYTHON) test/test_memory_usage.py
+	$(PYTHON) test/test_precision_import.py
","@@ -7,5 +7,7 @@ test:
 	$(PYTHON) -m memory_profiler test/test_loop.py
 	$(PYTHON) -m memory_profiler test/test_as.py
 	$(PYTHON) -m memory_profiler test/test_global.py
+	$(PYTHON) -m memory_profiler test/test_precision_command_line.py
 	$(PYTHON) test/test_import.py
 	$(PYTHON) test/test_memory_usage.py
+	$(PYTHON) test/test_precision_import.py
",True,Makefile,False
"@@ -88,6 +88,21 @@ A function decorator is also available.  Use as follows::
 In this case the script can be run without specifying ``-m
 memory_profiler`` in the command line.
 
+In function decorator, you can specify the precision as an argument to the
+decorator function.  Use as follows::
+
+    from memory_profiler import profile
+
+    @profile(precision=4)
+    def my_func():
+        a = [1] * (10 ** 6)
+        b = [2] * (2 * 10 ** 7)
+        del b
+        return a
+
+If a python script with decorator ``@profile`` is called using ``-m 
+memory_profiler`` in the command line, the ``precision`` parameter is ignored.
+
 Executing external scripts
 ==========================
 Sometimes it is useful to have full memory usage reports as a function of
","@@ -88,6 +88,21 @@ A function decorator is also available.  Use as follows::
 In this case the script can be run without specifying ``-m
 memory_profiler`` in the command line.
 
+In function decorator, you can specify the precision as an argument to the
+decorator function.  Use as follows::
+
+    from memory_profiler import profile
+
+    @profile(precision=4)
+    def my_func():
+        a = [1] * (10 ** 6)
+        b = [2] * (2 * 10 ** 7)
+        del b
+        return a
+
+If a python script with decorator ``@profile`` is called using ``-m 
+memory_profiler`` in the command line, the ``precision`` parameter is ignored.
+
 Executing external scripts
 ==========================
 Sometimes it is useful to have full memory usage reports as a function of
",True,README.rst,False
"@@ -332,17 +332,22 @@ class TimeStamper:
     def __init__(self):
         self.functions = {}
 
-    def __call__(self, func):
-        if not hasattr(func, ""__call__""):
-            raise ValueError(""Value must be callable"")
-
-        self.add_function(func)
-        f = self.wrap_function(func)
-        f.__module__ = func.__module__
-        f.__name__ = func.__name__
-        f.__doc__ = func.__doc__
-        f.__dict__.update(getattr(func, '__dict__', {}))
-        return f
+    def __call__(self, func=None, precision=None):
+        if func is not None:
+            if not hasattr(func, ""__call__""):
+                raise ValueError(""Value must be callable"")
+
+            self.add_function(func)
+            f = self.wrap_function(func)
+            f.__module__ = func.__module__
+            f.__name__ = func.__name__
+            f.__doc__ = func.__doc__
+            f.__dict__.update(getattr(func, '__dict__', {}))
+            return f
+        else:
+            def inner_partial(func):
+                return self.__call__(func, precision=precision)
+            return inner_partial
 
     def timestamp(self, name=""<block>""):
         """"""Returns a context manager for timestamping a block of code.""""""
@@ -397,14 +402,19 @@ class LineProfiler(object):
         self.prevline = None
         self.include_children = kw.get('include_children', False)
 
-    def __call__(self, func):
-        self.add_function(func)
-        f = self.wrap_function(func)
-        f.__module__ = func.__module__
-        f.__name__ = func.__name__
-        f.__doc__ = func.__doc__
-        f.__dict__.update(getattr(func, '__dict__', {}))
-        return f
+    def __call__(self, func=None, precision=1):
+        if func is not None:
+            self.add_function(func)
+            f = self.wrap_function(func)
+            f.__module__ = func.__module__
+            f.__name__ = func.__name__
+            f.__doc__ = func.__doc__
+            f.__dict__.update(getattr(func, '__dict__', {}))
+            return f
+        else:
+            def inner_partial(func):
+                return self.__call__(func, precision=precision)
+            return inner_partial
 
     def add_code(self, code, toplevel_code=None):
         if code not in self.code_map:
@@ -781,16 +791,21 @@ def load_ipython_extension(ip):
     ip.define_magic('memit', magic_memit)
 
 
-def profile(func, stream=None):
+def profile(func=None, stream=None, precision=1):
     """"""
     Decorator that will run the function and print a line-by-line profile
     """"""
-    def wrapper(*args, **kwargs):
-        prof = LineProfiler()
-        val = prof(func)(*args, **kwargs)
-        show_results(prof, stream=stream)
-        return val
-    return wrapper
+    if func is not None:
+        def wrapper(*args, **kwargs):
+            prof = LineProfiler()
+            val = prof(func)(*args, **kwargs)
+            show_results(prof, stream=stream, precision=precision)
+            return val
+        return wrapper
+    else:
+        def inner_wrapper(func):
+            return profile(func, stream=stream, precision=precision)
+        return inner_wrapper
 
 
 if __name__ == '__main__':
","@@ -332,17 +332,22 @@ class TimeStamper:
     def __init__(self):
         self.functions = {}
 
-    def __call__(self, func):
-        if not hasattr(func, ""__call__""):
-            raise ValueError(""Value must be callable"")
+    def __call__(self, func=None, precision=None):
+        if func is not None:
+            if not hasattr(func, ""__call__""):
+                raise ValueError(""Value must be callable"")
 
-        self.add_function(func)
-        f = self.wrap_function(func)
-        f.__module__ = func.__module__
-        f.__name__ = func.__name__
-        f.__doc__ = func.__doc__
-        f.__dict__.update(getattr(func, '__dict__', {}))
-        return f
+            self.add_function(func)
+            f = self.wrap_function(func)
+            f.__module__ = func.__module__
+            f.__name__ = func.__name__
+            f.__doc__ = func.__doc__
+            f.__dict__.update(getattr(func, '__dict__', {}))
+            return f
+        else:
+            def inner_partial(func):
+                return self.__call__(func, precision=precision)
+            return inner_partial
 
     def timestamp(self, name=""<block>""):
         """"""Returns a context manager for timestamping a block of code.""""""
@@ -397,14 +402,19 @@ class LineProfiler(object):
         self.prevline = None
         self.include_children = kw.get('include_children', False)
 
-    def __call__(self, func):
-        self.add_function(func)
-        f = self.wrap_function(func)
-        f.__module__ = func.__module__
-        f.__name__ = func.__name__
-        f.__doc__ = func.__doc__
-        f.__dict__.update(getattr(func, '__dict__', {}))
-        return f
+    def __call__(self, func=None, precision=1):
+        if func is not None:
+            self.add_function(func)
+            f = self.wrap_function(func)
+            f.__module__ = func.__module__
+            f.__name__ = func.__name__
+            f.__doc__ = func.__doc__
+            f.__dict__.update(getattr(func, '__dict__', {}))
+            return f
+        else:
+            def inner_partial(func):
+                return self.__call__(func, precision=precision)
+            return inner_partial
 
     def add_code(self, code, toplevel_code=None):
         if code not in self.code_map:
@@ -781,16 +791,21 @@ def load_ipython_extension(ip):
     ip.define_magic('memit', magic_memit)
 
 
-def profile(func, stream=None):
+def profile(func=None, stream=None, precision=1):
     """"""
     Decorator that will run the function and print a line-by-line profile
     """"""
-    def wrapper(*args, **kwargs):
-        prof = LineProfiler()
-        val = prof(func)(*args, **kwargs)
-        show_results(prof, stream=stream)
-        return val
-    return wrapper
+    if func is not None:
+        def wrapper(*args, **kwargs):
+            prof = LineProfiler()
+            val = prof(func)(*args, **kwargs)
+            show_results(prof, stream=stream, precision=precision)
+            return val
+        return wrapper
+    else:
+        def inner_wrapper(func):
+            return profile(func, stream=stream, precision=precision)
+        return inner_wrapper
 
 
 if __name__ == '__main__':
",False,memory_profiler.py,True
"@@ -0,0 +1,35 @@
+# .. an example to test decorator with precision keyword argument ..
+""""""
+Test profiling using command line ``profile`` function (either
+``TimeStamper`` or ``LineProfiler``) with precision specified as command
+line parameter.
+The precision argument specified in the decorator, therefore, is not used.
+""""""
+
+import time
+
+@profile(precision=4)
+def test_1():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    time.sleep(0.6)
+    del b
+
+    for i in range(2):
+        a = [1] * (10 ** 6)
+        b = [2] * (2 * 10 ** 7)
+        del b
+    return a
+
+@profile(precision=2)
+def test_2():
+    a = {}
+    time.sleep(0.5)
+    for i in range(10000):
+        a[i] = i + 1
+    time.sleep(0.6)
+    return
+
+if __name__ == '__main__':
+    test_1()
+    test_2()
","@@ -0,0 +1,35 @@
+# .. an example to test decorator with precision keyword argument ..
+""""""
+Test profiling using command line ``profile`` function (either
+``TimeStamper`` or ``LineProfiler``) with precision specified as command
+line parameter.
+The precision argument specified in the decorator, therefore, is not used.
+""""""
+
+import time
+
+@profile(precision=4)
+def test_1():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    time.sleep(0.6)
+    del b
+
+    for i in range(2):
+        a = [1] * (10 ** 6)
+        b = [2] * (2 * 10 ** 7)
+        del b
+    return a
+
+@profile(precision=2)
+def test_2():
+    a = {}
+    time.sleep(0.5)
+    for i in range(10000):
+        a[i] = i + 1
+    time.sleep(0.6)
+    return
+
+if __name__ == '__main__':
+    test_1()
+    test_2()
",True,test/test_precision_command_line.py,True
"@@ -0,0 +1,37 @@
+# .. an example to test decorator with precision keyword argument ..
+""""""
+Test profiling using imported ``profile`` function with precision
+specified as parameter to ``profile`` function.
+This is useful if the python script we're trying to profile is called as a
+module (like `python -m test_module`) and so we can't specify command line
+precision parameter.
+""""""
+
+import time
+from memory_profiler import profile
+
+@profile(precision=4)
+def test_1():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    time.sleep(0.6)
+    del b
+
+    for i in range(2):
+        a = [1] * (10 ** 6)
+        b = [2] * (2 * 10 ** 7)
+        del b
+    return a
+
+@profile(precision=5)
+def test_2():
+    a = {}
+    time.sleep(0.5)
+    for i in range(10000):
+        a[i] = i + 1
+    time.sleep(0.6)
+    return
+
+if __name__ == '__main__':
+    test_1()
+    test_2()
","@@ -0,0 +1,37 @@
+# .. an example to test decorator with precision keyword argument ..
+""""""
+Test profiling using imported ``profile`` function with precision
+specified as parameter to ``profile`` function.
+This is useful if the python script we're trying to profile is called as a
+module (like `python -m test_module`) and so we can't specify command line
+precision parameter.
+""""""
+
+import time
+from memory_profiler import profile
+
+@profile(precision=4)
+def test_1():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    time.sleep(0.6)
+    del b
+
+    for i in range(2):
+        a = [1] * (10 ** 6)
+        b = [2] * (2 * 10 ** 7)
+        del b
+    return a
+
+@profile(precision=5)
+def test_2():
+    a = {}
+    time.sleep(0.5)
+    for i in range(10000):
+        a[i] = i + 1
+    time.sleep(0.6)
+    return
+
+if __name__ == '__main__':
+    test_1()
+    test_2()
",True,test/test_precision_import.py,True
"@@ -311,6 +311,8 @@ Projects using memory_profiler
 
 `Benchy <https://github.com/python-recsys/benchy>`_
 
+`SpeedIT <https://github.com/peter1000/SpeedIT>`_ (uses a reduced version of memory_profiler)
+
 =========
  Authors
 =========
","@@ -311,6 +311,8 @@ Projects using memory_profiler
 
 `Benchy <https://github.com/python-recsys/benchy>`_
 
+`SpeedIT <https://github.com/peter1000/SpeedIT>`_ (uses a reduced version of memory_profiler)
+
 =========
  Authors
 =========
",True,README.rst,False
"@@ -345,8 +345,8 @@ class TimeStamper:
             f.__dict__.update(getattr(func, '__dict__', {}))
             return f
         else:
-            def inner_partial(func):
-                return self.__call__(func, precision=precision)
+            def inner_partial(f):
+                return self.__call__(f, precision=precision)
             return inner_partial
 
     def timestamp(self, name=""<block>""):
@@ -412,8 +412,8 @@ class LineProfiler(object):
             f.__dict__.update(getattr(func, '__dict__', {}))
             return f
         else:
-            def inner_partial(func):
-                return self.__call__(func, precision=precision)
+            def inner_partial(f):
+                return self.__call__(f, precision=precision)
             return inner_partial
 
     def add_code(self, code, toplevel_code=None):
@@ -803,8 +803,8 @@ def profile(func=None, stream=None, precision=1):
             return val
         return wrapper
     else:
-        def inner_wrapper(func):
-            return profile(func, stream=stream, precision=precision)
+        def inner_wrapper(f):
+            return profile(f, stream=stream, precision=precision)
         return inner_wrapper
 
 
","@@ -345,8 +345,8 @@ class TimeStamper:
             f.__dict__.update(getattr(func, '__dict__', {}))
             return f
         else:
-            def inner_partial(func):
-                return self.__call__(func, precision=precision)
+            def inner_partial(f):
+                return self.__call__(f, precision=precision)
             return inner_partial
 
     def timestamp(self, name=""<block>""):
@@ -412,8 +412,8 @@ class LineProfiler(object):
             f.__dict__.update(getattr(func, '__dict__', {}))
             return f
         else:
-            def inner_partial(func):
-                return self.__call__(func, precision=precision)
+            def inner_partial(f):
+                return self.__call__(f, precision=precision)
             return inner_partial
 
     def add_code(self, code, toplevel_code=None):
@@ -803,8 +803,8 @@ def profile(func=None, stream=None, precision=1):
             return val
         return wrapper
     else:
-        def inner_wrapper(func):
-            return profile(func, stream=stream, precision=precision)
+        def inner_wrapper(f):
+            return profile(f, stream=stream, precision=precision)
         return inner_wrapper
 
 
",True,memory_profiler.py,True
"@@ -1,5 +1,6 @@
 import memory_profiler
 from distutils.core import setup
+import setuptools
 
 CLASSIFIERS = """"""\
 Development Status :: 5 - Production/Stable
","@@ -1,5 +1,6 @@
 import memory_profiler
 from distutils.core import setup
+import setuptools
 
 CLASSIFIERS = """"""\
 Development Status :: 5 - Production/Stable
",True,setup.py,True
"@@ -311,6 +311,9 @@ Projects using memory_profiler
 
 `Benchy <https://github.com/python-recsys/benchy>`_
 
+`IPython memory usage <https://github.com/ianozsvald/ipython_memory_usage_>`_
+
+
 =========
  Authors
 =========
","@@ -311,6 +311,9 @@ Projects using memory_profiler
 
 `Benchy <https://github.com/python-recsys/benchy>`_
 
+`IPython memory usage <https://github.com/ianozsvald/ipython_memory_usage_>`_
+
+
 =========
  Authors
 =========
",True,README.rst,False
"@@ -401,6 +401,8 @@ def plot_action():
     parser.add_option(""--no-function-ts"", ""-n"", dest=""no_timestamps"",
                       default=False, action=""store_true"",
                       help=""Do not display function timestamps on plot."")
+    parser.add_option(""--output"", ""-o"",
+                      help=""Save plot to file instead of displaying it."")
     (options, args) = parser.parse_args()
 
     profiles = glob.glob(""mprofile_??????????????.dat"")
@@ -449,7 +451,10 @@ def plot_action():
     leg = ax.legend(loc='best', fancybox=True)
     leg.get_frame().set_alpha(0.5)
     pl.grid()
-    pl.show()
+    if options.output:
+        pl.savefig(options.output)
+    else:
+        pl.show()
 
 if __name__ == ""__main__"":
     # Workaround for optparse limitation: insert -- before first negative
","@@ -401,6 +401,8 @@ def plot_action():
     parser.add_option(""--no-function-ts"", ""-n"", dest=""no_timestamps"",
                       default=False, action=""store_true"",
                       help=""Do not display function timestamps on plot."")
+    parser.add_option(""--output"", ""-o"",
+                      help=""Save plot to file instead of displaying it."")
     (options, args) = parser.parse_args()
 
     profiles = glob.glob(""mprofile_??????????????.dat"")
@@ -449,7 +451,10 @@ def plot_action():
     leg = ax.legend(loc='best', fancybox=True)
     leg.get_frame().set_alpha(0.5)
     pl.grid()
-    pl.show()
+    if options.output:
+        pl.savefig(options.output)
+    else:
+        pl.show()
 
 if __name__ == ""__main__"":
     # Workaround for optparse limitation: insert -- before first negative
",True,mprof,False
"@@ -354,7 +354,7 @@ def plot_file(filename, index=0, timestamps=True):
     max_mem_ind = mem.argmax()
 
     all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
-    mem_line_colors=('k', ""b"", ""r"")
+    mem_line_colors=(""k"", ""b"", ""r"", ""g"", ""c"", ""y"", ""m"")
     mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
                                    time.localtime(global_start)) \
                                    + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
","@@ -354,7 +354,7 @@ def plot_file(filename, index=0, timestamps=True):
     max_mem_ind = mem.argmax()
 
     all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
-    mem_line_colors=('k', ""b"", ""r"")
+    mem_line_colors=(""k"", ""b"", ""r"", ""g"", ""c"", ""y"", ""m"")
     mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
                                    time.localtime(global_start)) \
                                    + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
",True,mprof,False
"@@ -328,7 +328,7 @@ Projects using memory_profiler
 
 `IPython memory usage <https://github.com/ianozsvald/ipython_memory_usage_>`_
 
-`SpeedIT <https://github.com/peter1000/SpeedIT>`_ (uses a reduced version of memory_profiler)
+`PySpeedIT <https://github.com/peter1000/PySpeedIT>`_ (uses a reduced version of memory_profiler)
 
 =========
  Authors
","@@ -328,7 +328,7 @@ Projects using memory_profiler
 
 `IPython memory usage <https://github.com/ianozsvald/ipython_memory_usage_>`_
 
-`SpeedIT <https://github.com/peter1000/SpeedIT>`_ (uses a reduced version of memory_profiler)
+`PySpeedIT <https://github.com/peter1000/PySpeedIT>`_ (uses a reduced version of memory_profiler)
 
 =========
  Authors
",True,README.rst,False
"@@ -0,0 +1,32 @@
+New BSD License
+
+Copyright (c) 20072014 Fabian Pedregosa.
+All rights reserved.
+
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+  a. Redistributions of source code must retain the above copyright notice,
+     this list of conditions and the following disclaimer.
+  b. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+  c. Neither the name of the Scikit-learn Developers  nor the names of
+     its contributors may be used to endorse or promote products
+     derived from this software without specific prior written
+     permission. 
+
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGE.
+
","@@ -0,0 +1,32 @@
+New BSD License
+
+Copyright (c) 20072014 Fabian Pedregosa.
+All rights reserved.
+
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+  a. Redistributions of source code must retain the above copyright notice,
+     this list of conditions and the following disclaimer.
+  b. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+  c. Neither the name of the Scikit-learn Developers  nor the names of
+     its contributors may be used to endorse or promote products
+     derived from this software without specific prior written
+     permission. 
+
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGE.
+
",True,COPYING,False
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
-__version__ = '0.31'
+__version__ = '0.32'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
-__version__ = '0.31'
+__version__ = '0.32'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -26,7 +26,7 @@ setup(
     long_description=open('README.rst').read(),
     version=memory_profiler.__version__,
     author='Fabian Pedregosa',
-    author_email='fabian@fseoane.net',
+    author_email='f@bianp.net',
     url='http://pypi.python.org/pypi/memory_profiler',
     py_modules=['memory_profiler'],
     scripts=['mprof'],
","@@ -26,7 +26,7 @@ setup(
     long_description=open('README.rst').read(),
     version=memory_profiler.__version__,
     author='Fabian Pedregosa',
-    author_email='fabian@fseoane.net',
+    author_email='f@bianp.net',
     url='http://pypi.python.org/pypi/memory_profiler',
     py_modules=['memory_profiler'],
     scripts=['mprof'],
",True,setup.py,True
"@@ -12,7 +12,7 @@ modification, are permitted provided that the following conditions are met:
   b. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
-  c. Neither the name of the Scikit-learn Developers  nor the names of
+  c. Neither the name of the memory_profiler developers nor the names of
      its contributors may be used to endorse or promote products
      derived from this software without specific prior written
      permission. 
","@@ -12,7 +12,7 @@ modification, are permitted provided that the following conditions are met:
   b. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
-  c. Neither the name of the Scikit-learn Developers  nor the names of
+  c. Neither the name of the memory_profiler developers nor the names of
      its contributors may be used to endorse or promote products
      derived from this software without specific prior written
      permission. 
",True,COPYING,False
"@@ -352,4 +352,4 @@ cleanup.
 =========
  License
 =========
-Simplified BSD
+BSD License, see file COPYING for full text.
","@@ -352,4 +352,4 @@ cleanup.
 =========
  License
 =========
-Simplified BSD
+BSD License, see file COPYING for full text.
",True,README.rst,False
"@@ -6,7 +6,7 @@ CLASSIFIERS = """"""\
 Development Status :: 5 - Production/Stable
 Intended Audience :: Science/Research
 Intended Audience :: Developers
-License :: OSI Approved
+License :: OSI Approved :: BSD License
 Programming Language :: Python
 Programming Language :: Python :: 2
 Programming Language :: Python :: 2.6
@@ -31,6 +31,6 @@ setup(
     py_modules=['memory_profiler'],
     scripts=['mprof'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
-    license='Simplified BSD'
+    license='BSD'
 
 )
","@@ -6,7 +6,7 @@ CLASSIFIERS = """"""\
 Development Status :: 5 - Production/Stable
 Intended Audience :: Science/Research
 Intended Audience :: Developers
-License :: OSI Approved
+License :: OSI Approved :: BSD License
 Programming Language :: Python
 Programming Language :: Python :: 2
 Programming Language :: Python :: 2.6
@@ -31,6 +31,6 @@ setup(
     py_modules=['memory_profiler'],
     scripts=['mprof'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
-    license='Simplified BSD'
+    license='BSD'
 
 )
",True,setup.py,True
"@@ -13,19 +13,23 @@ from optparse import OptionParser
 
 import memory_profiler as mp
 
+ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"")
 
 def print_usage():
     print(""Usage: %s <command> <options> <arguments>""
-          % osp.basename(sys.argv[0]))
+                  % osp.basename(sys.argv[0]))
+    print(""Where <command> is one of: "" + "" "".join(ALL_ACTIONS))
+    print(""Type mprof <command> --help for usage help"")
+
+
 
 def get_action():
     """"""Pop first argument, check it is a valid action.""""""
-    all_actions = (""run"", ""rm"", ""clean"", ""list"", ""plot"")
     if len(sys.argv) <= 1:
         print_usage()
         sys.exit(1)
-    if not sys.argv[1] in all_actions:
-        print(""Valid actions are: "" + "" "".join(all_actions))
+    if not sys.argv[1] in ALL_ACTIONS:
+        print_usage()
         sys.exit(1)
 
     return sys.argv.pop(1)
@@ -178,7 +182,7 @@ def run_action():
                       a Python program (currently: function timestamping.)"""""")
     parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.1"",
                       type=""float"", action=""store"",
-                      help=""Sampling period (in seconds)"")
+                      help=""Sampling period (in seconds), defaults to 0.1"")
     parser.add_option(""--include-children"", ""-C"", dest=""include_children"",
                       default=False, action=""store_true"",
                       help=""""""Monitors forked processes as well (sum up all process memory)"""""")
@@ -285,6 +289,8 @@ def read_mprofile_file(filename):
     cmd_line = None
     f = open(filename, ""r"")
     for l in f:
+        if l == '\n':
+            raise ValueError('Sampling time was too short')
         field, value = l.split(' ', 1)
         if field == ""MEM"":
             # mem, timestamp
","@@ -13,19 +13,23 @@ from optparse import OptionParser
 
 import memory_profiler as mp
 
+ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"")
 
 def print_usage():
     print(""Usage: %s <command> <options> <arguments>""
-          % osp.basename(sys.argv[0]))
+                  % osp.basename(sys.argv[0]))
+    print(""Where <command> is one of: "" + "" "".join(ALL_ACTIONS))
+    print(""Type mprof <command> --help for usage help"")
+
+
 
 def get_action():
     """"""Pop first argument, check it is a valid action.""""""
-    all_actions = (""run"", ""rm"", ""clean"", ""list"", ""plot"")
     if len(sys.argv) <= 1:
         print_usage()
         sys.exit(1)
-    if not sys.argv[1] in all_actions:
-        print(""Valid actions are: "" + "" "".join(all_actions))
+    if not sys.argv[1] in ALL_ACTIONS:
+        print_usage()
         sys.exit(1)
 
     return sys.argv.pop(1)
@@ -178,7 +182,7 @@ def run_action():
                       a Python program (currently: function timestamping.)"""""")
     parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.1"",
                       type=""float"", action=""store"",
-                      help=""Sampling period (in seconds)"")
+                      help=""Sampling period (in seconds), defaults to 0.1"")
     parser.add_option(""--include-children"", ""-C"", dest=""include_children"",
                       default=False, action=""store_true"",
                       help=""""""Monitors forked processes as well (sum up all process memory)"""""")
@@ -285,6 +289,8 @@ def read_mprofile_file(filename):
     cmd_line = None
     f = open(filename, ""r"")
     for l in f:
+        if l == '\n':
+            raise ValueError('Sampling time was too short')
         field, value = l.split(' ', 1)
         if field == ""MEM"":
             # mem, timestamp
",True,mprof,False
"@@ -1,11 +1,11 @@
 
 @profile
-def test_1():
+def test_1(i):
     # .. will be called twice ..
     c = {}
-    for i in range(1000):
+    for i in range(i):
         c[i] = 2
 
 if __name__ == '__main__':
-    test_1()
-    test_1()
+    test_1(10)
+    test_1(10000)
","@@ -1,11 +1,11 @@
 
 @profile
-def test_1():
+def test_1(i):
     # .. will be called twice ..
     c = {}
-    for i in range(1000):
+    for i in range(i):
         c[i] = 2
 
 if __name__ == '__main__':
-    test_1()
-    test_1()
+    test_1(10)
+    test_1(10000)
",True,test/test_func.py,True
"@@ -3,21 +3,19 @@
 import time
 
 @profile
-def test1():
-    a = [1] * 100000
+def test1(l):
+    a = [1] * l
     time.sleep(1)
     return a
 
 @profile
 def test2(l):
-    b = [2 * n for n in l]
+    b = [1] * l
     time.sleep(1)
-    del b
-
+    return b
 
 if __name__ == ""__main__"":
-    time.sleep(1)
-    l = test1()
-    test2(l)
-    time.sleep(1)
+    l = 100000
+    test1(l)
+    test2(2 * l)
 
","@@ -3,21 +3,19 @@
 import time
 
 @profile
-def test1():
-    a = [1] * 100000
+def test1(l):
+    a = [1] * l
     time.sleep(1)
     return a
 
 @profile
 def test2(l):
-    b = [2 * n for n in l]
+    b = [1] * l
     time.sleep(1)
-    del b
-
+    return b
 
 if __name__ == ""__main__"":
-    time.sleep(1)
-    l = test1()
-    test2(l)
-    time.sleep(1)
+    l = 100000
+    test1(l)
+    test2(2 * l)
 
",True,test/test_mprofile.py,True
"@@ -14,12 +14,23 @@ from optparse import OptionParser
 import memory_profiler as mp
 
 ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"")
+help_msg = """"""
+Available commands:
+
+    run      run a given command or python file
+    rm       remove a given file generated by mprof
+    clean    clean the current directory from files created by mprof
+    list     display existing profiles, with indices
+    plot     plot memory consumption generated by mprof run
+
+Type mprof <command> --help for usage help on a specific command.
+For example, mprof plot --help will list all plotting options.
+""""""
 
 def print_usage():
     print(""Usage: %s <command> <options> <arguments>""
                   % osp.basename(sys.argv[0]))
-    print(""Where <command> is one of: "" + "" "".join(ALL_ACTIONS))
-    print(""Type mprof <command> --help for usage help"")
+    print(help_msg)
 
 
 
","@@ -14,12 +14,23 @@ from optparse import OptionParser
 import memory_profiler as mp
 
 ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"")
+help_msg = """"""
+Available commands:
+
+    run      run a given command or python file
+    rm       remove a given file generated by mprof
+    clean    clean the current directory from files created by mprof
+    list     display existing profiles, with indices
+    plot     plot memory consumption generated by mprof run
+
+Type mprof <command> --help for usage help on a specific command.
+For example, mprof plot --help will list all plotting options.
+""""""
 
 def print_usage():
     print(""Usage: %s <command> <options> <arguments>""
                   % osp.basename(sys.argv[0]))
-    print(""Where <command> is one of: "" + "" "".join(ALL_ACTIONS))
-    print(""Type mprof <command> --help for usage help"")
+    print(help_msg)
 
 
 
",True,mprof,False
"@@ -45,12 +45,11 @@ def _get_memory(pid, timestamps=False, include_children=False):
     if has_psutil:
         process = psutil.Process(pid)
         try:
-            mem_info = getattr(process, 'memory_info', process.get_memory_info)
-            mem = mem_info()[0] / _TWO_20
+            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
+            mem = getattr(process, meminfo_attr)()[0] / _TWO_20
             if include_children:
                 for p in process.get_children(recursive=True):
-                    mem_info = getattr(p, 'memory_info', p.get_memory_info)
-                    mem += mem_info()[0] / _TWO_20
+                    mem += getattr(process, meminfo_attr)()[0] / _TWO_20
             if timestamps:
                 return (mem, time.time())
             else:
","@@ -45,12 +45,11 @@ def _get_memory(pid, timestamps=False, include_children=False):
     if has_psutil:
         process = psutil.Process(pid)
         try:
-            mem_info = getattr(process, 'memory_info', process.get_memory_info)
-            mem = mem_info()[0] / _TWO_20
+            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
+            mem = getattr(process, meminfo_attr)()[0] / _TWO_20
             if include_children:
                 for p in process.get_children(recursive=True):
-                    mem_info = getattr(p, 'memory_info', p.get_memory_info)
-                    mem += mem_info()[0] / _TWO_20
+                    mem += getattr(process, meminfo_attr)()[0] / _TWO_20
             if timestamps:
                 return (mem, time.time())
             else:
",True,memory_profiler.py,True
"@@ -45,6 +45,8 @@ def _get_memory(pid, timestamps=False, include_children=False):
     if has_psutil:
         process = psutil.Process(pid)
         try:
+            # avoid useing get_memory_info since it does not exists 
+            # in psutil > 2.0 and accessing it will cause exception.
             meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
             mem = getattr(process, meminfo_attr)()[0] / _TWO_20
             if include_children:
","@@ -45,6 +45,8 @@ def _get_memory(pid, timestamps=False, include_children=False):
     if has_psutil:
         process = psutil.Process(pid)
         try:
+            # avoid useing get_memory_info since it does not exists 
+            # in psutil > 2.0 and accessing it will cause exception.
             meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
             mem = getattr(process, meminfo_attr)()[0] / _TWO_20
             if include_children:
",True,memory_profiler.py,True
"@@ -441,10 +441,10 @@ def plot_action():
             else:
                 try:
                     n = int(arg)
+                    if not profiles[n] in filenames:
+                        filenames.append(profiles[n])
                 except ValueError:
                     print(""Input file not found: "" + arg)
-                if not profiles[n] in filenames:
-                    filenames.append(profiles[n])
 
     pl.figure(figsize=(14, 6), dpi=90)
     if len(filenames) > 1 or options.no_timestamps:
","@@ -441,10 +441,10 @@ def plot_action():
             else:
                 try:
                     n = int(arg)
+                    if not profiles[n] in filenames:
+                        filenames.append(profiles[n])
                 except ValueError:
                     print(""Input file not found: "" + arg)
-                if not profiles[n] in filenames:
-                    filenames.append(profiles[n])
 
     pl.figure(figsize=(14, 6), dpi=90)
     if len(filenames) > 1 or options.no_timestamps:
",True,mprof,False
"@@ -431,6 +431,7 @@ def plot_action():
                   ""mprofile_*.dat files, generated by the ""
                   ""'mprof run' command."")
             sys.exit(-1)
+        print(""Using last profile data."")
         filenames = [profiles[-1]]
     else:
         filenames = []
@@ -445,6 +446,9 @@ def plot_action():
                         filenames.append(profiles[n])
                 except ValueError:
                     print(""Input file not found: "" + arg)
+    if not len(filenames):
+        print(""No files found from given input."")
+        sys.exit(-1)
 
     pl.figure(figsize=(14, 6), dpi=90)
     if len(filenames) > 1 or options.no_timestamps:
","@@ -431,6 +431,7 @@ def plot_action():
                   ""mprofile_*.dat files, generated by the ""
                   ""'mprof run' command."")
             sys.exit(-1)
+        print(""Using last profile data."")
         filenames = [profiles[-1]]
     else:
         filenames = []
@@ -445,6 +446,9 @@ def plot_action():
                         filenames.append(profiles[n])
                 except ValueError:
                     print(""Input file not found: "" + arg)
+    if not len(filenames):
+        print(""No files found from given input."")
+        sys.exit(-1)
 
     pl.figure(figsize=(14, 6), dpi=90)
     if len(filenames) > 1 or options.no_timestamps:
",True,mprof,False
"@@ -227,6 +227,45 @@ args, kw)``. For example::
 This will execute the code `f(1, n=int(1e6))` and return the memory
 consumption during this execution.
 
+=====
+ REPORTING
+=====
+
+The output can be redirected to a log file by passing IO stream as
+parameter to the decorator like @profile(stream=fp)
+
+    >>> fp=open('hi.txt','w+')
+    >>> @profile(stream=fp)
+    >>> def my_func():
+        ...     a = [1] * (10 ** 6)
+        ...     b = [2] * (2 * 10 ** 7)
+        ...     del b
+        ...     return a
+
+Reporting via logger Module:
+
+Sometime it'd be very convenient to use logger module specially when
+we need to use RotatingFileHandler.
+
+The output can be redirected to logger module by simply making use of
+LogFile of memory profiler module.
+
+    >>> from memory_profiler import LogFile
+    >>> import sys
+    >>> sys.stdout = LogFile('memory_profile_log')
+
+Customised reporting:
+
+Sending everything to the log file while running the memory_profiler
+could be cumbersome and one can choose only entries with increments
+by passing True to reportIncrementFlag, where reportIncrementFlag is
+a parameter to LogFile class of memory profiler module.
+
+    >>> from memory_profiler import LogFile
+    >>> import sys
+    >>> sys.stdout = LogFile('memory_profile_log', reportIncrementFlag=False)
+
+Refer examples section for details.
 
 =====================
  IPython integration
","@@ -227,6 +227,45 @@ args, kw)``. For example::
 This will execute the code `f(1, n=int(1e6))` and return the memory
 consumption during this execution.
 
+=====
+ REPORTING
+=====
+
+The output can be redirected to a log file by passing IO stream as
+parameter to the decorator like @profile(stream=fp)
+
+    >>> fp=open('hi.txt','w+')
+    >>> @profile(stream=fp)
+    >>> def my_func():
+        ...     a = [1] * (10 ** 6)
+        ...     b = [2] * (2 * 10 ** 7)
+        ...     del b
+        ...     return a
+
+Reporting via logger Module:
+
+Sometime it'd be very convenient to use logger module specially when
+we need to use RotatingFileHandler.
+
+The output can be redirected to logger module by simply making use of
+LogFile of memory profiler module.
+
+    >>> from memory_profiler import LogFile
+    >>> import sys
+    >>> sys.stdout = LogFile('memory_profile_log')
+
+Customised reporting:
+
+Sending everything to the log file while running the memory_profiler
+could be cumbersome and one can choose only entries with increments
+by passing True to reportIncrementFlag, where reportIncrementFlag is
+a parameter to LogFile class of memory profiler module.
+
+    >>> from memory_profiler import LogFile
+    >>> import sys
+    >>> sys.stdout = LogFile('memory_profile_log', reportIncrementFlag=False)
+
+Refer examples section for details.
 
 =====================
  IPython integration
",True,README.rst,False
"@@ -1,4 +1,4 @@
-
+from memory_profiler import profile
 @profile
 def my_func():
     a = [1] * (10 ** 6)
","@@ -1,4 +1,4 @@
-
+from memory_profiler import profile
 @profile
 def my_func():
     a = [1] * (10 ** 6)
",True,examples/example.py,True
"@@ -0,0 +1,39 @@
+from memory_profiler import profile
+import logging
+
+# create logger
+logger = logging.getLogger('memory_profile_log')
+logger.setLevel(logging.DEBUG)
+
+# create file handler which logs even debug messages
+fh = logging.FileHandler(""memory_profile.log"")
+fh.setLevel(logging.DEBUG)
+
+# create formatter
+formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
+fh.setFormatter(formatter)
+
+# add the handlers to the logger
+logger.addHandler(fh)
+
+from memory_profiler import LogFile
+import sys
+sys.stdout = LogFile('memory_profile_log', reportIncrementFlag=False)
+
+@profile
+def my_func():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    del b
+    return a
+
+@profile
+def my_func1():
+    a = [2] * (10 ** 6)
+    b = [3] * (2 * 10 ** 7)
+    del b
+    return a
+
+if __name__ == '__main__':
+    my_func()
+    my_func1()
\ No newline at end of file
","@@ -0,0 +1,39 @@
+from memory_profiler import profile
+import logging
+
+# create logger
+logger = logging.getLogger('memory_profile_log')
+logger.setLevel(logging.DEBUG)
+
+# create file handler which logs even debug messages
+fh = logging.FileHandler(""memory_profile.log"")
+fh.setLevel(logging.DEBUG)
+
+# create formatter
+formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
+fh.setFormatter(formatter)
+
+# add the handlers to the logger
+logger.addHandler(fh)
+
+from memory_profiler import LogFile
+import sys
+sys.stdout = LogFile('memory_profile_log', reportIncrementFlag=False)
+
+@profile
+def my_func():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    del b
+    return a
+
+@profile
+def my_func1():
+    a = [2] * (10 ** 6)
+    b = [3] * (2 * 10 ** 7)
+    del b
+    return a
+
+if __name__ == '__main__':
+    my_func()
+    my_func1()
\ No newline at end of file
",True,examples/reportingViaLogger.py,True
"@@ -0,0 +1,21 @@
+from memory_profiler import profile
+
+f=open('hi.txt','w+')
+
+@profile(stream=f)
+def my_func():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    del b
+    return a
+
+@profile(stream=f)
+def my_func1():
+    a = [2] * (10 ** 6)
+    b = [3] * (2 * 10 ** 7)
+    del b
+    return a
+
+if __name__ == '__main__':
+    my_func()
+    my_func1()
\ No newline at end of file
","@@ -0,0 +1,21 @@
+from memory_profiler import profile
+
+f=open('hi.txt','w+')
+
+@profile(stream=f)
+def my_func():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    del b
+    return a
+
+@profile(stream=f)
+def my_func1():
+    a = [2] * (10 ** 6)
+    b = [3] * (2 * 10 ** 7)
+    del b
+    return a
+
+if __name__ == '__main__':
+    my_func()
+    my_func1()
\ No newline at end of file
",True,examples/reporting_file.py,True
"@@ -16,6 +16,7 @@ import linecache
 import inspect
 import subprocess
 from copy import copy
+import logging
 
 # TODO: provide alternative when multprocessing is not available
 try:
@@ -808,6 +809,25 @@ def profile(func=None, stream=None, precision=1):
             return profile(f, stream=stream, precision=precision)
         return inner_wrapper
 
+class LogFile(object):
+    """"""File-like object to log text using the `logging` module and the log report can be customised.""""""
+
+    def __init__(self, name=None, reportIncrementFlag=False):
+        self.logger = logging.getLogger(name)
+        self.reportIncrementFlag = reportIncrementFlag
+
+    def write(self, msg, level=logging.INFO):
+        if self.reportIncrementFlag:
+            if ""MiB"" in msg and float(msg.split(""MiB"")[1].strip())>0:
+                self.logger.log(level, msg)
+            elif msg.__contains__(""Filename:"") or msg.__contains__(""Line Contents""):
+                self.logger.log(level, msg)
+        else:
+            self.logger.log(level, msg)
+
+    def flush(self):
+        for handler in self.logger.handlers:
+            handler.flush()
 
 if __name__ == '__main__':
     from optparse import OptionParser
","@@ -16,6 +16,7 @@ import linecache
 import inspect
 import subprocess
 from copy import copy
+import logging
 
 # TODO: provide alternative when multprocessing is not available
 try:
@@ -808,6 +809,25 @@ def profile(func=None, stream=None, precision=1):
             return profile(f, stream=stream, precision=precision)
         return inner_wrapper
 
+class LogFile(object):
+    """"""File-like object to log text using the `logging` module and the log report can be customised.""""""
+
+    def __init__(self, name=None, reportIncrementFlag=False):
+        self.logger = logging.getLogger(name)
+        self.reportIncrementFlag = reportIncrementFlag
+
+    def write(self, msg, level=logging.INFO):
+        if self.reportIncrementFlag:
+            if ""MiB"" in msg and float(msg.split(""MiB"")[1].strip())>0:
+                self.logger.log(level, msg)
+            elif msg.__contains__(""Filename:"") or msg.__contains__(""Line Contents""):
+                self.logger.log(level, msg)
+        else:
+            self.logger.log(level, msg)
+
+    def flush(self):
+        for handler in self.logger.handlers:
+            handler.flush()
 
 if __name__ == '__main__':
     from optparse import OptionParser
",True,memory_profiler.py,True
"@@ -234,7 +234,7 @@ consumption during this execution.
 The output can be redirected to a log file by passing IO stream as
 parameter to the decorator like @profile(stream=fp)
 
-    >>> fp=open('hi.txt','w+')
+    >>> fp=open('memory_profiler.log','w+')
     >>> @profile(stream=fp)
     >>> def my_func():
         ...     a = [1] * (10 ** 6)
@@ -242,10 +242,12 @@ parameter to the decorator like @profile(stream=fp)
         ...     del b
         ...     return a
 
+    For details refer: examples/reporting_file.py
+
 Reporting via logger Module:
 
-Sometime it'd be very convenient to use logger module specially when
-we need to use RotatingFileHandler.
+Sometime it would be very convenient to use logger module specially
+when we need to use RotatingFileHandler.
 
 The output can be redirected to logger module by simply making use of
 LogFile of memory profiler module.
@@ -265,7 +267,7 @@ a parameter to LogFile class of memory profiler module.
     >>> import sys
     >>> sys.stdout = LogFile('memory_profile_log', reportIncrementFlag=False)
 
-Refer examples section for details.
+    For details refer: examples/reportingViaLogger.py
 
 =====================
  IPython integration
","@@ -234,7 +234,7 @@ consumption during this execution.
 The output can be redirected to a log file by passing IO stream as
 parameter to the decorator like @profile(stream=fp)
 
-    >>> fp=open('hi.txt','w+')
+    >>> fp=open('memory_profiler.log','w+')
     >>> @profile(stream=fp)
     >>> def my_func():
         ...     a = [1] * (10 ** 6)
@@ -242,10 +242,12 @@ parameter to the decorator like @profile(stream=fp)
         ...     del b
         ...     return a
 
+    For details refer: examples/reporting_file.py
+
 Reporting via logger Module:
 
-Sometime it'd be very convenient to use logger module specially when
-we need to use RotatingFileHandler.
+Sometime it would be very convenient to use logger module specially
+when we need to use RotatingFileHandler.
 
 The output can be redirected to logger module by simply making use of
 LogFile of memory profiler module.
@@ -265,7 +267,7 @@ a parameter to LogFile class of memory profiler module.
     >>> import sys
     >>> sys.stdout = LogFile('memory_profile_log', reportIncrementFlag=False)
 
-Refer examples section for details.
+    For details refer: examples/reportingViaLogger.py
 
 =====================
  IPython integration
",True,README.rst,False
"@@ -36,4 +36,4 @@ def my_func1():
 
 if __name__ == '__main__':
     my_func()
-    my_func1()
\ No newline at end of file
+    my_func1()
","@@ -36,4 +36,4 @@ def my_func1():
 
 if __name__ == '__main__':
     my_func()
-    my_func1()
\ No newline at end of file
+    my_func1()
",True,examples/reporting_logger.py,True
"@@ -267,7 +267,7 @@ a parameter to LogFile class of memory profiler module.
     >>> import sys
     >>> sys.stdout = LogFile('memory_profile_log', reportIncrementFlag=False)
 
-    For details refer: examples/reportingViaLogger.py
+    For details refer: examples/reporting_logger.py
 
 =====================
  IPython integration
","@@ -267,7 +267,7 @@ a parameter to LogFile class of memory profiler module.
     >>> import sys
     >>> sys.stdout = LogFile('memory_profile_log', reportIncrementFlag=False)
 
-    For details refer: examples/reportingViaLogger.py
+    For details refer: examples/reporting_logger.py
 
 =====================
  IPython integration
",True,README.rst,False
"@@ -244,7 +244,7 @@ parameter to the decorator like @profile(stream=fp)
 
     For details refer: examples/reporting_file.py
 
-Reporting via logger Module:
+``Reporting via logger Module:``
 
 Sometime it would be very convenient to use logger module specially
 when we need to use RotatingFileHandler.
@@ -256,7 +256,7 @@ LogFile of memory profiler module.
     >>> import sys
     >>> sys.stdout = LogFile('memory_profile_log')
 
-Customised reporting:
+``Customised reporting:``
 
 Sending everything to the log file while running the memory_profiler
 could be cumbersome and one can choose only entries with increments
@@ -389,6 +389,8 @@ cleanup.
 
 `Thomas Kluyver <https://github.com/takluyver>`_ added the IPython extension.
 
+`Sagar UDAY KUMAR <https://github.com/sagaru>`_ added Report generation feature and examples.
+
 
 =========
  License
","@@ -244,7 +244,7 @@ parameter to the decorator like @profile(stream=fp)
 
     For details refer: examples/reporting_file.py
 
-Reporting via logger Module:
+``Reporting via logger Module:``
 
 Sometime it would be very convenient to use logger module specially
 when we need to use RotatingFileHandler.
@@ -256,7 +256,7 @@ LogFile of memory profiler module.
     >>> import sys
     >>> sys.stdout = LogFile('memory_profile_log')
 
-Customised reporting:
+``Customised reporting:``
 
 Sending everything to the log file while running the memory_profiler
 could be cumbersome and one can choose only entries with increments
@@ -389,6 +389,8 @@ cleanup.
 
 `Thomas Kluyver <https://github.com/takluyver>`_ added the IPython extension.
 
+`Sagar UDAY KUMAR <https://github.com/sagaru>`_ added Report generation feature and examples.
+
 
 =========
  License
",True,README.rst,False
"@@ -813,6 +813,14 @@ class LogFile(object):
     """"""File-like object to log text using the `logging` module and the log report can be customised.""""""
 
     def __init__(self, name=None, reportIncrementFlag=False):
+        """"""
+        :param name: name of the logger module
+               reportIncrementFlag: This must be set to True if only the steps with memory increments are to be reported
+
+        :type self: object
+              name: string
+              reportIncrementFlag: bool
+        """"""
         self.logger = logging.getLogger(name)
         self.reportIncrementFlag = reportIncrementFlag
 
","@@ -813,6 +813,14 @@ class LogFile(object):
     """"""File-like object to log text using the `logging` module and the log report can be customised.""""""
 
     def __init__(self, name=None, reportIncrementFlag=False):
+        """"""
+        :param name: name of the logger module
+               reportIncrementFlag: This must be set to True if only the steps with memory increments are to be reported
+
+        :type self: object
+              name: string
+              reportIncrementFlag: bool
+        """"""
         self.logger = logging.getLogger(name)
         self.reportIncrementFlag = reportIncrementFlag
 
",True,memory_profiler.py,True
"@@ -371,6 +371,8 @@ Projects using memory_profiler
 
 `PySpeedIT <https://github.com/peter1000/PySpeedIT>`_ (uses a reduced version of memory_profiler)
 
+`pydio-sync <https://github.com/pydio/pydio-sync>`_ (uses custom wrapper on top of memory_profiler)
+
 =========
  Authors
 =========
","@@ -371,6 +371,8 @@ Projects using memory_profiler
 
 `PySpeedIT <https://github.com/peter1000/PySpeedIT>`_ (uses a reduced version of memory_profiler)
 
+`pydio-sync <https://github.com/pydio/pydio-sync>`_ (uses custom wrapper on top of memory_profiler)
+
 =========
  Authors
 =========
",True,README.rst,False
"@@ -344,7 +344,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
  Support, bugs & wish list
 ===========================
 For support, please ask your question on `stack overflow
-<http://stackoverflow.com/>`_ and add the *memory-profiling* tag.
+<http://stackoverflow.com/>`_ and add the [*memory-profiling* tag](http://stackoverflow.com/questions/tagged/memory-profiling).
 Send issues, proposals, etc. to `github's issue tracker
 <https://github.com/fabianp/memory_profiler/issues>`_ .
 
","@@ -344,7 +344,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
  Support, bugs & wish list
 ===========================
 For support, please ask your question on `stack overflow
-<http://stackoverflow.com/>`_ and add the *memory-profiling* tag.
+<http://stackoverflow.com/>`_ and add the [*memory-profiling* tag](http://stackoverflow.com/questions/tagged/memory-profiling).
 Send issues, proposals, etc. to `github's issue tracker
 <https://github.com/fabianp/memory_profiler/issues>`_ .
 
",True,README.rst,False
"@@ -344,7 +344,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
  Support, bugs & wish list
 ===========================
 For support, please ask your question on `stack overflow
-<http://stackoverflow.com/>`_ and add the [*memory-profiling* tag](http://stackoverflow.com/questions/tagged/memory-profiling).
+<http://stackoverflow.com/>`_ and add the `*memory-profiling* tag <http://stackoverflow.com/questions/tagged/memory-profiling>`_.
 Send issues, proposals, etc. to `github's issue tracker
 <https://github.com/fabianp/memory_profiler/issues>`_ .
 
","@@ -344,7 +344,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
  Support, bugs & wish list
 ===========================
 For support, please ask your question on `stack overflow
-<http://stackoverflow.com/>`_ and add the [*memory-profiling* tag](http://stackoverflow.com/questions/tagged/memory-profiling).
+<http://stackoverflow.com/>`_ and add the `*memory-profiling* tag <http://stackoverflow.com/questions/tagged/memory-profiling>`_.
 Send issues, proposals, etc. to `github's issue tracker
 <https://github.com/fabianp/memory_profiler/issues>`_ .
 
",True,README.rst,False
"@@ -199,13 +199,14 @@ def run_action():
                       help=""""""Monitors forked processes as well (sum up all process memory)"""""")
 
     (options, args) = parser.parse_args()
-    print(""{1}: Sampling memory every {0.interval}s"".format(
-        options, osp.basename(sys.argv[0])))
 
     if len(args) == 0:
         print(""A program to run must be provided. Use -h for help"")
         sys.exit(1)
 
+    print(""{1}: Sampling memory every {0.interval}s"".format(
+        options, osp.basename(sys.argv[0])))
+
     ## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
     ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
     ## directory. This file contains the process memory consumption, in Mb (one
","@@ -199,13 +199,14 @@ def run_action():
                       help=""""""Monitors forked processes as well (sum up all process memory)"""""")
 
     (options, args) = parser.parse_args()
-    print(""{1}: Sampling memory every {0.interval}s"".format(
-        options, osp.basename(sys.argv[0])))
 
     if len(args) == 0:
         print(""A program to run must be provided. Use -h for help"")
         sys.exit(1)
 
+    print(""{1}: Sampling memory every {0.interval}s"".format(
+        options, osp.basename(sys.argv[0])))
+
     ## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
     ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
     ## directory. This file contains the process memory consumption, in Mb (one
",True,mprof,False
"@@ -1,7 +1,7 @@
 """"""Profile the memory usage of a Python program""""""
 
 # .. we'll use this to pass it to the child script ..
-_clean_globals = globals().copy()
+_CLEAN_GLOBALS = globals().copy()
 
 __version__ = '0.32'
 
@@ -46,7 +46,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
     if has_psutil:
         process = psutil.Process(pid)
         try:
-            # avoid useing get_memory_info since it does not exists 
+            # avoid useing get_memory_info since it does not exists
             # in psutil > 2.0 and accessing it will cause exception.
             meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
             mem = getattr(process, meminfo_attr)()[0] / _TWO_20
@@ -877,13 +877,13 @@ if __name__ == '__main__':
             # script where @profile is used)
             import __builtin__
             __builtin__.__dict__['profile'] = prof
-            ns = copy(_clean_globals)
+            ns = copy(_CLEAN_GLOBALS)
             ns['profile'] = prof  # shadow the profile decorator defined above
             execfile(__file__, ns, ns)
         else:
             import builtins
             builtins.__dict__['profile'] = prof
-            ns = copy(_clean_globals)
+            ns = copy(_CLEAN_GLOBALS)
             ns['profile'] = prof  # shadow the profile decorator defined above
             exec(compile(open(__file__).read(), __file__, 'exec'), ns, ns)
     finally:
","@@ -1,7 +1,7 @@
 """"""Profile the memory usage of a Python program""""""
 
 # .. we'll use this to pass it to the child script ..
-_clean_globals = globals().copy()
+_CLEAN_GLOBALS = globals().copy()
 
 __version__ = '0.32'
 
@@ -46,7 +46,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
     if has_psutil:
         process = psutil.Process(pid)
         try:
-            # avoid useing get_memory_info since it does not exists 
+            # avoid useing get_memory_info since it does not exists
             # in psutil > 2.0 and accessing it will cause exception.
             meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
             mem = getattr(process, meminfo_attr)()[0] / _TWO_20
@@ -877,13 +877,13 @@ if __name__ == '__main__':
             # script where @profile is used)
             import __builtin__
             __builtin__.__dict__['profile'] = prof
-            ns = copy(_clean_globals)
+            ns = copy(_CLEAN_GLOBALS)
             ns['profile'] = prof  # shadow the profile decorator defined above
             execfile(__file__, ns, ns)
         else:
             import builtins
             builtins.__dict__['profile'] = prof
-            ns = copy(_clean_globals)
+            ns = copy(_CLEAN_GLOBALS)
             ns['profile'] = prof  # shadow the profile decorator defined above
             exec(compile(open(__file__).read(), __file__, 'exec'), ns, ns)
     finally:
",True,memory_profiler.py,True
"@@ -131,22 +131,16 @@ script with
 
     mprof run --python <script>
 
-will record timestamps when entering/leaving the profiled function,
-and plot them on the graph afterward. 
-An example output can be found 
-`here <https://github.com/scikit-learn/scikit-learn/pull/2248>`_
+will record timestamps when entering/leaving the profiled function. Runnning
 
-It is also possible to timestamp a portion of code using a context
-manager like this::
+    mprof plot
 
-    def my_func():
-        a = [1] * (10 ** 6)
-        with profile.timestamp(""b_computation""):
-            b = [2] * (2 * 10 ** 7)
-        del b
-        return a
+afterward will plot the result, making plots (using matplotlib) similar to these:
+
+.. image:: https://camo.githubusercontent.com/3a584c7cfbae38c9220a755aa21b5ef926c1031d/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313930383631382f3836313332302f63623865376337382d663563632d313165322d386531652d3539373237623636663462322e706e67
+   :target: https://github.com/scikit-learn/scikit-learn/pull/2248
 
-the string provided in the call will be displayed in the plot.
+A discussion of these capabilities can be found `here <http://fa.bianp.net/blog/2014/plot-memory-usage-as-a-function-of-time/>`_.
 
 The available commands for `mprof` are: 
 
","@@ -131,22 +131,16 @@ script with
 
     mprof run --python <script>
 
-will record timestamps when entering/leaving the profiled function,
-and plot them on the graph afterward. 
-An example output can be found 
-`here <https://github.com/scikit-learn/scikit-learn/pull/2248>`_
+will record timestamps when entering/leaving the profiled function. Runnning
 
-It is also possible to timestamp a portion of code using a context
-manager like this::
+    mprof plot
 
-    def my_func():
-        a = [1] * (10 ** 6)
-        with profile.timestamp(""b_computation""):
-            b = [2] * (2 * 10 ** 7)
-        del b
-        return a
+afterward will plot the result, making plots (using matplotlib) similar to these:
 
-the string provided in the call will be displayed in the plot.
+.. image:: https://camo.githubusercontent.com/3a584c7cfbae38c9220a755aa21b5ef926c1031d/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313930383631382f3836313332302f63623865376337382d663563632d313165322d386531652d3539373237623636663462322e706e67
+   :target: https://github.com/scikit-learn/scikit-learn/pull/2248
+
+A discussion of these capabilities can be found `here <http://fa.bianp.net/blog/2014/plot-memory-usage-as-a-function-of-time/>`_.
 
 The available commands for `mprof` are: 
 
",False,README.rst,False
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.32'
+__version__ = '0.33'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.32'
+__version__ = '0.33'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.33'
+__version__ = '0.34'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.33'
+__version__ = '0.34'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -139,6 +139,7 @@ afterward will plot the result, making plots (using matplotlib) similar to these
 
 .. image:: https://camo.githubusercontent.com/3a584c7cfbae38c9220a755aa21b5ef926c1031d/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313930383631382f3836313332302f63623865376337382d663563632d313165322d386531652d3539373237623636663462322e706e67
    :target: https://github.com/scikit-learn/scikit-learn/pull/2248
+   :height: 350px
 
 A discussion of these capabilities can be found `here <http://fa.bianp.net/blog/2014/plot-memory-usage-as-a-function-of-time/>`_.
 
@@ -221,9 +222,9 @@ args, kw)``. For example::
 This will execute the code `f(1, n=int(1e6))` and return the memory
 consumption during this execution.
 
-=====
- REPORTING
-=====
+=========
+REPORTING
+=========
 
 The output can be redirected to a log file by passing IO stream as
 parameter to the decorator like @profile(stream=fp)
","@@ -139,6 +139,7 @@ afterward will plot the result, making plots (using matplotlib) similar to these
 
 .. image:: https://camo.githubusercontent.com/3a584c7cfbae38c9220a755aa21b5ef926c1031d/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313930383631382f3836313332302f63623865376337382d663563632d313165322d386531652d3539373237623636663462322e706e67
    :target: https://github.com/scikit-learn/scikit-learn/pull/2248
+   :height: 350px
 
 A discussion of these capabilities can be found `here <http://fa.bianp.net/blog/2014/plot-memory-usage-as-a-function-of-time/>`_.
 
@@ -221,9 +222,9 @@ args, kw)``. For example::
 This will execute the code `f(1, n=int(1e6))` and return the memory
 consumption during this execution.
 
-=====
- REPORTING
-=====
+=========
+REPORTING
+=========
 
 The output can be redirected to a log file by passing IO stream as
 parameter to the decorator like @profile(stream=fp)
",True,README.rst,False
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.34'
+__version__ = '0.36'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.34'
+__version__ = '0.36'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -51,8 +51,13 @@ def _get_memory(pid, timestamps=False, include_children=False):
             meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
             mem = getattr(process, meminfo_attr)()[0] / _TWO_20
             if include_children:
-                for p in process.get_children(recursive=True):
-                    mem += getattr(process, meminfo_attr)()[0] / _TWO_20
+                try:
+                    for p in process.get_children(recursive=True):
+                        mem += getattr(process, meminfo_attr)()[0] / _TWO_20
+                except AttributeError:
+                    # fix for newer psutil
+                    for p in process.children(recursive=True):
+                        mem += getattr(process, meminfo_attr)()[0] / _TWO_20
             if timestamps:
                 return (mem, time.time())
             else:
","@@ -51,8 +51,13 @@ def _get_memory(pid, timestamps=False, include_children=False):
             meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
             mem = getattr(process, meminfo_attr)()[0] / _TWO_20
             if include_children:
-                for p in process.get_children(recursive=True):
-                    mem += getattr(process, meminfo_attr)()[0] / _TWO_20
+                try:
+                    for p in process.get_children(recursive=True):
+                        mem += getattr(process, meminfo_attr)()[0] / _TWO_20
+                except AttributeError:
+                    # fix for newer psutil
+                    for p in process.children(recursive=True):
+                        mem += getattr(process, meminfo_attr)()[0] / _TWO_20
             if timestamps:
                 return (mem, time.time())
             else:
",True,memory_profiler.py,True
"@@ -143,6 +143,8 @@ afterward will plot the result, making plots (using matplotlib) similar to these
 
 A discussion of these capabilities can be found `here <http://fa.bianp.net/blog/2014/plot-memory-usage-as-a-function-of-time/>`_.
 
+.. warning:: If your Python file imports the memory profiler `from memory_profiler import profile` these timestamps will not be recorded. Comment out the import, leave your functions decorated, and re-run.
+
 The available commands for `mprof` are: 
 
   - ``mprof run``: running an executable, recording memory usage  
","@@ -143,6 +143,8 @@ afterward will plot the result, making plots (using matplotlib) similar to these
 
 A discussion of these capabilities can be found `here <http://fa.bianp.net/blog/2014/plot-memory-usage-as-a-function-of-time/>`_.
 
+.. warning:: If your Python file imports the memory profiler `from memory_profiler import profile` these timestamps will not be recorded. Comment out the import, leave your functions decorated, and re-run.
+
 The available commands for `mprof` are: 
 
   - ``mprof run``: running an executable, recording memory usage  
",True,README.rst,False
"@@ -5,7 +5,7 @@ import scipy.signal
 @profile
 def create_data():
     ret = []
-    for n in xrange(70):
+    for n in range(70):
         ret.append(np.random.randn(1, 70, 71, 72))
     return ret
 
","@@ -5,7 +5,7 @@ import scipy.signal
 @profile
 def create_data():
     ret = []
-    for n in xrange(70):
+    for n in range(70):
         ret.append(np.random.randn(1, 70, 71, 72))
     return ret
 
",True,examples/numpy_example.py,True
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.36'
+__version__ = '0.37'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.36'
+__version__ = '0.37'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -451,7 +451,8 @@ def plot_action():
         print(""No files found from given input."")
         sys.exit(-1)
 
-    pl.figure(figsize=(14, 6), dpi=90)
+    fig = pl.figure(figsize=(14, 6), dpi=90)
+    ax = fig.add_axes([0.1, 0.1, 0.6, 0.75])
     if len(filenames) > 1 or options.no_timestamps:
         timestamps = False
     else:
@@ -467,10 +468,9 @@ def plot_action():
         if options.title is not None:
             pl.title(options.title)
 
-    ax = pl.gca()
     # place legend within the plot, make partially transparent in
     # case it obscures part of the lineplot
-    leg = ax.legend(loc='best', fancybox=True)
+    leg = ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))
     leg.get_frame().set_alpha(0.5)
     pl.grid()
     if options.output:
","@@ -451,7 +451,8 @@ def plot_action():
         print(""No files found from given input."")
         sys.exit(-1)
 
-    pl.figure(figsize=(14, 6), dpi=90)
+    fig = pl.figure(figsize=(14, 6), dpi=90)
+    ax = fig.add_axes([0.1, 0.1, 0.6, 0.75])
     if len(filenames) > 1 or options.no_timestamps:
         timestamps = False
     else:
@@ -467,10 +468,9 @@ def plot_action():
         if options.title is not None:
             pl.title(options.title)
 
-    ax = pl.gca()
     # place legend within the plot, make partially transparent in
     # case it obscures part of the lineplot
-    leg = ax.legend(loc='best', fancybox=True)
+    leg = ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))
     leg.get_frame().set_alpha(0.5)
     pl.grid()
     if options.output:
",True,mprof,False
"@@ -269,8 +269,8 @@ a parameter to LogFile class of memory profiler module.
 =====================
  IPython integration
 =====================
-After installing the module, if you use IPython, you can use the `%mprun`
-and `%memit` magics.
+After installing the module, if you use IPython, you can use the `%mprun`, `%%mprun`,
+`%memit` and `%%memit` magics.
 
 For IPython 0.11+, you can use the module directly as an extension, with
 ``%load_ext memory_profiler``
@@ -288,22 +288,36 @@ the list)::
 a terminal.)
 
 It then can be used directly from IPython to obtain a line-by-line
-report using the `%mprun` magic command. In this case, you can skip
+report using the `%mprun` or `%%mprun` magic command. In this case, you can skip
 the `@profile` decorator and instead use the `-f` parameter, like
 this. Note however that function my_func must be defined in a file
 (cannot have been defined interactively in the Python interpreter)::
 
-    In [1] from example import my_func
+    In [1]: from example import my_func, my_func_2
 
-    In [2] %mprun -f my_func my_func()
+    In [2]: %mprun -f my_func my_func()
+
+or in cell mode::
+
+    In [3]: %%mprun -f my_func -f my_func_2
+       ...: my_func()
+       ...: my_func_2()
 
 Another useful magic that we define is `%memit`, which is analogous to
 `%timeit`. It can be used as follows::
 
-    In [1]: import numpy as np
+    In [1]: %memit range(10000)
+    peak memory: 21.42 MiB, increment: 0.41 MiB
+
+    In [2]: %memit range(1000000)
+    peak memory: 52.10 MiB, increment: 31.08 MiB
+
+or in cell mode (with setup code)::
 
-    In [2]: %memit np.zeros(1e7)
-    maximum of 3: 76.402344 MB per loop
+    In [3]: %%memit l=range(1000000)
+       ...: len(l)
+       ...:
+    peak memory: 52.14 MiB, increment: 0.08 MiB
 
 For more details, see the docstrings of the magics.
 
@@ -316,8 +330,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
 
     # These two are the important ones.
     import memory_profiler
-    ip.expose_magic('mprun', memory_profiler.magic_mprun)
-    ip.expose_magic('memit', memory_profiler.magic_memit)
+    memory_profiler.load_ipython_extension(ip)
 
 ============================
  Frequently Asked Questions
@@ -373,7 +386,7 @@ Projects using memory_profiler
 =========
  Authors
 =========
-This module was written by `Fabian Pedregosa <http://fseoane.net>`_ 
+This module was written by `Fabian Pedregosa <http://fseoane.net>`_
 and `Philippe Gervais <https://github.com/pgervais>`_
 inspired by Robert Kern's `line profiler
 <http://packages.python.org/line_profiler/>`_.
","@@ -269,8 +269,8 @@ a parameter to LogFile class of memory profiler module.
 =====================
  IPython integration
 =====================
-After installing the module, if you use IPython, you can use the `%mprun`
-and `%memit` magics.
+After installing the module, if you use IPython, you can use the `%mprun`, `%%mprun`,
+`%memit` and `%%memit` magics.
 
 For IPython 0.11+, you can use the module directly as an extension, with
 ``%load_ext memory_profiler``
@@ -288,22 +288,36 @@ the list)::
 a terminal.)
 
 It then can be used directly from IPython to obtain a line-by-line
-report using the `%mprun` magic command. In this case, you can skip
+report using the `%mprun` or `%%mprun` magic command. In this case, you can skip
 the `@profile` decorator and instead use the `-f` parameter, like
 this. Note however that function my_func must be defined in a file
 (cannot have been defined interactively in the Python interpreter)::
 
-    In [1] from example import my_func
+    In [1]: from example import my_func, my_func_2
 
-    In [2] %mprun -f my_func my_func()
+    In [2]: %mprun -f my_func my_func()
+
+or in cell mode::
+
+    In [3]: %%mprun -f my_func -f my_func_2
+       ...: my_func()
+       ...: my_func_2()
 
 Another useful magic that we define is `%memit`, which is analogous to
 `%timeit`. It can be used as follows::
 
-    In [1]: import numpy as np
+    In [1]: %memit range(10000)
+    peak memory: 21.42 MiB, increment: 0.41 MiB
 
-    In [2]: %memit np.zeros(1e7)
-    maximum of 3: 76.402344 MB per loop
+    In [2]: %memit range(1000000)
+    peak memory: 52.10 MiB, increment: 31.08 MiB
+
+or in cell mode (with setup code)::
+
+    In [3]: %%memit l=range(1000000)
+       ...: len(l)
+       ...:
+    peak memory: 52.14 MiB, increment: 0.08 MiB
 
 For more details, see the docstrings of the magics.
 
@@ -316,8 +330,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
 
     # These two are the important ones.
     import memory_profiler
-    ip.expose_magic('mprun', memory_profiler.magic_mprun)
-    ip.expose_magic('memit', memory_profiler.magic_memit)
+    memory_profiler.load_ipython_extension(ip)
 
 ============================
  Frequently Asked Questions
@@ -373,7 +386,7 @@ Projects using memory_profiler
 =========
  Authors
 =========
-This module was written by `Fabian Pedregosa <http://fseoane.net>`_ 
+This module was written by `Fabian Pedregosa <http://fseoane.net>`_
 and `Philippe Gervais <https://github.com/pgervais>`_
 inspired by Robert Kern's `line profiler
 <http://packages.python.org/line_profiler/>`_.
",False,README.rst,False
"@@ -24,6 +24,16 @@ try:
 except ImportError:
     from multiprocessing.dummy import Process, Pipe
 
+try:
+    from IPython.core.magic import Magics, line_cell_magic, magics_class
+except ImportError:
+    # ipython_version < '0.13'
+    Magics = object
+    line_cell_magic = lambda func: func
+    magics_class = lambda cls: cls
+
+PY3 = sys.version_info[0] == 3
+
 _TWO_20 = float(2 ** 20)
 
 has_psutil = False
@@ -593,209 +603,271 @@ def show_results(prof, stream=None, precision=1):
         stream.write('\n\n')
 
 
-# A lprun-style %mprun magic for IPython.
-def magic_mprun(self, parameter_s=''):
-    """""" Execute a statement under the line-by-line memory profiler from the
-    memory_profiler module.
+def _func_exec(stmt, ns):
+    # helper for magic_memit, just a function proxy for the exec
+    # statement
+    exec(stmt, ns)
 
-    Usage:
-      %mprun -f func1 -f func2 <statement>
 
-    The given statement (which doesn't require quote marks) is run via the
-    LineProfiler. Profiling is enabled for the functions specified by the -f
-    options. The statistics will be shown side-by-side with the code through
-    the pager once the statement has completed.
+@magics_class
+class MemoryProfilerMagics(Magics):
 
-    Options:
+    # A lprun-style %mprun magic for IPython.
+    @line_cell_magic
+    def mprun(self, parameter_s='', cell=None):
+        """""" Execute a statement under the line-by-line memory profiler from the
+        memory_profiler module.
 
-    -f <function>: LineProfiler only profiles functions and methods it is told
-    to profile.  This option tells the profiler about these functions. Multiple
-    -f options may be used. The argument may be any expression that gives
-    a Python function or method object. However, one must be careful to avoid
-    spaces that may confuse the option parser. Additionally, functions defined
-    in the interpreter at the In[] prompt or via %run currently cannot be
-    displayed.  Write these functions out to a separate file and import them.
+        Usage, in line mode:
+          %mprun -f func1 -f func2 <statement>
 
-    One or more -f options are required to get any useful results.
+        Usage, in cell mode:
+          %%mprun -f func1 -f func2 [statement]
+          code...
+          code...
 
-    -T <filename>: dump the text-formatted statistics with the code
-    side-by-side out to a text file.
+        In cell mode, the additional code lines are appended to the (possibly
+        empty) statement in the first line. Cell mode allows you to easily
+        profile multiline blocks without having to put them in a separate
+        function.
 
-    -r: return the LineProfiler object after it has completed profiling.
+        The given statement (which doesn't require quote marks) is run via the
+        LineProfiler. Profiling is enabled for the functions specified by the -f
+        options. The statistics will be shown side-by-side with the code through
+        the pager once the statement has completed.
 
-    -c: If present, add the memory usage of any children process to the report.
-    """"""
-    try:
-        from StringIO import StringIO
-    except ImportError:  # Python 3.x
-        from io import StringIO
-
-    # Local imports to avoid hard dependency.
-    from distutils.version import LooseVersion
-    import IPython
-    ipython_version = LooseVersion(IPython.__version__)
-    if ipython_version < '0.11':
-        from IPython.genutils import page
-        from IPython.ipstruct import Struct
-        from IPython.ipapi import UsageError
-    else:
-        from IPython.core.page import page
-        from IPython.utils.ipstruct import Struct
-        from IPython.core.error import UsageError
-
-    # Escape quote markers.
-    opts_def = Struct(T=[''], f=[])
-    parameter_s = parameter_s.replace('""', r'\""').replace(""'"", r""\'"")
-    opts, arg_str = self.parse_options(parameter_s, 'rf:T:c', list_all=True)
-    opts.merge(opts_def)
-    global_ns = self.shell.user_global_ns
-    local_ns = self.shell.user_ns
-
-    # Get the requested functions.
-    funcs = []
-    for name in opts.f:
-        try:
-            funcs.append(eval(name, global_ns, local_ns))
-        except Exception as e:
-            raise UsageError('Could not find function %r.\n%s: %s' % (name,
-                             e.__class__.__name__, e))
+        Options:
 
-    include_children = 'c' in opts
-    profile = LineProfiler(include_children=include_children)
-    for func in funcs:
-        profile(func)
+        -f <function>: LineProfiler only profiles functions and methods it is told
+        to profile.  This option tells the profiler about these functions. Multiple
+        -f options may be used. The argument may be any expression that gives
+        a Python function or method object. However, one must be careful to avoid
+        spaces that may confuse the option parser. Additionally, functions defined
+        in the interpreter at the In[] prompt or via %run currently cannot be
+        displayed.  Write these functions out to a separate file and import them.
 
-    # Add the profiler to the builtins for @profile.
-    try:
-        import builtins
-    except ImportError:  # Python 3x
-        import __builtin__ as builtins
+        One or more -f options are required to get any useful results.
 
-    if 'profile' in builtins.__dict__:
-        had_profile = True
-        old_profile = builtins.__dict__['profile']
-    else:
-        had_profile = False
-        old_profile = None
-    builtins.__dict__['profile'] = profile
+        -T <filename>: dump the text-formatted statistics with the code
+        side-by-side out to a text file.
 
-    try:
+        -r: return the LineProfiler object after it has completed profiling.
+
+        -c: If present, add the memory usage of any children process to the report.
+        """"""
+        from memory_profiler import show_results, LineProfiler
         try:
-            profile.runctx(arg_str, global_ns, local_ns)
-            message = ''
-        except SystemExit:
-            message = ""*** SystemExit exception caught in code being profiled.""
-        except KeyboardInterrupt:
-            message = (""*** KeyboardInterrupt exception caught in code being ""
-                       ""profiled."")
-    finally:
-        if had_profile:
-            builtins.__dict__['profile'] = old_profile
+            from StringIO import StringIO
+        except ImportError:  # Python 3.x
+            from io import StringIO
+
+        # Local imports to avoid hard dependency.
+        from distutils.version import LooseVersion
+        import IPython
+        ipython_version = LooseVersion(IPython.__version__)
+        if ipython_version < '0.11':
+            from IPython.genutils import page
+            from IPython.ipstruct import Struct
+            from IPython.ipapi import UsageError
+        else:
+            from IPython.core.page import page
+            from IPython.utils.ipstruct import Struct
+            from IPython.core.error import UsageError
+
+        # Escape quote markers.
+        opts_def = Struct(T=[''], f=[])
+        parameter_s = parameter_s.replace('""', r'\""').replace(""'"", r""\'"")
+        opts, arg_str = self.parse_options(parameter_s, 'rf:T:c', list_all=True)
+        opts.merge(opts_def)
+        global_ns = self.shell.user_global_ns
+        local_ns = self.shell.user_ns
+
+        if cell is not None:
+            arg_str += '\n' + cell
+
+        # Get the requested functions.
+        funcs = []
+        for name in opts.f:
+            try:
+                funcs.append(eval(name, global_ns, local_ns))
+            except Exception as e:
+                raise UsageError('Could not find function %r.\n%s: %s' % (name,
+                                 e.__class__.__name__, e))
+
+        include_children = 'c' in opts
+        profile = LineProfiler(include_children=include_children)
+        for func in funcs:
+            profile(func)
+
+        # Add the profiler to the builtins for @profile.
+        if PY3:
+            import builtins
+        else:
+            import __builtin__ as builtins
 
-    # Trap text output.
-    stdout_trap = StringIO()
-    show_results(profile, stdout_trap)
-    output = stdout_trap.getvalue()
-    output = output.rstrip()
+        if 'profile' in builtins.__dict__:
+            had_profile = True
+            old_profile = builtins.__dict__['profile']
+        else:
+            had_profile = False
+            old_profile = None
+        builtins.__dict__['profile'] = profile
 
-    if ipython_version < '0.11':
-        page(output, screen_lines=self.shell.rc.screen_length)
-    else:
-        page(output)
-    print(message,)
+        try:
+            try:
+                profile.runctx(arg_str, global_ns, local_ns)
+                message = ''
+            except SystemExit:
+                message = ""*** SystemExit exception caught in code being profiled.""
+            except KeyboardInterrupt:
+                message = (""*** KeyboardInterrupt exception caught in code being ""
+                           ""profiled."")
+        finally:
+            if had_profile:
+                builtins.__dict__['profile'] = old_profile
 
-    text_file = opts.T[0]
-    if text_file:
-        with open(text_file, 'w') as pfile:
-            pfile.write(output)
-        print('\n*** Profile printout saved to text file %s. %s' % (text_file,
-                                                                    message))
+        # Trap text output.
+        stdout_trap = StringIO()
+        show_results(profile, stdout_trap)
+        output = stdout_trap.getvalue()
+        output = output.rstrip()
 
-    return_value = None
-    if 'r' in opts:
-        return_value = profile
+        if ipython_version < '0.11':
+            page(output, screen_lines=self.shell.rc.screen_length)
+        else:
+            page(output)
+        print(message,)
 
-    return return_value
+        text_file = opts.T[0]
+        if text_file:
+            with open(text_file, 'w') as pfile:
+                pfile.write(output)
+            print('\n*** Profile printout saved to text file %s. %s' % (text_file,
+                                                                        message))
 
+        return_value = None
+        if 'r' in opts:
+            return_value = profile
 
-def _func_exec(stmt, ns):
-    # helper for magic_memit, just a function proxy for the exec
-    # statement
-    exec(stmt, ns)
+        return return_value
 
-# a timeit-style %memit magic for IPython
+    # a timeit-style %memit magic for IPython
+    @line_cell_magic
+    def memit(self, line='', cell=None):
+        """"""Measure memory usage of a Python statement
 
+        Usage, in line mode:
+          %memit [-r<R>t<T>i<I>] statement
 
-def magic_memit(self, line=''):
-    """"""Measure memory usage of a Python statement
+        Usage, in cell mode:
+          %%memit [-r<R>t<T>i<I>] setup_code
+          code...
+          code...
 
-    Usage, in line mode:
-      %memit [-r<R>t<T>i<I>] statement
+        This function can be used both as a line and cell magic:
 
-    Options:
-    -r<R>: repeat the loop iteration <R> times and take the best result.
-    Default: 1
+        - In line mode you can measure a single-line statement (though multiple
+          ones can be chained with using semicolons).
 
-    -t<T>: timeout after <T> seconds. Default: None
+        - In cell mode, the statement in the first line is used as setup code
+          (executed but not measured) and the body of the cell is measured.
+          The cell body has access to any variables created in the setup code.
 
-    -i<I>: Get time information at an interval of I times per second.
-        Defaults to 0.1 so that there is ten measurements per second.
+        Options:
+        -r<R>: repeat the loop iteration <R> times and take the best result.
+        Default: 1
 
-    -c: If present, add the memory usage of any children process to the report.
+        -t<T>: timeout after <T> seconds. Default: None
 
-    Examples
-    --------
-    ::
+        -i<I>: Get time information at an interval of I times per second.
+            Defaults to 0.1 so that there is ten measurements per second.
 
-      In [1]: import numpy as np
+        -c: If present, add the memory usage of any children process to the report.
 
-      In [2]: %memit np.zeros(1e7)
-      maximum of 1: 76.402344 MiB per loop
+        Examples
+        --------
+        ::
 
-      In [3]: %memit np.ones(1e6)
-      maximum of 1: 7.820312 MiB per loop
+          In [1]: %memit range(10000)
+          peak memory: 21.42 MiB, increment: 0.41 MiB
 
-      In [4]: %memit -r 10 np.empty(1e8)
-      maximum of 10: 0.101562 MiB per loop
+          In [2]: %memit range(1000000)
+          peak memory: 52.10 MiB, increment: 31.08 MiB
 
-    """"""
-    opts, stmt = self.parse_options(line, 'r:t:i:c', posix=False, strict=False)
-    repeat = int(getattr(opts, 'r', 1))
-    if repeat < 1:
-        repeat == 1
-    timeout = int(getattr(opts, 't', 0))
-    if timeout <= 0:
-        timeout = None
-    interval = float(getattr(opts, 'i', 0.1))
-    include_children = 'c' in opts
-
-    # I've noticed we get less noisier measurements if we run
-    # a garbage collection first
-    import gc
-    gc.collect()
-
-    mem_usage = 0
-    counter = 0
-    baseline = memory_usage()[0]
-    while counter < repeat:
-        counter += 1
-        tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
-                           timeout=timeout, interval=interval, max_usage=True,
-                           include_children=include_children)
-        mem_usage = max(mem_usage, tmp[0])
-
-    if mem_usage:
-        print('peak memory: %.02f MiB, increment: %.02f MiB' %
-              (mem_usage, mem_usage - baseline))
-    else:
-        print('ERROR: could not read memory usage, try with a lower interval '
-              'or more iterations')
+          In [3]: %%memit l=range(1000000)
+             ...: len(l)
+             ...:
+          peak memory: 52.14 MiB, increment: 0.08 MiB
+
+        """"""
+        from memory_profiler import memory_usage, _func_exec
+        opts, stmt = self.parse_options(line, 'r:t:i:c', posix=False, strict=False)
+
+        if cell is None:
+            setup = 'pass'
+        else:
+            setup = stmt
+            stmt = cell
+
+        repeat = int(getattr(opts, 'r', 1))
+        if repeat < 1:
+            repeat == 1
+        timeout = int(getattr(opts, 't', 0))
+        if timeout <= 0:
+            timeout = None
+        interval = float(getattr(opts, 'i', 0.1))
+        include_children = 'c' in opts
+
+        # I've noticed we get less noisier measurements if we run
+        # a garbage collection first
+        import gc
+        gc.collect()
+
+        _func_exec(setup, self.shell.user_ns)
+
+        mem_usage = 0
+        counter = 0
+        baseline = memory_usage()[0]
+        while counter < repeat:
+            counter += 1
+            tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
+                               timeout=timeout, interval=interval, max_usage=True,
+                               include_children=include_children)
+            mem_usage = max(mem_usage, tmp[0])
+
+        if mem_usage:
+            print('peak memory: %.02f MiB, increment: %.02f MiB' %
+                  (mem_usage, mem_usage - baseline))
+        else:
+            print('ERROR: could not read memory usage, try with a lower interval '
+                  'or more iterations')
+
+    @classmethod
+    def register_magics(cls, ip):
+        from distutils.version import LooseVersion
+        import IPython
+        ipython_version = LooseVersion(IPython.__version__)
+
+        if ipython_version < '0.13':
+            try:
+                _register_magic = ip.define_magic
+            except AttributeError:  # ipython 0.10
+                _register_magic = ip.expose_magic
+
+            _register_magic('mprun', cls.mprun.__func__)
+            _register_magic('memit', cls.memit.__func__)
+        else:
+            ip.register_magics(cls)
+
+# Ensuring old interface of magics expose for IPython 0.10
+magic_mprun = MemoryProfilerMagics.mprun.__func__
+magic_memit = MemoryProfilerMagics.memit.__func__
 
 
 def load_ipython_extension(ip):
     """"""This is called to load the module as an IPython extension.""""""
-    ip.define_magic('mprun', magic_mprun)
-    ip.define_magic('memit', magic_memit)
+
+    MemoryProfilerMagics.register_magics(ip)
 
 
 def profile(func=None, stream=None, precision=1):
@@ -875,7 +947,7 @@ if __name__ == '__main__':
         prof = LineProfiler(max_mem=options.max_mem)
     __file__ = _find_script(args[0])
     try:
-        if sys.version_info[0] < 3:
+        if not PY3:
             # we need to ovewrite the builtins to have profile
             # globally defined (global variables is not enough
             # for all cases, e.g. a script that imports another
","@@ -24,6 +24,16 @@ try:
 except ImportError:
     from multiprocessing.dummy import Process, Pipe
 
+try:
+    from IPython.core.magic import Magics, line_cell_magic, magics_class
+except ImportError:
+    # ipython_version < '0.13'
+    Magics = object
+    line_cell_magic = lambda func: func
+    magics_class = lambda cls: cls
+
+PY3 = sys.version_info[0] == 3
+
 _TWO_20 = float(2 ** 20)
 
 has_psutil = False
@@ -593,209 +603,271 @@ def show_results(prof, stream=None, precision=1):
         stream.write('\n\n')
 
 
-# A lprun-style %mprun magic for IPython.
-def magic_mprun(self, parameter_s=''):
-    """""" Execute a statement under the line-by-line memory profiler from the
-    memory_profiler module.
-
-    Usage:
-      %mprun -f func1 -f func2 <statement>
-
-    The given statement (which doesn't require quote marks) is run via the
-    LineProfiler. Profiling is enabled for the functions specified by the -f
-    options. The statistics will be shown side-by-side with the code through
-    the pager once the statement has completed.
-
-    Options:
-
-    -f <function>: LineProfiler only profiles functions and methods it is told
-    to profile.  This option tells the profiler about these functions. Multiple
-    -f options may be used. The argument may be any expression that gives
-    a Python function or method object. However, one must be careful to avoid
-    spaces that may confuse the option parser. Additionally, functions defined
-    in the interpreter at the In[] prompt or via %run currently cannot be
-    displayed.  Write these functions out to a separate file and import them.
-
-    One or more -f options are required to get any useful results.
-
-    -T <filename>: dump the text-formatted statistics with the code
-    side-by-side out to a text file.
-
-    -r: return the LineProfiler object after it has completed profiling.
-
-    -c: If present, add the memory usage of any children process to the report.
-    """"""
-    try:
-        from StringIO import StringIO
-    except ImportError:  # Python 3.x
-        from io import StringIO
-
-    # Local imports to avoid hard dependency.
-    from distutils.version import LooseVersion
-    import IPython
-    ipython_version = LooseVersion(IPython.__version__)
-    if ipython_version < '0.11':
-        from IPython.genutils import page
-        from IPython.ipstruct import Struct
-        from IPython.ipapi import UsageError
-    else:
-        from IPython.core.page import page
-        from IPython.utils.ipstruct import Struct
-        from IPython.core.error import UsageError
-
-    # Escape quote markers.
-    opts_def = Struct(T=[''], f=[])
-    parameter_s = parameter_s.replace('""', r'\""').replace(""'"", r""\'"")
-    opts, arg_str = self.parse_options(parameter_s, 'rf:T:c', list_all=True)
-    opts.merge(opts_def)
-    global_ns = self.shell.user_global_ns
-    local_ns = self.shell.user_ns
-
-    # Get the requested functions.
-    funcs = []
-    for name in opts.f:
-        try:
-            funcs.append(eval(name, global_ns, local_ns))
-        except Exception as e:
-            raise UsageError('Could not find function %r.\n%s: %s' % (name,
-                             e.__class__.__name__, e))
-
-    include_children = 'c' in opts
-    profile = LineProfiler(include_children=include_children)
-    for func in funcs:
-        profile(func)
-
-    # Add the profiler to the builtins for @profile.
-    try:
-        import builtins
-    except ImportError:  # Python 3x
-        import __builtin__ as builtins
-
-    if 'profile' in builtins.__dict__:
-        had_profile = True
-        old_profile = builtins.__dict__['profile']
-    else:
-        had_profile = False
-        old_profile = None
-    builtins.__dict__['profile'] = profile
-
-    try:
-        try:
-            profile.runctx(arg_str, global_ns, local_ns)
-            message = ''
-        except SystemExit:
-            message = ""*** SystemExit exception caught in code being profiled.""
-        except KeyboardInterrupt:
-            message = (""*** KeyboardInterrupt exception caught in code being ""
-                       ""profiled."")
-    finally:
-        if had_profile:
-            builtins.__dict__['profile'] = old_profile
-
-    # Trap text output.
-    stdout_trap = StringIO()
-    show_results(profile, stdout_trap)
-    output = stdout_trap.getvalue()
-    output = output.rstrip()
-
-    if ipython_version < '0.11':
-        page(output, screen_lines=self.shell.rc.screen_length)
-    else:
-        page(output)
-    print(message,)
-
-    text_file = opts.T[0]
-    if text_file:
-        with open(text_file, 'w') as pfile:
-            pfile.write(output)
-        print('\n*** Profile printout saved to text file %s. %s' % (text_file,
-                                                                    message))
-
-    return_value = None
-    if 'r' in opts:
-        return_value = profile
-
-    return return_value
-
-
 def _func_exec(stmt, ns):
     # helper for magic_memit, just a function proxy for the exec
     # statement
     exec(stmt, ns)
 
-# a timeit-style %memit magic for IPython
 
+@magics_class
+class MemoryProfilerMagics(Magics):
 
-def magic_memit(self, line=''):
-    """"""Measure memory usage of a Python statement
+    # A lprun-style %mprun magic for IPython.
+    @line_cell_magic
+    def mprun(self, parameter_s='', cell=None):
+        """""" Execute a statement under the line-by-line memory profiler from the
+        memory_profiler module.
 
-    Usage, in line mode:
-      %memit [-r<R>t<T>i<I>] statement
+        Usage, in line mode:
+          %mprun -f func1 -f func2 <statement>
 
-    Options:
-    -r<R>: repeat the loop iteration <R> times and take the best result.
-    Default: 1
+        Usage, in cell mode:
+          %%mprun -f func1 -f func2 [statement]
+          code...
+          code...
 
-    -t<T>: timeout after <T> seconds. Default: None
+        In cell mode, the additional code lines are appended to the (possibly
+        empty) statement in the first line. Cell mode allows you to easily
+        profile multiline blocks without having to put them in a separate
+        function.
 
-    -i<I>: Get time information at an interval of I times per second.
-        Defaults to 0.1 so that there is ten measurements per second.
+        The given statement (which doesn't require quote marks) is run via the
+        LineProfiler. Profiling is enabled for the functions specified by the -f
+        options. The statistics will be shown side-by-side with the code through
+        the pager once the statement has completed.
 
-    -c: If present, add the memory usage of any children process to the report.
+        Options:
 
-    Examples
-    --------
-    ::
+        -f <function>: LineProfiler only profiles functions and methods it is told
+        to profile.  This option tells the profiler about these functions. Multiple
+        -f options may be used. The argument may be any expression that gives
+        a Python function or method object. However, one must be careful to avoid
+        spaces that may confuse the option parser. Additionally, functions defined
+        in the interpreter at the In[] prompt or via %run currently cannot be
+        displayed.  Write these functions out to a separate file and import them.
 
-      In [1]: import numpy as np
+        One or more -f options are required to get any useful results.
 
-      In [2]: %memit np.zeros(1e7)
-      maximum of 1: 76.402344 MiB per loop
+        -T <filename>: dump the text-formatted statistics with the code
+        side-by-side out to a text file.
 
-      In [3]: %memit np.ones(1e6)
-      maximum of 1: 7.820312 MiB per loop
+        -r: return the LineProfiler object after it has completed profiling.
 
-      In [4]: %memit -r 10 np.empty(1e8)
-      maximum of 10: 0.101562 MiB per loop
+        -c: If present, add the memory usage of any children process to the report.
+        """"""
+        from memory_profiler import show_results, LineProfiler
+        try:
+            from StringIO import StringIO
+        except ImportError:  # Python 3.x
+            from io import StringIO
 
-    """"""
-    opts, stmt = self.parse_options(line, 'r:t:i:c', posix=False, strict=False)
-    repeat = int(getattr(opts, 'r', 1))
-    if repeat < 1:
-        repeat == 1
-    timeout = int(getattr(opts, 't', 0))
-    if timeout <= 0:
-        timeout = None
-    interval = float(getattr(opts, 'i', 0.1))
-    include_children = 'c' in opts
+        # Local imports to avoid hard dependency.
+        from distutils.version import LooseVersion
+        import IPython
+        ipython_version = LooseVersion(IPython.__version__)
+        if ipython_version < '0.11':
+            from IPython.genutils import page
+            from IPython.ipstruct import Struct
+            from IPython.ipapi import UsageError
+        else:
+            from IPython.core.page import page
+            from IPython.utils.ipstruct import Struct
+            from IPython.core.error import UsageError
 
-    # I've noticed we get less noisier measurements if we run
-    # a garbage collection first
-    import gc
-    gc.collect()
+        # Escape quote markers.
+        opts_def = Struct(T=[''], f=[])
+        parameter_s = parameter_s.replace('""', r'\""').replace(""'"", r""\'"")
+        opts, arg_str = self.parse_options(parameter_s, 'rf:T:c', list_all=True)
+        opts.merge(opts_def)
+        global_ns = self.shell.user_global_ns
+        local_ns = self.shell.user_ns
 
-    mem_usage = 0
-    counter = 0
-    baseline = memory_usage()[0]
-    while counter < repeat:
-        counter += 1
-        tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
-                           timeout=timeout, interval=interval, max_usage=True,
-                           include_children=include_children)
-        mem_usage = max(mem_usage, tmp[0])
+        if cell is not None:
+            arg_str += '\n' + cell
 
-    if mem_usage:
-        print('peak memory: %.02f MiB, increment: %.02f MiB' %
-              (mem_usage, mem_usage - baseline))
-    else:
-        print('ERROR: could not read memory usage, try with a lower interval '
-              'or more iterations')
+        # Get the requested functions.
+        funcs = []
+        for name in opts.f:
+            try:
+                funcs.append(eval(name, global_ns, local_ns))
+            except Exception as e:
+                raise UsageError('Could not find function %r.\n%s: %s' % (name,
+                                 e.__class__.__name__, e))
+
+        include_children = 'c' in opts
+        profile = LineProfiler(include_children=include_children)
+        for func in funcs:
+            profile(func)
+
+        # Add the profiler to the builtins for @profile.
+        if PY3:
+            import builtins
+        else:
+            import __builtin__ as builtins
+
+        if 'profile' in builtins.__dict__:
+            had_profile = True
+            old_profile = builtins.__dict__['profile']
+        else:
+            had_profile = False
+            old_profile = None
+        builtins.__dict__['profile'] = profile
+
+        try:
+            try:
+                profile.runctx(arg_str, global_ns, local_ns)
+                message = ''
+            except SystemExit:
+                message = ""*** SystemExit exception caught in code being profiled.""
+            except KeyboardInterrupt:
+                message = (""*** KeyboardInterrupt exception caught in code being ""
+                           ""profiled."")
+        finally:
+            if had_profile:
+                builtins.__dict__['profile'] = old_profile
+
+        # Trap text output.
+        stdout_trap = StringIO()
+        show_results(profile, stdout_trap)
+        output = stdout_trap.getvalue()
+        output = output.rstrip()
+
+        if ipython_version < '0.11':
+            page(output, screen_lines=self.shell.rc.screen_length)
+        else:
+            page(output)
+        print(message,)
+
+        text_file = opts.T[0]
+        if text_file:
+            with open(text_file, 'w') as pfile:
+                pfile.write(output)
+            print('\n*** Profile printout saved to text file %s. %s' % (text_file,
+                                                                        message))
+
+        return_value = None
+        if 'r' in opts:
+            return_value = profile
+
+        return return_value
+
+    # a timeit-style %memit magic for IPython
+    @line_cell_magic
+    def memit(self, line='', cell=None):
+        """"""Measure memory usage of a Python statement
+
+        Usage, in line mode:
+          %memit [-r<R>t<T>i<I>] statement
+
+        Usage, in cell mode:
+          %%memit [-r<R>t<T>i<I>] setup_code
+          code...
+          code...
+
+        This function can be used both as a line and cell magic:
+
+        - In line mode you can measure a single-line statement (though multiple
+          ones can be chained with using semicolons).
+
+        - In cell mode, the statement in the first line is used as setup code
+          (executed but not measured) and the body of the cell is measured.
+          The cell body has access to any variables created in the setup code.
+
+        Options:
+        -r<R>: repeat the loop iteration <R> times and take the best result.
+        Default: 1
+
+        -t<T>: timeout after <T> seconds. Default: None
+
+        -i<I>: Get time information at an interval of I times per second.
+            Defaults to 0.1 so that there is ten measurements per second.
+
+        -c: If present, add the memory usage of any children process to the report.
+
+        Examples
+        --------
+        ::
+
+          In [1]: %memit range(10000)
+          peak memory: 21.42 MiB, increment: 0.41 MiB
+
+          In [2]: %memit range(1000000)
+          peak memory: 52.10 MiB, increment: 31.08 MiB
+
+          In [3]: %%memit l=range(1000000)
+             ...: len(l)
+             ...:
+          peak memory: 52.14 MiB, increment: 0.08 MiB
+
+        """"""
+        from memory_profiler import memory_usage, _func_exec
+        opts, stmt = self.parse_options(line, 'r:t:i:c', posix=False, strict=False)
+
+        if cell is None:
+            setup = 'pass'
+        else:
+            setup = stmt
+            stmt = cell
+
+        repeat = int(getattr(opts, 'r', 1))
+        if repeat < 1:
+            repeat == 1
+        timeout = int(getattr(opts, 't', 0))
+        if timeout <= 0:
+            timeout = None
+        interval = float(getattr(opts, 'i', 0.1))
+        include_children = 'c' in opts
+
+        # I've noticed we get less noisier measurements if we run
+        # a garbage collection first
+        import gc
+        gc.collect()
+
+        _func_exec(setup, self.shell.user_ns)
+
+        mem_usage = 0
+        counter = 0
+        baseline = memory_usage()[0]
+        while counter < repeat:
+            counter += 1
+            tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
+                               timeout=timeout, interval=interval, max_usage=True,
+                               include_children=include_children)
+            mem_usage = max(mem_usage, tmp[0])
+
+        if mem_usage:
+            print('peak memory: %.02f MiB, increment: %.02f MiB' %
+                  (mem_usage, mem_usage - baseline))
+        else:
+            print('ERROR: could not read memory usage, try with a lower interval '
+                  'or more iterations')
+
+    @classmethod
+    def register_magics(cls, ip):
+        from distutils.version import LooseVersion
+        import IPython
+        ipython_version = LooseVersion(IPython.__version__)
+
+        if ipython_version < '0.13':
+            try:
+                _register_magic = ip.define_magic
+            except AttributeError:  # ipython 0.10
+                _register_magic = ip.expose_magic
+
+            _register_magic('mprun', cls.mprun.__func__)
+            _register_magic('memit', cls.memit.__func__)
+        else:
+            ip.register_magics(cls)
+
+# Ensuring old interface of magics expose for IPython 0.10
+magic_mprun = MemoryProfilerMagics.mprun.__func__
+magic_memit = MemoryProfilerMagics.memit.__func__
 
 
 def load_ipython_extension(ip):
     """"""This is called to load the module as an IPython extension.""""""
-    ip.define_magic('mprun', magic_mprun)
-    ip.define_magic('memit', magic_memit)
+
+    MemoryProfilerMagics.register_magics(ip)
 
 
 def profile(func=None, stream=None, precision=1):
@@ -875,7 +947,7 @@ if __name__ == '__main__':
         prof = LineProfiler(max_mem=options.max_mem)
     __file__ = _find_script(args[0])
     try:
-        if sys.version_info[0] < 3:
+        if not PY3:
             # we need to ovewrite the builtins to have profile
             # globally defined (global variables is not enough
             # for all cases, e.g. a script that imports another
",False,memory_profiler.py,True
"@@ -860,8 +860,8 @@ class MemoryProfilerMagics(Magics):
             ip.register_magics(cls)
 
 # Ensuring old interface of magics expose for IPython 0.10
-magic_mprun = MemoryProfilerMagics.mprun.__func__
-magic_memit = MemoryProfilerMagics.memit.__func__
+magic_mprun = MemoryProfilerMagics().mprun.__func__
+magic_memit = MemoryProfilerMagics().memit.__func__
 
 
 def load_ipython_extension(ip):
","@@ -860,8 +860,8 @@ class MemoryProfilerMagics(Magics):
             ip.register_magics(cls)
 
 # Ensuring old interface of magics expose for IPython 0.10
-magic_mprun = MemoryProfilerMagics.mprun.__func__
-magic_memit = MemoryProfilerMagics.memit.__func__
+magic_mprun = MemoryProfilerMagics().mprun.__func__
+magic_memit = MemoryProfilerMagics().memit.__func__
 
 
 def load_ipython_extension(ip):
",True,memory_profiler.py,True
"@@ -236,7 +236,7 @@ def run_action():
                          include_children=options.include_children, stream=f)
 
 
-def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
+def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
     """"""Add two brackets on the memory line plot.
 
     This function uses the current figure.
@@ -265,10 +265,12 @@ def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
     # Matplotlib workaround: labels starting with _ aren't displayed
     if label[0] == '_':
         label = ' ' + label
-    pl.plot(bracket_x + xloc[0] - xshift, bracket_y + yloc[0],
-            ""-"" + color, linewidth=2, label=label)
-    pl.plot(-bracket_x + xloc[1] - xshift, bracket_y + yloc[1],
-            ""-"" + color, linewidth=2 )
+    if options.xlim is None or options.xlim[0] <= (xloc[0] - xshift) <= options.xlim[1]:
+        pl.plot(bracket_x + xloc[0] - xshift, bracket_y + yloc[0],
+                ""-"" + color, linewidth=2, label=label)
+    if options.xlim is None or options.xlim[0] <= (xloc[1] - xshift) <= options.xlim[1]:
+        pl.plot(-bracket_x + xloc[1] - xshift, bracket_y + yloc[1],
+                ""-"" + color, linewidth=2 )
 
     # TODO: use matplotlib.patches.Polygon to draw a colored background for
     # each function.
@@ -330,7 +332,7 @@ def read_mprofile_file(filename):
 
 
 
-def plot_file(filename, index=0, timestamps=True):
+def plot_file(filename, index=0, timestamps=True, options=None):
     try:
         import pylab as pl
     except ImportError:
@@ -392,7 +394,7 @@ def plot_file(filename, index=0, timestamps=True):
                 add_brackets(execution[:2], execution[2:], xshift=global_start,
                              color= all_colors[func_num % len(all_colors)],
                              label=f.split(""."")[-1]
-                             + "" %.3fs"" % (execution[1] - execution[0]))
+                             + "" %.3fs"" % (execution[1] - execution[0]), options=options)
             func_num += 1
 
     if timestamps:
@@ -405,6 +407,15 @@ def plot_file(filename, index=0, timestamps=True):
 
 
 def plot_action():
+    def get_comma_separated_args(option, opt, value, parser):
+        try:
+            newvalue = [float(x) for x in value.split(',')]
+        except:
+            raise OptionValueError(""'%s' option must contain two numbers separated with a comma"" % value)
+        if len(newvalue) != 2:
+            raise OptionValueError(""'%s' option must contain two numbers separated with a comma"" % value)
+        setattr(parser.values, option.dest, newvalue)
+
     try:
         import pylab as pl
     except ImportError:
@@ -421,6 +432,10 @@ def plot_action():
                       help=""Do not display function timestamps on plot."")
     parser.add_option(""--output"", ""-o"",
                       help=""Save plot to file instead of displaying it."")
+    parser.add_option(""--window"", ""-w"", dest=""xlim"",
+                      type=""str"", action=""callback"",
+                      callback=get_comma_separated_args,
+                      help=""Plot a time-subset of the data. E.g. to plot between 0 and 20.5 seconds: --window 0,20.5"")
     (options, args) = parser.parse_args()
 
     profiles = glob.glob(""mprofile_??????????????.dat"")
@@ -453,12 +468,15 @@ def plot_action():
 
     fig = pl.figure(figsize=(14, 6), dpi=90)
     ax = fig.add_axes([0.1, 0.1, 0.6, 0.75])
+    if options.xlim is not None:
+        pl.xlim(options.xlim[0], options.xlim[1])
+
     if len(filenames) > 1 or options.no_timestamps:
         timestamps = False
     else:
         timestamps = True
     for n, filename in enumerate(filenames):
-        mprofile = plot_file(filename, index=n, timestamps=timestamps)
+        mprofile = plot_file(filename, index=n, timestamps=timestamps, options=options)
     pl.xlabel(""time (in seconds)"")
     pl.ylabel(""memory used (in MiB)"")
 
","@@ -236,7 +236,7 @@ def run_action():
                          include_children=options.include_children, stream=f)
 
 
-def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
+def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
     """"""Add two brackets on the memory line plot.
 
     This function uses the current figure.
@@ -265,10 +265,12 @@ def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
     # Matplotlib workaround: labels starting with _ aren't displayed
     if label[0] == '_':
         label = ' ' + label
-    pl.plot(bracket_x + xloc[0] - xshift, bracket_y + yloc[0],
-            ""-"" + color, linewidth=2, label=label)
-    pl.plot(-bracket_x + xloc[1] - xshift, bracket_y + yloc[1],
-            ""-"" + color, linewidth=2 )
+    if options.xlim is None or options.xlim[0] <= (xloc[0] - xshift) <= options.xlim[1]:
+        pl.plot(bracket_x + xloc[0] - xshift, bracket_y + yloc[0],
+                ""-"" + color, linewidth=2, label=label)
+    if options.xlim is None or options.xlim[0] <= (xloc[1] - xshift) <= options.xlim[1]:
+        pl.plot(-bracket_x + xloc[1] - xshift, bracket_y + yloc[1],
+                ""-"" + color, linewidth=2 )
 
     # TODO: use matplotlib.patches.Polygon to draw a colored background for
     # each function.
@@ -330,7 +332,7 @@ def read_mprofile_file(filename):
 
 
 
-def plot_file(filename, index=0, timestamps=True):
+def plot_file(filename, index=0, timestamps=True, options=None):
     try:
         import pylab as pl
     except ImportError:
@@ -392,7 +394,7 @@ def plot_file(filename, index=0, timestamps=True):
                 add_brackets(execution[:2], execution[2:], xshift=global_start,
                              color= all_colors[func_num % len(all_colors)],
                              label=f.split(""."")[-1]
-                             + "" %.3fs"" % (execution[1] - execution[0]))
+                             + "" %.3fs"" % (execution[1] - execution[0]), options=options)
             func_num += 1
 
     if timestamps:
@@ -405,6 +407,15 @@ def plot_file(filename, index=0, timestamps=True):
 
 
 def plot_action():
+    def get_comma_separated_args(option, opt, value, parser):
+        try:
+            newvalue = [float(x) for x in value.split(',')]
+        except:
+            raise OptionValueError(""'%s' option must contain two numbers separated with a comma"" % value)
+        if len(newvalue) != 2:
+            raise OptionValueError(""'%s' option must contain two numbers separated with a comma"" % value)
+        setattr(parser.values, option.dest, newvalue)
+
     try:
         import pylab as pl
     except ImportError:
@@ -421,6 +432,10 @@ def plot_action():
                       help=""Do not display function timestamps on plot."")
     parser.add_option(""--output"", ""-o"",
                       help=""Save plot to file instead of displaying it."")
+    parser.add_option(""--window"", ""-w"", dest=""xlim"",
+                      type=""str"", action=""callback"",
+                      callback=get_comma_separated_args,
+                      help=""Plot a time-subset of the data. E.g. to plot between 0 and 20.5 seconds: --window 0,20.5"")
     (options, args) = parser.parse_args()
 
     profiles = glob.glob(""mprofile_??????????????.dat"")
@@ -453,12 +468,15 @@ def plot_action():
 
     fig = pl.figure(figsize=(14, 6), dpi=90)
     ax = fig.add_axes([0.1, 0.1, 0.6, 0.75])
+    if options.xlim is not None:
+        pl.xlim(options.xlim[0], options.xlim[1])
+
     if len(filenames) > 1 or options.no_timestamps:
         timestamps = False
     else:
         timestamps = True
     for n, filename in enumerate(filenames):
-        mprofile = plot_file(filename, index=n, timestamps=timestamps)
+        mprofile = plot_file(filename, index=n, timestamps=timestamps, options=options)
     pl.xlabel(""time (in seconds)"")
     pl.ylabel(""memory used (in MiB)"")
 
",True,mprof,False
"@@ -25,7 +25,11 @@ To install from source, download the package, extract and type::
  Usage
 =======
 
-The line-by-line profiler is used much in the same way of the
+
+line-by-line memory usage
+=========================
+
+The line-by-line memory usage mode is used much in the same way of the
 `line_profiler <https://pypi.python.org/pypi/line_profiler/>`_: first
 decorate the function you would like to profile with ``@profile`` and
 then run the script with a special script (in this case with specific
@@ -103,7 +107,7 @@ decorator function.  Use as follows::
 If a python script with decorator ``@profile`` is called using ``-m 
 memory_profiler`` in the command line, the ``precision`` parameter is ignored.
 
-Executing external scripts
+Time-based memory usage 
 ==========================
 Sometimes it is useful to have full memory usage reports as a function of
 time (not line-by-line) of external processes (be it Python scripts or not).
@@ -129,7 +133,7 @@ of the code that is causing the highest memory usage.
 Adding the `profile` decorator to a function and running the Python
 script with 
 
-    mprof run --python <script>
+    mprof run <script>
 
 will record timestamps when entering/leaving the profiled function. Runnning
 
","@@ -25,7 +25,11 @@ To install from source, download the package, extract and type::
  Usage
 =======
 
-The line-by-line profiler is used much in the same way of the
+
+line-by-line memory usage
+=========================
+
+The line-by-line memory usage mode is used much in the same way of the
 `line_profiler <https://pypi.python.org/pypi/line_profiler/>`_: first
 decorate the function you would like to profile with ``@profile`` and
 then run the script with a special script (in this case with specific
@@ -103,7 +107,7 @@ decorator function.  Use as follows::
 If a python script with decorator ``@profile`` is called using ``-m 
 memory_profiler`` in the command line, the ``precision`` parameter is ignored.
 
-Executing external scripts
+Time-based memory usage 
 ==========================
 Sometimes it is useful to have full memory usage reports as a function of
 time (not line-by-line) of external processes (be it Python scripts or not).
@@ -129,7 +133,7 @@ of the code that is causing the highest memory usage.
 Adding the `profile` decorator to a function and running the Python
 script with 
 
-    mprof run --python <script>
+    mprof run <script>
 
 will record timestamps when entering/leaving the profiled function. Runnning
 
",True,README.rst,False
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.37'
+__version__ = '0.38'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.37'
+__version__ = '0.38'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -9,7 +9,7 @@ import copy
 import time
 import math
 
-from optparse import OptionParser
+from optparse import OptionParser, OptionValueError
 
 import memory_profiler as mp
 
","@@ -9,7 +9,7 @@ import copy
 import time
 import math
 
-from optparse import OptionParser
+from optparse import OptionParser, OptionValueError
 
 import memory_profiler as mp
 
",True,mprof,False
"@@ -859,9 +859,11 @@ class MemoryProfilerMagics(Magics):
         else:
             ip.register_magics(cls)
 
-# Ensuring old interface of magics expose for IPython 0.10
-magic_mprun = MemoryProfilerMagics().mprun.__func__
-magic_memit = MemoryProfilerMagics().memit.__func__
+# commenting out due to failures with some versions of IPython
+# see https://github.com/fabianp/memory_profiler/issues/106
+# # Ensuring old interface of magics expose for IPython 0.10
+# magic_mprun = MemoryProfilerMagics().mprun.__func__
+# magic_memit = MemoryProfilerMagics().memit.__func__
 
 
 def load_ipython_extension(ip):
","@@ -859,9 +859,11 @@ class MemoryProfilerMagics(Magics):
         else:
             ip.register_magics(cls)
 
-# Ensuring old interface of magics expose for IPython 0.10
-magic_mprun = MemoryProfilerMagics().mprun.__func__
-magic_memit = MemoryProfilerMagics().memit.__func__
+# commenting out due to failures with some versions of IPython
+# see https://github.com/fabianp/memory_profiler/issues/106
+# # Ensuring old interface of magics expose for IPython 0.10
+# magic_mprun = MemoryProfilerMagics().mprun.__func__
+# magic_memit = MemoryProfilerMagics().memit.__func__
 
 
 def load_ipython_extension(ip):
",True,memory_profiler.py,True
"@@ -63,11 +63,11 @@ def _get_memory(pid, timestamps=False, include_children=False):
             if include_children:
                 try:
                     for p in process.get_children(recursive=True):
-                        mem += getattr(process, meminfo_attr)()[0] / _TWO_20
+                        mem += getattr(p, meminfo_attr)()[0] / _TWO_20
                 except AttributeError:
                     # fix for newer psutil
                     for p in process.children(recursive=True):
-                        mem += getattr(process, meminfo_attr)()[0] / _TWO_20
+                        mem += getattr(p, meminfo_attr)()[0] / _TWO_20
             if timestamps:
                 return (mem, time.time())
             else:
","@@ -63,11 +63,11 @@ def _get_memory(pid, timestamps=False, include_children=False):
             if include_children:
                 try:
                     for p in process.get_children(recursive=True):
-                        mem += getattr(process, meminfo_attr)()[0] / _TWO_20
+                        mem += getattr(p, meminfo_attr)()[0] / _TWO_20
                 except AttributeError:
                     # fix for newer psutil
                     for p in process.children(recursive=True):
-                        mem += getattr(process, meminfo_attr)()[0] / _TWO_20
+                        mem += getattr(p, meminfo_attr)()[0] / _TWO_20
             if timestamps:
                 return (mem, time.time())
             else:
",True,memory_profiler.py,True
"@@ -1,6 +1,7 @@
 .idea
 dist
 build
-*.pyc
 MANIFEST
+*.egg-info
+*.pyc
 *~
","@@ -1,6 +1,7 @@
 .idea
 dist
 build
-*.pyc
 MANIFEST
+*.egg-info
+*.pyc
 *~
",True,.gitignore,False
"@@ -15,10 +15,9 @@ import warnings
 import linecache
 import inspect
 import subprocess
-from copy import copy
 import logging
 
-# TODO: provide alternative when multprocessing is not available
+# TODO: provide alternative when multiprocessing is not available
 try:
     from multiprocessing import Process, Pipe
 except ImportError:
@@ -36,14 +35,17 @@ PY3 = sys.version_info[0] == 3
 
 _TWO_20 = float(2 ** 20)
 
-has_psutil = False
+if PY3:
+    import builtins
+else:
+    import __builtin__ as builtins
 
 # .. get available packages ..
 try:
     import psutil
     has_psutil = True
 except ImportError:
-    pass
+    has_psutil = False
 
 
 def _get_memory(pid, timestamps=False, include_children=False):
@@ -102,7 +104,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
             if timestamps:
                 return (-1, time.time())
             else:
-                    return -1
+                return -1
     else:
         raise NotImplementedError('The psutil module is required for non-unix '
                                   'platforms')
@@ -121,29 +123,21 @@ class MemTimer(Process):
         self.max_usage = max_usage
         self.n_measurements = 1
 
-        if ""timestamps"" in kw:
-            self.timestamps = kw[""timestamps""]
-            del kw[""timestamps""]
-        else:
-            self.timestamps = False
-        if ""include_children"" in kw:
-            self.include_children = kw[""include_children""]
-            del kw[""include_children""]
-        else:
-            self.include_children = False
+        self.timestamps = kw.pop(""timestamps"", False)
+        self.include_children = kw.pop(""include_children"", False)
+
         # get baseline memory usage
         self.mem_usage = [
             _get_memory(self.monitor_pid, timestamps=self.timestamps,
                         include_children=self.include_children)]
         super(MemTimer, self).__init__(*args, **kw)
 
-
     def run(self):
         self.pipe.send(0)  # we're ready
         stop = False
         while True:
             cur_mem = _get_memory(self.monitor_pid, timestamps=self.timestamps,
-                            include_children=self.include_children)
+                                  include_children=self.include_children)
             if not self.max_usage:
                 self.mem_usage.append(cur_mem)
             else:
@@ -223,7 +217,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         # for a Python function wait until it finishes
         max_iter = float('inf')
 
-    if hasattr(proc, '__call__'):
+    if callable(proc):
         proc = (proc, (), {})
     if isinstance(proc, (list, tuple)):
         if len(proc) == 1:
@@ -238,7 +232,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         while True:
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
             p = MemTimer(os.getpid(), interval, child_conn, timestamps=timestamps,
-                      max_usage=max_usage, include_children=include_children)
+                         max_usage=max_usage, include_children=include_children)
             p.start()
             parent_conn.recv()  # wait until we start getting memory
             returned = f(*args, **kw)
@@ -263,9 +257,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 else:
                     ret.append(mem_usage)
             else:
-                ret = max([ret,
-                           _get_memory(proc.pid,
-                                       include_children=include_children)])
+                ret = max(ret,
+                          _get_memory(proc.pid,
+                                      include_children=include_children))
             time.sleep(interval)
             line_count += 1
             # flush every 50 lines. Make 'tail -f' usable on profile file
@@ -351,7 +345,7 @@ class TimeStamper:
 
     def __call__(self, func=None, precision=None):
         if func is not None:
-            if not hasattr(func, ""__call__""):
+            if not callable(func):
                 raise ValueError(""Value must be callable"")
 
             self.add_function(func)
@@ -380,7 +374,7 @@ class TimeStamper:
         return _TimeStamperCM(timestamps)
 
     def add_function(self, func):
-        if not func in self.functions:
+        if func not in self.functions:
             self.functions[func] = []
 
     def wrap_function(self, func):
@@ -391,11 +385,10 @@ class TimeStamper:
             timestamps = [_get_memory(os.getpid(), timestamps=True)]
             self.functions[func].append(timestamps)
             try:
-                result = func(*args, **kwds)
+                return func(*args, **kwds)
             finally:
                 # end time
                 timestamps.append(_get_memory(os.getpid(), timestamps=True))
-            return result
         return f
 
     def show_results(self, stream=None):
@@ -459,10 +452,9 @@ class LineProfiler(object):
         def f(*args, **kwds):
             self.enable_by_count()
             try:
-                result = func(*args, **kwds)
+                return func(*args, **kwds)
             finally:
                 self.disable_by_count()
-            return result
         return f
 
     def run(self, cmd):
@@ -521,8 +513,8 @@ class LineProfiler(object):
         if event in ('line', 'return') and frame.f_code in self.code_map:
             c = _get_memory(-1)
             if c >= self.max_mem:
-                t = ('Current memory {0:.2f} MiB exceeded the maximum'
-                     ''.format(c) + 'of {0:.2f} MiB\n'.format(self.max_mem))
+                t = ('Current memory {0:.2f} MiB exceeded the '
+                     'maximum of {1:.2f} MiB\n'.format(c, self.max_mem))
                 sys.stdout.write(t)
                 sys.stdout.write('Stepping into the debugger \n')
                 frame.f_lineno -= 2
@@ -655,11 +647,8 @@ class MemoryProfilerMagics(Magics):
 
         -c: If present, add the memory usage of any children process to the report.
         """"""
+        from io import StringIO
         from memory_profiler import show_results, LineProfiler
-        try:
-            from StringIO import StringIO
-        except ImportError:  # Python 3.x
-            from io import StringIO
 
         # Local imports to avoid hard dependency.
         from distutils.version import LooseVersion
@@ -700,11 +689,6 @@ class MemoryProfilerMagics(Magics):
             profile(func)
 
         # Add the profiler to the builtins for @profile.
-        if PY3:
-            import builtins
-        else:
-            import __builtin__ as builtins
-
         if 'profile' in builtins.__dict__:
             had_profile = True
             old_profile = builtins.__dict__['profile']
@@ -714,14 +698,13 @@ class MemoryProfilerMagics(Magics):
         builtins.__dict__['profile'] = profile
 
         try:
-            try:
-                profile.runctx(arg_str, global_ns, local_ns)
-                message = ''
-            except SystemExit:
-                message = ""*** SystemExit exception caught in code being profiled.""
-            except KeyboardInterrupt:
-                message = (""*** KeyboardInterrupt exception caught in code being ""
-                           ""profiled."")
+            profile.runctx(arg_str, global_ns, local_ns)
+            message = ''
+        except SystemExit:
+            message = ""*** SystemExit exception caught in code being profiled.""
+        except KeyboardInterrupt:
+            message = (""*** KeyboardInterrupt exception caught in code being ""
+                       ""profiled."")
         finally:
             if had_profile:
                 builtins.__dict__['profile'] = old_profile
@@ -888,6 +871,25 @@ def profile(func=None, stream=None, precision=1):
             return profile(f, stream=stream, precision=precision)
         return inner_wrapper
 
+
+# Insert in the built-ins to have profile
+# globally defined (global variables is not enough
+# for all cases, e.g. a script that imports another
+# script where @profile is used)
+if PY3:
+    def exec_with_profiler(filename, profiler):
+        builtins.__dict__['profile'] = profiler
+        # shadow the profile decorator defined above
+        ns = dict(_CLEAN_GLOBALS, profile=profiler)
+        with open(filename) as f:
+            exec(compile(f.read(), filename, 'exec'), ns, ns)
+else:
+    def exec_with_profiler(filename, profiler):
+        builtins.__dict__['profile'] = profiler
+        ns = dict(_CLEAN_GLOBALS, profile=profiler)
+        execfile(filename, ns, ns)
+
+
 class LogFile(object):
     """"""File-like object to log text using the `logging` module and the log report can be customised.""""""
 
@@ -905,7 +907,7 @@ class LogFile(object):
 
     def write(self, msg, level=logging.INFO):
         if self.reportIncrementFlag:
-            if ""MiB"" in msg and float(msg.split(""MiB"")[1].strip())>0:
+            if ""MiB"" in msg and float(msg.split(""MiB"")[1].strip()) > 0:
                 self.logger.log(level, msg)
             elif msg.__contains__(""Filename:"") or msg.__contains__(""Line Contents""):
                 self.logger.log(level, msg)
@@ -916,6 +918,7 @@ class LogFile(object):
         for handler in self.logger.handlers:
             handler.flush()
 
+
 if __name__ == '__main__':
     from optparse import OptionParser
     parser = OptionParser(usage=_CMD_USAGE, version=__version__)
@@ -947,24 +950,9 @@ if __name__ == '__main__':
         prof = TimeStamper()
     else:
         prof = LineProfiler(max_mem=options.max_mem)
-    __file__ = _find_script(args[0])
+    script_filename = _find_script(args[0])
     try:
-        if not PY3:
-            # we need to ovewrite the builtins to have profile
-            # globally defined (global variables is not enough
-            # for all cases, e.g. a script that imports another
-            # script where @profile is used)
-            import __builtin__
-            __builtin__.__dict__['profile'] = prof
-            ns = copy(_CLEAN_GLOBALS)
-            ns['profile'] = prof  # shadow the profile decorator defined above
-            execfile(__file__, ns, ns)
-        else:
-            import builtins
-            builtins.__dict__['profile'] = prof
-            ns = copy(_CLEAN_GLOBALS)
-            ns['profile'] = prof  # shadow the profile decorator defined above
-            exec(compile(open(__file__).read(), __file__, 'exec'), ns, ns)
+        exec_with_profiler(script_filename, prof)
     finally:
         if options.out_filename is not None:
             out_file = open(options.out_filename, ""a"")
","@@ -15,10 +15,9 @@ import warnings
 import linecache
 import inspect
 import subprocess
-from copy import copy
 import logging
 
-# TODO: provide alternative when multprocessing is not available
+# TODO: provide alternative when multiprocessing is not available
 try:
     from multiprocessing import Process, Pipe
 except ImportError:
@@ -36,14 +35,17 @@ PY3 = sys.version_info[0] == 3
 
 _TWO_20 = float(2 ** 20)
 
-has_psutil = False
+if PY3:
+    import builtins
+else:
+    import __builtin__ as builtins
 
 # .. get available packages ..
 try:
     import psutil
     has_psutil = True
 except ImportError:
-    pass
+    has_psutil = False
 
 
 def _get_memory(pid, timestamps=False, include_children=False):
@@ -102,7 +104,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
             if timestamps:
                 return (-1, time.time())
             else:
-                    return -1
+                return -1
     else:
         raise NotImplementedError('The psutil module is required for non-unix '
                                   'platforms')
@@ -121,29 +123,21 @@ class MemTimer(Process):
         self.max_usage = max_usage
         self.n_measurements = 1
 
-        if ""timestamps"" in kw:
-            self.timestamps = kw[""timestamps""]
-            del kw[""timestamps""]
-        else:
-            self.timestamps = False
-        if ""include_children"" in kw:
-            self.include_children = kw[""include_children""]
-            del kw[""include_children""]
-        else:
-            self.include_children = False
+        self.timestamps = kw.pop(""timestamps"", False)
+        self.include_children = kw.pop(""include_children"", False)
+
         # get baseline memory usage
         self.mem_usage = [
             _get_memory(self.monitor_pid, timestamps=self.timestamps,
                         include_children=self.include_children)]
         super(MemTimer, self).__init__(*args, **kw)
 
-
     def run(self):
         self.pipe.send(0)  # we're ready
         stop = False
         while True:
             cur_mem = _get_memory(self.monitor_pid, timestamps=self.timestamps,
-                            include_children=self.include_children)
+                                  include_children=self.include_children)
             if not self.max_usage:
                 self.mem_usage.append(cur_mem)
             else:
@@ -223,7 +217,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         # for a Python function wait until it finishes
         max_iter = float('inf')
 
-    if hasattr(proc, '__call__'):
+    if callable(proc):
         proc = (proc, (), {})
     if isinstance(proc, (list, tuple)):
         if len(proc) == 1:
@@ -238,7 +232,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         while True:
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
             p = MemTimer(os.getpid(), interval, child_conn, timestamps=timestamps,
-                      max_usage=max_usage, include_children=include_children)
+                         max_usage=max_usage, include_children=include_children)
             p.start()
             parent_conn.recv()  # wait until we start getting memory
             returned = f(*args, **kw)
@@ -263,9 +257,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 else:
                     ret.append(mem_usage)
             else:
-                ret = max([ret,
-                           _get_memory(proc.pid,
-                                       include_children=include_children)])
+                ret = max(ret,
+                          _get_memory(proc.pid,
+                                      include_children=include_children))
             time.sleep(interval)
             line_count += 1
             # flush every 50 lines. Make 'tail -f' usable on profile file
@@ -351,7 +345,7 @@ class TimeStamper:
 
     def __call__(self, func=None, precision=None):
         if func is not None:
-            if not hasattr(func, ""__call__""):
+            if not callable(func):
                 raise ValueError(""Value must be callable"")
 
             self.add_function(func)
@@ -380,7 +374,7 @@ class TimeStamper:
         return _TimeStamperCM(timestamps)
 
     def add_function(self, func):
-        if not func in self.functions:
+        if func not in self.functions:
             self.functions[func] = []
 
     def wrap_function(self, func):
@@ -391,11 +385,10 @@ class TimeStamper:
             timestamps = [_get_memory(os.getpid(), timestamps=True)]
             self.functions[func].append(timestamps)
             try:
-                result = func(*args, **kwds)
+                return func(*args, **kwds)
             finally:
                 # end time
                 timestamps.append(_get_memory(os.getpid(), timestamps=True))
-            return result
         return f
 
     def show_results(self, stream=None):
@@ -459,10 +452,9 @@ class LineProfiler(object):
         def f(*args, **kwds):
             self.enable_by_count()
             try:
-                result = func(*args, **kwds)
+                return func(*args, **kwds)
             finally:
                 self.disable_by_count()
-            return result
         return f
 
     def run(self, cmd):
@@ -521,8 +513,8 @@ class LineProfiler(object):
         if event in ('line', 'return') and frame.f_code in self.code_map:
             c = _get_memory(-1)
             if c >= self.max_mem:
-                t = ('Current memory {0:.2f} MiB exceeded the maximum'
-                     ''.format(c) + 'of {0:.2f} MiB\n'.format(self.max_mem))
+                t = ('Current memory {0:.2f} MiB exceeded the '
+                     'maximum of {1:.2f} MiB\n'.format(c, self.max_mem))
                 sys.stdout.write(t)
                 sys.stdout.write('Stepping into the debugger \n')
                 frame.f_lineno -= 2
@@ -655,11 +647,8 @@ class MemoryProfilerMagics(Magics):
 
         -c: If present, add the memory usage of any children process to the report.
         """"""
+        from io import StringIO
         from memory_profiler import show_results, LineProfiler
-        try:
-            from StringIO import StringIO
-        except ImportError:  # Python 3.x
-            from io import StringIO
 
         # Local imports to avoid hard dependency.
         from distutils.version import LooseVersion
@@ -700,11 +689,6 @@ class MemoryProfilerMagics(Magics):
             profile(func)
 
         # Add the profiler to the builtins for @profile.
-        if PY3:
-            import builtins
-        else:
-            import __builtin__ as builtins
-
         if 'profile' in builtins.__dict__:
             had_profile = True
             old_profile = builtins.__dict__['profile']
@@ -714,14 +698,13 @@ class MemoryProfilerMagics(Magics):
         builtins.__dict__['profile'] = profile
 
         try:
-            try:
-                profile.runctx(arg_str, global_ns, local_ns)
-                message = ''
-            except SystemExit:
-                message = ""*** SystemExit exception caught in code being profiled.""
-            except KeyboardInterrupt:
-                message = (""*** KeyboardInterrupt exception caught in code being ""
-                           ""profiled."")
+            profile.runctx(arg_str, global_ns, local_ns)
+            message = ''
+        except SystemExit:
+            message = ""*** SystemExit exception caught in code being profiled.""
+        except KeyboardInterrupt:
+            message = (""*** KeyboardInterrupt exception caught in code being ""
+                       ""profiled."")
         finally:
             if had_profile:
                 builtins.__dict__['profile'] = old_profile
@@ -888,6 +871,25 @@ def profile(func=None, stream=None, precision=1):
             return profile(f, stream=stream, precision=precision)
         return inner_wrapper
 
+
+# Insert in the built-ins to have profile
+# globally defined (global variables is not enough
+# for all cases, e.g. a script that imports another
+# script where @profile is used)
+if PY3:
+    def exec_with_profiler(filename, profiler):
+        builtins.__dict__['profile'] = profiler
+        # shadow the profile decorator defined above
+        ns = dict(_CLEAN_GLOBALS, profile=profiler)
+        with open(filename) as f:
+            exec(compile(f.read(), filename, 'exec'), ns, ns)
+else:
+    def exec_with_profiler(filename, profiler):
+        builtins.__dict__['profile'] = profiler
+        ns = dict(_CLEAN_GLOBALS, profile=profiler)
+        execfile(filename, ns, ns)
+
+
 class LogFile(object):
     """"""File-like object to log text using the `logging` module and the log report can be customised.""""""
 
@@ -905,7 +907,7 @@ class LogFile(object):
 
     def write(self, msg, level=logging.INFO):
         if self.reportIncrementFlag:
-            if ""MiB"" in msg and float(msg.split(""MiB"")[1].strip())>0:
+            if ""MiB"" in msg and float(msg.split(""MiB"")[1].strip()) > 0:
                 self.logger.log(level, msg)
             elif msg.__contains__(""Filename:"") or msg.__contains__(""Line Contents""):
                 self.logger.log(level, msg)
@@ -916,6 +918,7 @@ class LogFile(object):
         for handler in self.logger.handlers:
             handler.flush()
 
+
 if __name__ == '__main__':
     from optparse import OptionParser
     parser = OptionParser(usage=_CMD_USAGE, version=__version__)
@@ -947,24 +950,9 @@ if __name__ == '__main__':
         prof = TimeStamper()
     else:
         prof = LineProfiler(max_mem=options.max_mem)
-    __file__ = _find_script(args[0])
+    script_filename = _find_script(args[0])
     try:
-        if not PY3:
-            # we need to ovewrite the builtins to have profile
-            # globally defined (global variables is not enough
-            # for all cases, e.g. a script that imports another
-            # script where @profile is used)
-            import __builtin__
-            __builtin__.__dict__['profile'] = prof
-            ns = copy(_CLEAN_GLOBALS)
-            ns['profile'] = prof  # shadow the profile decorator defined above
-            execfile(__file__, ns, ns)
-        else:
-            import builtins
-            builtins.__dict__['profile'] = prof
-            ns = copy(_CLEAN_GLOBALS)
-            ns['profile'] = prof  # shadow the profile decorator defined above
-            exec(compile(open(__file__).read(), __file__, 'exec'), ns, ns)
+        exec_with_profiler(script_filename, prof)
     finally:
         if options.out_filename is not None:
             out_file = open(options.out_filename, ""a"")
",True,memory_profiler.py,True
"@@ -8,6 +8,7 @@ test:
 	$(PYTHON) -m memory_profiler test/test_as.py
 	$(PYTHON) -m memory_profiler test/test_global.py
 	$(PYTHON) -m memory_profiler test/test_precision_command_line.py
+	$(PYTHON) -m memory_profiler test/test_gen.py
 	$(PYTHON) test/test_import.py
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
","@@ -8,6 +8,7 @@ test:
 	$(PYTHON) -m memory_profiler test/test_as.py
 	$(PYTHON) -m memory_profiler test/test_global.py
 	$(PYTHON) -m memory_profiler test/test_precision_command_line.py
+	$(PYTHON) -m memory_profiler test/test_gen.py
 	$(PYTHON) test/test_import.py
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
",True,Makefile,False
"@@ -402,15 +402,64 @@ class TimeStamper:
                     (function_name,) + ts[0] + ts[1]))
 
 
+class CodeMap(dict):
+
+    def __init__(self, include_children):
+        self.include_children = include_children
+        self._toplevel = []
+
+    def add(self, code, toplevel_code=None):
+        if code in self:
+            return
+
+        if toplevel_code is None:
+            filename = code.co_filename
+            if filename.endswith(("".pyc"", "".pyo"")):
+                filename = filename[:-1]
+            if not os.path.exists(filename):
+                print('ERROR: Could not find file ' + filename)
+                if filename.startswith((""ipython-input"", ""<ipython-input"")):
+                    print(""NOTE: %mprun can only be used on functions defined in ""
+                          ""physical files, and not in the IPython environment."")
+                return
+
+            toplevel_code = code
+            (sub_lines, start_line) = inspect.getsourcelines(code)
+            linenos = range(start_line,
+                            start_line + len(sub_lines))
+            self._toplevel.append((filename, code, linenos))
+            self[code] = {}
+        else:
+            self[code] = self[toplevel_code]
+
+        for subcode in filter(inspect.iscode, code.co_consts):
+            self.add(subcode, toplevel_code=toplevel_code)
+
+    def trace(self, code, lineno):
+        memory = _get_memory(-1, include_children=self.include_children)
+        # if there is already a measurement for that line get the max
+        previous_memory = self[code].get(lineno, 0)
+        self[code][lineno] = max(memory, previous_memory)
+
+    def items(self):
+        """"""Iterate on the toplevel code blocks.""""""
+        for (filename, code, linenos) in self._toplevel:
+            measures = self[code]
+            if not measures:
+                continue    # skip if no measurement
+            line_iterator = ((line, measures.get(line)) for line in linenos)
+            yield (filename, line_iterator)
+
+
 class LineProfiler(object):
     """""" A profiler that records the amount of memory for each line """"""
 
     def __init__(self, **kw):
-        self.code_map = {}
+        include_children = kw.get('include_children', False)
+        self.code_map = CodeMap(include_children=include_children)
         self.enable_count = 0
         self.max_mem = kw.get('max_mem', None)
-        self.prevline = None
-        self.include_children = kw.get('include_children', False)
+        self.prevlines = []
 
     def __call__(self, func=None, precision=1):
         if func is not None:
@@ -426,13 +475,6 @@ class LineProfiler(object):
                 return self.__call__(f, precision=precision)
             return inner_partial
 
-    def add_code(self, code, toplevel_code=None):
-        if code not in self.code_map:
-            self.code_map[code] = {}
-
-            for subcode in filter(inspect.iscode, code.co_consts):
-                self.add_code(subcode)
-
     def add_function(self, func):
         """""" Record line profiling information for the given Python function.
         """"""
@@ -443,7 +485,7 @@ class LineProfiler(object):
             warnings.warn(""Could not extract a code object for the object %r""
                           % func)
         else:
-            self.add_code(code)
+            self.code_map.add(code)
 
     def wrap_function(self, func):
         """""" Wrap a function to profile it.
@@ -493,15 +535,15 @@ class LineProfiler(object):
 
     def trace_memory_usage(self, frame, event, arg):
         """"""Callback for sys.settrace""""""
-        if (event in ('call', 'line', 'return')
-                and frame.f_code in self.code_map):
-            if event != 'call':
+        if frame.f_code in self.code_map:
+            if event == 'call':
                 # ""call"" event just saves the lineno but not the memory
-                mem = _get_memory(-1, include_children=self.include_children)
-                # if there is already a measurement for that line get the max
-                old_mem = self.code_map[frame.f_code].get(self.prevline, 0)
-                self.code_map[frame.f_code][self.prevline] = max(mem, old_mem)
-            self.prevline = frame.f_lineno
+                self.prevlines.append(frame.f_lineno)
+            elif event == 'line':
+                self.code_map.trace(frame.f_code, self.prevlines[-1])
+                self.prevlines[-1] = frame.f_lineno
+            elif event == 'return':
+                self.code_map.trace(frame.f_code, self.prevlines.pop())
 
         if self._original_trace_function is not None:
             (self._original_trace_function)(frame, event, arg)
@@ -553,45 +595,28 @@ def show_results(prof, stream=None, precision=1):
         stream = sys.stdout
     template = '{0:>6} {1:>12} {2:>12}   {3:<}'
 
-    for code in prof.code_map:
-        lines = prof.code_map[code]
-        if not lines:
-            # .. measurements are empty ..
-            continue
-        filename = code.co_filename
-        if filename.endswith(("".pyc"", "".pyo"")):
-            filename = filename[:-1]
-        stream.write('Filename: ' + filename + '\n\n')
-        if not os.path.exists(filename):
-            stream.write('ERROR: Could not find file ' + filename + '\n')
-            if any([filename.startswith(k) for k in
-                    (""ipython-input"", ""<ipython-input"")]):
-                print(""NOTE: %mprun can only be used on functions defined in ""
-                      ""physical files, and not in the IPython environment."")
-            continue
-        all_lines = linecache.getlines(filename)
-        sub_lines = inspect.getblock(all_lines[code.co_firstlineno - 1:])
-        linenos = range(code.co_firstlineno,
-                        code.co_firstlineno + len(sub_lines))
-
+    for (filename, lines) in prof.code_map.items():
         header = template.format('Line #', 'Mem usage', 'Increment',
                                  'Line Contents')
+
+        stream.write('Filename: ' + filename + '\n\n')
         stream.write(header + '\n')
         stream.write('=' * len(header) + '\n')
 
-        mem_old = lines[min(lines.keys())]
+        all_lines = linecache.getlines(filename)
+        mem_old = None
         float_format = '{0}.{1}f'.format(precision + 4, precision)
         template_mem = '{0:' + float_format + '} MiB'
-        for line in linenos:
-            mem = ''
-            inc = ''
-            if line in lines:
-                mem = lines[line]
-                inc = mem - mem_old
+        for (lineno, mem) in lines:
+            if mem:
+                inc = (mem - mem_old) if mem_old else 0
                 mem_old = mem
                 mem = template_mem.format(mem)
                 inc = template_mem.format(inc)
-            stream.write(template.format(line, mem, inc, all_lines[line - 1]))
+            else:
+                mem = ''
+                inc = ''
+            stream.write(template.format(lineno, mem, inc, all_lines[lineno - 1]))
         stream.write('\n\n')
 
 
","@@ -402,15 +402,64 @@ class TimeStamper:
                     (function_name,) + ts[0] + ts[1]))
 
 
+class CodeMap(dict):
+
+    def __init__(self, include_children):
+        self.include_children = include_children
+        self._toplevel = []
+
+    def add(self, code, toplevel_code=None):
+        if code in self:
+            return
+
+        if toplevel_code is None:
+            filename = code.co_filename
+            if filename.endswith(("".pyc"", "".pyo"")):
+                filename = filename[:-1]
+            if not os.path.exists(filename):
+                print('ERROR: Could not find file ' + filename)
+                if filename.startswith((""ipython-input"", ""<ipython-input"")):
+                    print(""NOTE: %mprun can only be used on functions defined in ""
+                          ""physical files, and not in the IPython environment."")
+                return
+
+            toplevel_code = code
+            (sub_lines, start_line) = inspect.getsourcelines(code)
+            linenos = range(start_line,
+                            start_line + len(sub_lines))
+            self._toplevel.append((filename, code, linenos))
+            self[code] = {}
+        else:
+            self[code] = self[toplevel_code]
+
+        for subcode in filter(inspect.iscode, code.co_consts):
+            self.add(subcode, toplevel_code=toplevel_code)
+
+    def trace(self, code, lineno):
+        memory = _get_memory(-1, include_children=self.include_children)
+        # if there is already a measurement for that line get the max
+        previous_memory = self[code].get(lineno, 0)
+        self[code][lineno] = max(memory, previous_memory)
+
+    def items(self):
+        """"""Iterate on the toplevel code blocks.""""""
+        for (filename, code, linenos) in self._toplevel:
+            measures = self[code]
+            if not measures:
+                continue    # skip if no measurement
+            line_iterator = ((line, measures.get(line)) for line in linenos)
+            yield (filename, line_iterator)
+
+
 class LineProfiler(object):
     """""" A profiler that records the amount of memory for each line """"""
 
     def __init__(self, **kw):
-        self.code_map = {}
+        include_children = kw.get('include_children', False)
+        self.code_map = CodeMap(include_children=include_children)
         self.enable_count = 0
         self.max_mem = kw.get('max_mem', None)
-        self.prevline = None
-        self.include_children = kw.get('include_children', False)
+        self.prevlines = []
 
     def __call__(self, func=None, precision=1):
         if func is not None:
@@ -426,13 +475,6 @@ class LineProfiler(object):
                 return self.__call__(f, precision=precision)
             return inner_partial
 
-    def add_code(self, code, toplevel_code=None):
-        if code not in self.code_map:
-            self.code_map[code] = {}
-
-            for subcode in filter(inspect.iscode, code.co_consts):
-                self.add_code(subcode)
-
     def add_function(self, func):
         """""" Record line profiling information for the given Python function.
         """"""
@@ -443,7 +485,7 @@ class LineProfiler(object):
             warnings.warn(""Could not extract a code object for the object %r""
                           % func)
         else:
-            self.add_code(code)
+            self.code_map.add(code)
 
     def wrap_function(self, func):
         """""" Wrap a function to profile it.
@@ -493,15 +535,15 @@ class LineProfiler(object):
 
     def trace_memory_usage(self, frame, event, arg):
         """"""Callback for sys.settrace""""""
-        if (event in ('call', 'line', 'return')
-                and frame.f_code in self.code_map):
-            if event != 'call':
+        if frame.f_code in self.code_map:
+            if event == 'call':
                 # ""call"" event just saves the lineno but not the memory
-                mem = _get_memory(-1, include_children=self.include_children)
-                # if there is already a measurement for that line get the max
-                old_mem = self.code_map[frame.f_code].get(self.prevline, 0)
-                self.code_map[frame.f_code][self.prevline] = max(mem, old_mem)
-            self.prevline = frame.f_lineno
+                self.prevlines.append(frame.f_lineno)
+            elif event == 'line':
+                self.code_map.trace(frame.f_code, self.prevlines[-1])
+                self.prevlines[-1] = frame.f_lineno
+            elif event == 'return':
+                self.code_map.trace(frame.f_code, self.prevlines.pop())
 
         if self._original_trace_function is not None:
             (self._original_trace_function)(frame, event, arg)
@@ -553,45 +595,28 @@ def show_results(prof, stream=None, precision=1):
         stream = sys.stdout
     template = '{0:>6} {1:>12} {2:>12}   {3:<}'
 
-    for code in prof.code_map:
-        lines = prof.code_map[code]
-        if not lines:
-            # .. measurements are empty ..
-            continue
-        filename = code.co_filename
-        if filename.endswith(("".pyc"", "".pyo"")):
-            filename = filename[:-1]
-        stream.write('Filename: ' + filename + '\n\n')
-        if not os.path.exists(filename):
-            stream.write('ERROR: Could not find file ' + filename + '\n')
-            if any([filename.startswith(k) for k in
-                    (""ipython-input"", ""<ipython-input"")]):
-                print(""NOTE: %mprun can only be used on functions defined in ""
-                      ""physical files, and not in the IPython environment."")
-            continue
-        all_lines = linecache.getlines(filename)
-        sub_lines = inspect.getblock(all_lines[code.co_firstlineno - 1:])
-        linenos = range(code.co_firstlineno,
-                        code.co_firstlineno + len(sub_lines))
-
+    for (filename, lines) in prof.code_map.items():
         header = template.format('Line #', 'Mem usage', 'Increment',
                                  'Line Contents')
+
+        stream.write('Filename: ' + filename + '\n\n')
         stream.write(header + '\n')
         stream.write('=' * len(header) + '\n')
 
-        mem_old = lines[min(lines.keys())]
+        all_lines = linecache.getlines(filename)
+        mem_old = None
         float_format = '{0}.{1}f'.format(precision + 4, precision)
         template_mem = '{0:' + float_format + '} MiB'
-        for line in linenos:
-            mem = ''
-            inc = ''
-            if line in lines:
-                mem = lines[line]
-                inc = mem - mem_old
+        for (lineno, mem) in lines:
+            if mem:
+                inc = (mem - mem_old) if mem_old else 0
                 mem_old = mem
                 mem = template_mem.format(mem)
                 inc = template_mem.format(inc)
-            stream.write(template.format(line, mem, inc, all_lines[line - 1]))
+            else:
+                mem = ''
+                inc = ''
+            stream.write(template.format(lineno, mem, inc, all_lines[lineno - 1]))
         stream.write('\n\n')
 
 
",True,memory_profiler.py,True
"@@ -0,0 +1,41 @@
+
+@profile
+def test_comprehension():
+    # Dict comprehension
+    d_comp = {str(k*k): [v] * (1<<17)
+              for (v, k) in enumerate(range(99, 111))}
+
+    # List comprehension
+    l_comp = [[i] * (i<<9) for i in range(99)]
+    del l_comp
+    del d_comp
+
+    def hh(x=1):
+        # Set comprehension
+        s_comp = {('Z',) * (k<<13) for k in range(x, 19 + 2*x)}
+        return s_comp
+
+    val = [range(1, 4), max(1, 4), 42 + len(hh())]
+    val = hh() | hh(4)
+    val.add(40)
+    l1_comp = [[(1, i)] * (i<<9) for i in range(99)]
+    l2_comp = [[(3, i)] * (i<<9) for i in range(99)]
+
+    return val
+
+
+@profile
+def test_generator():
+    a_gen = ([42] * (1<<20) for __ in '123')
+    huge_lst = list(a_gen)
+
+    b_gen = ([24] * (1<<20) for __ in '123')
+    del b_gen
+    del huge_lst
+
+    return a_gen
+
+
+if __name__ == '__main__':
+    test_generator()
+    test_comprehension()
","@@ -0,0 +1,41 @@
+
+@profile
+def test_comprehension():
+    # Dict comprehension
+    d_comp = {str(k*k): [v] * (1<<17)
+              for (v, k) in enumerate(range(99, 111))}
+
+    # List comprehension
+    l_comp = [[i] * (i<<9) for i in range(99)]
+    del l_comp
+    del d_comp
+
+    def hh(x=1):
+        # Set comprehension
+        s_comp = {('Z',) * (k<<13) for k in range(x, 19 + 2*x)}
+        return s_comp
+
+    val = [range(1, 4), max(1, 4), 42 + len(hh())]
+    val = hh() | hh(4)
+    val.add(40)
+    l1_comp = [[(1, i)] * (i<<9) for i in range(99)]
+    l2_comp = [[(3, i)] * (i<<9) for i in range(99)]
+
+    return val
+
+
+@profile
+def test_generator():
+    a_gen = ([42] * (1<<20) for __ in '123')
+    huge_lst = list(a_gen)
+
+    b_gen = ([24] * (1<<20) for __ in '123')
+    del b_gen
+    del huge_lst
+
+    return a_gen
+
+
+if __name__ == '__main__':
+    test_generator()
+    test_comprehension()
",True,test/test_gen.py,True
"@@ -1,4 +1,12 @@
 
+@profile
+def my_func():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    del b
+    yield a
+
+
 @profile
 def test_comprehension():
     # Dict comprehension
@@ -37,5 +45,8 @@ def test_generator():
 
 
 if __name__ == '__main__':
+    with profile:
+        next(my_func())     # Issue #42
+
     test_generator()
     test_comprehension()
","@@ -1,4 +1,12 @@
 
+@profile
+def my_func():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    del b
+    yield a
+
+
 @profile
 def test_comprehension():
     # Dict comprehension
@@ -37,5 +45,8 @@ def test_generator():
 
 
 if __name__ == '__main__':
+    with profile:
+        next(my_func())     # Issue #42
+
     test_generator()
     test_comprehension()
",True,test/test_gen.py,True
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.38'
+__version__ = '0.39'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.38'
+__version__ = '0.39'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.39'
+__version__ = '0.40'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.39'
+__version__ = '0.40'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -0,0 +1,27 @@
+language: python
+python:
+  - ""2.7""
+  - ""3.3""
+install:
+  - sudo apt-get update
+  # We do this conditionally because it saves us some downloading if the
+  # version is the same.
+  - if [[ ""$TRAVIS_PYTHON_VERSION"" == ""2.7"" ]]; then
+      wget https://repo.continuum.io/miniconda/Miniconda-latest-Linux-x86_64.sh -O miniconda.sh;
+    else
+      wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh -O miniconda.sh;
+    fi
+  - bash miniconda.sh -b -p $HOME/miniconda
+  - export PATH=""$HOME/miniconda/bin:$PATH""
+  - hash -r
+  - conda config --set always_yes yes --set changeps1 no
+  - conda update -q conda
+  # Useful for debugging any issues with conda
+  - conda info -a
+
+  # Replace dep1 dep2 ... with your dependencies
+  - conda create -q -n test-environment python=$TRAVIS_PYTHON_VERSION numpy nose
+  - source activate test-environment
+  - make test
+script:
+- nosetests -v
\ No newline at end of file
","@@ -0,0 +1,27 @@
+language: python
+python:
+  - ""2.7""
+  - ""3.3""
+install:
+  - sudo apt-get update
+  # We do this conditionally because it saves us some downloading if the
+  # version is the same.
+  - if [[ ""$TRAVIS_PYTHON_VERSION"" == ""2.7"" ]]; then
+      wget https://repo.continuum.io/miniconda/Miniconda-latest-Linux-x86_64.sh -O miniconda.sh;
+    else
+      wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh -O miniconda.sh;
+    fi
+  - bash miniconda.sh -b -p $HOME/miniconda
+  - export PATH=""$HOME/miniconda/bin:$PATH""
+  - hash -r
+  - conda config --set always_yes yes --set changeps1 no
+  - conda update -q conda
+  # Useful for debugging any issues with conda
+  - conda info -a
+
+  # Replace dep1 dep2 ... with your dependencies
+  - conda create -q -n test-environment python=$TRAVIS_PYTHON_VERSION numpy nose
+  - source activate test-environment
+  - make test
+script:
+- nosetests -v
\ No newline at end of file
",True,.travis.yml,False
"@@ -22,6 +22,7 @@ install:
   # Replace dep1 dep2 ... with your dependencies
   - conda create -q -n test-environment python=$TRAVIS_PYTHON_VERSION numpy nose
   - source activate test-environment
+  - python setup.py install
   - make test
 script:
 - nosetests -v
\ No newline at end of file
","@@ -22,6 +22,7 @@ install:
   # Replace dep1 dep2 ... with your dependencies
   - conda create -q -n test-environment python=$TRAVIS_PYTHON_VERSION numpy nose
   - source activate test-environment
+  - python setup.py install
   - make test
 script:
 - nosetests -v
\ No newline at end of file
",True,.travis.yml,False
"@@ -1,3 +1,6 @@
+.. image:: https://travis-ci.org/fabianp/memory_profiler.svg?branch=master
+    :target: https://travis-ci.org/fabianp/memory_profiler
+
 =================
  Memory Profiler
 =================
","@@ -1,3 +1,6 @@
+.. image:: https://travis-ci.org/fabianp/memory_profiler.svg?branch=master
+    :target: https://travis-ci.org/fabianp/memory_profiler
+
 =================
  Memory Profiler
 =================
",True,README.rst,False
"@@ -23,6 +23,5 @@ install:
   - conda create -q -n test-environment python=$TRAVIS_PYTHON_VERSION numpy nose
   - source activate test-environment
   - python setup.py install
-  - make test
 script:
-- nosetests -v
\ No newline at end of file
+  - make test
\ No newline at end of file
","@@ -23,6 +23,5 @@ install:
   - conda create -q -n test-environment python=$TRAVIS_PYTHON_VERSION numpy nose
   - source activate test-environment
   - python setup.py install
-  - make test
 script:
-- nosetests -v
\ No newline at end of file
+  - make test
\ No newline at end of file
",True,.travis.yml,False
"@@ -1,4 +1,5 @@
 PYTHON ?= python
+IPYTHON ?= ipython
 
 .PHONY: test
 
@@ -12,3 +13,4 @@ test:
 	$(PYTHON) test/test_import.py
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
+	$(IPYTHON) test/test_ipython.py
","@@ -1,4 +1,5 @@
 PYTHON ?= python
+IPYTHON ?= ipython
 
 .PHONY: test
 
@@ -12,3 +13,4 @@ test:
 	$(PYTHON) test/test_import.py
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
+	$(IPYTHON) test/test_ipython.py
",True,Makefile,False
"@@ -599,14 +599,14 @@ def show_results(prof, stream=None, precision=1):
         header = template.format('Line #', 'Mem usage', 'Increment',
                                  'Line Contents')
 
-        stream.write('Filename: ' + filename + '\n\n')
-        stream.write(header + '\n')
-        stream.write('=' * len(header) + '\n')
+        stream.write(u'Filename: ' + filename + '\n\n')
+        stream.write(header + u'\n')
+        stream.write(u'=' * len(header) + '\n')
 
         all_lines = linecache.getlines(filename)
         mem_old = None
-        float_format = '{0}.{1}f'.format(precision + 4, precision)
-        template_mem = '{0:' + float_format + '} MiB'
+        float_format = u'{0}.{1}f'.format(precision + 4, precision)
+        template_mem = u'{0:' + float_format + '} MiB'
         for (lineno, mem) in lines:
             if mem:
                 inc = (mem - mem_old) if mem_old else 0
@@ -614,10 +614,11 @@ def show_results(prof, stream=None, precision=1):
                 mem = template_mem.format(mem)
                 inc = template_mem.format(inc)
             else:
-                mem = ''
-                inc = ''
-            stream.write(template.format(lineno, mem, inc, all_lines[lineno - 1]))
-        stream.write('\n\n')
+                mem = u''
+                inc = u''
+            tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
+            stream.write(unicode(tmp))
+        stream.write(u'\n\n')
 
 
 def _func_exec(stmt, ns):
","@@ -599,14 +599,14 @@ def show_results(prof, stream=None, precision=1):
         header = template.format('Line #', 'Mem usage', 'Increment',
                                  'Line Contents')
 
-        stream.write('Filename: ' + filename + '\n\n')
-        stream.write(header + '\n')
-        stream.write('=' * len(header) + '\n')
+        stream.write(u'Filename: ' + filename + '\n\n')
+        stream.write(header + u'\n')
+        stream.write(u'=' * len(header) + '\n')
 
         all_lines = linecache.getlines(filename)
         mem_old = None
-        float_format = '{0}.{1}f'.format(precision + 4, precision)
-        template_mem = '{0:' + float_format + '} MiB'
+        float_format = u'{0}.{1}f'.format(precision + 4, precision)
+        template_mem = u'{0:' + float_format + '} MiB'
         for (lineno, mem) in lines:
             if mem:
                 inc = (mem - mem_old) if mem_old else 0
@@ -614,10 +614,11 @@ def show_results(prof, stream=None, precision=1):
                 mem = template_mem.format(mem)
                 inc = template_mem.format(inc)
             else:
-                mem = ''
-                inc = ''
-            stream.write(template.format(lineno, mem, inc, all_lines[lineno - 1]))
-        stream.write('\n\n')
+                mem = u''
+                inc = u''
+            tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
+            stream.write(unicode(tmp))
+        stream.write(u'\n\n')
 
 
 def _func_exec(stmt, ns):
",True,memory_profiler.py,True
"@@ -37,6 +37,7 @@ _TWO_20 = float(2 ** 20)
 
 if PY3:
     import builtins
+    def unicode(x): return str(x)
 else:
     import __builtin__ as builtins
 
","@@ -37,6 +37,7 @@ _TWO_20 = float(2 ** 20)
 
 if PY3:
     import builtins
+    def unicode(x): return str(x)
 else:
     import __builtin__ as builtins
 
",True,memory_profiler.py,True
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.38'
+__version__ = '0.41'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.38'
+__version__ = '0.41'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -20,7 +20,7 @@ install:
   - conda info -a
 
   # Replace dep1 dep2 ... with your dependencies
-  - conda create -q -n test-environment python=$TRAVIS_PYTHON_VERSION numpy nose
+  - conda create -q -n test-environment python=$TRAVIS_PYTHON_VERSION numpy nose ipython
   - source activate test-environment
   - python setup.py install
 script:
","@@ -20,7 +20,7 @@ install:
   - conda info -a
 
   # Replace dep1 dep2 ... with your dependencies
-  - conda create -q -n test-environment python=$TRAVIS_PYTHON_VERSION numpy nose
+  - conda create -q -n test-environment python=$TRAVIS_PYTHON_VERSION numpy nose ipython
   - source activate test-environment
   - python setup.py install
 script:
",True,.travis.yml,False
"@@ -31,15 +31,15 @@ except ImportError:
     line_cell_magic = lambda func: func
     magics_class = lambda cls: cls
 
-PY3 = sys.version_info[0] == 3
+PY2 = sys.version_info[0] == 2
 
 _TWO_20 = float(2 ** 20)
 
-if PY3:
+if PY2:
+    import __builtin__ as builtins
+else:
     import builtins
     def unicode(x): return str(x)
-else:
-    import __builtin__ as builtins
 
 # .. get available packages ..
 try:
@@ -903,18 +903,18 @@ def profile(func=None, stream=None, precision=1):
 # globally defined (global variables is not enough
 # for all cases, e.g. a script that imports another
 # script where @profile is used)
-if PY3:
+if PY2:
     def exec_with_profiler(filename, profiler):
         builtins.__dict__['profile'] = profiler
-        # shadow the profile decorator defined above
         ns = dict(_CLEAN_GLOBALS, profile=profiler)
-        with open(filename) as f:
-            exec(compile(f.read(), filename, 'exec'), ns, ns)
+        execfile(filename, ns, ns)
 else:
     def exec_with_profiler(filename, profiler):
         builtins.__dict__['profile'] = profiler
+        # shadow the profile decorator defined above
         ns = dict(_CLEAN_GLOBALS, profile=profiler)
-        execfile(filename, ns, ns)
+        with open(filename) as f:
+            exec(compile(f.read(), filename, 'exec'), ns, ns)
 
 
 class LogFile(object):
","@@ -31,15 +31,15 @@ except ImportError:
     line_cell_magic = lambda func: func
     magics_class = lambda cls: cls
 
-PY3 = sys.version_info[0] == 3
+PY2 = sys.version_info[0] == 2
 
 _TWO_20 = float(2 ** 20)
 
-if PY3:
+if PY2:
+    import __builtin__ as builtins
+else:
     import builtins
     def unicode(x): return str(x)
-else:
-    import __builtin__ as builtins
 
 # .. get available packages ..
 try:
@@ -903,18 +903,18 @@ def profile(func=None, stream=None, precision=1):
 # globally defined (global variables is not enough
 # for all cases, e.g. a script that imports another
 # script where @profile is used)
-if PY3:
+if PY2:
+    def exec_with_profiler(filename, profiler):
+        builtins.__dict__['profile'] = profiler
+        ns = dict(_CLEAN_GLOBALS, profile=profiler)
+        execfile(filename, ns, ns)
+else:
     def exec_with_profiler(filename, profiler):
         builtins.__dict__['profile'] = profiler
         # shadow the profile decorator defined above
         ns = dict(_CLEAN_GLOBALS, profile=profiler)
         with open(filename) as f:
             exec(compile(f.read(), filename, 'exec'), ns, ns)
-else:
-    def exec_with_profiler(filename, profiler):
-        builtins.__dict__['profile'] = profiler
-        ns = dict(_CLEAN_GLOBALS, profile=profiler)
-        execfile(filename, ns, ns)
 
 
 class LogFile(object):
",False,memory_profiler.py,True
"@@ -9,6 +9,7 @@ test:
 	$(PYTHON) -m memory_profiler test/test_global.py
 	$(PYTHON) -m memory_profiler test/test_precision_command_line.py
 	$(PYTHON) -m memory_profiler test/test_gen.py
+	$(PYTHON) -m memory_profiler test/test_unicode.py
 	$(PYTHON) test/test_import.py
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
","@@ -9,6 +9,7 @@ test:
 	$(PYTHON) -m memory_profiler test/test_global.py
 	$(PYTHON) -m memory_profiler test/test_precision_command_line.py
 	$(PYTHON) -m memory_profiler test/test_gen.py
+	$(PYTHON) -m memory_profiler test/test_unicode.py
 	$(PYTHON) test/test_import.py
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
",True,Makefile,False
"@@ -0,0 +1,15 @@
+# coding: utf-8
+
+import time
+
+@profile
+def test_unicode():
+    # test when unicode is present
+    eval("" = 0"")
+    return
+
+if __name__ == '__main__':
+    # run only for Python 3
+    import sys
+    if sys.version_info >= (3, 0):
+        test_unicode()
","@@ -0,0 +1,15 @@
+# coding: utf-8
+
+import time
+
+@profile
+def test_unicode():
+    # test when unicode is present
+    eval("" = 0"")
+    return
+
+if __name__ == '__main__':
+    # run only for Python 3
+    import sys
+    if sys.version_info >= (3, 0):
+        test_unicode()
",True,test/test_unicode.py,True
"@@ -5,7 +5,7 @@ import time
 @profile
 def test_unicode():
     # test when unicode is present
-    eval("" = 0"")
+    exec("" = 0"")
     return
 
 if __name__ == '__main__':
","@@ -5,7 +5,7 @@ import time
 @profile
 def test_unicode():
     # test when unicode is present
-    eval("" = 0"")
+    exec("" = 0"")
     return
 
 if __name__ == '__main__':
",True,test/test_unicode.py,True
"@@ -618,7 +618,7 @@ def show_results(prof, stream=None, precision=1):
                 mem = u''
                 inc = u''
             tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
-            stream.write(unicode(tmp))
+            stream.write(unicode(tmp, 'UTF-8'))
         stream.write(u'\n\n')
 
 
","@@ -618,7 +618,7 @@ def show_results(prof, stream=None, precision=1):
                 mem = u''
                 inc = u''
             tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
-            stream.write(unicode(tmp))
+            stream.write(unicode(tmp, 'UTF-8'))
         stream.write(u'\n\n')
 
 
",True,memory_profiler.py,True
"@@ -1,15 +1,9 @@
-# coding: utf-8
-
-import time
-
+# -*- coding: utf-8  -*-
+# run only for Python 2.xx
 @profile
-def test_unicode():
+def test_unicode(txt):
     # test when unicode is present
-    exec("" = 0"")
-    return
-
+    txt = txt.replace (u"""", u"""") #Arabic Yah = 
+    return txt
 if __name__ == '__main__':
-    # run only for Python 3
-    import sys
-    if sys.version_info >= (3, 0):
-        test_unicode()
+	test_unicode (u"""")
\ No newline at end of file
","@@ -1,15 +1,9 @@
-# coding: utf-8
-
-import time
-
+# -*- coding: utf-8  -*-
+# run only for Python 2.xx
 @profile
-def test_unicode():
+def test_unicode(txt):
     # test when unicode is present
-    exec("" = 0"")
-    return
-
+    txt = txt.replace (u"""", u"""") #Arabic Yah = 
+    return txt
 if __name__ == '__main__':
-    # run only for Python 3
-    import sys
-    if sys.version_info >= (3, 0):
-        test_unicode()
+	test_unicode (u"""")
\ No newline at end of file
",True,test/test_unicode.py,True
"@@ -39,7 +39,7 @@ if PY2:
     import __builtin__ as builtins
 else:
     import builtins
-    def unicode(x): return str(x)
+    def unicode(x, *args): return str(x)
 
 # .. get available packages ..
 try:
","@@ -39,7 +39,7 @@ if PY2:
     import __builtin__ as builtins
 else:
     import builtins
-    def unicode(x): return str(x)
+    def unicode(x, *args): return str(x)
 
 # .. get available packages ..
 try:
",True,memory_profiler.py,True
"@@ -49,6 +49,28 @@ except ImportError:
     has_psutil = False
 
 
+class MemitResult(object):
+    """"""memit magic run details.
+
+    Object based on IPython's TimeitResult
+    """"""
+    def __init__(self, mem_usage, baseline, repeat, timeout, interval,
+                 include_children):
+        self.mem_usage = mem_usage
+        self.baseline = baseline
+        self.repeat = repeat
+        self.timeout = timeout
+        self.interval = interval
+        self.include_children = include_children
+
+    def _repr_pretty_(self, p , cycle):
+        max_mem = max(self.mem_usage)
+        inc = max_mem - self.baseline
+        msg = 'peak memory: %.02f MiB, increment: %.02f MiB' % (max_mem, inc)
+
+        p.text(u'<MemitResult : '+msg+u'>')
+
+
 def _get_memory(pid, timestamps=False, include_children=False):
 
     # .. only for current process and only on unix..
@@ -794,6 +816,7 @@ class MemoryProfilerMagics(Magics):
 
         -c: If present, add the memory usage of any children process to the report.
 
+        -o: If present, return a object containing memit run details
         Examples
         --------
         ::
@@ -811,7 +834,7 @@ class MemoryProfilerMagics(Magics):
 
         """"""
         from memory_profiler import memory_usage, _func_exec
-        opts, stmt = self.parse_options(line, 'r:t:i:c', posix=False, strict=False)
+        opts, stmt = self.parse_options(line, 'r:t:i:co', posix=False, strict=False)
 
         if cell is None:
             setup = 'pass'
@@ -827,6 +850,7 @@ class MemoryProfilerMagics(Magics):
             timeout = None
         interval = float(getattr(opts, 'i', 0.1))
         include_children = 'c' in opts
+        return_result = 'o' in opts
 
         # I've noticed we get less noisier measurements if we run
         # a garbage collection first
@@ -835,7 +859,7 @@ class MemoryProfilerMagics(Magics):
 
         _func_exec(setup, self.shell.user_ns)
 
-        mem_usage = 0
+        mem_usage = []
         counter = 0
         baseline = memory_usage()[0]
         while counter < repeat:
@@ -843,15 +867,20 @@ class MemoryProfilerMagics(Magics):
             tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
                                timeout=timeout, interval=interval, max_usage=True,
                                include_children=include_children)
-            mem_usage = max(mem_usage, tmp[0])
+            mem_usage.append(tmp[0])
 
         if mem_usage:
+            max_mem = max(mem_usage)
             print('peak memory: %.02f MiB, increment: %.02f MiB' %
-                  (mem_usage, mem_usage - baseline))
+                  (max_mem, max_mem - baseline))
         else:
             print('ERROR: could not read memory usage, try with a lower interval '
                   'or more iterations')
 
+        if return_result:
+            return MemitResult(mem_usage, baseline, repeat, timeout, interval,
+                               include_children)
+
     @classmethod
     def register_magics(cls, ip):
         from distutils.version import LooseVersion
","@@ -49,6 +49,28 @@ except ImportError:
     has_psutil = False
 
 
+class MemitResult(object):
+    """"""memit magic run details.
+
+    Object based on IPython's TimeitResult
+    """"""
+    def __init__(self, mem_usage, baseline, repeat, timeout, interval,
+                 include_children):
+        self.mem_usage = mem_usage
+        self.baseline = baseline
+        self.repeat = repeat
+        self.timeout = timeout
+        self.interval = interval
+        self.include_children = include_children
+
+    def _repr_pretty_(self, p , cycle):
+        max_mem = max(self.mem_usage)
+        inc = max_mem - self.baseline
+        msg = 'peak memory: %.02f MiB, increment: %.02f MiB' % (max_mem, inc)
+
+        p.text(u'<MemitResult : '+msg+u'>')
+
+
 def _get_memory(pid, timestamps=False, include_children=False):
 
     # .. only for current process and only on unix..
@@ -794,6 +816,7 @@ class MemoryProfilerMagics(Magics):
 
         -c: If present, add the memory usage of any children process to the report.
 
+        -o: If present, return a object containing memit run details
         Examples
         --------
         ::
@@ -811,7 +834,7 @@ class MemoryProfilerMagics(Magics):
 
         """"""
         from memory_profiler import memory_usage, _func_exec
-        opts, stmt = self.parse_options(line, 'r:t:i:c', posix=False, strict=False)
+        opts, stmt = self.parse_options(line, 'r:t:i:co', posix=False, strict=False)
 
         if cell is None:
             setup = 'pass'
@@ -827,6 +850,7 @@ class MemoryProfilerMagics(Magics):
             timeout = None
         interval = float(getattr(opts, 'i', 0.1))
         include_children = 'c' in opts
+        return_result = 'o' in opts
 
         # I've noticed we get less noisier measurements if we run
         # a garbage collection first
@@ -835,7 +859,7 @@ class MemoryProfilerMagics(Magics):
 
         _func_exec(setup, self.shell.user_ns)
 
-        mem_usage = 0
+        mem_usage = []
         counter = 0
         baseline = memory_usage()[0]
         while counter < repeat:
@@ -843,15 +867,20 @@ class MemoryProfilerMagics(Magics):
             tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
                                timeout=timeout, interval=interval, max_usage=True,
                                include_children=include_children)
-            mem_usage = max(mem_usage, tmp[0])
+            mem_usage.append(tmp[0])
 
         if mem_usage:
+            max_mem = max(mem_usage)
             print('peak memory: %.02f MiB, increment: %.02f MiB' %
-                  (mem_usage, mem_usage - baseline))
+                  (max_mem, max_mem - baseline))
         else:
             print('ERROR: could not read memory usage, try with a lower interval '
                   'or more iterations')
 
+        if return_result:
+            return MemitResult(mem_usage, baseline, repeat, timeout, interval,
+                               include_children)
+
     @classmethod
     def register_magics(cls, ip):
         from distutils.version import LooseVersion
",True,memory_profiler.py,True
"@@ -817,6 +817,9 @@ class MemoryProfilerMagics(Magics):
         -c: If present, add the memory usage of any children process to the report.
 
         -o: If present, return a object containing memit run details
+
+        -q: If present, be quiet and do not output a result.
+
         Examples
         --------
         ::
@@ -834,7 +837,7 @@ class MemoryProfilerMagics(Magics):
 
         """"""
         from memory_profiler import memory_usage, _func_exec
-        opts, stmt = self.parse_options(line, 'r:t:i:co', posix=False, strict=False)
+        opts, stmt = self.parse_options(line, 'r:t:i:coq', posix=False, strict=False)
 
         if cell is None:
             setup = 'pass'
@@ -851,6 +854,7 @@ class MemoryProfilerMagics(Magics):
         interval = float(getattr(opts, 'i', 0.1))
         include_children = 'c' in opts
         return_result = 'o' in opts
+        quiet = 'q' in opts
 
         # I've noticed we get less noisier measurements if we run
         # a garbage collection first
@@ -869,13 +873,14 @@ class MemoryProfilerMagics(Magics):
                                include_children=include_children)
             mem_usage.append(tmp[0])
 
-        if mem_usage:
-            max_mem = max(mem_usage)
-            print('peak memory: %.02f MiB, increment: %.02f MiB' %
-                  (max_mem, max_mem - baseline))
-        else:
-            print('ERROR: could not read memory usage, try with a lower interval '
-                  'or more iterations')
+        if not quiet:
+            if mem_usage:
+                max_mem = max(mem_usage)
+                print('peak memory: %.02f MiB, increment: %.02f MiB' %
+                      (max_mem, max_mem - baseline))
+            else:
+                print('ERROR: could not read memory usage, try with a lower interval '
+                      'or more iterations')
 
         if return_result:
             return MemitResult(mem_usage, baseline, repeat, timeout, interval,
","@@ -817,6 +817,9 @@ class MemoryProfilerMagics(Magics):
         -c: If present, add the memory usage of any children process to the report.
 
         -o: If present, return a object containing memit run details
+
+        -q: If present, be quiet and do not output a result.
+
         Examples
         --------
         ::
@@ -834,7 +837,7 @@ class MemoryProfilerMagics(Magics):
 
         """"""
         from memory_profiler import memory_usage, _func_exec
-        opts, stmt = self.parse_options(line, 'r:t:i:co', posix=False, strict=False)
+        opts, stmt = self.parse_options(line, 'r:t:i:coq', posix=False, strict=False)
 
         if cell is None:
             setup = 'pass'
@@ -851,6 +854,7 @@ class MemoryProfilerMagics(Magics):
         interval = float(getattr(opts, 'i', 0.1))
         include_children = 'c' in opts
         return_result = 'o' in opts
+        quiet = 'q' in opts
 
         # I've noticed we get less noisier measurements if we run
         # a garbage collection first
@@ -869,13 +873,14 @@ class MemoryProfilerMagics(Magics):
                                include_children=include_children)
             mem_usage.append(tmp[0])
 
-        if mem_usage:
-            max_mem = max(mem_usage)
-            print('peak memory: %.02f MiB, increment: %.02f MiB' %
-                  (max_mem, max_mem - baseline))
-        else:
-            print('ERROR: could not read memory usage, try with a lower interval '
-                  'or more iterations')
+        if not quiet:
+            if mem_usage:
+                max_mem = max(mem_usage)
+                print('peak memory: %.02f MiB, increment: %.02f MiB' %
+                      (max_mem, max_mem - baseline))
+            else:
+                print('ERROR: could not read memory usage, try with a lower interval '
+                      'or more iterations')
 
         if return_result:
             return MemitResult(mem_usage, baseline, repeat, timeout, interval,
",True,memory_profiler.py,True
"@@ -63,11 +63,13 @@ class MemitResult(object):
         self.interval = interval
         self.include_children = include_children
 
-    def _repr_pretty_(self, p , cycle):
+    def __str__(self):
         max_mem = max(self.mem_usage)
         inc = max_mem - self.baseline
-        msg = 'peak memory: %.02f MiB, increment: %.02f MiB' % (max_mem, inc)
+        return 'peak memory: %.02f MiB, increment: %.02f MiB' % (max_mem, inc)
 
+    def _repr_pretty_(self, p , cycle):
+        msg = str(self)
         p.text(u'<MemitResult : '+msg+u'>')
 
 
@@ -873,18 +875,18 @@ class MemoryProfilerMagics(Magics):
                                include_children=include_children)
             mem_usage.append(tmp[0])
 
+        result = MemitResult(mem_usage, baseline, repeat, timeout, interval,
+                             include_children)
+
         if not quiet:
             if mem_usage:
-                max_mem = max(mem_usage)
-                print('peak memory: %.02f MiB, increment: %.02f MiB' %
-                      (max_mem, max_mem - baseline))
+                print(result)
             else:
                 print('ERROR: could not read memory usage, try with a lower interval '
                       'or more iterations')
 
         if return_result:
-            return MemitResult(mem_usage, baseline, repeat, timeout, interval,
-                               include_children)
+            return result
 
     @classmethod
     def register_magics(cls, ip):
","@@ -63,11 +63,13 @@ class MemitResult(object):
         self.interval = interval
         self.include_children = include_children
 
-    def _repr_pretty_(self, p , cycle):
+    def __str__(self):
         max_mem = max(self.mem_usage)
         inc = max_mem - self.baseline
-        msg = 'peak memory: %.02f MiB, increment: %.02f MiB' % (max_mem, inc)
+        return 'peak memory: %.02f MiB, increment: %.02f MiB' % (max_mem, inc)
 
+    def _repr_pretty_(self, p , cycle):
+        msg = str(self)
         p.text(u'<MemitResult : '+msg+u'>')
 
 
@@ -873,18 +875,18 @@ class MemoryProfilerMagics(Magics):
                                include_children=include_children)
             mem_usage.append(tmp[0])
 
+        result = MemitResult(mem_usage, baseline, repeat, timeout, interval,
+                             include_children)
+
         if not quiet:
             if mem_usage:
-                max_mem = max(mem_usage)
-                print('peak memory: %.02f MiB, increment: %.02f MiB' %
-                      (max_mem, max_mem - baseline))
+                print(result)
             else:
                 print('ERROR: could not read memory usage, try with a lower interval '
                       'or more iterations')
 
         if return_result:
-            return MemitResult(mem_usage, baseline, repeat, timeout, interval,
-                               include_children)
+            return result
 
     @classmethod
     def register_magics(cls, ip):
",True,memory_profiler.py,True
"@@ -17,6 +17,8 @@ import inspect
 import subprocess
 import logging
 
+from collections import OrderedDict
+
 # TODO: provide alternative when multiprocessing is not available
 try:
     from multiprocessing import Process, Pipe
@@ -39,7 +41,9 @@ if PY2:
     import __builtin__ as builtins
 else:
     import builtins
-    def unicode(x, *args): return str(x)
+
+    def unicode(x, *args):
+        return str(x)
 
 # .. get available packages ..
 try:
@@ -48,6 +52,15 @@ try:
 except ImportError:
     has_psutil = False
 
+try:
+    import tracemalloc
+    has_tracemalloc = True
+except ImportError:
+    has_tracemalloc = False
+
+_backend_chosen = False
+_backend = 'psutil'
+
 
 class MemitResult(object):
     """"""memit magic run details.
@@ -73,14 +86,24 @@ class MemitResult(object):
         p.text(u'<MemitResult : '+msg+u'>')
 
 
-def _get_memory(pid, timestamps=False, include_children=False):
+def _get_memory(pid, timestamps=False, include_children=False, filename=None):
 
     # .. only for current process and only on unix..
     if pid == -1:
         pid = os.getpid()
 
-    # .. cross-platform but but requires psutil ..
-    if has_psutil:
+    def tracemalloc_tool():
+        # .. cross-platform but but requires Python 3.4 or higher
+        stat = next(filter(lambda item: str(item).startswith(filename),
+                           tracemalloc.take_snapshot().statistics('filename')))
+        mem = stat.size / _TWO_20
+        if timestamps:
+            return mem, time.time()
+        else:
+            return mem
+
+    def ps_util_tool():
+        # .. cross-platform but but requires psutil ..
         process = psutil.Process(pid)
         try:
             # avoid useing get_memory_info since it does not exists
@@ -96,15 +119,15 @@ def _get_memory(pid, timestamps=False, include_children=False):
                     for p in process.children(recursive=True):
                         mem += getattr(p, meminfo_attr)()[0] / _TWO_20
             if timestamps:
-                return (mem, time.time())
+                return mem, time.time()
             else:
                 return mem
         except psutil.AccessDenied:
             pass
             # continue and try to get this from ps
 
-    # .. scary stuff ..
-    if os.name == 'posix':
+    def posix_tool():
+        # .. scary stuff ..
         if include_children:
             raise NotImplementedError('The psutil module is required when to'
                                       ' monitor memory usage of children'
@@ -122,17 +145,20 @@ def _get_memory(pid, timestamps=False, include_children=False):
             vsz_index = out[0].split().index(b'RSS')
             mem = float(out[1].split()[vsz_index]) / 1024
             if timestamps:
-                return(mem, time.time())
+                return mem, time.time()
             else:
                 return mem
         except:
             if timestamps:
-                return (-1, time.time())
+                return -1, time.time()
             else:
                 return -1
-    else:
-        raise NotImplementedError('The psutil module is required for non-unix '
-                                  'platforms')
+
+    if _backend == 'tracemalloc' and (filename is None or filename == '<unknown>'):
+        raise RuntimeError('There is no access to source file of the profiled function')
+
+    tools = {'tracemalloc': tracemalloc_tool, 'psutil': ps_util_tool, 'posix': posix_tool}
+    return tools[_backend]()
 
 
 class MemTimer(Process):
@@ -152,6 +178,7 @@ class MemTimer(Process):
         self.include_children = kw.pop(""include_children"", False)
 
         # get baseline memory usage
+        # TODO: add filename
         self.mem_usage = [
             _get_memory(self.monitor_pid, timestamps=self.timestamps,
                         include_children=self.include_children)]
@@ -161,6 +188,7 @@ class MemTimer(Process):
         self.pipe.send(0)  # we're ready
         stop = False
         while True:
+            # TODO: add filename
             cur_mem = _get_memory(self.monitor_pid, timestamps=self.timestamps,
                                   include_children=self.include_children)
             if not self.max_usage:
@@ -275,6 +303,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         line_count = 0
         while True:
             if not max_usage:
+                # TODO: add filename
                 mem_usage = _get_memory(proc.pid, timestamps=timestamps,
                                         include_children=include_children)
                 if stream is not None:
@@ -282,6 +311,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 else:
                     ret.append(mem_usage)
             else:
+                # TODO: add filename
                 ret = max(ret,
                           _get_memory(proc.pid,
                                       include_children=include_children))
@@ -306,6 +336,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         while counter < max_iter:
             counter += 1
             if not max_usage:
+                # TODO: add filename
                 mem_usage = _get_memory(proc, timestamps=timestamps,
                                         include_children=include_children)
                 if stream is not None:
@@ -313,6 +344,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 else:
                     ret.append(mem_usage)
             else:
+                # TODO: add filename
                 ret = max([ret,
                            _get_memory(proc, include_children=include_children)
                            ])
@@ -351,14 +383,15 @@ def _find_script(script_name):
 class _TimeStamperCM(object):
     """"""Time-stamping context manager.""""""
 
-    def __init__(self, timestamps):
+    def __init__(self, timestamps, filename):
         self._timestamps = timestamps
+        self._filename = filename
 
     def __enter__(self):
-        self._timestamps.append(_get_memory(os.getpid(), timestamps=True))
+        self._timestamps.append(_get_memory(os.getpid(), timestamps=True, filename=self._filename))
 
     def __exit__(self, *args):
-        self._timestamps.append(_get_memory(os.getpid(), timestamps=True))
+        self._timestamps.append(_get_memory(os.getpid(), timestamps=True, filename=self._filename))
 
 
 class TimeStamper:
@@ -396,7 +429,11 @@ class TimeStamper:
         self.functions[func].append(timestamps)
         # A new object is required each time, since there can be several
         # nested context managers.
-        return _TimeStamperCM(timestamps)
+        try:
+            filename = inspect.getsourcefile(func)
+        except TypeError:
+            filename = '<unknown>'
+        return _TimeStamperCM(timestamps, filename)
 
     def add_function(self, func):
         if func not in self.functions:
@@ -407,13 +444,17 @@ class TimeStamper:
         """"""
         def f(*args, **kwds):
             # Start time
-            timestamps = [_get_memory(os.getpid(), timestamps=True)]
+            try:
+                filename = inspect.getsourcefile(func)
+            except TypeError:
+                filename = '<unknown>'
+            timestamps = [_get_memory(os.getpid(), timestamps=True, filename=filename)]
             self.functions[func].append(timestamps)
             try:
                 return func(*args, **kwds)
             finally:
                 # end time
-                timestamps.append(_get_memory(os.getpid(), timestamps=True))
+                timestamps.append(_get_memory(os.getpid(), timestamps=True, filename=filename))
         return f
 
     def show_results(self, stream=None):
@@ -461,7 +502,7 @@ class CodeMap(dict):
             self.add(subcode, toplevel_code=toplevel_code)
 
     def trace(self, code, lineno):
-        memory = _get_memory(-1, include_children=self.include_children)
+        memory = _get_memory(-1, include_children=self.include_children, filename=code.co_filename)
         # if there is already a measurement for that line get the max
         previous_memory = self[code].get(lineno, 0)
         self[code][lineno] = max(memory, previous_memory)
@@ -578,7 +619,7 @@ class LineProfiler(object):
     def trace_max_mem(self, frame, event, arg):
         # run into PDB as soon as memory is higher than MAX_MEM
         if event in ('line', 'return') and frame.f_code in self.code_map:
-            c = _get_memory(-1)
+            c = _get_memory(-1, filename=frame.f_code.co_filename)
             if c >= self.max_mem:
                 t = ('Current memory {0:.2f} MiB exceeded the '
                      'maximum of {1:.2f} MiB\n'.format(c, self.max_mem))
@@ -918,10 +959,16 @@ def load_ipython_extension(ip):
     MemoryProfilerMagics.register_magics(ip)
 
 
-def profile(func=None, stream=None, precision=1):
+def profile(func=None, stream=None, precision=1, backend='psutil'):
     """"""
     Decorator that will run the function and print a line-by-line profile
     """"""
+    global _backend
+    _backend = backend
+    if not _backend_chosen:
+        choose_backend()
+    if _backend == 'tracemalloc' and not tracemalloc.is_tracing():
+        tracemalloc.start()
     if func is not None:
         def wrapper(*args, **kwargs):
             prof = LineProfiler()
@@ -931,10 +978,37 @@ def profile(func=None, stream=None, precision=1):
         return wrapper
     else:
         def inner_wrapper(f):
-            return profile(f, stream=stream, precision=precision)
+            return profile(f, stream=stream, precision=precision, backend=backend)
         return inner_wrapper
 
 
+def choose_backend():
+    """"""
+    Function that tries to setup backend, chosen by user, and if failed,
+    setup one of the allowable backends
+    """"""
+    global _backend
+    old_backend = _backend
+    backends = OrderedDict([
+        ('psutil', has_psutil),
+        ('posix', os.name == 'posix'),
+        ('tracemalloc', has_tracemalloc),
+        ('no_backend', True)
+    ])
+    backends.move_to_end(_backend, last=False)
+    for n_backend, is_available in backends.items():
+        if is_available:
+            _backend = n_backend
+            break
+    if _backend == 'no_backend':
+        raise NotImplementedError('Tracemalloc or psutil module is required for non-unix '
+                                  'platforms')
+    if _backend != old_backend:
+        print('{} can not be used, {} used instead'.format(old_backend, _backend))
+    global _backend_chosen
+    _backend_chosen = True
+
+
 # Insert in the built-ins to have profile
 # globally defined (global variables is not enough
 # for all cases, e.g. a script that imports another
@@ -943,14 +1017,22 @@ if PY2:
     def exec_with_profiler(filename, profiler):
         builtins.__dict__['profile'] = profiler
         ns = dict(_CLEAN_GLOBALS, profile=profiler)
+        choose_backend()
         execfile(filename, ns, ns)
 else:
     def exec_with_profiler(filename, profiler):
+        if _backend == 'tracemalloc' and has_tracemalloc:
+            tracemalloc.start()
         builtins.__dict__['profile'] = profiler
         # shadow the profile decorator defined above
         ns = dict(_CLEAN_GLOBALS, profile=profiler)
-        with open(filename) as f:
-            exec(compile(f.read(), filename, 'exec'), ns, ns)
+        choose_backend()
+        try:
+            with open(filename) as f:
+                exec(compile(f.read(), filename, 'exec'), ns, ns)
+        finally:
+            if tracemalloc.is_tracing():
+                tracemalloc.stop()
 
 
 class LogFile(object):
@@ -987,20 +1069,23 @@ if __name__ == '__main__':
     parser = OptionParser(usage=_CMD_USAGE, version=__version__)
     parser.disable_interspersed_args()
     parser.add_option(
-        ""--pdb-mmem"", dest=""max_mem"", metavar=""MAXMEM"",
-        type=""float"", action=""store"",
-        help=""step into the debugger when memory exceeds MAXMEM"")
+        '--pdb-mmem', dest='max_mem', metavar='MAXMEM',
+        type='float', action='store',
+        help='step into the debugger when memory exceeds MAXMEM')
     parser.add_option(
-        '--precision', dest=""precision"", type=""int"",
-        action=""store"", default=3,
-        help=""precision of memory output in number of significant digits"")
-    parser.add_option(""-o"", dest=""out_filename"", type=""str"",
-                      action=""store"", default=None,
-                      help=""path to a file where results will be written"")
-    parser.add_option(""--timestamp"", dest=""timestamp"", default=False,
-                      action=""store_true"",
-                      help=""""""print timestamp instead of memory measurement for
-                      decorated functions"""""")
+        '--precision', dest='precision', type='int',
+        action='store', default=3,
+        help='precision of memory output in number of significant digits')
+    parser.add_option('-o', dest='out_filename', type='str',
+                      action='store', default=None,
+                      help='path to a file where results will be written')
+    parser.add_option('--timestamp', dest='timestamp', default=False,
+                      action='store_true',
+                      help='''print timestamp instead of memory measurement for
+                      decorated functions''')
+    parser.add_option('--backend', dest='backend', type='choice', action='store',
+                      choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
+                      help='backend using for getting memory info (one of the {tracemalloc, psutil, posix})')
 
     if not sys.argv[1:]:
         parser.print_help()
@@ -1008,12 +1093,14 @@ if __name__ == '__main__':
 
     (options, args) = parser.parse_args()
     sys.argv[:] = args  # Remove every memory_profiler arguments
+    _backend = options.backend
 
+    script_filename = _find_script(args[0])
     if options.timestamp:
         prof = TimeStamper()
     else:
         prof = LineProfiler(max_mem=options.max_mem)
-    script_filename = _find_script(args[0])
+
     try:
         exec_with_profiler(script_filename, prof)
     finally:
","@@ -17,6 +17,8 @@ import inspect
 import subprocess
 import logging
 
+from collections import OrderedDict
+
 # TODO: provide alternative when multiprocessing is not available
 try:
     from multiprocessing import Process, Pipe
@@ -39,7 +41,9 @@ if PY2:
     import __builtin__ as builtins
 else:
     import builtins
-    def unicode(x, *args): return str(x)
+
+    def unicode(x, *args):
+        return str(x)
 
 # .. get available packages ..
 try:
@@ -48,6 +52,15 @@ try:
 except ImportError:
     has_psutil = False
 
+try:
+    import tracemalloc
+    has_tracemalloc = True
+except ImportError:
+    has_tracemalloc = False
+
+_backend_chosen = False
+_backend = 'psutil'
+
 
 class MemitResult(object):
     """"""memit magic run details.
@@ -73,14 +86,24 @@ class MemitResult(object):
         p.text(u'<MemitResult : '+msg+u'>')
 
 
-def _get_memory(pid, timestamps=False, include_children=False):
+def _get_memory(pid, timestamps=False, include_children=False, filename=None):
 
     # .. only for current process and only on unix..
     if pid == -1:
         pid = os.getpid()
 
-    # .. cross-platform but but requires psutil ..
-    if has_psutil:
+    def tracemalloc_tool():
+        # .. cross-platform but but requires Python 3.4 or higher
+        stat = next(filter(lambda item: str(item).startswith(filename),
+                           tracemalloc.take_snapshot().statistics('filename')))
+        mem = stat.size / _TWO_20
+        if timestamps:
+            return mem, time.time()
+        else:
+            return mem
+
+    def ps_util_tool():
+        # .. cross-platform but but requires psutil ..
         process = psutil.Process(pid)
         try:
             # avoid useing get_memory_info since it does not exists
@@ -96,15 +119,15 @@ def _get_memory(pid, timestamps=False, include_children=False):
                     for p in process.children(recursive=True):
                         mem += getattr(p, meminfo_attr)()[0] / _TWO_20
             if timestamps:
-                return (mem, time.time())
+                return mem, time.time()
             else:
                 return mem
         except psutil.AccessDenied:
             pass
             # continue and try to get this from ps
 
-    # .. scary stuff ..
-    if os.name == 'posix':
+    def posix_tool():
+        # .. scary stuff ..
         if include_children:
             raise NotImplementedError('The psutil module is required when to'
                                       ' monitor memory usage of children'
@@ -122,17 +145,20 @@ def _get_memory(pid, timestamps=False, include_children=False):
             vsz_index = out[0].split().index(b'RSS')
             mem = float(out[1].split()[vsz_index]) / 1024
             if timestamps:
-                return(mem, time.time())
+                return mem, time.time()
             else:
                 return mem
         except:
             if timestamps:
-                return (-1, time.time())
+                return -1, time.time()
             else:
                 return -1
-    else:
-        raise NotImplementedError('The psutil module is required for non-unix '
-                                  'platforms')
+
+    if _backend == 'tracemalloc' and (filename is None or filename == '<unknown>'):
+        raise RuntimeError('There is no access to source file of the profiled function')
+
+    tools = {'tracemalloc': tracemalloc_tool, 'psutil': ps_util_tool, 'posix': posix_tool}
+    return tools[_backend]()
 
 
 class MemTimer(Process):
@@ -152,6 +178,7 @@ class MemTimer(Process):
         self.include_children = kw.pop(""include_children"", False)
 
         # get baseline memory usage
+        # TODO: add filename
         self.mem_usage = [
             _get_memory(self.monitor_pid, timestamps=self.timestamps,
                         include_children=self.include_children)]
@@ -161,6 +188,7 @@ class MemTimer(Process):
         self.pipe.send(0)  # we're ready
         stop = False
         while True:
+            # TODO: add filename
             cur_mem = _get_memory(self.monitor_pid, timestamps=self.timestamps,
                                   include_children=self.include_children)
             if not self.max_usage:
@@ -275,6 +303,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         line_count = 0
         while True:
             if not max_usage:
+                # TODO: add filename
                 mem_usage = _get_memory(proc.pid, timestamps=timestamps,
                                         include_children=include_children)
                 if stream is not None:
@@ -282,6 +311,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 else:
                     ret.append(mem_usage)
             else:
+                # TODO: add filename
                 ret = max(ret,
                           _get_memory(proc.pid,
                                       include_children=include_children))
@@ -306,6 +336,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         while counter < max_iter:
             counter += 1
             if not max_usage:
+                # TODO: add filename
                 mem_usage = _get_memory(proc, timestamps=timestamps,
                                         include_children=include_children)
                 if stream is not None:
@@ -313,6 +344,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 else:
                     ret.append(mem_usage)
             else:
+                # TODO: add filename
                 ret = max([ret,
                            _get_memory(proc, include_children=include_children)
                            ])
@@ -351,14 +383,15 @@ def _find_script(script_name):
 class _TimeStamperCM(object):
     """"""Time-stamping context manager.""""""
 
-    def __init__(self, timestamps):
+    def __init__(self, timestamps, filename):
         self._timestamps = timestamps
+        self._filename = filename
 
     def __enter__(self):
-        self._timestamps.append(_get_memory(os.getpid(), timestamps=True))
+        self._timestamps.append(_get_memory(os.getpid(), timestamps=True, filename=self._filename))
 
     def __exit__(self, *args):
-        self._timestamps.append(_get_memory(os.getpid(), timestamps=True))
+        self._timestamps.append(_get_memory(os.getpid(), timestamps=True, filename=self._filename))
 
 
 class TimeStamper:
@@ -396,7 +429,11 @@ class TimeStamper:
         self.functions[func].append(timestamps)
         # A new object is required each time, since there can be several
         # nested context managers.
-        return _TimeStamperCM(timestamps)
+        try:
+            filename = inspect.getsourcefile(func)
+        except TypeError:
+            filename = '<unknown>'
+        return _TimeStamperCM(timestamps, filename)
 
     def add_function(self, func):
         if func not in self.functions:
@@ -407,13 +444,17 @@ class TimeStamper:
         """"""
         def f(*args, **kwds):
             # Start time
-            timestamps = [_get_memory(os.getpid(), timestamps=True)]
+            try:
+                filename = inspect.getsourcefile(func)
+            except TypeError:
+                filename = '<unknown>'
+            timestamps = [_get_memory(os.getpid(), timestamps=True, filename=filename)]
             self.functions[func].append(timestamps)
             try:
                 return func(*args, **kwds)
             finally:
                 # end time
-                timestamps.append(_get_memory(os.getpid(), timestamps=True))
+                timestamps.append(_get_memory(os.getpid(), timestamps=True, filename=filename))
         return f
 
     def show_results(self, stream=None):
@@ -461,7 +502,7 @@ class CodeMap(dict):
             self.add(subcode, toplevel_code=toplevel_code)
 
     def trace(self, code, lineno):
-        memory = _get_memory(-1, include_children=self.include_children)
+        memory = _get_memory(-1, include_children=self.include_children, filename=code.co_filename)
         # if there is already a measurement for that line get the max
         previous_memory = self[code].get(lineno, 0)
         self[code][lineno] = max(memory, previous_memory)
@@ -578,7 +619,7 @@ class LineProfiler(object):
     def trace_max_mem(self, frame, event, arg):
         # run into PDB as soon as memory is higher than MAX_MEM
         if event in ('line', 'return') and frame.f_code in self.code_map:
-            c = _get_memory(-1)
+            c = _get_memory(-1, filename=frame.f_code.co_filename)
             if c >= self.max_mem:
                 t = ('Current memory {0:.2f} MiB exceeded the '
                      'maximum of {1:.2f} MiB\n'.format(c, self.max_mem))
@@ -918,10 +959,16 @@ def load_ipython_extension(ip):
     MemoryProfilerMagics.register_magics(ip)
 
 
-def profile(func=None, stream=None, precision=1):
+def profile(func=None, stream=None, precision=1, backend='psutil'):
     """"""
     Decorator that will run the function and print a line-by-line profile
     """"""
+    global _backend
+    _backend = backend
+    if not _backend_chosen:
+        choose_backend()
+    if _backend == 'tracemalloc' and not tracemalloc.is_tracing():
+        tracemalloc.start()
     if func is not None:
         def wrapper(*args, **kwargs):
             prof = LineProfiler()
@@ -931,10 +978,37 @@ def profile(func=None, stream=None, precision=1):
         return wrapper
     else:
         def inner_wrapper(f):
-            return profile(f, stream=stream, precision=precision)
+            return profile(f, stream=stream, precision=precision, backend=backend)
         return inner_wrapper
 
 
+def choose_backend():
+    """"""
+    Function that tries to setup backend, chosen by user, and if failed,
+    setup one of the allowable backends
+    """"""
+    global _backend
+    old_backend = _backend
+    backends = OrderedDict([
+        ('psutil', has_psutil),
+        ('posix', os.name == 'posix'),
+        ('tracemalloc', has_tracemalloc),
+        ('no_backend', True)
+    ])
+    backends.move_to_end(_backend, last=False)
+    for n_backend, is_available in backends.items():
+        if is_available:
+            _backend = n_backend
+            break
+    if _backend == 'no_backend':
+        raise NotImplementedError('Tracemalloc or psutil module is required for non-unix '
+                                  'platforms')
+    if _backend != old_backend:
+        print('{} can not be used, {} used instead'.format(old_backend, _backend))
+    global _backend_chosen
+    _backend_chosen = True
+
+
 # Insert in the built-ins to have profile
 # globally defined (global variables is not enough
 # for all cases, e.g. a script that imports another
@@ -943,14 +1017,22 @@ if PY2:
     def exec_with_profiler(filename, profiler):
         builtins.__dict__['profile'] = profiler
         ns = dict(_CLEAN_GLOBALS, profile=profiler)
+        choose_backend()
         execfile(filename, ns, ns)
 else:
     def exec_with_profiler(filename, profiler):
+        if _backend == 'tracemalloc' and has_tracemalloc:
+            tracemalloc.start()
         builtins.__dict__['profile'] = profiler
         # shadow the profile decorator defined above
         ns = dict(_CLEAN_GLOBALS, profile=profiler)
-        with open(filename) as f:
-            exec(compile(f.read(), filename, 'exec'), ns, ns)
+        choose_backend()
+        try:
+            with open(filename) as f:
+                exec(compile(f.read(), filename, 'exec'), ns, ns)
+        finally:
+            if tracemalloc.is_tracing():
+                tracemalloc.stop()
 
 
 class LogFile(object):
@@ -987,20 +1069,23 @@ if __name__ == '__main__':
     parser = OptionParser(usage=_CMD_USAGE, version=__version__)
     parser.disable_interspersed_args()
     parser.add_option(
-        ""--pdb-mmem"", dest=""max_mem"", metavar=""MAXMEM"",
-        type=""float"", action=""store"",
-        help=""step into the debugger when memory exceeds MAXMEM"")
+        '--pdb-mmem', dest='max_mem', metavar='MAXMEM',
+        type='float', action='store',
+        help='step into the debugger when memory exceeds MAXMEM')
     parser.add_option(
-        '--precision', dest=""precision"", type=""int"",
-        action=""store"", default=3,
-        help=""precision of memory output in number of significant digits"")
-    parser.add_option(""-o"", dest=""out_filename"", type=""str"",
-                      action=""store"", default=None,
-                      help=""path to a file where results will be written"")
-    parser.add_option(""--timestamp"", dest=""timestamp"", default=False,
-                      action=""store_true"",
-                      help=""""""print timestamp instead of memory measurement for
-                      decorated functions"""""")
+        '--precision', dest='precision', type='int',
+        action='store', default=3,
+        help='precision of memory output in number of significant digits')
+    parser.add_option('-o', dest='out_filename', type='str',
+                      action='store', default=None,
+                      help='path to a file where results will be written')
+    parser.add_option('--timestamp', dest='timestamp', default=False,
+                      action='store_true',
+                      help='''print timestamp instead of memory measurement for
+                      decorated functions''')
+    parser.add_option('--backend', dest='backend', type='choice', action='store',
+                      choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
+                      help='backend using for getting memory info (one of the {tracemalloc, psutil, posix})')
 
     if not sys.argv[1:]:
         parser.print_help()
@@ -1008,12 +1093,14 @@ if __name__ == '__main__':
 
     (options, args) = parser.parse_args()
     sys.argv[:] = args  # Remove every memory_profiler arguments
+    _backend = options.backend
 
+    script_filename = _find_script(args[0])
     if options.timestamp:
         prof = TimeStamper()
     else:
         prof = LineProfiler(max_mem=options.max_mem)
-    script_filename = _find_script(args[0])
+
     try:
         exec_with_profiler(script_filename, prof)
     finally:
",True,memory_profiler.py,True
"@@ -27,13 +27,13 @@ Type mprof <command> --help for usage help on a specific command.
 For example, mprof plot --help will list all plotting options.
 """"""
 
+
 def print_usage():
     print(""Usage: %s <command> <options> <arguments>""
-                  % osp.basename(sys.argv[0]))
+          % osp.basename(sys.argv[0]))
     print(help_msg)
 
 
-
 def get_action():
     """"""Pop first argument, check it is a valid action.""""""
     if len(sys.argv) <= 1:
@@ -233,7 +233,7 @@ def run_action():
     with open(mprofile_output, ""a"") as f:
         f.write(""CMDLINE {0}\n"".format(cmd_line))
         mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
-                         include_children=options.include_children, stream=f)
+                        include_children=options.include_children, stream=f)
 
 
 def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
@@ -257,7 +257,7 @@ def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
         sys.exit(1)
     height_ratio = 20.
     vsize = (pl.ylim()[1] - pl.ylim()[0]) / height_ratio
-    hsize = (pl.xlim()[1] - pl.xlim()[0]) / (3.*height_ratio)
+    hsize = (pl.xlim()[1] - pl.xlim()[0]) / (3. * height_ratio)
 
     bracket_x = pl.asarray([hsize, 0, 0, hsize])
     bracket_y = pl.asarray([vsize, vsize, -vsize, -vsize])
@@ -270,16 +270,16 @@ def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
                 ""-"" + color, linewidth=2, label=label)
     if options.xlim is None or options.xlim[0] <= (xloc[1] - xshift) <= options.xlim[1]:
         pl.plot(-bracket_x + xloc[1] - xshift, bracket_y + yloc[1],
-                ""-"" + color, linewidth=2 )
+                ""-"" + color, linewidth=2)
 
-    # TODO: use matplotlib.patches.Polygon to draw a colored background for
-    # each function.
+        # TODO: use matplotlib.patches.Polygon to draw a colored background for
+        # each function.
 
-    # with maplotlib 1.2, use matplotlib.path.Path to create proper markers
-    # see http://matplotlib.org/examples/pylab_examples/marker_path.html
-    # This works with matplotlib 0.99.1
-    ## pl.plot(xloc[0], yloc[0], ""<""+color, markersize=7, label=label)
-    ## pl.plot(xloc[1], yloc[1], "">""+color, markersize=7)
+        # with maplotlib 1.2, use matplotlib.path.Path to create proper markers
+        # see http://matplotlib.org/examples/pylab_examples/marker_path.html
+        # This works with matplotlib 0.99.1
+        ## pl.plot(xloc[0], yloc[0], ""<""+color, markersize=7, label=label)
+        ## pl.plot(xloc[1], yloc[1], "">""+color, markersize=7)
 
 
 def read_mprofile_file(filename):
@@ -331,7 +331,6 @@ def read_mprofile_file(filename):
             'cmd_line': cmd_line}
 
 
-
 def plot_file(filename, index=0, timestamps=True, options=None):
     try:
         import pylab as pl
@@ -346,7 +345,7 @@ def plot_file(filename, index=0, timestamps=True, options=None):
               'file.**\nFile path: {0}\n'
               'File may be empty or invalid.\n'
               'It can be deleted with ""mprof rm {0}""'.format(
-              mprofile['filename']))
+            mprofile['filename']))
         sys.exit(0)
 
     # Merge function timestamps and memory usage together
@@ -373,11 +372,11 @@ def plot_file(filename, index=0, timestamps=True, options=None):
     max_mem = mem.max()
     max_mem_ind = mem.argmax()
 
-    all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
-    mem_line_colors=(""k"", ""b"", ""r"", ""g"", ""c"", ""y"", ""m"")
+    all_colors = (""c"", ""y"", ""g"", ""r"", ""b"")
+    mem_line_colors = (""k"", ""b"", ""r"", ""g"", ""c"", ""y"", ""m"")
     mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
                                    time.localtime(global_start)) \
-                                   + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
+                     + "".{0:03d}"".format(int(round(math.modf(global_start)[0] * 1000)))
 
     pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
             label=mem_line_label)
@@ -392,9 +391,9 @@ def plot_file(filename, index=0, timestamps=True, options=None):
         for f, exec_ts in ts.items():
             for execution in exec_ts:
                 add_brackets(execution[:2], execution[2:], xshift=global_start,
-                             color= all_colors[func_num % len(all_colors)],
+                             color=all_colors[func_num % len(all_colors)],
                              label=f.split(""."")[-1]
-                             + "" %.3fs"" % (execution[1] - execution[0]), options=options)
+                                   + "" %.3fs"" % (execution[1] - execution[0]), options=options)
             func_num += 1
 
     if timestamps:
@@ -496,6 +495,7 @@ def plot_action():
     else:
         pl.show()
 
+
 if __name__ == ""__main__"":
     # Workaround for optparse limitation: insert -- before first negative
     # number found.
","@@ -27,13 +27,13 @@ Type mprof <command> --help for usage help on a specific command.
 For example, mprof plot --help will list all plotting options.
 """"""
 
+
 def print_usage():
     print(""Usage: %s <command> <options> <arguments>""
-                  % osp.basename(sys.argv[0]))
+          % osp.basename(sys.argv[0]))
     print(help_msg)
 
 
-
 def get_action():
     """"""Pop first argument, check it is a valid action.""""""
     if len(sys.argv) <= 1:
@@ -233,7 +233,7 @@ def run_action():
     with open(mprofile_output, ""a"") as f:
         f.write(""CMDLINE {0}\n"".format(cmd_line))
         mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
-                         include_children=options.include_children, stream=f)
+                        include_children=options.include_children, stream=f)
 
 
 def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
@@ -257,7 +257,7 @@ def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
         sys.exit(1)
     height_ratio = 20.
     vsize = (pl.ylim()[1] - pl.ylim()[0]) / height_ratio
-    hsize = (pl.xlim()[1] - pl.xlim()[0]) / (3.*height_ratio)
+    hsize = (pl.xlim()[1] - pl.xlim()[0]) / (3. * height_ratio)
 
     bracket_x = pl.asarray([hsize, 0, 0, hsize])
     bracket_y = pl.asarray([vsize, vsize, -vsize, -vsize])
@@ -270,16 +270,16 @@ def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
                 ""-"" + color, linewidth=2, label=label)
     if options.xlim is None or options.xlim[0] <= (xloc[1] - xshift) <= options.xlim[1]:
         pl.plot(-bracket_x + xloc[1] - xshift, bracket_y + yloc[1],
-                ""-"" + color, linewidth=2 )
+                ""-"" + color, linewidth=2)
 
-    # TODO: use matplotlib.patches.Polygon to draw a colored background for
-    # each function.
+        # TODO: use matplotlib.patches.Polygon to draw a colored background for
+        # each function.
 
-    # with maplotlib 1.2, use matplotlib.path.Path to create proper markers
-    # see http://matplotlib.org/examples/pylab_examples/marker_path.html
-    # This works with matplotlib 0.99.1
-    ## pl.plot(xloc[0], yloc[0], ""<""+color, markersize=7, label=label)
-    ## pl.plot(xloc[1], yloc[1], "">""+color, markersize=7)
+        # with maplotlib 1.2, use matplotlib.path.Path to create proper markers
+        # see http://matplotlib.org/examples/pylab_examples/marker_path.html
+        # This works with matplotlib 0.99.1
+        ## pl.plot(xloc[0], yloc[0], ""<""+color, markersize=7, label=label)
+        ## pl.plot(xloc[1], yloc[1], "">""+color, markersize=7)
 
 
 def read_mprofile_file(filename):
@@ -331,7 +331,6 @@ def read_mprofile_file(filename):
             'cmd_line': cmd_line}
 
 
-
 def plot_file(filename, index=0, timestamps=True, options=None):
     try:
         import pylab as pl
@@ -346,7 +345,7 @@ def plot_file(filename, index=0, timestamps=True, options=None):
               'file.**\nFile path: {0}\n'
               'File may be empty or invalid.\n'
               'It can be deleted with ""mprof rm {0}""'.format(
-              mprofile['filename']))
+            mprofile['filename']))
         sys.exit(0)
 
     # Merge function timestamps and memory usage together
@@ -373,11 +372,11 @@ def plot_file(filename, index=0, timestamps=True, options=None):
     max_mem = mem.max()
     max_mem_ind = mem.argmax()
 
-    all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
-    mem_line_colors=(""k"", ""b"", ""r"", ""g"", ""c"", ""y"", ""m"")
+    all_colors = (""c"", ""y"", ""g"", ""r"", ""b"")
+    mem_line_colors = (""k"", ""b"", ""r"", ""g"", ""c"", ""y"", ""m"")
     mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
                                    time.localtime(global_start)) \
-                                   + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
+                     + "".{0:03d}"".format(int(round(math.modf(global_start)[0] * 1000)))
 
     pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
             label=mem_line_label)
@@ -392,9 +391,9 @@ def plot_file(filename, index=0, timestamps=True, options=None):
         for f, exec_ts in ts.items():
             for execution in exec_ts:
                 add_brackets(execution[:2], execution[2:], xshift=global_start,
-                             color= all_colors[func_num % len(all_colors)],
+                             color=all_colors[func_num % len(all_colors)],
                              label=f.split(""."")[-1]
-                             + "" %.3fs"" % (execution[1] - execution[0]), options=options)
+                                   + "" %.3fs"" % (execution[1] - execution[0]), options=options)
             func_num += 1
 
     if timestamps:
@@ -496,6 +495,7 @@ def plot_action():
     else:
         pl.show()
 
+
 if __name__ == ""__main__"":
     # Workaround for optparse limitation: insert -- before first negative
     # number found.
",True,mprof,False
"@@ -0,0 +1,47 @@
+import pytest
+import tracemalloc
+from io import StringIO
+from time import sleep
+
+from memory_profiler import profile
+import memory_profiler
+
+tracemalloc.start()
+output = StringIO()
+
+# allowable error in MB
+EPSILON = 0.0001
+
+memory_profiler._backend = 'tracemalloc'
+
+
+@pytest.mark.parametrize('test_input,expected', [
+    (100, 0.00012302398681640625),
+    (1000, 0.0009813308715820312),
+    (10000, 0.009564399719238281),
+    (100000, 0.09539508819580078),
+    (1000000, 0.9537019729614258),
+    (10000000, 9.536770820617676),
+    (100000000, 95.36745929718018),
+])
+def test_memory_profiler(test_input, expected):
+    mem_prof(test_input)
+    inc, dec = parse_mem_prof()
+    assert abs(inc - dec) <= EPSILON, 'inc = {}, dec = {}, err = {}'.format(inc, dec, abs(inc - dec))
+    assert abs(inc - expected) <= EPSILON, 'inc = {}, size = {}, err = {}'.format(inc, expected, abs(inc - expected))
+
+
+@profile(stream=output, precision=6)
+def mem_prof(n):
+    a = bytearray(n)
+    del a
+    sleep(1)
+
+
+def parse_mem_prof():
+    text = output.getvalue().split('\n')
+
+    def f(s):
+        return float(s.split()[3])
+
+    return f(text[-6]), -f(text[-5])
","@@ -0,0 +1,47 @@
+import pytest
+import tracemalloc
+from io import StringIO
+from time import sleep
+
+from memory_profiler import profile
+import memory_profiler
+
+tracemalloc.start()
+output = StringIO()
+
+# allowable error in MB
+EPSILON = 0.0001
+
+memory_profiler._backend = 'tracemalloc'
+
+
+@pytest.mark.parametrize('test_input,expected', [
+    (100, 0.00012302398681640625),
+    (1000, 0.0009813308715820312),
+    (10000, 0.009564399719238281),
+    (100000, 0.09539508819580078),
+    (1000000, 0.9537019729614258),
+    (10000000, 9.536770820617676),
+    (100000000, 95.36745929718018),
+])
+def test_memory_profiler(test_input, expected):
+    mem_prof(test_input)
+    inc, dec = parse_mem_prof()
+    assert abs(inc - dec) <= EPSILON, 'inc = {}, dec = {}, err = {}'.format(inc, dec, abs(inc - dec))
+    assert abs(inc - expected) <= EPSILON, 'inc = {}, size = {}, err = {}'.format(inc, expected, abs(inc - expected))
+
+
+@profile(stream=output, precision=6)
+def mem_prof(n):
+    a = bytearray(n)
+    del a
+    sleep(1)
+
+
+def parse_mem_prof():
+    text = output.getvalue().split('\n')
+
+    def f(s):
+        return float(s.split()[3])
+
+    return f(text[-6]), -f(text[-5])
",True,test/test_tracemalloc.py,True
"@@ -1031,7 +1031,7 @@ else:
             with open(filename) as f:
                 exec(compile(f.read(), filename, 'exec'), ns, ns)
         finally:
-            if tracemalloc.is_tracing():
+            if has_tracemalloc and tracemalloc.is_tracing():
                 tracemalloc.stop()
 
 
","@@ -1031,7 +1031,7 @@ else:
             with open(filename) as f:
                 exec(compile(f.read(), filename, 'exec'), ns, ns)
         finally:
-            if tracemalloc.is_tracing():
+            if has_tracemalloc and tracemalloc.is_tracing():
                 tracemalloc.stop()
 
 
",True,memory_profiler.py,True
"@@ -995,7 +995,19 @@ def choose_backend():
         ('tracemalloc', has_tracemalloc),
         ('no_backend', True)
     ])
-    backends.move_to_end(_backend, last=False)
+
+    def move_to_start(d, key):
+        """"""
+        Emulation of OrderedDict.move_to_end(last=False) for old versions of Python
+        """"""
+        items = [(key, d[key])]
+        for _key, _value in d.items():
+            if _key != key:
+                items.append((_key, _value))
+        return OrderedDict(items)
+
+    backends = move_to_start(backends, _backend)
+
     for n_backend, is_available in backends.items():
         if is_available:
             _backend = n_backend
","@@ -995,7 +995,19 @@ def choose_backend():
         ('tracemalloc', has_tracemalloc),
         ('no_backend', True)
     ])
-    backends.move_to_end(_backend, last=False)
+
+    def move_to_start(d, key):
+        """"""
+        Emulation of OrderedDict.move_to_end(last=False) for old versions of Python
+        """"""
+        items = [(key, d[key])]
+        for _key, _value in d.items():
+            if _key != key:
+                items.append((_key, _value))
+        return OrderedDict(items)
+
+    backends = move_to_start(backends, _backend)
+
     for n_backend, is_available in backends.items():
         if is_available:
             _backend = n_backend
",True,memory_profiler.py,True
"@@ -253,6 +253,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     ret : return value of the profiled function
         Only returned if retval is set to True
     """"""
+    if not _backend_chosen:
+        choose_backend()
     if stream is not None:
         timestamps = True
 
","@@ -253,6 +253,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     ret : return value of the profiled function
         Only returned if retval is set to True
     """"""
+    if not _backend_chosen:
+        choose_backend()
     if stream is not None:
         timestamps = True
 
",True,memory_profiler.py,True
"@@ -966,8 +966,8 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
     Decorator that will run the function and print a line-by-line profile
     """"""
     global _backend
-    _backend = backend
     if not _backend_chosen:
+        _backend = backend
         choose_backend()
     if _backend == 'tracemalloc' and not tracemalloc.is_tracing():
         tracemalloc.start()
","@@ -966,8 +966,8 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
     Decorator that will run the function and print a line-by-line profile
     """"""
     global _backend
-    _backend = backend
     if not _backend_chosen:
+        _backend = backend
         choose_backend()
     if _backend == 'tracemalloc' and not tracemalloc.is_tracing():
         tracemalloc.start()
",True,memory_profiler.py,True
"@@ -11,7 +11,9 @@ test:
 	$(PYTHON) -m memory_profiler test/test_precision_command_line.py
 	$(PYTHON) -m memory_profiler test/test_gen.py
 	$(PYTHON) -m memory_profiler test/test_unicode.py
+	$(PYTHON) test/test_tracemalloc.py
 	$(PYTHON) test/test_import.py
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
 	$(IPYTHON) test/test_ipython.py
+
","@@ -11,7 +11,9 @@ test:
 	$(PYTHON) -m memory_profiler test/test_precision_command_line.py
 	$(PYTHON) -m memory_profiler test/test_gen.py
 	$(PYTHON) -m memory_profiler test/test_unicode.py
+	$(PYTHON) test/test_tracemalloc.py
 	$(PYTHON) test/test_import.py
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
 	$(IPYTHON) test/test_ipython.py
+
",True,Makefile,False
"@@ -1,29 +1,20 @@
-import pytest
-import tracemalloc
 from io import StringIO
 from time import sleep
 
 from memory_profiler import profile
-import memory_profiler
 
-tracemalloc.start()
+try:
+    import tracemalloc
+    has_tracemalloc = True
+except ImportError:
+    has_tracemalloc = False
+
 output = StringIO()
 
 # allowable error in MB
 EPSILON = 0.0001
 
-memory_profiler._backend = 'tracemalloc'
-
 
-@pytest.mark.parametrize('test_input,expected', [
-    (100, 0.00012302398681640625),
-    (1000, 0.0009813308715820312),
-    (10000, 0.009564399719238281),
-    (100000, 0.09539508819580078),
-    (1000000, 0.9537019729614258),
-    (10000000, 9.536770820617676),
-    (100000000, 95.36745929718018),
-])
 def test_memory_profiler(test_input, expected):
     mem_prof(test_input)
     inc, dec = parse_mem_prof()
@@ -31,7 +22,7 @@ def test_memory_profiler(test_input, expected):
     assert abs(inc - expected) <= EPSILON, 'inc = {}, size = {}, err = {}'.format(inc, expected, abs(inc - expected))
 
 
-@profile(stream=output, precision=6)
+@profile(stream=output, precision=6, backend='tracemalloc')
 def mem_prof(n):
     a = bytearray(n)
     del a
@@ -45,3 +36,17 @@ def parse_mem_prof():
         return float(s.split()[3])
 
     return f(text[-6]), -f(text[-5])
+
+if __name__ == '__main__':
+    if has_tracemalloc:
+        tests = [
+            (100, 0.00012302398681640625),
+            (1000, 0.0009813308715820312),
+            (10000, 0.009564399719238281),
+            (100000, 0.09539508819580078),
+            (1000000, 0.9537019729614258),
+            (10000000, 9.536770820617676),
+            (100000000, 95.36745929718018),
+        ]
+        for test_input, expected in tests:
+            test_memory_profiler(test_input, expected)
","@@ -1,29 +1,20 @@
-import pytest
-import tracemalloc
 from io import StringIO
 from time import sleep
 
 from memory_profiler import profile
-import memory_profiler
 
-tracemalloc.start()
+try:
+    import tracemalloc
+    has_tracemalloc = True
+except ImportError:
+    has_tracemalloc = False
+
 output = StringIO()
 
 # allowable error in MB
 EPSILON = 0.0001
 
-memory_profiler._backend = 'tracemalloc'
 
-
-@pytest.mark.parametrize('test_input,expected', [
-    (100, 0.00012302398681640625),
-    (1000, 0.0009813308715820312),
-    (10000, 0.009564399719238281),
-    (100000, 0.09539508819580078),
-    (1000000, 0.9537019729614258),
-    (10000000, 9.536770820617676),
-    (100000000, 95.36745929718018),
-])
 def test_memory_profiler(test_input, expected):
     mem_prof(test_input)
     inc, dec = parse_mem_prof()
@@ -31,7 +22,7 @@ def test_memory_profiler(test_input, expected):
     assert abs(inc - expected) <= EPSILON, 'inc = {}, size = {}, err = {}'.format(inc, expected, abs(inc - expected))
 
 
-@profile(stream=output, precision=6)
+@profile(stream=output, precision=6, backend='tracemalloc')
 def mem_prof(n):
     a = bytearray(n)
     del a
@@ -45,3 +36,17 @@ def parse_mem_prof():
         return float(s.split()[3])
 
     return f(text[-6]), -f(text[-5])
+
+if __name__ == '__main__':
+    if has_tracemalloc:
+        tests = [
+            (100, 0.00012302398681640625),
+            (1000, 0.0009813308715820312),
+            (10000, 0.009564399719238281),
+            (100000, 0.09539508819580078),
+            (1000000, 0.9537019729614258),
+            (10000000, 9.536770820617676),
+            (100000000, 95.36745929718018),
+        ]
+        for test_input, expected in tests:
+            test_memory_profiler(test_input, expected)
",False,test/test_tracemalloc.py,True
"@@ -42,18 +42,21 @@ if PY2:
 else:
     import builtins
 
+
     def unicode(x, *args):
         return str(x)
 
 # .. get available packages ..
 try:
     import psutil
+
     has_psutil = True
 except ImportError:
     has_psutil = False
 
 try:
     import tracemalloc
+
     has_tracemalloc = True
 except ImportError:
     has_tracemalloc = False
@@ -67,6 +70,7 @@ class MemitResult(object):
 
     Object based on IPython's TimeitResult
     """"""
+
     def __init__(self, mem_usage, baseline, repeat, timeout, interval,
                  include_children):
         self.mem_usage = mem_usage
@@ -81,13 +85,12 @@ class MemitResult(object):
         inc = max_mem - self.baseline
         return 'peak memory: %.02f MiB, increment: %.02f MiB' % (max_mem, inc)
 
-    def _repr_pretty_(self, p , cycle):
+    def _repr_pretty_(self, p, cycle):
         msg = str(self)
-        p.text(u'<MemitResult : '+msg+u'>')
+        p.text(u'<MemitResult : ' + msg + u'>')
 
 
 def _get_memory(pid, timestamps=False, include_children=False, filename=None):
-
     # .. only for current process and only on unix..
     if pid == -1:
         pid = os.getpid()
@@ -108,7 +111,8 @@ def _get_memory(pid, timestamps=False, include_children=False, filename=None):
         try:
             # avoid useing get_memory_info since it does not exists
             # in psutil > 2.0 and accessing it will cause exception.
-            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
+            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') \
+                else 'get_memory_info'
             mem = getattr(process, meminfo_attr)()[0] / _TWO_20
             if include_children:
                 try:
@@ -154,10 +158,15 @@ def _get_memory(pid, timestamps=False, include_children=False, filename=None):
             else:
                 return -1
 
-    if _backend == 'tracemalloc' and (filename is None or filename == '<unknown>'):
-        raise RuntimeError('There is no access to source file of the profiled function')
+    if _backend == 'tracemalloc' and \
+            (filename is None or filename == '<unknown>'):
+        raise RuntimeError(
+            'There is no access to source file of the profiled function'
+        )
 
-    tools = {'tracemalloc': tracemalloc_tool, 'psutil': ps_util_tool, 'posix': posix_tool}
+    tools = {'tracemalloc': tracemalloc_tool,
+             'psutil': ps_util_tool,
+             'posix': posix_tool}
     return tools[_backend]()
 
 
@@ -165,6 +174,7 @@ class MemTimer(Process):
     """"""
     Fetch memory consumption from over a time interval
     """"""
+
     def __init__(self, monitor_pid, interval, pipe, max_usage=False,
                  *args, **kw):
         self.monitor_pid = monitor_pid
@@ -286,8 +296,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
         while True:
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
-            p = MemTimer(os.getpid(), interval, child_conn, timestamps=timestamps,
-                         max_usage=max_usage, include_children=include_children)
+            p = MemTimer(os.getpid(), interval, child_conn,
+                         timestamps=timestamps,
+                         max_usage=max_usage,
+                         include_children=include_children)
             p.start()
             parent_conn.recv()  # wait until we start getting memory
             returned = f(*args, **kw)
@@ -359,6 +371,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         return None
     return ret
 
+
 # ..
 # .. utility functions for line-by-line ..
 
@@ -390,16 +403,19 @@ class _TimeStamperCM(object):
         self._filename = filename
 
     def __enter__(self):
-        self._timestamps.append(_get_memory(os.getpid(), timestamps=True, filename=self._filename))
+        self._timestamps.append(
+            _get_memory(os.getpid(), timestamps=True, filename=self._filename))
 
     def __exit__(self, *args):
-        self._timestamps.append(_get_memory(os.getpid(), timestamps=True, filename=self._filename))
+        self._timestamps.append(
+            _get_memory(os.getpid(), timestamps=True, filename=self._filename))
 
 
 class TimeStamper:
     """""" A profiler that just records start and end execution times for
     any decorated function.
     """"""
+
     def __init__(self):
         self.functions = {}
 
@@ -418,6 +434,7 @@ class TimeStamper:
         else:
             def inner_partial(f):
                 return self.__call__(f, precision=precision)
+
             return inner_partial
 
     def timestamp(self, name=""<block>""):
@@ -444,19 +461,23 @@ class TimeStamper:
     def wrap_function(self, func):
         """""" Wrap a function to timestamp it.
         """"""
+
         def f(*args, **kwds):
             # Start time
             try:
                 filename = inspect.getsourcefile(func)
             except TypeError:
                 filename = '<unknown>'
-            timestamps = [_get_memory(os.getpid(), timestamps=True, filename=filename)]
+            timestamps = [
+                _get_memory(os.getpid(), timestamps=True, filename=filename)]
             self.functions[func].append(timestamps)
             try:
                 return func(*args, **kwds)
             finally:
                 # end time
-                timestamps.append(_get_memory(os.getpid(), timestamps=True, filename=filename))
+                timestamps.append(_get_memory(os.getpid(), timestamps=True,
+                                              filename=filename))
+
         return f
 
     def show_results(self, stream=None):
@@ -471,7 +492,6 @@ class TimeStamper:
 
 
 class CodeMap(dict):
-
     def __init__(self, include_children):
         self.include_children = include_children
         self._toplevel = []
@@ -487,8 +507,9 @@ class CodeMap(dict):
             if not os.path.exists(filename):
                 print('ERROR: Could not find file ' + filename)
                 if filename.startswith((""ipython-input"", ""<ipython-input"")):
-                    print(""NOTE: %mprun can only be used on functions defined in ""
-                          ""physical files, and not in the IPython environment."")
+                    print(
+                        ""NOTE: %mprun can only be used on functions defined in""
+                        "" physical files, and not in the IPython environment."")
                 return
 
             toplevel_code = code
@@ -504,7 +525,8 @@ class CodeMap(dict):
             self.add(subcode, toplevel_code=toplevel_code)
 
     def trace(self, code, lineno):
-        memory = _get_memory(-1, include_children=self.include_children, filename=code.co_filename)
+        memory = _get_memory(-1, include_children=self.include_children,
+                             filename=code.co_filename)
         # if there is already a measurement for that line get the max
         previous_memory = self[code].get(lineno, 0)
         self[code][lineno] = max(memory, previous_memory)
@@ -514,7 +536,7 @@ class CodeMap(dict):
         for (filename, code, linenos) in self._toplevel:
             measures = self[code]
             if not measures:
-                continue    # skip if no measurement
+                continue  # skip if no measurement
             line_iterator = ((line, measures.get(line)) for line in linenos)
             yield (filename, line_iterator)
 
@@ -541,6 +563,7 @@ class LineProfiler(object):
         else:
             def inner_partial(f):
                 return self.__call__(f, precision=precision)
+
             return inner_partial
 
     def add_function(self, func):
@@ -565,6 +588,7 @@ class LineProfiler(object):
                 return func(*args, **kwds)
             finally:
                 self.disable_by_count()
+
         return f
 
     def run(self, cmd):
@@ -697,7 +721,6 @@ def _func_exec(stmt, ns):
 
 @magics_class
 class MemoryProfilerMagics(Magics):
-
     # A lprun-style %mprun magic for IPython.
     @line_cell_magic
     def mprun(self, parameter_s='', cell=None):
@@ -760,7 +783,8 @@ class MemoryProfilerMagics(Magics):
         # Escape quote markers.
         opts_def = Struct(T=[''], f=[])
         parameter_s = parameter_s.replace('""', r'\""').replace(""'"", r""\'"")
-        opts, arg_str = self.parse_options(parameter_s, 'rf:T:c', list_all=True)
+        opts, arg_str = self.parse_options(parameter_s, 'rf:T:c',
+                                           list_all=True)
         opts.merge(opts_def)
         global_ns = self.shell.user_global_ns
         local_ns = self.shell.user_ns
@@ -775,7 +799,8 @@ class MemoryProfilerMagics(Magics):
                 funcs.append(eval(name, global_ns, local_ns))
             except Exception as e:
                 raise UsageError('Could not find function %r.\n%s: %s' % (name,
-                                 e.__class__.__name__, e))
+                                                                          e.__class__.__name__,
+                                                                          e))
 
         include_children = 'c' in opts
         profile = LineProfiler(include_children=include_children)
@@ -813,14 +838,15 @@ class MemoryProfilerMagics(Magics):
             page(output, screen_lines=self.shell.rc.screen_length)
         else:
             page(output)
-        print(message,)
+        print(message, )
 
         text_file = opts.T[0]
         if text_file:
             with open(text_file, 'w') as pfile:
                 pfile.write(output)
-            print('\n*** Profile printout saved to text file %s. %s' % (text_file,
-                                                                        message))
+            print('\n*** Profile printout saved to text file %s. %s' % (
+                text_file,
+                message))
 
         return_value = None
         if 'r' in opts:
@@ -882,7 +908,8 @@ class MemoryProfilerMagics(Magics):
 
         """"""
         from memory_profiler import memory_usage, _func_exec
-        opts, stmt = self.parse_options(line, 'r:t:i:coq', posix=False, strict=False)
+        opts, stmt = self.parse_options(line, 'r:t:i:coq', posix=False,
+                                        strict=False)
 
         if cell is None:
             setup = 'pass'
@@ -914,7 +941,8 @@ class MemoryProfilerMagics(Magics):
         while counter < repeat:
             counter += 1
             tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
-                               timeout=timeout, interval=interval, max_usage=True,
+                               timeout=timeout, interval=interval,
+                               max_usage=True,
                                include_children=include_children)
             mem_usage.append(tmp[0])
 
@@ -925,8 +953,9 @@ class MemoryProfilerMagics(Magics):
             if mem_usage:
                 print(result)
             else:
-                print('ERROR: could not read memory usage, try with a lower interval '
-                      'or more iterations')
+                print(
+                    'ERROR: could not read memory usage, try with a lower interval '
+                    'or more iterations')
 
         if return_result:
             return result
@@ -948,6 +977,7 @@ class MemoryProfilerMagics(Magics):
         else:
             ip.register_magics(cls)
 
+
 # commenting out due to failures with some versions of IPython
 # see https://github.com/fabianp/memory_profiler/issues/106
 # # Ensuring old interface of magics expose for IPython 0.10
@@ -977,10 +1007,13 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
             val = prof(func)(*args, **kwargs)
             show_results(prof, stream=stream, precision=precision)
             return val
+
         return wrapper
     else:
         def inner_wrapper(f):
-            return profile(f, stream=stream, precision=precision, backend=backend)
+            return profile(f, stream=stream, precision=precision,
+                           backend=backend)
+
         return inner_wrapper
 
 
@@ -1015,10 +1048,12 @@ def choose_backend():
             _backend = n_backend
             break
     if _backend == 'no_backend':
-        raise NotImplementedError('Tracemalloc or psutil module is required for non-unix '
-                                  'platforms')
+        raise NotImplementedError(
+            'Tracemalloc or psutil module is required for non-unix '
+            'platforms')
     if _backend != old_backend:
-        print('{} can not be used, {} used instead'.format(old_backend, _backend))
+        print('{} can not be used, {} used instead'.format(old_backend,
+                                                           _backend))
     global _backend_chosen
     _backend_chosen = True
 
@@ -1050,12 +1085,14 @@ else:
 
 
 class LogFile(object):
-    """"""File-like object to log text using the `logging` module and the log report can be customised.""""""
+    """"""File-like object to log text using the `logging` module and the log
+    report can be customised.""""""
 
     def __init__(self, name=None, reportIncrementFlag=False):
         """"""
         :param name: name of the logger module
-               reportIncrementFlag: This must be set to True if only the steps with memory increments are to be reported
+               reportIncrementFlag: This must be set to True if only the steps
+               with memory increments are to be reported
 
         :type self: object
               name: string
@@ -1068,7 +1105,8 @@ class LogFile(object):
         if self.reportIncrementFlag:
             if ""MiB"" in msg and float(msg.split(""MiB"")[1].strip()) > 0:
                 self.logger.log(level, msg)
-            elif msg.__contains__(""Filename:"") or msg.__contains__(""Line Contents""):
+            elif msg.__contains__(""Filename:"") or msg.__contains__(
+                    ""Line Contents""):
                 self.logger.log(level, msg)
         else:
             self.logger.log(level, msg)
@@ -1080,6 +1118,7 @@ class LogFile(object):
 
 if __name__ == '__main__':
     from optparse import OptionParser
+
     parser = OptionParser(usage=_CMD_USAGE, version=__version__)
     parser.disable_interspersed_args()
     parser.add_option(
@@ -1097,9 +1136,12 @@ if __name__ == '__main__':
                       action='store_true',
                       help='''print timestamp instead of memory measurement for
                       decorated functions''')
-    parser.add_option('--backend', dest='backend', type='choice', action='store',
-                      choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
-                      help='backend using for getting memory info (one of the {tracemalloc, psutil, posix})')
+    parser.add_option('--backend', dest='backend', type='choice',
+                      action='store',
+                      choices=['tracemalloc', 'psutil', 'posix'],
+                      default='psutil',
+                      help='backend using for getting memory info '
+                           '(one of the {tracemalloc, psutil, posix})')
 
     if not sys.argv[1:]:
         parser.print_help()
","@@ -42,18 +42,21 @@ if PY2:
 else:
     import builtins
 
+
     def unicode(x, *args):
         return str(x)
 
 # .. get available packages ..
 try:
     import psutil
+
     has_psutil = True
 except ImportError:
     has_psutil = False
 
 try:
     import tracemalloc
+
     has_tracemalloc = True
 except ImportError:
     has_tracemalloc = False
@@ -67,6 +70,7 @@ class MemitResult(object):
 
     Object based on IPython's TimeitResult
     """"""
+
     def __init__(self, mem_usage, baseline, repeat, timeout, interval,
                  include_children):
         self.mem_usage = mem_usage
@@ -81,13 +85,12 @@ class MemitResult(object):
         inc = max_mem - self.baseline
         return 'peak memory: %.02f MiB, increment: %.02f MiB' % (max_mem, inc)
 
-    def _repr_pretty_(self, p , cycle):
+    def _repr_pretty_(self, p, cycle):
         msg = str(self)
-        p.text(u'<MemitResult : '+msg+u'>')
+        p.text(u'<MemitResult : ' + msg + u'>')
 
 
 def _get_memory(pid, timestamps=False, include_children=False, filename=None):
-
     # .. only for current process and only on unix..
     if pid == -1:
         pid = os.getpid()
@@ -108,7 +111,8 @@ def _get_memory(pid, timestamps=False, include_children=False, filename=None):
         try:
             # avoid useing get_memory_info since it does not exists
             # in psutil > 2.0 and accessing it will cause exception.
-            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
+            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') \
+                else 'get_memory_info'
             mem = getattr(process, meminfo_attr)()[0] / _TWO_20
             if include_children:
                 try:
@@ -154,10 +158,15 @@ def _get_memory(pid, timestamps=False, include_children=False, filename=None):
             else:
                 return -1
 
-    if _backend == 'tracemalloc' and (filename is None or filename == '<unknown>'):
-        raise RuntimeError('There is no access to source file of the profiled function')
+    if _backend == 'tracemalloc' and \
+            (filename is None or filename == '<unknown>'):
+        raise RuntimeError(
+            'There is no access to source file of the profiled function'
+        )
 
-    tools = {'tracemalloc': tracemalloc_tool, 'psutil': ps_util_tool, 'posix': posix_tool}
+    tools = {'tracemalloc': tracemalloc_tool,
+             'psutil': ps_util_tool,
+             'posix': posix_tool}
     return tools[_backend]()
 
 
@@ -165,6 +174,7 @@ class MemTimer(Process):
     """"""
     Fetch memory consumption from over a time interval
     """"""
+
     def __init__(self, monitor_pid, interval, pipe, max_usage=False,
                  *args, **kw):
         self.monitor_pid = monitor_pid
@@ -286,8 +296,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
         while True:
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
-            p = MemTimer(os.getpid(), interval, child_conn, timestamps=timestamps,
-                         max_usage=max_usage, include_children=include_children)
+            p = MemTimer(os.getpid(), interval, child_conn,
+                         timestamps=timestamps,
+                         max_usage=max_usage,
+                         include_children=include_children)
             p.start()
             parent_conn.recv()  # wait until we start getting memory
             returned = f(*args, **kw)
@@ -359,6 +371,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         return None
     return ret
 
+
 # ..
 # .. utility functions for line-by-line ..
 
@@ -390,16 +403,19 @@ class _TimeStamperCM(object):
         self._filename = filename
 
     def __enter__(self):
-        self._timestamps.append(_get_memory(os.getpid(), timestamps=True, filename=self._filename))
+        self._timestamps.append(
+            _get_memory(os.getpid(), timestamps=True, filename=self._filename))
 
     def __exit__(self, *args):
-        self._timestamps.append(_get_memory(os.getpid(), timestamps=True, filename=self._filename))
+        self._timestamps.append(
+            _get_memory(os.getpid(), timestamps=True, filename=self._filename))
 
 
 class TimeStamper:
     """""" A profiler that just records start and end execution times for
     any decorated function.
     """"""
+
     def __init__(self):
         self.functions = {}
 
@@ -418,6 +434,7 @@ class TimeStamper:
         else:
             def inner_partial(f):
                 return self.__call__(f, precision=precision)
+
             return inner_partial
 
     def timestamp(self, name=""<block>""):
@@ -444,19 +461,23 @@ class TimeStamper:
     def wrap_function(self, func):
         """""" Wrap a function to timestamp it.
         """"""
+
         def f(*args, **kwds):
             # Start time
             try:
                 filename = inspect.getsourcefile(func)
             except TypeError:
                 filename = '<unknown>'
-            timestamps = [_get_memory(os.getpid(), timestamps=True, filename=filename)]
+            timestamps = [
+                _get_memory(os.getpid(), timestamps=True, filename=filename)]
             self.functions[func].append(timestamps)
             try:
                 return func(*args, **kwds)
             finally:
                 # end time
-                timestamps.append(_get_memory(os.getpid(), timestamps=True, filename=filename))
+                timestamps.append(_get_memory(os.getpid(), timestamps=True,
+                                              filename=filename))
+
         return f
 
     def show_results(self, stream=None):
@@ -471,7 +492,6 @@ class TimeStamper:
 
 
 class CodeMap(dict):
-
     def __init__(self, include_children):
         self.include_children = include_children
         self._toplevel = []
@@ -487,8 +507,9 @@ class CodeMap(dict):
             if not os.path.exists(filename):
                 print('ERROR: Could not find file ' + filename)
                 if filename.startswith((""ipython-input"", ""<ipython-input"")):
-                    print(""NOTE: %mprun can only be used on functions defined in ""
-                          ""physical files, and not in the IPython environment."")
+                    print(
+                        ""NOTE: %mprun can only be used on functions defined in""
+                        "" physical files, and not in the IPython environment."")
                 return
 
             toplevel_code = code
@@ -504,7 +525,8 @@ class CodeMap(dict):
             self.add(subcode, toplevel_code=toplevel_code)
 
     def trace(self, code, lineno):
-        memory = _get_memory(-1, include_children=self.include_children, filename=code.co_filename)
+        memory = _get_memory(-1, include_children=self.include_children,
+                             filename=code.co_filename)
         # if there is already a measurement for that line get the max
         previous_memory = self[code].get(lineno, 0)
         self[code][lineno] = max(memory, previous_memory)
@@ -514,7 +536,7 @@ class CodeMap(dict):
         for (filename, code, linenos) in self._toplevel:
             measures = self[code]
             if not measures:
-                continue    # skip if no measurement
+                continue  # skip if no measurement
             line_iterator = ((line, measures.get(line)) for line in linenos)
             yield (filename, line_iterator)
 
@@ -541,6 +563,7 @@ class LineProfiler(object):
         else:
             def inner_partial(f):
                 return self.__call__(f, precision=precision)
+
             return inner_partial
 
     def add_function(self, func):
@@ -565,6 +588,7 @@ class LineProfiler(object):
                 return func(*args, **kwds)
             finally:
                 self.disable_by_count()
+
         return f
 
     def run(self, cmd):
@@ -697,7 +721,6 @@ def _func_exec(stmt, ns):
 
 @magics_class
 class MemoryProfilerMagics(Magics):
-
     # A lprun-style %mprun magic for IPython.
     @line_cell_magic
     def mprun(self, parameter_s='', cell=None):
@@ -760,7 +783,8 @@ class MemoryProfilerMagics(Magics):
         # Escape quote markers.
         opts_def = Struct(T=[''], f=[])
         parameter_s = parameter_s.replace('""', r'\""').replace(""'"", r""\'"")
-        opts, arg_str = self.parse_options(parameter_s, 'rf:T:c', list_all=True)
+        opts, arg_str = self.parse_options(parameter_s, 'rf:T:c',
+                                           list_all=True)
         opts.merge(opts_def)
         global_ns = self.shell.user_global_ns
         local_ns = self.shell.user_ns
@@ -775,7 +799,8 @@ class MemoryProfilerMagics(Magics):
                 funcs.append(eval(name, global_ns, local_ns))
             except Exception as e:
                 raise UsageError('Could not find function %r.\n%s: %s' % (name,
-                                 e.__class__.__name__, e))
+                                                                          e.__class__.__name__,
+                                                                          e))
 
         include_children = 'c' in opts
         profile = LineProfiler(include_children=include_children)
@@ -813,14 +838,15 @@ class MemoryProfilerMagics(Magics):
             page(output, screen_lines=self.shell.rc.screen_length)
         else:
             page(output)
-        print(message,)
+        print(message, )
 
         text_file = opts.T[0]
         if text_file:
             with open(text_file, 'w') as pfile:
                 pfile.write(output)
-            print('\n*** Profile printout saved to text file %s. %s' % (text_file,
-                                                                        message))
+            print('\n*** Profile printout saved to text file %s. %s' % (
+                text_file,
+                message))
 
         return_value = None
         if 'r' in opts:
@@ -882,7 +908,8 @@ class MemoryProfilerMagics(Magics):
 
         """"""
         from memory_profiler import memory_usage, _func_exec
-        opts, stmt = self.parse_options(line, 'r:t:i:coq', posix=False, strict=False)
+        opts, stmt = self.parse_options(line, 'r:t:i:coq', posix=False,
+                                        strict=False)
 
         if cell is None:
             setup = 'pass'
@@ -914,7 +941,8 @@ class MemoryProfilerMagics(Magics):
         while counter < repeat:
             counter += 1
             tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
-                               timeout=timeout, interval=interval, max_usage=True,
+                               timeout=timeout, interval=interval,
+                               max_usage=True,
                                include_children=include_children)
             mem_usage.append(tmp[0])
 
@@ -925,8 +953,9 @@ class MemoryProfilerMagics(Magics):
             if mem_usage:
                 print(result)
             else:
-                print('ERROR: could not read memory usage, try with a lower interval '
-                      'or more iterations')
+                print(
+                    'ERROR: could not read memory usage, try with a lower interval '
+                    'or more iterations')
 
         if return_result:
             return result
@@ -948,6 +977,7 @@ class MemoryProfilerMagics(Magics):
         else:
             ip.register_magics(cls)
 
+
 # commenting out due to failures with some versions of IPython
 # see https://github.com/fabianp/memory_profiler/issues/106
 # # Ensuring old interface of magics expose for IPython 0.10
@@ -977,10 +1007,13 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
             val = prof(func)(*args, **kwargs)
             show_results(prof, stream=stream, precision=precision)
             return val
+
         return wrapper
     else:
         def inner_wrapper(f):
-            return profile(f, stream=stream, precision=precision, backend=backend)
+            return profile(f, stream=stream, precision=precision,
+                           backend=backend)
+
         return inner_wrapper
 
 
@@ -1015,10 +1048,12 @@ def choose_backend():
             _backend = n_backend
             break
     if _backend == 'no_backend':
-        raise NotImplementedError('Tracemalloc or psutil module is required for non-unix '
-                                  'platforms')
+        raise NotImplementedError(
+            'Tracemalloc or psutil module is required for non-unix '
+            'platforms')
     if _backend != old_backend:
-        print('{} can not be used, {} used instead'.format(old_backend, _backend))
+        print('{} can not be used, {} used instead'.format(old_backend,
+                                                           _backend))
     global _backend_chosen
     _backend_chosen = True
 
@@ -1050,12 +1085,14 @@ else:
 
 
 class LogFile(object):
-    """"""File-like object to log text using the `logging` module and the log report can be customised.""""""
+    """"""File-like object to log text using the `logging` module and the log
+    report can be customised.""""""
 
     def __init__(self, name=None, reportIncrementFlag=False):
         """"""
         :param name: name of the logger module
-               reportIncrementFlag: This must be set to True if only the steps with memory increments are to be reported
+               reportIncrementFlag: This must be set to True if only the steps
+               with memory increments are to be reported
 
         :type self: object
               name: string
@@ -1068,7 +1105,8 @@ class LogFile(object):
         if self.reportIncrementFlag:
             if ""MiB"" in msg and float(msg.split(""MiB"")[1].strip()) > 0:
                 self.logger.log(level, msg)
-            elif msg.__contains__(""Filename:"") or msg.__contains__(""Line Contents""):
+            elif msg.__contains__(""Filename:"") or msg.__contains__(
+                    ""Line Contents""):
                 self.logger.log(level, msg)
         else:
             self.logger.log(level, msg)
@@ -1080,6 +1118,7 @@ class LogFile(object):
 
 if __name__ == '__main__':
     from optparse import OptionParser
+
     parser = OptionParser(usage=_CMD_USAGE, version=__version__)
     parser.disable_interspersed_args()
     parser.add_option(
@@ -1097,9 +1136,12 @@ if __name__ == '__main__':
                       action='store_true',
                       help='''print timestamp instead of memory measurement for
                       decorated functions''')
-    parser.add_option('--backend', dest='backend', type='choice', action='store',
-                      choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
-                      help='backend using for getting memory info (one of the {tracemalloc, psutil, posix})')
+    parser.add_option('--backend', dest='backend', type='choice',
+                      action='store',
+                      choices=['tracemalloc', 'psutil', 'posix'],
+                      default='psutil',
+                      help='backend using for getting memory info '
+                           '(one of the {tracemalloc, psutil, posix})')
 
     if not sys.argv[1:]:
         parser.print_help()
",True,memory_profiler.py,True
"@@ -18,8 +18,12 @@ EPSILON = 0.0001
 def test_memory_profiler(test_input, expected):
     mem_prof(test_input)
     inc, dec = parse_mem_prof()
-    assert abs(inc - dec) <= EPSILON, 'inc = {}, dec = {}, err = {}'.format(inc, dec, abs(inc - dec))
-    assert abs(inc - expected) <= EPSILON, 'inc = {}, size = {}, err = {}'.format(inc, expected, abs(inc - expected))
+    assert abs(inc - dec) <= EPSILON, \
+        'inc = {}, dec = {}, err = {}'.format(inc, dec, abs(inc - dec))
+    assert abs(inc - expected) <= EPSILON, \
+        'inc = {}, size = {}, err = {}'.format(
+            inc, expected, abs(inc - expected)
+        )
 
 
 @profile(stream=output, precision=6, backend='tracemalloc')
","@@ -18,8 +18,12 @@ EPSILON = 0.0001
 def test_memory_profiler(test_input, expected):
     mem_prof(test_input)
     inc, dec = parse_mem_prof()
-    assert abs(inc - dec) <= EPSILON, 'inc = {}, dec = {}, err = {}'.format(inc, dec, abs(inc - dec))
-    assert abs(inc - expected) <= EPSILON, 'inc = {}, size = {}, err = {}'.format(inc, expected, abs(inc - expected))
+    assert abs(inc - dec) <= EPSILON, \
+        'inc = {}, dec = {}, err = {}'.format(inc, dec, abs(inc - dec))
+    assert abs(inc - expected) <= EPSILON, \
+        'inc = {}, size = {}, err = {}'.format(
+            inc, expected, abs(inc - expected)
+        )
 
 
 @profile(stream=output, precision=6, backend='tracemalloc')
",True,test/test_tracemalloc.py,True
"@@ -61,8 +61,7 @@ try:
 except ImportError:
     has_tracemalloc = False
 
-_backend_chosen = False
-_backend = 'psutil'
+_backend = None
 
 
 class MemitResult(object):
@@ -995,10 +994,7 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
     """"""
     Decorator that will run the function and print a line-by-line profile
     """"""
-    global _backend
-    if not _backend_chosen:
-        _backend = backend
-        choose_backend()
+    choose_backend(backend)
     if _backend == 'tracemalloc' and not tracemalloc.is_tracing():
         tracemalloc.start()
     if func is not None:
@@ -1017,13 +1013,12 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
         return inner_wrapper
 
 
-def choose_backend():
+def choose_backend(new_backend=None):
     """"""
     Function that tries to setup backend, chosen by user, and if failed,
     setup one of the allowable backends
     """"""
-    global _backend
-    old_backend = _backend
+
     backends = OrderedDict([
         ('psutil', has_psutil),
         ('posix', os.name == 'posix'),
@@ -1040,19 +1035,20 @@ def choose_backend():
             if _key != key:
                 items.append((_key, _value))
         return OrderedDict(items)
-
-    backends = move_to_start(backends, _backend)
+    if new_backend is not None:
+        backends = move_to_start(backends, new_backend)
 
     for n_backend, is_available in backends.items():
         if is_available:
+            global _backend
             _backend = n_backend
             break
     if _backend == 'no_backend':
         raise NotImplementedError(
             'Tracemalloc or psutil module is required for non-unix '
             'platforms')
-    if _backend != old_backend:
-        print('{} can not be used, {} used instead'.format(old_backend,
+    if _backend != new_backend and new_backend is not None:
+        print('{} can not be used, {} used instead'.format(new_backend,
                                                            _backend))
     global _backend_chosen
     _backend_chosen = True
@@ -1063,19 +1059,19 @@ def choose_backend():
 # for all cases, e.g. a script that imports another
 # script where @profile is used)
 if PY2:
-    def exec_with_profiler(filename, profiler):
+    def exec_with_profiler(filename, profiler, backend):
         builtins.__dict__['profile'] = profiler
         ns = dict(_CLEAN_GLOBALS, profile=profiler)
-        choose_backend()
+        choose_backend(backend)
         execfile(filename, ns, ns)
 else:
-    def exec_with_profiler(filename, profiler):
+    def exec_with_profiler(filename, profiler, backend):
+        choose_backend(backend)
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
         builtins.__dict__['profile'] = profiler
         # shadow the profile decorator defined above
         ns = dict(_CLEAN_GLOBALS, profile=profiler)
-        choose_backend()
         try:
             with open(filename) as f:
                 exec(compile(f.read(), filename, 'exec'), ns, ns)
@@ -1149,7 +1145,6 @@ if __name__ == '__main__':
 
     (options, args) = parser.parse_args()
     sys.argv[:] = args  # Remove every memory_profiler arguments
-    _backend = options.backend
 
     script_filename = _find_script(args[0])
     if options.timestamp:
@@ -1158,7 +1153,7 @@ if __name__ == '__main__':
         prof = LineProfiler(max_mem=options.max_mem)
 
     try:
-        exec_with_profiler(script_filename, prof)
+        exec_with_profiler(script_filename, prof, options.backend)
     finally:
         if options.out_filename is not None:
             out_file = open(options.out_filename, ""a"")
","@@ -61,8 +61,7 @@ try:
 except ImportError:
     has_tracemalloc = False
 
-_backend_chosen = False
-_backend = 'psutil'
+_backend = None
 
 
 class MemitResult(object):
@@ -995,10 +994,7 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
     """"""
     Decorator that will run the function and print a line-by-line profile
     """"""
-    global _backend
-    if not _backend_chosen:
-        _backend = backend
-        choose_backend()
+    choose_backend(backend)
     if _backend == 'tracemalloc' and not tracemalloc.is_tracing():
         tracemalloc.start()
     if func is not None:
@@ -1017,13 +1013,12 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
         return inner_wrapper
 
 
-def choose_backend():
+def choose_backend(new_backend=None):
     """"""
     Function that tries to setup backend, chosen by user, and if failed,
     setup one of the allowable backends
     """"""
-    global _backend
-    old_backend = _backend
+
     backends = OrderedDict([
         ('psutil', has_psutil),
         ('posix', os.name == 'posix'),
@@ -1040,19 +1035,20 @@ def choose_backend():
             if _key != key:
                 items.append((_key, _value))
         return OrderedDict(items)
-
-    backends = move_to_start(backends, _backend)
+    if new_backend is not None:
+        backends = move_to_start(backends, new_backend)
 
     for n_backend, is_available in backends.items():
         if is_available:
+            global _backend
             _backend = n_backend
             break
     if _backend == 'no_backend':
         raise NotImplementedError(
             'Tracemalloc or psutil module is required for non-unix '
             'platforms')
-    if _backend != old_backend:
-        print('{} can not be used, {} used instead'.format(old_backend,
+    if _backend != new_backend and new_backend is not None:
+        print('{} can not be used, {} used instead'.format(new_backend,
                                                            _backend))
     global _backend_chosen
     _backend_chosen = True
@@ -1063,19 +1059,19 @@ def choose_backend():
 # for all cases, e.g. a script that imports another
 # script where @profile is used)
 if PY2:
-    def exec_with_profiler(filename, profiler):
+    def exec_with_profiler(filename, profiler, backend):
         builtins.__dict__['profile'] = profiler
         ns = dict(_CLEAN_GLOBALS, profile=profiler)
-        choose_backend()
+        choose_backend(backend)
         execfile(filename, ns, ns)
 else:
-    def exec_with_profiler(filename, profiler):
+    def exec_with_profiler(filename, profiler, backend):
+        choose_backend(backend)
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
         builtins.__dict__['profile'] = profiler
         # shadow the profile decorator defined above
         ns = dict(_CLEAN_GLOBALS, profile=profiler)
-        choose_backend()
         try:
             with open(filename) as f:
                 exec(compile(f.read(), filename, 'exec'), ns, ns)
@@ -1149,7 +1145,6 @@ if __name__ == '__main__':
 
     (options, args) = parser.parse_args()
     sys.argv[:] = args  # Remove every memory_profiler arguments
-    _backend = options.backend
 
     script_filename = _find_script(args[0])
     if options.timestamp:
@@ -1158,7 +1153,7 @@ if __name__ == '__main__':
         prof = LineProfiler(max_mem=options.max_mem)
 
     try:
-        exec_with_profiler(script_filename, prof)
+        exec_with_profiler(script_filename, prof, options.backend)
     finally:
         if options.out_filename is not None:
             out_file = open(options.out_filename, ""a"")
",True,memory_profiler.py,True
"@@ -1048,7 +1048,7 @@ def choose_backend(new_backend=None):
             'Tracemalloc or psutil module is required for non-unix '
             'platforms')
     if _backend != new_backend and new_backend is not None:
-        print('{} can not be used, {} used instead'.format(new_backend,
+        print('{0} can not be used, {1} used instead'.format(new_backend,
                                                            _backend))
     global _backend_chosen
     _backend_chosen = True
","@@ -1048,7 +1048,7 @@ def choose_backend(new_backend=None):
             'Tracemalloc or psutil module is required for non-unix '
             'platforms')
     if _backend != new_backend and new_backend is not None:
-        print('{} can not be used, {} used instead'.format(new_backend,
+        print('{0} can not be used, {1} used instead'.format(new_backend,
                                                            _backend))
     global _backend_chosen
     _backend_chosen = True
",True,memory_profiler.py,True
"@@ -5,3 +5,6 @@ MANIFEST
 *.egg-info
 *.pyc
 *~
+
+# Ignore mprof generated files
+mprofile_*.dat
","@@ -5,3 +5,6 @@ MANIFEST
 *.egg-info
 *.pyc
 *~
+
+# Ignore mprof generated files
+mprofile_*.dat
",True,.gitignore,False
"@@ -0,0 +1,55 @@
+""""""
+An undecorated example of a script that allocates memory in multiprocessing
+workers to demonstrate the use of memory_profiler with multiple processes.
+
+Run this script with mprof run -C python multiprocessing_example.py
+You can then visualize the usage with mprof plot.
+""""""
+
+import time
+import multiprocessing as mp
+
+# Big numbers
+X6 = 10 ** 6
+X7 = 10 ** 7
+
+
+def worker(num, wait, amt=X6):
+    """"""
+    A function that allocates memory over time.
+    """"""
+    frame = []
+
+    for idx in range(num):
+        frame.extend([1] * amt)
+        time.sleep(wait)
+
+    del frame
+
+
+def main_sequential():
+    """"""
+    A sequential version of the work, where one worker is called at a time.
+    """"""
+    worker(5, 5, X6)
+    worker(5, 2, X7)
+    worker(5, 5, X6)
+    worker(5, 2, X7)
+
+
+def main_multiproc():
+    """"""
+    A multiprocessing version of the work, where workers work in their own
+    child processes and are collected by the master process.
+    """"""
+    pool    = mp.Pool(processes=4)
+    tasks   = [
+        pool.apply_async(worker, args) for args in
+        [(5, 5, X6), (5, 2, X7), (5, 5, X6), (5, 2, X7)]
+    ]
+
+    results = [p.get() for p in tasks]
+
+
+if __name__ == '__main__':
+    main_multiproc()
","@@ -0,0 +1,55 @@
+""""""
+An undecorated example of a script that allocates memory in multiprocessing
+workers to demonstrate the use of memory_profiler with multiple processes.
+
+Run this script with mprof run -C python multiprocessing_example.py
+You can then visualize the usage with mprof plot.
+""""""
+
+import time
+import multiprocessing as mp
+
+# Big numbers
+X6 = 10 ** 6
+X7 = 10 ** 7
+
+
+def worker(num, wait, amt=X6):
+    """"""
+    A function that allocates memory over time.
+    """"""
+    frame = []
+
+    for idx in range(num):
+        frame.extend([1] * amt)
+        time.sleep(wait)
+
+    del frame
+
+
+def main_sequential():
+    """"""
+    A sequential version of the work, where one worker is called at a time.
+    """"""
+    worker(5, 5, X6)
+    worker(5, 2, X7)
+    worker(5, 5, X6)
+    worker(5, 2, X7)
+
+
+def main_multiproc():
+    """"""
+    A multiprocessing version of the work, where workers work in their own
+    child processes and are collected by the master process.
+    """"""
+    pool    = mp.Pool(processes=4)
+    tasks   = [
+        pool.apply_async(worker, args) for args in
+        [(5, 5, X6), (5, 2, X7), (5, 5, X6), (5, 2, X7)]
+    ]
+
+    results = [p.get() for p in tasks]
+
+
+if __name__ == '__main__':
+    main_multiproc()
",True,examples/multiprocessing_example.py,True
"@@ -73,6 +73,34 @@ class MemitResult(object):
         p.text(u'<MemitResult : '+msg+u'>')
 
 
+def _get_child_memory(process, meminfo_attr=None):
+    """"""
+    Returns a generator that yields memory for all child processes.
+    """"""
+    if not has_psutil:
+        raise NotImplementedError((
+            ""The psutil module is required to monitor the ""
+            ""memory usage of child processes.""
+        ))
+
+    # Convert a pid to a process
+    if isinstance(process, int):
+        if process == -1: process = os.getpid()
+        process = psutil.Process(process)
+
+    if not meminfo_attr:
+        # Use the psutil 2.0 attr if the older version isn't passed in.
+        meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
+
+    # Select the psutil function get the children similar to how we selected
+    # the memory_info attr (a change from excepting the AttributeError).
+    children_attr = 'children' if hasattr(process, 'children') else 'get_children'
+
+    # Loop over the child processes and yield their memory
+    for child in getattr(process, children_attr)(recursive=True):
+        yield getattr(child, meminfo_attr)()[0] / _TWO_20
+
+
 def _get_memory(pid, timestamps=False, include_children=False):
 
     # .. only for current process and only on unix..
@@ -88,13 +116,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
             meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
             mem = getattr(process, meminfo_attr)()[0] / _TWO_20
             if include_children:
-                try:
-                    for p in process.get_children(recursive=True):
-                        mem += getattr(p, meminfo_attr)()[0] / _TWO_20
-                except AttributeError:
-                    # fix for newer psutil
-                    for p in process.children(recursive=True):
-                        mem += getattr(p, meminfo_attr)()[0] / _TWO_20
+                mem +=  sum(_get_child_memory(process, meminfo_attr))
             if timestamps:
                 return (mem, time.time())
             else:
@@ -106,9 +128,11 @@ def _get_memory(pid, timestamps=False, include_children=False):
     # .. scary stuff ..
     if os.name == 'posix':
         if include_children:
-            raise NotImplementedError('The psutil module is required when to'
-                                      ' monitor memory usage of children'
-                                      ' processes')
+            raise NotImplementedError((
+                ""The psutil module is required to monitor the ""
+                ""memory usage of child processes.""
+            ))
+
         warnings.warn(""psutil module not found. memory_profiler will be slow"")
         # ..
         # .. memory usage in MiB ..
","@@ -73,6 +73,34 @@ class MemitResult(object):
         p.text(u'<MemitResult : '+msg+u'>')
 
 
+def _get_child_memory(process, meminfo_attr=None):
+    """"""
+    Returns a generator that yields memory for all child processes.
+    """"""
+    if not has_psutil:
+        raise NotImplementedError((
+            ""The psutil module is required to monitor the ""
+            ""memory usage of child processes.""
+        ))
+
+    # Convert a pid to a process
+    if isinstance(process, int):
+        if process == -1: process = os.getpid()
+        process = psutil.Process(process)
+
+    if not meminfo_attr:
+        # Use the psutil 2.0 attr if the older version isn't passed in.
+        meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
+
+    # Select the psutil function get the children similar to how we selected
+    # the memory_info attr (a change from excepting the AttributeError).
+    children_attr = 'children' if hasattr(process, 'children') else 'get_children'
+
+    # Loop over the child processes and yield their memory
+    for child in getattr(process, children_attr)(recursive=True):
+        yield getattr(child, meminfo_attr)()[0] / _TWO_20
+
+
 def _get_memory(pid, timestamps=False, include_children=False):
 
     # .. only for current process and only on unix..
@@ -88,13 +116,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
             meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
             mem = getattr(process, meminfo_attr)()[0] / _TWO_20
             if include_children:
-                try:
-                    for p in process.get_children(recursive=True):
-                        mem += getattr(p, meminfo_attr)()[0] / _TWO_20
-                except AttributeError:
-                    # fix for newer psutil
-                    for p in process.children(recursive=True):
-                        mem += getattr(p, meminfo_attr)()[0] / _TWO_20
+                mem +=  sum(_get_child_memory(process, meminfo_attr))
             if timestamps:
                 return (mem, time.time())
             else:
@@ -106,9 +128,11 @@ def _get_memory(pid, timestamps=False, include_children=False):
     # .. scary stuff ..
     if os.name == 'posix':
         if include_children:
-            raise NotImplementedError('The psutil module is required when to'
-                                      ' monitor memory usage of children'
-                                      ' processes')
+            raise NotImplementedError((
+                ""The psutil module is required to monitor the ""
+                ""memory usage of child processes.""
+            ))
+
         warnings.warn(""psutil module not found. memory_profiler will be slow"")
         # ..
         # .. memory usage in MiB ..
",True,memory_profiler.py,True
"@@ -0,0 +1,184 @@
+#!/usr/bin/env python3
+""""""
+Multiprocessing version of memory profiling of Python programs.
+""""""
+
+import os
+import time
+import glob
+import argparse
+import subprocess
+import memory_profiler as mp
+
+
+# Command Descriptions and Constants
+DESCRIPTION = ""Multiprocessing memory profiling over time.""
+EPILOG      = ""If there are any bugs or concerns, submit an issue on Github""
+VERSION     = ""mpmprof v{}"".format(mp.__version__)
+FILETIME    = ""%Y%m%d%H%M%S""
+BLANKS      = set(' \t')
+
+
+def run_action(args):
+    """"""
+    Run the given program and profile its memory usage.
+    """"""
+
+    # Determine where to write the output to
+    if args.output is None:
+        args.output = ""mprofile_{}.dat"".format(
+            time.strftime(FILETIME, time.localtime())
+        )
+
+    # Determine if the command is a Python command
+    if args.command[0].endswith('.py') and not args.nopython:
+        args.python = True
+
+    # Run the executable with the extra features
+    if args.python:
+        print(""running as a Python program ..."")
+        if not args.command[0].startswith('python'):
+            args.command.insert(0, 'python')
+
+    # Inform the user we're sampling
+    print(""mpmprof: Sampling memory every {} seconds"".format(args.interval))
+
+    # Put the command back together from the argument parsing
+    command = "" "".join([
+        c if BLANKS.isdisjoint(c) else ""'{}'"".format(c) for c in args.command
+    ])
+
+    # Open a subprocess to the given command
+    proc = subprocess.Popen(args.command)
+
+    # This is where a call to mp.memory_usage should go.
+    # Instead we're adding the custom code for sampling spawned memory
+    with open(args.output, ""a"") as f:
+
+        # Write the command to the data file
+        f.write(""CMDLINE {}\n"".format(command))
+
+        # Continue sampling until the subprocess is over, counting lines
+        lines = 0
+        while True:
+            # Determine if the subprocess is still running
+            if proc.poll() is not None: break
+
+            # Collect memory usage of master program and write to profile
+            mem = mp._get_memory(proc.pid)
+            f.write(""MEM {0:.6f} {1:.4f}\n"".format(mem, time.time()))
+            lines += 1
+
+            # Collect memory usage of spawned children and write to profile
+            for idx, mem in enumerate(mp._get_child_memory(proc.pid)):
+                f.write(""CHLD{0} {1:.6f} {2:.4f}\n"".format(idx, mem, time.time()))
+                lines += 1
+
+            # Flush every 50 lines
+            if lines > 50:
+                lines = 0
+                f.flush()
+
+            # Sleep for the given interval
+            time.sleep(args.interval)
+
+    return ""memory profile written to {}"".format(args.output)
+
+
+def plot_action(args):
+    """"""
+    Use matplotlib to draw the memory usage of a mprofile .dat file.
+    """"""
+    raise NotImplementedError(""Not implemented yet."")
+
+
+if __name__ == '__main__':
+    # Create the argument parser and subparsers for each command
+    parser = argparse.ArgumentParser(description=DESCRIPTION, epilog=EPILOG)
+    subparsers = parser.add_subparsers(title='commands')
+
+    # Add the version command
+    parser.add_argument('-v', '--version', action='version', version=VERSION)
+
+    # Commands defined in an dictionary for easy adding
+    commands = (
+        # Run command definition
+        {
+            'name': 'run',
+            'action': run_action,
+            'help': 'monitor the memory usage of a command',
+            'args': {
+                '--python': {
+                    'default': False,
+                    'action': 'store_true',
+                    'help': 'activates extra features for Python programs',
+                },
+                '--nopython': {
+                    'default': False,
+                    'action': 'store_true',
+                    'help': 'disables extra features for Python programs',
+                },
+                ('-T', '--interval'): {
+                    'type': float,
+                    'default': 0.1,
+                    'metavar': 'S',
+                    'help': 'sampling period (in seconds), defaults to 0.1',
+                },
+                ('-o', '--output'): {
+                    'type': str,
+                    'default': None,
+                    'metavar': 'PATH',
+                    'help': 'location to write the memory profiler output to',
+                },
+                'command': {
+                    'nargs': argparse.REMAINDER,
+                    'help': 'command to run and profile memory usage',
+                }
+            }
+        },
+
+        # Plot command definition
+        {
+            'name': 'plot',
+            'action': plot_action,
+            'help': 'plot the memory usage of a mprofile data file',
+            'args': {
+                ('-t', '--title'): {
+                    'type': str,
+                    'default': None,
+                    'metavar': 'S',
+                    'help': 'set the title of the figure',
+                },
+                ('-o', '--output'): {
+                    'type': str,
+                    'default': None,
+                    'metavar': 'PATH',
+                    'help': 'write the figure as a png to disk'
+                },
+                'profile': {
+                    'nargs': '*',
+                    'help': 'profile to plot, omit to use the latest',
+                }
+            }
+        }
+    )
+
+    # Add the commands and their arguments.
+    for cmd in commands:
+        # Create the command subparser and add the action
+        cmd_parser = subparsers.add_parser(cmd['name'], help=cmd['help'])
+        cmd_parser.set_defaults(func=cmd['action'])
+
+        # Add the arguments
+        for args, kwargs in cmd['args'].items():
+            if isinstance(args, str):
+                args = (args,)
+            cmd_parser.add_argument(*args, **kwargs)
+
+    # Handle input from the command line
+    args = parser.parse_args()            # Parse the arguments
+    # try:
+    msg = args.func(args)             # Call the default function
+    parser.exit(0, msg+""\n"")          # Exit cleanly with message
+    # except Exception as e:
+    #     parser.error(str(e))              # Exit with error
","@@ -0,0 +1,184 @@
+#!/usr/bin/env python3
+""""""
+Multiprocessing version of memory profiling of Python programs.
+""""""
+
+import os
+import time
+import glob
+import argparse
+import subprocess
+import memory_profiler as mp
+
+
+# Command Descriptions and Constants
+DESCRIPTION = ""Multiprocessing memory profiling over time.""
+EPILOG      = ""If there are any bugs or concerns, submit an issue on Github""
+VERSION     = ""mpmprof v{}"".format(mp.__version__)
+FILETIME    = ""%Y%m%d%H%M%S""
+BLANKS      = set(' \t')
+
+
+def run_action(args):
+    """"""
+    Run the given program and profile its memory usage.
+    """"""
+
+    # Determine where to write the output to
+    if args.output is None:
+        args.output = ""mprofile_{}.dat"".format(
+            time.strftime(FILETIME, time.localtime())
+        )
+
+    # Determine if the command is a Python command
+    if args.command[0].endswith('.py') and not args.nopython:
+        args.python = True
+
+    # Run the executable with the extra features
+    if args.python:
+        print(""running as a Python program ..."")
+        if not args.command[0].startswith('python'):
+            args.command.insert(0, 'python')
+
+    # Inform the user we're sampling
+    print(""mpmprof: Sampling memory every {} seconds"".format(args.interval))
+
+    # Put the command back together from the argument parsing
+    command = "" "".join([
+        c if BLANKS.isdisjoint(c) else ""'{}'"".format(c) for c in args.command
+    ])
+
+    # Open a subprocess to the given command
+    proc = subprocess.Popen(args.command)
+
+    # This is where a call to mp.memory_usage should go.
+    # Instead we're adding the custom code for sampling spawned memory
+    with open(args.output, ""a"") as f:
+
+        # Write the command to the data file
+        f.write(""CMDLINE {}\n"".format(command))
+
+        # Continue sampling until the subprocess is over, counting lines
+        lines = 0
+        while True:
+            # Determine if the subprocess is still running
+            if proc.poll() is not None: break
+
+            # Collect memory usage of master program and write to profile
+            mem = mp._get_memory(proc.pid)
+            f.write(""MEM {0:.6f} {1:.4f}\n"".format(mem, time.time()))
+            lines += 1
+
+            # Collect memory usage of spawned children and write to profile
+            for idx, mem in enumerate(mp._get_child_memory(proc.pid)):
+                f.write(""CHLD{0} {1:.6f} {2:.4f}\n"".format(idx, mem, time.time()))
+                lines += 1
+
+            # Flush every 50 lines
+            if lines > 50:
+                lines = 0
+                f.flush()
+
+            # Sleep for the given interval
+            time.sleep(args.interval)
+
+    return ""memory profile written to {}"".format(args.output)
+
+
+def plot_action(args):
+    """"""
+    Use matplotlib to draw the memory usage of a mprofile .dat file.
+    """"""
+    raise NotImplementedError(""Not implemented yet."")
+
+
+if __name__ == '__main__':
+    # Create the argument parser and subparsers for each command
+    parser = argparse.ArgumentParser(description=DESCRIPTION, epilog=EPILOG)
+    subparsers = parser.add_subparsers(title='commands')
+
+    # Add the version command
+    parser.add_argument('-v', '--version', action='version', version=VERSION)
+
+    # Commands defined in an dictionary for easy adding
+    commands = (
+        # Run command definition
+        {
+            'name': 'run',
+            'action': run_action,
+            'help': 'monitor the memory usage of a command',
+            'args': {
+                '--python': {
+                    'default': False,
+                    'action': 'store_true',
+                    'help': 'activates extra features for Python programs',
+                },
+                '--nopython': {
+                    'default': False,
+                    'action': 'store_true',
+                    'help': 'disables extra features for Python programs',
+                },
+                ('-T', '--interval'): {
+                    'type': float,
+                    'default': 0.1,
+                    'metavar': 'S',
+                    'help': 'sampling period (in seconds), defaults to 0.1',
+                },
+                ('-o', '--output'): {
+                    'type': str,
+                    'default': None,
+                    'metavar': 'PATH',
+                    'help': 'location to write the memory profiler output to',
+                },
+                'command': {
+                    'nargs': argparse.REMAINDER,
+                    'help': 'command to run and profile memory usage',
+                }
+            }
+        },
+
+        # Plot command definition
+        {
+            'name': 'plot',
+            'action': plot_action,
+            'help': 'plot the memory usage of a mprofile data file',
+            'args': {
+                ('-t', '--title'): {
+                    'type': str,
+                    'default': None,
+                    'metavar': 'S',
+                    'help': 'set the title of the figure',
+                },
+                ('-o', '--output'): {
+                    'type': str,
+                    'default': None,
+                    'metavar': 'PATH',
+                    'help': 'write the figure as a png to disk'
+                },
+                'profile': {
+                    'nargs': '*',
+                    'help': 'profile to plot, omit to use the latest',
+                }
+            }
+        }
+    )
+
+    # Add the commands and their arguments.
+    for cmd in commands:
+        # Create the command subparser and add the action
+        cmd_parser = subparsers.add_parser(cmd['name'], help=cmd['help'])
+        cmd_parser.set_defaults(func=cmd['action'])
+
+        # Add the arguments
+        for args, kwargs in cmd['args'].items():
+            if isinstance(args, str):
+                args = (args,)
+            cmd_parser.add_argument(*args, **kwargs)
+
+    # Handle input from the command line
+    args = parser.parse_args()            # Parse the arguments
+    # try:
+    msg = args.func(args)             # Call the default function
+    parser.exit(0, msg+""\n"")          # Exit cleanly with message
+    # except Exception as e:
+    #     parser.error(str(e))              # Exit with error
",True,mpmprof,False
"@@ -4,12 +4,22 @@ Multiprocessing version of memory profiling of Python programs.
 """"""
 
 import os
+import re
 import time
 import glob
 import argparse
 import subprocess
 import memory_profiler as mp
 
+from collections import defaultdict
+
+try:
+    import numpy as np
+    import matplotlib.pyplot as plt
+except ImportError:
+    plt = None
+    np  = None
+
 
 # Command Descriptions and Constants
 DESCRIPTION = ""Multiprocessing memory profiling over time.""
@@ -82,6 +92,7 @@ def run_action(args):
             # Sleep for the given interval
             time.sleep(args.interval)
 
+    # Return the results of the run action
     return ""memory profile written to {}"".format(args.output)
 
 
@@ -89,7 +100,122 @@ def plot_action(args):
     """"""
     Use matplotlib to draw the memory usage of a mprofile .dat file.
     """"""
-    raise NotImplementedError(""Not implemented yet."")
+    if plt is None:
+        raise ImportError(
+            ""matplotlib is needed for plotting.""
+        )
+
+    def read_mprofile_file(path):
+        """"""
+        Reads the specialized version of the mprofile for multiprocessing
+        """"""
+        # Regular expression line parsers for parsing data
+        cmdre = re.compile(r""^CMDLINE\s+(.+)$"")
+        memre = re.compile(r""^MEM\s+([\d\.e]+)\s+([\d\.e]+)$"")
+        cldre = re.compile(r""^CHLD(\d+)\s+([\d\.e]+)\s+([\d\.e]+)$"")
+
+        # Data structure returned is a series of names (mem, ts) tuples.
+        series  = defaultdict(list)
+        command = None
+
+        with open(path, 'r') as f:
+            for line in f:
+
+                # Match children memory usage lines
+                match = cldre.match(line)
+                if match:
+                    idx, mem, ts = match.groups()
+                    series[""child "" + idx].append((float(mem), float(ts)))
+                    continue
+
+                # Match main process memory usage lines
+                match = memre.match(line)
+                if match:
+                    series['main'].append(tuple(map(float, match.groups())))
+                    continue
+
+                # Match command line(s)
+                # NOTE: mprofile files are openeded for appending, could be multiple
+                match = cmdre.match(line)
+                if match:
+                    command = match.groups()[0]
+
+        return command, series
+
+
+    def plot_mprofile_file(path, title=None):
+        """"""
+        Plots an mprofile file that contains specialized child process data.
+        """"""
+        # Parse the mprofile file to get the data
+        command, series = read_mprofile_file(path)
+        title = title or command
+
+        # Create and configure the figure
+        fig = plt.figure(figsize=(14, 6), dpi=90)
+        axe = fig.add_axes([0.1, 0.1, 0.6, 0.75])
+        axe.set_xlabel(""time (in seconds)"")
+        axe.set_ylabel(""memory used (in MiB)"")
+        axe.set_title(title)
+
+        # Find the start timestamp for the process and track the maximal memory point
+        # This currently assumes that the series were written in order
+        start  = series['main'][0][1]
+        mpoint = (0, 0)
+
+        # Plot all of the series, the main process and the child.
+        for proc, data in series.items():
+            # Create the numpy arrays from the series data
+            ts  = np.asarray([item[1] for item in data]) - start
+            mem = np.asarray([item[0] for item in data])
+
+            # Plot the line to the figure
+            plt.plot(ts, mem, ""+-"", label=proc)
+
+            # Detect the maximal memory point
+            max_mem = mem.max()
+            if max_mem > mpoint[1]:
+                mpoint = (mem.argmax(), max_mem)
+
+        # Add the marker lines for the maximal memory usage
+        plt.hlines(mpoint[1], plt.xlim()[0]+0.001, plt.xlim()[1] - 0.001, 'r', '--')
+        plt.vlines(ts[mpoint[0]], plt.ylim()[0]+0.001, plt.ylim()[1] - 0.001, 'r', '--')
+
+        # Add the legend
+        legend = axe.legend(loc='center left', bbox_to_anchor=(1, 0.5))
+        legend.get_frame().set_alpha(0.5)
+        axe.grid()
+
+    # Get the latest profile if no profile files were passed in.
+    if not args.profile:
+
+        # Glob profiles of our format and sort them.
+        profiles = glob.glob(""mprofile_??????????????.dat"")
+        profiles.sort()
+
+        if not profiles:
+            raise ValueError((
+                ""No input file found.\nThis program looks for mprofile_*.dat ""
+                ""files generated by the `mpmprof run` command.""
+            ))
+
+        # Assign the latest profile to visualize
+        args.profile = profiles[0:1]
+
+    # Filter out any files that do not exist
+    args.profile = list(filter(os.path.exists, args.profile))
+    if not args.profile:
+        raise ValueError(""No input files found!"")
+
+    # For each passed in file, create a figure from the mprofile.
+    for path in args.profile:
+        axe = plot_mprofile_file(path, args.title)
+        if args.output:
+            plt.savefig(args.output)
+        else:
+            plt.show()
+
+    return ""{} memory profiles plotted."".format(len(args.profile))
 
 
 if __name__ == '__main__':
","@@ -4,12 +4,22 @@ Multiprocessing version of memory profiling of Python programs.
 """"""
 
 import os
+import re
 import time
 import glob
 import argparse
 import subprocess
 import memory_profiler as mp
 
+from collections import defaultdict
+
+try:
+    import numpy as np
+    import matplotlib.pyplot as plt
+except ImportError:
+    plt = None
+    np  = None
+
 
 # Command Descriptions and Constants
 DESCRIPTION = ""Multiprocessing memory profiling over time.""
@@ -82,6 +92,7 @@ def run_action(args):
             # Sleep for the given interval
             time.sleep(args.interval)
 
+    # Return the results of the run action
     return ""memory profile written to {}"".format(args.output)
 
 
@@ -89,7 +100,122 @@ def plot_action(args):
     """"""
     Use matplotlib to draw the memory usage of a mprofile .dat file.
     """"""
-    raise NotImplementedError(""Not implemented yet."")
+    if plt is None:
+        raise ImportError(
+            ""matplotlib is needed for plotting.""
+        )
+
+    def read_mprofile_file(path):
+        """"""
+        Reads the specialized version of the mprofile for multiprocessing
+        """"""
+        # Regular expression line parsers for parsing data
+        cmdre = re.compile(r""^CMDLINE\s+(.+)$"")
+        memre = re.compile(r""^MEM\s+([\d\.e]+)\s+([\d\.e]+)$"")
+        cldre = re.compile(r""^CHLD(\d+)\s+([\d\.e]+)\s+([\d\.e]+)$"")
+
+        # Data structure returned is a series of names (mem, ts) tuples.
+        series  = defaultdict(list)
+        command = None
+
+        with open(path, 'r') as f:
+            for line in f:
+
+                # Match children memory usage lines
+                match = cldre.match(line)
+                if match:
+                    idx, mem, ts = match.groups()
+                    series[""child "" + idx].append((float(mem), float(ts)))
+                    continue
+
+                # Match main process memory usage lines
+                match = memre.match(line)
+                if match:
+                    series['main'].append(tuple(map(float, match.groups())))
+                    continue
+
+                # Match command line(s)
+                # NOTE: mprofile files are openeded for appending, could be multiple
+                match = cmdre.match(line)
+                if match:
+                    command = match.groups()[0]
+
+        return command, series
+
+
+    def plot_mprofile_file(path, title=None):
+        """"""
+        Plots an mprofile file that contains specialized child process data.
+        """"""
+        # Parse the mprofile file to get the data
+        command, series = read_mprofile_file(path)
+        title = title or command
+
+        # Create and configure the figure
+        fig = plt.figure(figsize=(14, 6), dpi=90)
+        axe = fig.add_axes([0.1, 0.1, 0.6, 0.75])
+        axe.set_xlabel(""time (in seconds)"")
+        axe.set_ylabel(""memory used (in MiB)"")
+        axe.set_title(title)
+
+        # Find the start timestamp for the process and track the maximal memory point
+        # This currently assumes that the series were written in order
+        start  = series['main'][0][1]
+        mpoint = (0, 0)
+
+        # Plot all of the series, the main process and the child.
+        for proc, data in series.items():
+            # Create the numpy arrays from the series data
+            ts  = np.asarray([item[1] for item in data]) - start
+            mem = np.asarray([item[0] for item in data])
+
+            # Plot the line to the figure
+            plt.plot(ts, mem, ""+-"", label=proc)
+
+            # Detect the maximal memory point
+            max_mem = mem.max()
+            if max_mem > mpoint[1]:
+                mpoint = (mem.argmax(), max_mem)
+
+        # Add the marker lines for the maximal memory usage
+        plt.hlines(mpoint[1], plt.xlim()[0]+0.001, plt.xlim()[1] - 0.001, 'r', '--')
+        plt.vlines(ts[mpoint[0]], plt.ylim()[0]+0.001, plt.ylim()[1] - 0.001, 'r', '--')
+
+        # Add the legend
+        legend = axe.legend(loc='center left', bbox_to_anchor=(1, 0.5))
+        legend.get_frame().set_alpha(0.5)
+        axe.grid()
+
+    # Get the latest profile if no profile files were passed in.
+    if not args.profile:
+
+        # Glob profiles of our format and sort them.
+        profiles = glob.glob(""mprofile_??????????????.dat"")
+        profiles.sort()
+
+        if not profiles:
+            raise ValueError((
+                ""No input file found.\nThis program looks for mprofile_*.dat ""
+                ""files generated by the `mpmprof run` command.""
+            ))
+
+        # Assign the latest profile to visualize
+        args.profile = profiles[0:1]
+
+    # Filter out any files that do not exist
+    args.profile = list(filter(os.path.exists, args.profile))
+    if not args.profile:
+        raise ValueError(""No input files found!"")
+
+    # For each passed in file, create a figure from the mprofile.
+    for path in args.profile:
+        axe = plot_mprofile_file(path, args.title)
+        if args.output:
+            plt.savefig(args.output)
+        else:
+            plt.show()
+
+    return ""{} memory profiles plotted."".format(len(args.profile))
 
 
 if __name__ == '__main__':
",True,mpmprof,False
"@@ -262,7 +262,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     ret : return value of the profiled function
         Only returned if retval is set to True
     """"""
-    if not _backend_chosen:
+    if _backend is None:
         choose_backend()
     if stream is not None:
         timestamps = True
@@ -952,9 +952,8 @@ class MemoryProfilerMagics(Magics):
             if mem_usage:
                 print(result)
             else:
-                print(
-                    'ERROR: could not read memory usage, try with a lower interval '
-                    'or more iterations')
+                print('ERROR: could not read memory usage, try with a '
+                      'lower interval or more iterations')
 
         if return_result:
             return result
@@ -1050,8 +1049,6 @@ def choose_backend(new_backend=None):
     if _backend != new_backend and new_backend is not None:
         print('{0} can not be used, {1} used instead'.format(new_backend,
                                                            _backend))
-    global _backend_chosen
-    _backend_chosen = True
 
 
 # Insert in the built-ins to have profile
","@@ -262,7 +262,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     ret : return value of the profiled function
         Only returned if retval is set to True
     """"""
-    if not _backend_chosen:
+    if _backend is None:
         choose_backend()
     if stream is not None:
         timestamps = True
@@ -952,9 +952,8 @@ class MemoryProfilerMagics(Magics):
             if mem_usage:
                 print(result)
             else:
-                print(
-                    'ERROR: could not read memory usage, try with a lower interval '
-                    'or more iterations')
+                print('ERROR: could not read memory usage, try with a '
+                      'lower interval or more iterations')
 
         if return_result:
             return result
@@ -1050,8 +1049,6 @@ def choose_backend(new_backend=None):
     if _backend != new_backend and new_backend is not None:
         print('{0} can not be used, {1} used instead'.format(new_backend,
                                                            _backend))
-    global _backend_chosen
-    _backend_chosen = True
 
 
 # Insert in the built-ins to have profile
",True,memory_profiler.py,True
"@@ -187,7 +187,6 @@ class MemTimer(Process):
         self.include_children = kw.pop(""include_children"", False)
 
         # get baseline memory usage
-        # TODO: add filename
         self.mem_usage = [
             _get_memory(self.monitor_pid, timestamps=self.timestamps,
                         include_children=self.include_children)]
@@ -197,7 +196,6 @@ class MemTimer(Process):
         self.pipe.send(0)  # we're ready
         stop = False
         while True:
-            # TODO: add filename
             cur_mem = _get_memory(self.monitor_pid, timestamps=self.timestamps,
                                   include_children=self.include_children)
             if not self.max_usage:
@@ -316,7 +314,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         line_count = 0
         while True:
             if not max_usage:
-                # TODO: add filename
                 mem_usage = _get_memory(proc.pid, timestamps=timestamps,
                                         include_children=include_children)
                 if stream is not None:
@@ -324,7 +321,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 else:
                     ret.append(mem_usage)
             else:
-                # TODO: add filename
                 ret = max(ret,
                           _get_memory(proc.pid,
                                       include_children=include_children))
@@ -349,7 +345,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         while counter < max_iter:
             counter += 1
             if not max_usage:
-                # TODO: add filename
                 mem_usage = _get_memory(proc, timestamps=timestamps,
                                         include_children=include_children)
                 if stream is not None:
@@ -357,7 +352,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 else:
                     ret.append(mem_usage)
             else:
-                # TODO: add filename
                 ret = max([ret,
                            _get_memory(proc, include_children=include_children)
                            ])
","@@ -187,7 +187,6 @@ class MemTimer(Process):
         self.include_children = kw.pop(""include_children"", False)
 
         # get baseline memory usage
-        # TODO: add filename
         self.mem_usage = [
             _get_memory(self.monitor_pid, timestamps=self.timestamps,
                         include_children=self.include_children)]
@@ -197,7 +196,6 @@ class MemTimer(Process):
         self.pipe.send(0)  # we're ready
         stop = False
         while True:
-            # TODO: add filename
             cur_mem = _get_memory(self.monitor_pid, timestamps=self.timestamps,
                                   include_children=self.include_children)
             if not self.max_usage:
@@ -316,7 +314,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         line_count = 0
         while True:
             if not max_usage:
-                # TODO: add filename
                 mem_usage = _get_memory(proc.pid, timestamps=timestamps,
                                         include_children=include_children)
                 if stream is not None:
@@ -324,7 +321,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 else:
                     ret.append(mem_usage)
             else:
-                # TODO: add filename
                 ret = max(ret,
                           _get_memory(proc.pid,
                                       include_children=include_children))
@@ -349,7 +345,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         while counter < max_iter:
             counter += 1
             if not max_usage:
-                # TODO: add filename
                 mem_usage = _get_memory(proc, timestamps=timestamps,
                                         include_children=include_children)
                 if stream is not None:
@@ -357,7 +352,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 else:
                     ret.append(mem_usage)
             else:
-                # TODO: add filename
                 ret = max([ret,
                            _get_memory(proc, include_children=include_children)
                            ])
",True,memory_profiler.py,True
"@@ -17,7 +17,6 @@ import inspect
 import subprocess
 import logging
 
-from collections import OrderedDict
 
 # TODO: provide alternative when multiprocessing is not available
 try:
@@ -1012,26 +1011,18 @@ def choose_backend(new_backend=None):
     setup one of the allowable backends
     """"""
 
-    backends = OrderedDict([
+    backends = [
         ('psutil', has_psutil),
         ('posix', os.name == 'posix'),
         ('tracemalloc', has_tracemalloc),
         ('no_backend', True)
-    ])
+    ]
+    backends_indices = {b[0]: i for i, b in enumerate(backends)}
 
-    def move_to_start(d, key):
-        """"""
-        Emulation of OrderedDict.move_to_end(last=False) for old versions of Python
-        """"""
-        items = [(key, d[key])]
-        for _key, _value in d.items():
-            if _key != key:
-                items.append((_key, _value))
-        return OrderedDict(items)
     if new_backend is not None:
-        backends = move_to_start(backends, new_backend)
+        backends.insert(0, backends.pop(backends_indices[new_backend]))
 
-    for n_backend, is_available in backends.items():
+    for n_backend, is_available in backends:
         if is_available:
             global _backend
             _backend = n_backend
","@@ -17,7 +17,6 @@ import inspect
 import subprocess
 import logging
 
-from collections import OrderedDict
 
 # TODO: provide alternative when multiprocessing is not available
 try:
@@ -1012,26 +1011,18 @@ def choose_backend(new_backend=None):
     setup one of the allowable backends
     """"""
 
-    backends = OrderedDict([
+    backends = [
         ('psutil', has_psutil),
         ('posix', os.name == 'posix'),
         ('tracemalloc', has_tracemalloc),
         ('no_backend', True)
-    ])
+    ]
+    backends_indices = {b[0]: i for i, b in enumerate(backends)}
 
-    def move_to_start(d, key):
-        """"""
-        Emulation of OrderedDict.move_to_end(last=False) for old versions of Python
-        """"""
-        items = [(key, d[key])]
-        for _key, _value in d.items():
-            if _key != key:
-                items.append((_key, _value))
-        return OrderedDict(items)
     if new_backend is not None:
-        backends = move_to_start(backends, new_backend)
+        backends.insert(0, backends.pop(backends_indices[new_backend]))
 
-    for n_backend, is_available in backends.items():
+    for n_backend, is_available in backends:
         if is_available:
             global _backend
             _backend = n_backend
",True,memory_profiler.py,True
"@@ -60,8 +60,6 @@ try:
 except ImportError:
     has_tracemalloc = False
 
-_backend = None
-
 
 class MemitResult(object):
     """"""memit magic run details.
@@ -88,13 +86,13 @@ class MemitResult(object):
         p.text(u'<MemitResult : ' + msg + u'>')
 
 
-def _get_memory(pid, timestamps=False, include_children=False, filename=None):
-    # .. only for current process and only on unix..
+def _get_memory(pid, backend, timestamps=False, include_children=False, filename=None):
+    # .. low function to get memory consumption ..
     if pid == -1:
         pid = os.getpid()
 
     def tracemalloc_tool():
-        # .. cross-platform but but requires Python 3.4 or higher
+        # .. cross-platform but but requires Python 3.4 or higher ..
         stat = next(filter(lambda item: str(item).startswith(filename),
                            tracemalloc.take_snapshot().statistics('filename')))
         mem = stat.size / _TWO_20
@@ -156,7 +154,7 @@ def _get_memory(pid, timestamps=False, include_children=False, filename=None):
             else:
                 return -1
 
-    if _backend == 'tracemalloc' and \
+    if backend == 'tracemalloc' and \
             (filename is None or filename == '<unknown>'):
         raise RuntimeError(
             'There is no access to source file of the profiled function'
@@ -165,7 +163,7 @@ def _get_memory(pid, timestamps=False, include_children=False, filename=None):
     tools = {'tracemalloc': tracemalloc_tool,
              'psutil': ps_util_tool,
              'posix': posix_tool}
-    return tools[_backend]()
+    return tools[backend]()
 
 
 class MemTimer(Process):
@@ -173,12 +171,13 @@ class MemTimer(Process):
     Fetch memory consumption from over a time interval
     """"""
 
-    def __init__(self, monitor_pid, interval, pipe, max_usage=False,
+    def __init__(self, monitor_pid, interval, pipe, backend, max_usage=False,
                  *args, **kw):
         self.monitor_pid = monitor_pid
         self.interval = interval
         self.pipe = pipe
         self.cont = True
+        self.backend = backend
         self.max_usage = max_usage
         self.n_measurements = 1
 
@@ -187,7 +186,7 @@ class MemTimer(Process):
 
         # get baseline memory usage
         self.mem_usage = [
-            _get_memory(self.monitor_pid, timestamps=self.timestamps,
+            _get_memory(self.monitor_pid, self.backend, timestamps=self.timestamps,
                         include_children=self.include_children)]
         super(MemTimer, self).__init__(*args, **kw)
 
@@ -195,8 +194,9 @@ class MemTimer(Process):
         self.pipe.send(0)  # we're ready
         stop = False
         while True:
-            cur_mem = _get_memory(self.monitor_pid, timestamps=self.timestamps,
-                                  include_children=self.include_children)
+            cur_mem = _get_memory(
+                self.monitor_pid, self.backend, timestamps=self.timestamps,
+                include_children=self.include_children,)
             if not self.max_usage:
                 self.mem_usage.append(cur_mem)
             else:
@@ -213,7 +213,7 @@ class MemTimer(Process):
 
 def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                  include_children=False, max_usage=False, retval=False,
-                 stream=None):
+                 stream=None, backend=None):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -259,8 +259,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     ret : return value of the profiled function
         Only returned if retval is set to True
     """"""
-    if _backend is None:
-        choose_backend()
+    backend = choose_backend(backend)
     if stream is not None:
         timestamps = True
 
@@ -292,7 +291,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
         while True:
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
-            p = MemTimer(os.getpid(), interval, child_conn,
+            p = MemTimer(os.getpid(), interval, child_conn, backend,
                          timestamps=timestamps,
                          max_usage=max_usage,
                          include_children=include_children)
@@ -313,16 +312,17 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         line_count = 0
         while True:
             if not max_usage:
-                mem_usage = _get_memory(proc.pid, timestamps=timestamps,
-                                        include_children=include_children)
+                mem_usage = _get_memory(
+                    proc.pid, backend, timestamps=timestamps,
+                    include_children=include_children)
                 if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
                 else:
                     ret.append(mem_usage)
             else:
                 ret = max(ret,
-                          _get_memory(proc.pid,
-                                      include_children=include_children))
+                          _get_memory(
+                              proc.pid, backend, include_children=include_children))
             time.sleep(interval)
             line_count += 1
             # flush every 50 lines. Make 'tail -f' usable on profile file
@@ -344,15 +344,16 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         while counter < max_iter:
             counter += 1
             if not max_usage:
-                mem_usage = _get_memory(proc, timestamps=timestamps,
-                                        include_children=include_children)
+                mem_usage = _get_memory(
+                    proc, backend, timestamps=timestamps,
+                    include_children=include_children)
                 if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
                 else:
                     ret.append(mem_usage)
             else:
                 ret = max([ret,
-                           _get_memory(proc, include_children=include_children)
+                           _get_memory(proc, backend, include_children=include_children)
                            ])
 
             time.sleep(interval)
@@ -390,17 +391,18 @@ def _find_script(script_name):
 class _TimeStamperCM(object):
     """"""Time-stamping context manager.""""""
 
-    def __init__(self, timestamps, filename):
-        self._timestamps = timestamps
-        self._filename = filename
+    def __init__(self, timestamps, filename, backend):
+        self.timestamps = timestamps
+        self.filename = filename
+        self.backend = backend
 
     def __enter__(self):
-        self._timestamps.append(
-            _get_memory(os.getpid(), timestamps=True, filename=self._filename))
+        self.timestamps.append(
+            _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
 
     def __exit__(self, *args):
-        self._timestamps.append(
-            _get_memory(os.getpid(), timestamps=True, filename=self._filename))
+        self.timestamps.append(
+            _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
 
 
 class TimeStamper:
@@ -408,8 +410,9 @@ class TimeStamper:
     any decorated function.
     """"""
 
-    def __init__(self):
+    def __init__(self, backend):
         self.functions = {}
+        self.backend = backend
 
     def __call__(self, func=None, precision=None):
         if func is not None:
@@ -444,7 +447,7 @@ class TimeStamper:
             filename = inspect.getsourcefile(func)
         except TypeError:
             filename = '<unknown>'
-        return _TimeStamperCM(timestamps, filename)
+        return _TimeStamperCM(timestamps, filename, self.backend)
 
     def add_function(self, func):
         if func not in self.functions:
@@ -461,13 +464,13 @@ class TimeStamper:
             except TypeError:
                 filename = '<unknown>'
             timestamps = [
-                _get_memory(os.getpid(), timestamps=True, filename=filename)]
+                _get_memory(os.getpid(), self.backend, timestamps=True, filename=filename)]
             self.functions[func].append(timestamps)
             try:
                 return func(*args, **kwds)
             finally:
                 # end time
-                timestamps.append(_get_memory(os.getpid(), timestamps=True,
+                timestamps.append(_get_memory(os.getpid(), self.backend, timestamps=True,
                                               filename=filename))
 
         return f
@@ -484,9 +487,10 @@ class TimeStamper:
 
 
 class CodeMap(dict):
-    def __init__(self, include_children):
+    def __init__(self, include_children, backend):
         self.include_children = include_children
         self._toplevel = []
+        self.backend = backend
 
     def add(self, code, toplevel_code=None):
         if code in self:
@@ -517,7 +521,7 @@ class CodeMap(dict):
             self.add(subcode, toplevel_code=toplevel_code)
 
     def trace(self, code, lineno):
-        memory = _get_memory(-1, include_children=self.include_children,
+        memory = _get_memory(-1, self.backend, include_children=self.include_children,
                              filename=code.co_filename)
         # if there is already a measurement for that line get the max
         previous_memory = self[code].get(lineno, 0)
@@ -538,10 +542,13 @@ class LineProfiler(object):
 
     def __init__(self, **kw):
         include_children = kw.get('include_children', False)
-        self.code_map = CodeMap(include_children=include_children)
+        backend = kw.get('backend', 'psutil')
+        self.code_map = CodeMap(
+            include_children=include_children, backend=backend)
         self.enable_count = 0
         self.max_mem = kw.get('max_mem', None)
         self.prevlines = []
+        self.backend = choose_backend(kw.get('backend', None))
 
     def __call__(self, func=None, precision=1):
         if func is not None:
@@ -583,14 +590,6 @@ class LineProfiler(object):
 
         return f
 
-    def run(self, cmd):
-        """""" Profile a single executable statement in the main namespace.
-        """"""
-        # TODO: can this be removed ?
-        import __main__
-        main_dict = __main__.__dict__
-        return self.runctx(cmd, main_dict, main_dict)
-
     def runctx(self, cmd, globals, locals):
         """""" Profile a single executable statement in the given namespaces.
         """"""
@@ -630,14 +629,14 @@ class LineProfiler(object):
                 self.code_map.trace(frame.f_code, self.prevlines.pop())
 
         if self._original_trace_function is not None:
-            (self._original_trace_function)(frame, event, arg)
+            self._original_trace_function(frame, event, arg)
 
         return self.trace_memory_usage
 
     def trace_max_mem(self, frame, event, arg):
         # run into PDB as soon as memory is higher than MAX_MEM
         if event in ('line', 'return') and frame.f_code in self.code_map:
-            c = _get_memory(-1, filename=frame.f_code.co_filename)
+            c = _get_memory(-1, self.backend, filename=frame.f_code.co_filename)
             if c >= self.max_mem:
                 t = ('Current memory {0:.2f} MiB exceeded the '
                      'maximum of {1:.2f} MiB\n'.format(c, self.max_mem))
@@ -986,12 +985,11 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
     """"""
     Decorator that will run the function and print a line-by-line profile
     """"""
-    choose_backend(backend)
-    if _backend == 'tracemalloc' and not tracemalloc.is_tracing():
+    if backend == 'tracemalloc' and not tracemalloc.is_tracing():
         tracemalloc.start()
     if func is not None:
         def wrapper(*args, **kwargs):
-            prof = LineProfiler()
+            prof = LineProfiler(backend=backend)
             val = prof(func)(*args, **kwargs)
             show_results(prof, stream=stream, precision=precision)
             return val
@@ -1024,7 +1022,6 @@ def choose_backend(new_backend=None):
 
     for n_backend, is_available in backends:
         if is_available:
-            global _backend
             _backend = n_backend
             break
     if _backend == 'no_backend':
@@ -1032,8 +1029,9 @@ def choose_backend(new_backend=None):
             'Tracemalloc or psutil module is required for non-unix '
             'platforms')
     if _backend != new_backend and new_backend is not None:
-        print('{0} can not be used, {1} used instead'.format(new_backend,
-                                                           _backend))
+        raise ValueError('{0} can not be used, {1} used instead'.format(
+            new_backend, _backend))
+    return _backend
 
 
 # Insert in the built-ins to have profile
@@ -1129,10 +1127,11 @@ if __name__ == '__main__':
     sys.argv[:] = args  # Remove every memory_profiler arguments
 
     script_filename = _find_script(args[0])
+    _backend = choose_backend(options.backend)
     if options.timestamp:
-        prof = TimeStamper()
+        prof = TimeStamper(_backend)
     else:
-        prof = LineProfiler(max_mem=options.max_mem)
+        prof = LineProfiler(max_mem=options.max_mem, backend=_backend)
 
     try:
         exec_with_profiler(script_filename, prof, options.backend)
","@@ -60,8 +60,6 @@ try:
 except ImportError:
     has_tracemalloc = False
 
-_backend = None
-
 
 class MemitResult(object):
     """"""memit magic run details.
@@ -88,13 +86,13 @@ class MemitResult(object):
         p.text(u'<MemitResult : ' + msg + u'>')
 
 
-def _get_memory(pid, timestamps=False, include_children=False, filename=None):
-    # .. only for current process and only on unix..
+def _get_memory(pid, backend, timestamps=False, include_children=False, filename=None):
+    # .. low function to get memory consumption ..
     if pid == -1:
         pid = os.getpid()
 
     def tracemalloc_tool():
-        # .. cross-platform but but requires Python 3.4 or higher
+        # .. cross-platform but but requires Python 3.4 or higher ..
         stat = next(filter(lambda item: str(item).startswith(filename),
                            tracemalloc.take_snapshot().statistics('filename')))
         mem = stat.size / _TWO_20
@@ -156,7 +154,7 @@ def _get_memory(pid, timestamps=False, include_children=False, filename=None):
             else:
                 return -1
 
-    if _backend == 'tracemalloc' and \
+    if backend == 'tracemalloc' and \
             (filename is None or filename == '<unknown>'):
         raise RuntimeError(
             'There is no access to source file of the profiled function'
@@ -165,7 +163,7 @@ def _get_memory(pid, timestamps=False, include_children=False, filename=None):
     tools = {'tracemalloc': tracemalloc_tool,
              'psutil': ps_util_tool,
              'posix': posix_tool}
-    return tools[_backend]()
+    return tools[backend]()
 
 
 class MemTimer(Process):
@@ -173,12 +171,13 @@ class MemTimer(Process):
     Fetch memory consumption from over a time interval
     """"""
 
-    def __init__(self, monitor_pid, interval, pipe, max_usage=False,
+    def __init__(self, monitor_pid, interval, pipe, backend, max_usage=False,
                  *args, **kw):
         self.monitor_pid = monitor_pid
         self.interval = interval
         self.pipe = pipe
         self.cont = True
+        self.backend = backend
         self.max_usage = max_usage
         self.n_measurements = 1
 
@@ -187,7 +186,7 @@ class MemTimer(Process):
 
         # get baseline memory usage
         self.mem_usage = [
-            _get_memory(self.monitor_pid, timestamps=self.timestamps,
+            _get_memory(self.monitor_pid, self.backend, timestamps=self.timestamps,
                         include_children=self.include_children)]
         super(MemTimer, self).__init__(*args, **kw)
 
@@ -195,8 +194,9 @@ class MemTimer(Process):
         self.pipe.send(0)  # we're ready
         stop = False
         while True:
-            cur_mem = _get_memory(self.monitor_pid, timestamps=self.timestamps,
-                                  include_children=self.include_children)
+            cur_mem = _get_memory(
+                self.monitor_pid, self.backend, timestamps=self.timestamps,
+                include_children=self.include_children,)
             if not self.max_usage:
                 self.mem_usage.append(cur_mem)
             else:
@@ -213,7 +213,7 @@ class MemTimer(Process):
 
 def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                  include_children=False, max_usage=False, retval=False,
-                 stream=None):
+                 stream=None, backend=None):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -259,8 +259,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     ret : return value of the profiled function
         Only returned if retval is set to True
     """"""
-    if _backend is None:
-        choose_backend()
+    backend = choose_backend(backend)
     if stream is not None:
         timestamps = True
 
@@ -292,7 +291,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
         while True:
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
-            p = MemTimer(os.getpid(), interval, child_conn,
+            p = MemTimer(os.getpid(), interval, child_conn, backend,
                          timestamps=timestamps,
                          max_usage=max_usage,
                          include_children=include_children)
@@ -313,16 +312,17 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         line_count = 0
         while True:
             if not max_usage:
-                mem_usage = _get_memory(proc.pid, timestamps=timestamps,
-                                        include_children=include_children)
+                mem_usage = _get_memory(
+                    proc.pid, backend, timestamps=timestamps,
+                    include_children=include_children)
                 if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
                 else:
                     ret.append(mem_usage)
             else:
                 ret = max(ret,
-                          _get_memory(proc.pid,
-                                      include_children=include_children))
+                          _get_memory(
+                              proc.pid, backend, include_children=include_children))
             time.sleep(interval)
             line_count += 1
             # flush every 50 lines. Make 'tail -f' usable on profile file
@@ -344,15 +344,16 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         while counter < max_iter:
             counter += 1
             if not max_usage:
-                mem_usage = _get_memory(proc, timestamps=timestamps,
-                                        include_children=include_children)
+                mem_usage = _get_memory(
+                    proc, backend, timestamps=timestamps,
+                    include_children=include_children)
                 if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
                 else:
                     ret.append(mem_usage)
             else:
                 ret = max([ret,
-                           _get_memory(proc, include_children=include_children)
+                           _get_memory(proc, backend, include_children=include_children)
                            ])
 
             time.sleep(interval)
@@ -390,17 +391,18 @@ def _find_script(script_name):
 class _TimeStamperCM(object):
     """"""Time-stamping context manager.""""""
 
-    def __init__(self, timestamps, filename):
-        self._timestamps = timestamps
-        self._filename = filename
+    def __init__(self, timestamps, filename, backend):
+        self.timestamps = timestamps
+        self.filename = filename
+        self.backend = backend
 
     def __enter__(self):
-        self._timestamps.append(
-            _get_memory(os.getpid(), timestamps=True, filename=self._filename))
+        self.timestamps.append(
+            _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
 
     def __exit__(self, *args):
-        self._timestamps.append(
-            _get_memory(os.getpid(), timestamps=True, filename=self._filename))
+        self.timestamps.append(
+            _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
 
 
 class TimeStamper:
@@ -408,8 +410,9 @@ class TimeStamper:
     any decorated function.
     """"""
 
-    def __init__(self):
+    def __init__(self, backend):
         self.functions = {}
+        self.backend = backend
 
     def __call__(self, func=None, precision=None):
         if func is not None:
@@ -444,7 +447,7 @@ class TimeStamper:
             filename = inspect.getsourcefile(func)
         except TypeError:
             filename = '<unknown>'
-        return _TimeStamperCM(timestamps, filename)
+        return _TimeStamperCM(timestamps, filename, self.backend)
 
     def add_function(self, func):
         if func not in self.functions:
@@ -461,13 +464,13 @@ class TimeStamper:
             except TypeError:
                 filename = '<unknown>'
             timestamps = [
-                _get_memory(os.getpid(), timestamps=True, filename=filename)]
+                _get_memory(os.getpid(), self.backend, timestamps=True, filename=filename)]
             self.functions[func].append(timestamps)
             try:
                 return func(*args, **kwds)
             finally:
                 # end time
-                timestamps.append(_get_memory(os.getpid(), timestamps=True,
+                timestamps.append(_get_memory(os.getpid(), self.backend, timestamps=True,
                                               filename=filename))
 
         return f
@@ -484,9 +487,10 @@ class TimeStamper:
 
 
 class CodeMap(dict):
-    def __init__(self, include_children):
+    def __init__(self, include_children, backend):
         self.include_children = include_children
         self._toplevel = []
+        self.backend = backend
 
     def add(self, code, toplevel_code=None):
         if code in self:
@@ -517,7 +521,7 @@ class CodeMap(dict):
             self.add(subcode, toplevel_code=toplevel_code)
 
     def trace(self, code, lineno):
-        memory = _get_memory(-1, include_children=self.include_children,
+        memory = _get_memory(-1, self.backend, include_children=self.include_children,
                              filename=code.co_filename)
         # if there is already a measurement for that line get the max
         previous_memory = self[code].get(lineno, 0)
@@ -538,10 +542,13 @@ class LineProfiler(object):
 
     def __init__(self, **kw):
         include_children = kw.get('include_children', False)
-        self.code_map = CodeMap(include_children=include_children)
+        backend = kw.get('backend', 'psutil')
+        self.code_map = CodeMap(
+            include_children=include_children, backend=backend)
         self.enable_count = 0
         self.max_mem = kw.get('max_mem', None)
         self.prevlines = []
+        self.backend = choose_backend(kw.get('backend', None))
 
     def __call__(self, func=None, precision=1):
         if func is not None:
@@ -583,14 +590,6 @@ class LineProfiler(object):
 
         return f
 
-    def run(self, cmd):
-        """""" Profile a single executable statement in the main namespace.
-        """"""
-        # TODO: can this be removed ?
-        import __main__
-        main_dict = __main__.__dict__
-        return self.runctx(cmd, main_dict, main_dict)
-
     def runctx(self, cmd, globals, locals):
         """""" Profile a single executable statement in the given namespaces.
         """"""
@@ -630,14 +629,14 @@ class LineProfiler(object):
                 self.code_map.trace(frame.f_code, self.prevlines.pop())
 
         if self._original_trace_function is not None:
-            (self._original_trace_function)(frame, event, arg)
+            self._original_trace_function(frame, event, arg)
 
         return self.trace_memory_usage
 
     def trace_max_mem(self, frame, event, arg):
         # run into PDB as soon as memory is higher than MAX_MEM
         if event in ('line', 'return') and frame.f_code in self.code_map:
-            c = _get_memory(-1, filename=frame.f_code.co_filename)
+            c = _get_memory(-1, self.backend, filename=frame.f_code.co_filename)
             if c >= self.max_mem:
                 t = ('Current memory {0:.2f} MiB exceeded the '
                      'maximum of {1:.2f} MiB\n'.format(c, self.max_mem))
@@ -986,12 +985,11 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
     """"""
     Decorator that will run the function and print a line-by-line profile
     """"""
-    choose_backend(backend)
-    if _backend == 'tracemalloc' and not tracemalloc.is_tracing():
+    if backend == 'tracemalloc' and not tracemalloc.is_tracing():
         tracemalloc.start()
     if func is not None:
         def wrapper(*args, **kwargs):
-            prof = LineProfiler()
+            prof = LineProfiler(backend=backend)
             val = prof(func)(*args, **kwargs)
             show_results(prof, stream=stream, precision=precision)
             return val
@@ -1024,7 +1022,6 @@ def choose_backend(new_backend=None):
 
     for n_backend, is_available in backends:
         if is_available:
-            global _backend
             _backend = n_backend
             break
     if _backend == 'no_backend':
@@ -1032,8 +1029,9 @@ def choose_backend(new_backend=None):
             'Tracemalloc or psutil module is required for non-unix '
             'platforms')
     if _backend != new_backend and new_backend is not None:
-        print('{0} can not be used, {1} used instead'.format(new_backend,
-                                                           _backend))
+        raise ValueError('{0} can not be used, {1} used instead'.format(
+            new_backend, _backend))
+    return _backend
 
 
 # Insert in the built-ins to have profile
@@ -1129,10 +1127,11 @@ if __name__ == '__main__':
     sys.argv[:] = args  # Remove every memory_profiler arguments
 
     script_filename = _find_script(args[0])
+    _backend = choose_backend(options.backend)
     if options.timestamp:
-        prof = TimeStamper()
+        prof = TimeStamper(_backend)
     else:
-        prof = LineProfiler(max_mem=options.max_mem)
+        prof = LineProfiler(max_mem=options.max_mem, backend=_backend)
 
     try:
         exec_with_profiler(script_filename, prof, options.backend)
",True,memory_profiler.py,True
"@@ -1029,7 +1029,7 @@ def choose_backend(new_backend=None):
             'Tracemalloc or psutil module is required for non-unix '
             'platforms')
     if _backend != new_backend and new_backend is not None:
-        raise ValueError('{0} can not be used, {1} used instead'.format(
+        raise warnings.warn('{0} can not be used, {1} used instead'.format(
             new_backend, _backend))
     return _backend
 
","@@ -1029,7 +1029,7 @@ def choose_backend(new_backend=None):
             'Tracemalloc or psutil module is required for non-unix '
             'platforms')
     if _backend != new_backend and new_backend is not None:
-        raise ValueError('{0} can not be used, {1} used instead'.format(
+        raise warnings.warn('{0} can not be used, {1} used instead'.format(
             new_backend, _backend))
     return _backend
 
",True,memory_profiler.py,True
"@@ -410,6 +410,7 @@ cleanup.
 
 `Sagar UDAY KUMAR <https://github.com/sagaru>`_ added Report generation feature and examples.
 
+`Dmitriy Novozhilov <https://github.com/demiurg906>`_ and `Sergei Lebedev <https://github.com/superbobry>`_ added support for `tracemalloc <https://docs.python.org/3/library/tracemalloc.html>`_.
 
 =========
  License
","@@ -410,6 +410,7 @@ cleanup.
 
 `Sagar UDAY KUMAR <https://github.com/sagaru>`_ added Report generation feature and examples.
 
+`Dmitriy Novozhilov <https://github.com/demiurg906>`_ and `Sergei Lebedev <https://github.com/superbobry>`_ added support for `tracemalloc <https://docs.python.org/3/library/tracemalloc.html>`_.
 
 =========
  License
",True,README.rst,False
"@@ -1029,7 +1029,7 @@ def choose_backend(new_backend=None):
             'Tracemalloc or psutil module is required for non-unix '
             'platforms')
     if _backend != new_backend and new_backend is not None:
-        raise warnings.warn('{0} can not be used, {1} used instead'.format(
+        warnings.warn('{0} can not be used, {1} used instead'.format(
             new_backend, _backend))
     return _backend
 
","@@ -1029,7 +1029,7 @@ def choose_backend(new_backend=None):
             'Tracemalloc or psutil module is required for non-unix '
             'platforms')
     if _backend != new_backend and new_backend is not None:
-        raise warnings.warn('{0} can not be used, {1} used instead'.format(
+        warnings.warn('{0} can not be used, {1} used instead'.format(
             new_backend, _backend))
     return _backend
 
",True,memory_profiler.py,True
"@@ -1009,6 +1009,7 @@ def choose_backend(new_backend=None):
     setup one of the allowable backends
     """"""
 
+    _backend = 'no_backend'
     backends = [
         ('psutil', has_psutil),
         ('posix', os.name == 'posix'),
","@@ -1009,6 +1009,7 @@ def choose_backend(new_backend=None):
     setup one of the allowable backends
     """"""
 
+    _backend = 'no_backend'
     backends = [
         ('psutil', has_psutil),
         ('posix', os.name == 'posix'),
",True,memory_profiler.py,True
"@@ -985,8 +985,9 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
     """"""
     Decorator that will run the function and print a line-by-line profile
     """"""
-    if backend == 'tracemalloc' and not tracemalloc.is_tracing():
-        tracemalloc.start()
+    if backend == 'tracemalloc' and has_tracemalloc:
+        if not tracemalloc.is_tracing():
+            tracemalloc.start()
     if func is not None:
         def wrapper(*args, **kwargs):
             prof = LineProfiler(backend=backend)
","@@ -985,8 +985,9 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
     """"""
     Decorator that will run the function and print a line-by-line profile
     """"""
-    if backend == 'tracemalloc' and not tracemalloc.is_tracing():
-        tracemalloc.start()
+    if backend == 'tracemalloc' and has_tracemalloc:
+        if not tracemalloc.is_tracing():
+            tracemalloc.start()
     if func is not None:
         def wrapper(*args, **kwargs):
             prof = LineProfiler(backend=backend)
",True,memory_profiler.py,True
"@@ -985,6 +985,7 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
     """"""
     Decorator that will run the function and print a line-by-line profile
     """"""
+    backend = choose_backend(backend)
     if backend == 'tracemalloc' and has_tracemalloc:
         if not tracemalloc.is_tracing():
             tracemalloc.start()
","@@ -985,6 +985,7 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
     """"""
     Decorator that will run the function and print a line-by-line profile
     """"""
+    backend = choose_backend(backend)
     if backend == 'tracemalloc' and has_tracemalloc:
         if not tracemalloc.is_tracing():
             tracemalloc.start()
",True,memory_profiler.py,True
"@@ -1012,18 +1012,18 @@ def choose_backend(new_backend=None):
     """"""
 
     _backend = 'no_backend'
-    backends = [
+    all_backends = [
         ('psutil', has_psutil),
         ('posix', os.name == 'posix'),
         ('tracemalloc', has_tracemalloc),
         ('no_backend', True)
     ]
-    backends_indices = {b[0]: i for i, b in enumerate(backends)}
+    backends_indices = {b[0]: i for i, b in enumerate(all_backends)}
 
     if new_backend is not None:
-        backends.insert(0, backends.pop(backends_indices[new_backend]))
+        all_backends.insert(0, all_backends.pop(backends_indices[new_backend]))
 
-    for n_backend, is_available in backends:
+    for n_backend, is_available in all_backends:
         if is_available:
             _backend = n_backend
             break
","@@ -1012,18 +1012,18 @@ def choose_backend(new_backend=None):
     """"""
 
     _backend = 'no_backend'
-    backends = [
+    all_backends = [
         ('psutil', has_psutil),
         ('posix', os.name == 'posix'),
         ('tracemalloc', has_tracemalloc),
         ('no_backend', True)
     ]
-    backends_indices = {b[0]: i for i, b in enumerate(backends)}
+    backends_indices = {b[0]: i for i, b in enumerate(all_backends)}
 
     if new_backend is not None:
-        backends.insert(0, backends.pop(backends_indices[new_backend]))
+        all_backends.insert(0, all_backends.pop(backends_indices[new_backend]))
 
-    for n_backend, is_available in backends:
+    for n_backend, is_available in all_backends:
         if is_available:
             _backend = n_backend
             break
",True,memory_profiler.py,True
"@@ -253,7 +253,7 @@ def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
     try:
         import pylab as pl
     except ImportError:
-        print(""matplotlib is needed for plotting."")
+        print(""matplotlib is needed for plotting and tkinter for visualisation."")
         sys.exit(1)
     height_ratio = 20.
     vsize = (pl.ylim()[1] - pl.ylim()[0]) / height_ratio
","@@ -253,7 +253,7 @@ def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
     try:
         import pylab as pl
     except ImportError:
-        print(""matplotlib is needed for plotting."")
+        print(""matplotlib is needed for plotting and tkinter for visualisation."")
         sys.exit(1)
     height_ratio = 20.
     vsize = (pl.ylim()[1] - pl.ylim()[0]) / height_ratio
",True,mprof,False
"@@ -252,8 +252,9 @@ def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
     """"""
     try:
         import pylab as pl
-    except ImportError:
-        print(""matplotlib is needed for plotting and tkinter for visualisation."")
+    except ImportError as e:
+        print(""matplotlib is needed for plotting."")
+        print(e)
         sys.exit(1)
     height_ratio = 20.
     vsize = (pl.ylim()[1] - pl.ylim()[0]) / height_ratio
","@@ -252,8 +252,9 @@ def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
     """"""
     try:
         import pylab as pl
-    except ImportError:
-        print(""matplotlib is needed for plotting and tkinter for visualisation."")
+    except ImportError as e:
+        print(""matplotlib is needed for plotting."")
+        print(e)
         sys.exit(1)
     height_ratio = 20.
     vsize = (pl.ylim()[1] - pl.ylim()[0]) / height_ratio
",True,mprof,False
"@@ -1 +1,2 @@
 include README.rst
+include COPYING
","@@ -1 +1,2 @@
 include README.rst
+include COPYING
",True,MANIFEST.in,False
"@@ -181,16 +181,14 @@ def get_cmd_line(args):
 
 def run_action():
     import time, subprocess
-    parser = OptionParser(version=mp.__version__)
+    parser = OptionParser(version=mp.__version__, usage=""mprof run [options]"")
     parser.disable_interspersed_args()
     parser.add_option(""--python"", dest=""python"", default=False,
                       action=""store_true"",
-                      help=""""""Activates extra features when the profiled executable is
-                      a Python program (currently: function timestamping.)"""""")
+                      help=""""""Activates extra features when the profiling executable is a Python program (currently: function timestamping.)"""""")
     parser.add_option(""--nopython"", dest=""nopython"", default=False,
                       action=""store_true"",
-                      help=""""""Disables extra features when the profiled executable is
-                      a Python program (currently: function timestamping.)"""""")
+                      help=""""""Disables extra features when the profiled executable is a Python program (currently: function timestamping.)"""""")
     parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.1"",
                       type=""float"", action=""store"",
                       help=""Sampling period (in seconds), defaults to 0.1"")
","@@ -181,16 +181,14 @@ def get_cmd_line(args):
 
 def run_action():
     import time, subprocess
-    parser = OptionParser(version=mp.__version__)
+    parser = OptionParser(version=mp.__version__, usage=""mprof run [options]"")
     parser.disable_interspersed_args()
     parser.add_option(""--python"", dest=""python"", default=False,
                       action=""store_true"",
-                      help=""""""Activates extra features when the profiled executable is
-                      a Python program (currently: function timestamping.)"""""")
+                      help=""""""Activates extra features when the profiling executable is a Python program (currently: function timestamping.)"""""")
     parser.add_option(""--nopython"", dest=""nopython"", default=False,
                       action=""store_true"",
-                      help=""""""Disables extra features when the profiled executable is
-                      a Python program (currently: function timestamping.)"""""")
+                      help=""""""Disables extra features when the profiled executable is a Python program (currently: function timestamping.)"""""")
     parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.1"",
                       type=""float"", action=""store"",
                       help=""Sampling period (in seconds), defaults to 0.1"")
",True,mprof,False
"@@ -252,7 +252,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
     Returns
     -------
-    mem_usage : list of floating-poing values
+    mem_usage : list of floating-point values
         memory usage, in MiB. It's length is always < timeout / interval
         if max_usage is given, returns the two elements maximum memory and
         number of measurements effectuated
","@@ -252,7 +252,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
     Returns
     -------
-    mem_usage : list of floating-poing values
+    mem_usage : list of floating-point values
         memory usage, in MiB. It's length is always < timeout / interval
         if max_usage is given, returns the two elements maximum memory and
         number of measurements effectuated
",True,memory_profiler.py,True
"@@ -118,6 +118,9 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
                     # fix for newer psutil
                     for p in process.children(recursive=True):
                         mem += getattr(p, meminfo_attr)()[0] / _TWO_20
+                except os.OSError:
+                    # https://github.com/fabianp/memory_profiler/issues/71
+                    pass
             if timestamps:
                 return mem, time.time()
             else:
","@@ -118,6 +118,9 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
                     # fix for newer psutil
                     for p in process.children(recursive=True):
                         mem += getattr(p, meminfo_attr)()[0] / _TWO_20
+                except os.OSError:
+                    # https://github.com/fabianp/memory_profiler/issues/71
+                    pass
             if timestamps:
                 return mem, time.time()
             else:
",True,memory_profiler.py,True
"@@ -112,10 +112,6 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
             mem = getattr(process, meminfo_attr)()[0] / _TWO_20
             if include_children:
                 try:
-                    for p in process.get_children(recursive=True):
-                        mem += getattr(p, meminfo_attr)()[0] / _TWO_20
-                except AttributeError:
-                    # fix for newer psutil
                     for p in process.children(recursive=True):
                         mem += getattr(p, meminfo_attr)()[0] / _TWO_20
                 except os.OSError:
","@@ -112,10 +112,6 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
             mem = getattr(process, meminfo_attr)()[0] / _TWO_20
             if include_children:
                 try:
-                    for p in process.get_children(recursive=True):
-                        mem += getattr(p, meminfo_attr)()[0] / _TWO_20
-                except AttributeError:
-                    # fix for newer psutil
                     for p in process.children(recursive=True):
                         mem += getattr(p, meminfo_attr)()[0] / _TWO_20
                 except os.OSError:
",True,memory_profiler.py,True
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.41'
+__version__ = '0.42'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.41'
+__version__ = '0.42'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -114,7 +114,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
                 try:
                     for p in process.children(recursive=True):
                         mem += getattr(p, meminfo_attr)()[0] / _TWO_20
-                except os.OSError:
+                except psutil.NoSuchProcess:
                     # https://github.com/fabianp/memory_profiler/issues/71
                     pass
             if timestamps:
","@@ -114,7 +114,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
                 try:
                     for p in process.children(recursive=True):
                         mem += getattr(p, meminfo_attr)()[0] / _TWO_20
-                except os.OSError:
+                except psutil.NoSuchProcess:
                     # https://github.com/fabianp/memory_profiler/issues/71
                     pass
             if timestamps:
",True,memory_profiler.py,True
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.42'
+__version__ = '0.43'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.42'
+__version__ = '0.43'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -2,7 +2,7 @@
 An undecorated example of a script that allocates memory in multiprocessing
 workers to demonstrate the use of memory_profiler with multiple processes.
 
-Run this script with mprof run -C python multiprocessing_example.py
+Run this script with mprof run -M python multiprocessing_example.py
 You can then visualize the usage with mprof plot.
 """"""
 
","@@ -2,7 +2,7 @@
 An undecorated example of a script that allocates memory in multiprocessing
 workers to demonstrate the use of memory_profiler with multiple processes.
 
-Run this script with mprof run -C python multiprocessing_example.py
+Run this script with mprof run -M python multiprocessing_example.py
 You can then visualize the usage with mprof plot.
 """"""
 
",True,examples/multiprocessing_example.py,True
"@@ -240,8 +240,8 @@ class MemTimer(Process):
 
 
 def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
-                 include_children=False, max_usage=False, retval=False,
-                 stream=None, backend=None):
+                 include_children=False, multiprocess=False, max_usage=False,
+                 retval=False, stream=None, backend=None):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -272,6 +272,12 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     timestamps : bool, optional
         if True, timestamps of memory usage measurement are collected as well.
 
+    include_children : bool, optional
+        if True, sum the memory of all forked processes as well
+
+    multiprocess : bool, optional
+        if True, track the memory usage of all forked processes.
+
     stream : File
         if stream is a File opened with write access, then results are written
         to this file instead of stored in memory and returned at the end of
@@ -343,10 +349,18 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 mem_usage = _get_memory(
                     proc.pid, backend, timestamps=timestamps,
                     include_children=include_children)
+
                 if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
+
+                    # Only write children to the stream file, warn if appending to the return.
+                    if multiprocess:
+                        for idx, chldmem in enumerate(_get_child_memory(proc.pid)):
+                            stream.write(""CHLD {0} {1:.6f} {2:.4f}\n"".format(idx, chldmem, time.time()))
                 else:
                     ret.append(mem_usage)
+                    if multiprocess:
+                        warnings.warn(""use include_children not multiprocess without a stream"")
             else:
                 ret = max(ret,
                           _get_memory(
@@ -377,8 +391,16 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                     include_children=include_children)
                 if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
+
+                    # Only write children to the stream file, warn if appending to the return.
+                    if multiprocess:
+                        for idx, chldmem in enumerate(_get_child_memory(proc.pid)):
+                            stream.write(""CHLD {0} {1:.6f} {2:.4f}\n"".format(idx, chldmem, time.time()))
                 else:
                     ret.append(mem_usage)
+
+                    if multiprocess:
+                        warnings.warn(""use include_children not multiprocess without a stream"")
             else:
                 ret = max([ret,
                            _get_memory(proc, backend, include_children=include_children)
","@@ -240,8 +240,8 @@ class MemTimer(Process):
 
 
 def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
-                 include_children=False, max_usage=False, retval=False,
-                 stream=None, backend=None):
+                 include_children=False, multiprocess=False, max_usage=False,
+                 retval=False, stream=None, backend=None):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -272,6 +272,12 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     timestamps : bool, optional
         if True, timestamps of memory usage measurement are collected as well.
 
+    include_children : bool, optional
+        if True, sum the memory of all forked processes as well
+
+    multiprocess : bool, optional
+        if True, track the memory usage of all forked processes.
+
     stream : File
         if stream is a File opened with write access, then results are written
         to this file instead of stored in memory and returned at the end of
@@ -343,10 +349,18 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 mem_usage = _get_memory(
                     proc.pid, backend, timestamps=timestamps,
                     include_children=include_children)
+
                 if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
+
+                    # Only write children to the stream file, warn if appending to the return.
+                    if multiprocess:
+                        for idx, chldmem in enumerate(_get_child_memory(proc.pid)):
+                            stream.write(""CHLD {0} {1:.6f} {2:.4f}\n"".format(idx, chldmem, time.time()))
                 else:
                     ret.append(mem_usage)
+                    if multiprocess:
+                        warnings.warn(""use include_children not multiprocess without a stream"")
             else:
                 ret = max(ret,
                           _get_memory(
@@ -377,8 +391,16 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                     include_children=include_children)
                 if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
+
+                    # Only write children to the stream file, warn if appending to the return.
+                    if multiprocess:
+                        for idx, chldmem in enumerate(_get_child_memory(proc.pid)):
+                            stream.write(""CHLD {0} {1:.6f} {2:.4f}\n"".format(idx, chldmem, time.time()))
                 else:
                     ret.append(mem_usage)
+
+                    if multiprocess:
+                        warnings.warn(""use include_children not multiprocess without a stream"")
             else:
                 ret = max([ret,
                            _get_memory(proc, backend, include_children=include_children)
",True,memory_profiler.py,True
"@@ -1,310 +0,0 @@
-#!/usr/bin/env python3
-""""""
-Multiprocessing version of memory profiling of Python programs.
-""""""
-
-import os
-import re
-import time
-import glob
-import argparse
-import subprocess
-import memory_profiler as mp
-
-from collections import defaultdict
-
-try:
-    import numpy as np
-    import matplotlib.pyplot as plt
-except ImportError:
-    plt = None
-    np  = None
-
-
-# Command Descriptions and Constants
-DESCRIPTION = ""Multiprocessing memory profiling over time.""
-EPILOG      = ""If there are any bugs or concerns, submit an issue on Github""
-VERSION     = ""mpmprof v{}"".format(mp.__version__)
-FILETIME    = ""%Y%m%d%H%M%S""
-BLANKS      = set(' \t')
-
-
-def run_action(args):
-    """"""
-    Run the given program and profile its memory usage.
-    """"""
-
-    # Determine where to write the output to
-    if args.output is None:
-        args.output = ""mprofile_{}.dat"".format(
-            time.strftime(FILETIME, time.localtime())
-        )
-
-    # Determine if the command is a Python command
-    if args.command[0].endswith('.py') and not args.nopython:
-        args.python = True
-
-    # Run the executable with the extra features
-    if args.python:
-        print(""running as a Python program ..."")
-        if not args.command[0].startswith('python'):
-            args.command.insert(0, 'python')
-
-    # Inform the user we're sampling
-    print(""mpmprof: Sampling memory every {} seconds"".format(args.interval))
-
-    # Put the command back together from the argument parsing
-    command = "" "".join([
-        c if BLANKS.isdisjoint(c) else ""'{}'"".format(c) for c in args.command
-    ])
-
-    # Open a subprocess to the given command
-    proc = subprocess.Popen(args.command)
-
-    # This is where a call to mp.memory_usage should go.
-    # Instead we're adding the custom code for sampling spawned memory
-    with open(args.output, ""a"") as f:
-
-        # Write the command to the data file
-        f.write(""CMDLINE {}\n"".format(command))
-
-        # Continue sampling until the subprocess is over, counting lines
-        lines = 0
-        while True:
-            # Determine if the subprocess is still running
-            if proc.poll() is not None: break
-
-            # Collect memory usage of master program and write to profile
-            mem = mp._get_memory(proc.pid)
-            f.write(""MEM {0:.6f} {1:.4f}\n"".format(mem, time.time()))
-            lines += 1
-
-            # Collect memory usage of spawned children and write to profile
-            for idx, mem in enumerate(mp._get_child_memory(proc.pid)):
-                f.write(""CHLD{0} {1:.6f} {2:.4f}\n"".format(idx, mem, time.time()))
-                lines += 1
-
-            # Flush every 50 lines
-            if lines > 50:
-                lines = 0
-                f.flush()
-
-            # Sleep for the given interval
-            time.sleep(args.interval)
-
-    # Return the results of the run action
-    return ""memory profile written to {}"".format(args.output)
-
-
-def plot_action(args):
-    """"""
-    Use matplotlib to draw the memory usage of a mprofile .dat file.
-    """"""
-    if plt is None:
-        raise ImportError(
-            ""matplotlib is needed for plotting.""
-        )
-
-    def read_mprofile_file(path):
-        """"""
-        Reads the specialized version of the mprofile for multiprocessing
-        """"""
-        # Regular expression line parsers for parsing data
-        cmdre = re.compile(r""^CMDLINE\s+(.+)$"")
-        memre = re.compile(r""^MEM\s+([\d\.e]+)\s+([\d\.e]+)$"")
-        cldre = re.compile(r""^CHLD(\d+)\s+([\d\.e]+)\s+([\d\.e]+)$"")
-
-        # Data structure returned is a series of names (mem, ts) tuples.
-        series  = defaultdict(list)
-        command = None
-
-        with open(path, 'r') as f:
-            for line in f:
-
-                # Match children memory usage lines
-                match = cldre.match(line)
-                if match:
-                    idx, mem, ts = match.groups()
-                    series[""child "" + idx].append((float(mem), float(ts)))
-                    continue
-
-                # Match main process memory usage lines
-                match = memre.match(line)
-                if match:
-                    series['main'].append(tuple(map(float, match.groups())))
-                    continue
-
-                # Match command line(s)
-                # NOTE: mprofile files are openeded for appending, could be multiple
-                match = cmdre.match(line)
-                if match:
-                    command = match.groups()[0]
-
-        return command, series
-
-
-    def plot_mprofile_file(path, title=None):
-        """"""
-        Plots an mprofile file that contains specialized child process data.
-        """"""
-        # Parse the mprofile file to get the data
-        command, series = read_mprofile_file(path)
-        title = title or command
-
-        # Create and configure the figure
-        fig = plt.figure(figsize=(14, 6), dpi=90)
-        axe = fig.add_axes([0.1, 0.1, 0.6, 0.75])
-        axe.set_xlabel(""time (in seconds)"")
-        axe.set_ylabel(""memory used (in MiB)"")
-        axe.set_title(title)
-
-        # Find the start timestamp for the process and track the maximal memory point
-        # This currently assumes that the series were written in order
-        start  = series['main'][0][1]
-        mpoint = (0, 0)
-
-        # Plot all of the series, the main process and the child.
-        for proc, data in series.items():
-            # Create the numpy arrays from the series data
-            ts  = np.asarray([item[1] for item in data]) - start
-            mem = np.asarray([item[0] for item in data])
-
-            # Plot the line to the figure
-            plt.plot(ts, mem, ""+-"", label=proc)
-
-            # Detect the maximal memory point
-            max_mem = mem.max()
-            if max_mem > mpoint[1]:
-                mpoint = (mem.argmax(), max_mem)
-
-        # Add the marker lines for the maximal memory usage
-        plt.hlines(mpoint[1], plt.xlim()[0]+0.001, plt.xlim()[1] - 0.001, 'r', '--')
-        plt.vlines(ts[mpoint[0]], plt.ylim()[0]+0.001, plt.ylim()[1] - 0.001, 'r', '--')
-
-        # Add the legend
-        legend = axe.legend(loc='center left', bbox_to_anchor=(1, 0.5))
-        legend.get_frame().set_alpha(0.5)
-        axe.grid()
-
-    # Get the latest profile if no profile files were passed in.
-    if not args.profile:
-
-        # Glob profiles of our format and sort them.
-        profiles = glob.glob(""mprofile_??????????????.dat"")
-        profiles.sort()
-
-        if not profiles:
-            raise ValueError((
-                ""No input file found.\nThis program looks for mprofile_*.dat ""
-                ""files generated by the `mpmprof run` command.""
-            ))
-
-        # Assign the latest profile to visualize
-        args.profile = profiles[0:1]
-
-    # Filter out any files that do not exist
-    args.profile = list(filter(os.path.exists, args.profile))
-    if not args.profile:
-        raise ValueError(""No input files found!"")
-
-    # For each passed in file, create a figure from the mprofile.
-    for path in args.profile:
-        axe = plot_mprofile_file(path, args.title)
-        if args.output:
-            plt.savefig(args.output)
-        else:
-            plt.show()
-
-    return ""{} memory profiles plotted."".format(len(args.profile))
-
-
-if __name__ == '__main__':
-    # Create the argument parser and subparsers for each command
-    parser = argparse.ArgumentParser(description=DESCRIPTION, epilog=EPILOG)
-    subparsers = parser.add_subparsers(title='commands')
-
-    # Add the version command
-    parser.add_argument('-v', '--version', action='version', version=VERSION)
-
-    # Commands defined in an dictionary for easy adding
-    commands = (
-        # Run command definition
-        {
-            'name': 'run',
-            'action': run_action,
-            'help': 'monitor the memory usage of a command',
-            'args': {
-                '--python': {
-                    'default': False,
-                    'action': 'store_true',
-                    'help': 'activates extra features for Python programs',
-                },
-                '--nopython': {
-                    'default': False,
-                    'action': 'store_true',
-                    'help': 'disables extra features for Python programs',
-                },
-                ('-T', '--interval'): {
-                    'type': float,
-                    'default': 0.1,
-                    'metavar': 'S',
-                    'help': 'sampling period (in seconds), defaults to 0.1',
-                },
-                ('-o', '--output'): {
-                    'type': str,
-                    'default': None,
-                    'metavar': 'PATH',
-                    'help': 'location to write the memory profiler output to',
-                },
-                'command': {
-                    'nargs': argparse.REMAINDER,
-                    'help': 'command to run and profile memory usage',
-                }
-            }
-        },
-
-        # Plot command definition
-        {
-            'name': 'plot',
-            'action': plot_action,
-            'help': 'plot the memory usage of a mprofile data file',
-            'args': {
-                ('-t', '--title'): {
-                    'type': str,
-                    'default': None,
-                    'metavar': 'S',
-                    'help': 'set the title of the figure',
-                },
-                ('-o', '--output'): {
-                    'type': str,
-                    'default': None,
-                    'metavar': 'PATH',
-                    'help': 'write the figure as a png to disk'
-                },
-                'profile': {
-                    'nargs': '*',
-                    'help': 'profile to plot, omit to use the latest',
-                }
-            }
-        }
-    )
-
-    # Add the commands and their arguments.
-    for cmd in commands:
-        # Create the command subparser and add the action
-        cmd_parser = subparsers.add_parser(cmd['name'], help=cmd['help'])
-        cmd_parser.set_defaults(func=cmd['action'])
-
-        # Add the arguments
-        for args, kwargs in cmd['args'].items():
-            if isinstance(args, str):
-                args = (args,)
-            cmd_parser.add_argument(*args, **kwargs)
-
-    # Handle input from the command line
-    args = parser.parse_args()            # Parse the arguments
-    # try:
-    msg = args.func(args)             # Call the default function
-    parser.exit(0, msg+""\n"")          # Exit cleanly with message
-    # except Exception as e:
-    #     parser.error(str(e))              # Exit with error
","@@ -1,310 +0,0 @@
-#!/usr/bin/env python3
-""""""
-Multiprocessing version of memory profiling of Python programs.
-""""""
-
-import os
-import re
-import time
-import glob
-import argparse
-import subprocess
-import memory_profiler as mp
-
-from collections import defaultdict
-
-try:
-    import numpy as np
-    import matplotlib.pyplot as plt
-except ImportError:
-    plt = None
-    np  = None
-
-
-# Command Descriptions and Constants
-DESCRIPTION = ""Multiprocessing memory profiling over time.""
-EPILOG      = ""If there are any bugs or concerns, submit an issue on Github""
-VERSION     = ""mpmprof v{}"".format(mp.__version__)
-FILETIME    = ""%Y%m%d%H%M%S""
-BLANKS      = set(' \t')
-
-
-def run_action(args):
-    """"""
-    Run the given program and profile its memory usage.
-    """"""
-
-    # Determine where to write the output to
-    if args.output is None:
-        args.output = ""mprofile_{}.dat"".format(
-            time.strftime(FILETIME, time.localtime())
-        )
-
-    # Determine if the command is a Python command
-    if args.command[0].endswith('.py') and not args.nopython:
-        args.python = True
-
-    # Run the executable with the extra features
-    if args.python:
-        print(""running as a Python program ..."")
-        if not args.command[0].startswith('python'):
-            args.command.insert(0, 'python')
-
-    # Inform the user we're sampling
-    print(""mpmprof: Sampling memory every {} seconds"".format(args.interval))
-
-    # Put the command back together from the argument parsing
-    command = "" "".join([
-        c if BLANKS.isdisjoint(c) else ""'{}'"".format(c) for c in args.command
-    ])
-
-    # Open a subprocess to the given command
-    proc = subprocess.Popen(args.command)
-
-    # This is where a call to mp.memory_usage should go.
-    # Instead we're adding the custom code for sampling spawned memory
-    with open(args.output, ""a"") as f:
-
-        # Write the command to the data file
-        f.write(""CMDLINE {}\n"".format(command))
-
-        # Continue sampling until the subprocess is over, counting lines
-        lines = 0
-        while True:
-            # Determine if the subprocess is still running
-            if proc.poll() is not None: break
-
-            # Collect memory usage of master program and write to profile
-            mem = mp._get_memory(proc.pid)
-            f.write(""MEM {0:.6f} {1:.4f}\n"".format(mem, time.time()))
-            lines += 1
-
-            # Collect memory usage of spawned children and write to profile
-            for idx, mem in enumerate(mp._get_child_memory(proc.pid)):
-                f.write(""CHLD{0} {1:.6f} {2:.4f}\n"".format(idx, mem, time.time()))
-                lines += 1
-
-            # Flush every 50 lines
-            if lines > 50:
-                lines = 0
-                f.flush()
-
-            # Sleep for the given interval
-            time.sleep(args.interval)
-
-    # Return the results of the run action
-    return ""memory profile written to {}"".format(args.output)
-
-
-def plot_action(args):
-    """"""
-    Use matplotlib to draw the memory usage of a mprofile .dat file.
-    """"""
-    if plt is None:
-        raise ImportError(
-            ""matplotlib is needed for plotting.""
-        )
-
-    def read_mprofile_file(path):
-        """"""
-        Reads the specialized version of the mprofile for multiprocessing
-        """"""
-        # Regular expression line parsers for parsing data
-        cmdre = re.compile(r""^CMDLINE\s+(.+)$"")
-        memre = re.compile(r""^MEM\s+([\d\.e]+)\s+([\d\.e]+)$"")
-        cldre = re.compile(r""^CHLD(\d+)\s+([\d\.e]+)\s+([\d\.e]+)$"")
-
-        # Data structure returned is a series of names (mem, ts) tuples.
-        series  = defaultdict(list)
-        command = None
-
-        with open(path, 'r') as f:
-            for line in f:
-
-                # Match children memory usage lines
-                match = cldre.match(line)
-                if match:
-                    idx, mem, ts = match.groups()
-                    series[""child "" + idx].append((float(mem), float(ts)))
-                    continue
-
-                # Match main process memory usage lines
-                match = memre.match(line)
-                if match:
-                    series['main'].append(tuple(map(float, match.groups())))
-                    continue
-
-                # Match command line(s)
-                # NOTE: mprofile files are openeded for appending, could be multiple
-                match = cmdre.match(line)
-                if match:
-                    command = match.groups()[0]
-
-        return command, series
-
-
-    def plot_mprofile_file(path, title=None):
-        """"""
-        Plots an mprofile file that contains specialized child process data.
-        """"""
-        # Parse the mprofile file to get the data
-        command, series = read_mprofile_file(path)
-        title = title or command
-
-        # Create and configure the figure
-        fig = plt.figure(figsize=(14, 6), dpi=90)
-        axe = fig.add_axes([0.1, 0.1, 0.6, 0.75])
-        axe.set_xlabel(""time (in seconds)"")
-        axe.set_ylabel(""memory used (in MiB)"")
-        axe.set_title(title)
-
-        # Find the start timestamp for the process and track the maximal memory point
-        # This currently assumes that the series were written in order
-        start  = series['main'][0][1]
-        mpoint = (0, 0)
-
-        # Plot all of the series, the main process and the child.
-        for proc, data in series.items():
-            # Create the numpy arrays from the series data
-            ts  = np.asarray([item[1] for item in data]) - start
-            mem = np.asarray([item[0] for item in data])
-
-            # Plot the line to the figure
-            plt.plot(ts, mem, ""+-"", label=proc)
-
-            # Detect the maximal memory point
-            max_mem = mem.max()
-            if max_mem > mpoint[1]:
-                mpoint = (mem.argmax(), max_mem)
-
-        # Add the marker lines for the maximal memory usage
-        plt.hlines(mpoint[1], plt.xlim()[0]+0.001, plt.xlim()[1] - 0.001, 'r', '--')
-        plt.vlines(ts[mpoint[0]], plt.ylim()[0]+0.001, plt.ylim()[1] - 0.001, 'r', '--')
-
-        # Add the legend
-        legend = axe.legend(loc='center left', bbox_to_anchor=(1, 0.5))
-        legend.get_frame().set_alpha(0.5)
-        axe.grid()
-
-    # Get the latest profile if no profile files were passed in.
-    if not args.profile:
-
-        # Glob profiles of our format and sort them.
-        profiles = glob.glob(""mprofile_??????????????.dat"")
-        profiles.sort()
-
-        if not profiles:
-            raise ValueError((
-                ""No input file found.\nThis program looks for mprofile_*.dat ""
-                ""files generated by the `mpmprof run` command.""
-            ))
-
-        # Assign the latest profile to visualize
-        args.profile = profiles[0:1]
-
-    # Filter out any files that do not exist
-    args.profile = list(filter(os.path.exists, args.profile))
-    if not args.profile:
-        raise ValueError(""No input files found!"")
-
-    # For each passed in file, create a figure from the mprofile.
-    for path in args.profile:
-        axe = plot_mprofile_file(path, args.title)
-        if args.output:
-            plt.savefig(args.output)
-        else:
-            plt.show()
-
-    return ""{} memory profiles plotted."".format(len(args.profile))
-
-
-if __name__ == '__main__':
-    # Create the argument parser and subparsers for each command
-    parser = argparse.ArgumentParser(description=DESCRIPTION, epilog=EPILOG)
-    subparsers = parser.add_subparsers(title='commands')
-
-    # Add the version command
-    parser.add_argument('-v', '--version', action='version', version=VERSION)
-
-    # Commands defined in an dictionary for easy adding
-    commands = (
-        # Run command definition
-        {
-            'name': 'run',
-            'action': run_action,
-            'help': 'monitor the memory usage of a command',
-            'args': {
-                '--python': {
-                    'default': False,
-                    'action': 'store_true',
-                    'help': 'activates extra features for Python programs',
-                },
-                '--nopython': {
-                    'default': False,
-                    'action': 'store_true',
-                    'help': 'disables extra features for Python programs',
-                },
-                ('-T', '--interval'): {
-                    'type': float,
-                    'default': 0.1,
-                    'metavar': 'S',
-                    'help': 'sampling period (in seconds), defaults to 0.1',
-                },
-                ('-o', '--output'): {
-                    'type': str,
-                    'default': None,
-                    'metavar': 'PATH',
-                    'help': 'location to write the memory profiler output to',
-                },
-                'command': {
-                    'nargs': argparse.REMAINDER,
-                    'help': 'command to run and profile memory usage',
-                }
-            }
-        },
-
-        # Plot command definition
-        {
-            'name': 'plot',
-            'action': plot_action,
-            'help': 'plot the memory usage of a mprofile data file',
-            'args': {
-                ('-t', '--title'): {
-                    'type': str,
-                    'default': None,
-                    'metavar': 'S',
-                    'help': 'set the title of the figure',
-                },
-                ('-o', '--output'): {
-                    'type': str,
-                    'default': None,
-                    'metavar': 'PATH',
-                    'help': 'write the figure as a png to disk'
-                },
-                'profile': {
-                    'nargs': '*',
-                    'help': 'profile to plot, omit to use the latest',
-                }
-            }
-        }
-    )
-
-    # Add the commands and their arguments.
-    for cmd in commands:
-        # Create the command subparser and add the action
-        cmd_parser = subparsers.add_parser(cmd['name'], help=cmd['help'])
-        cmd_parser.set_defaults(func=cmd['action'])
-
-        # Add the arguments
-        for args, kwargs in cmd['args'].items():
-            if isinstance(args, str):
-                args = (args,)
-            cmd_parser.add_argument(*args, **kwargs)
-
-    # Handle input from the command line
-    args = parser.parse_args()            # Parse the arguments
-    # try:
-    msg = args.func(args)             # Call the default function
-    parser.exit(0, msg+""\n"")          # Exit cleanly with message
-    # except Exception as e:
-    #     parser.error(str(e))              # Exit with error
",True,,False
"@@ -9,6 +9,7 @@ import copy
 import time
 import math
 
+from collections import defaultdict
 from optparse import OptionParser, OptionValueError
 
 import memory_profiler as mp
@@ -195,6 +196,9 @@ def run_action():
     parser.add_option(""--include-children"", ""-C"", dest=""include_children"",
                       default=False, action=""store_true"",
                       help=""""""Monitors forked processes as well (sum up all process memory)"""""")
+    parser.add_option(""--multiprocess"", ""-M"", dest=""multiprocess"",
+                      default=False, action=""store_true"",
+                      help=""""""Monitors forked processes creating individual plots for each child"""""")
 
     (options, args) = parser.parse_args()
 
@@ -231,7 +235,8 @@ def run_action():
     with open(mprofile_output, ""a"") as f:
         f.write(""CMDLINE {0}\n"".format(cmd_line))
         mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
-                        include_children=options.include_children, stream=f)
+                        include_children=options.include_children,
+                        multiprocess=options.multiprocess, stream=f)
 
 
 def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
@@ -299,6 +304,7 @@ def read_mprofile_file(filename):
     func_ts = {}
     mem_usage = []
     timestamp = []
+    children  = defaultdict(list)
     cmd_line = None
     f = open(filename, ""r"")
     for l in f:
@@ -319,6 +325,13 @@ def read_mprofile_file(filename):
                        float(mem_start), float(mem_end)])
             func_ts[f_name] = ts
 
+        elif field == ""CHLD"":
+            values = value.split(' ')
+            chldnum = values[0]
+            children[chldnum].append(
+                (float(values[1]), float(values[2]))
+            )
+
         elif field == ""CMDLINE"":
             cmd_line = value
         else:
@@ -327,10 +340,10 @@ def read_mprofile_file(filename):
 
     return {""mem_usage"": mem_usage, ""timestamp"": timestamp,
             ""func_timestamp"": func_ts, 'filename': filename,
-            'cmd_line': cmd_line}
+            'cmd_line': cmd_line, 'children': children}
 
 
-def plot_file(filename, index=0, timestamps=True, options=None):
+def plot_file(filename, index=0, timestamps=True, children=True, options=None):
     try:
         import pylab as pl
     except ImportError:
@@ -351,6 +364,7 @@ def plot_file(filename, index=0, timestamps=True, options=None):
     ts = mprofile['func_timestamp']
     t = mprofile['timestamp']
     mem = mprofile['mem_usage']
+    chld = mprofile['children']
 
     if len(ts) > 0:
         for values in ts.values():
@@ -384,6 +398,17 @@ def plot_file(filename, index=0, timestamps=True, options=None):
     bottom += 0.001
     top -= 0.001
 
+    # plot children, if any
+    if len(chld) > 0 and children:
+        for idx, (proc, data) in enumerate(chld.items()):
+            # Create the numpy arrays from the series data
+            cts  = np.asarray([item[1] for item in data]) - global_start
+            cmem = np.asarray([item[0] for item in data])
+
+            # Plot the line to the figure
+            pl.plot(cts, cmem, ""+-""  + mem_line_colors[idx+1 % len(mem_line_colors)],
+                     label=""child {}"".format(proc))
+
     # plot timestamps, if any
     if len(ts) > 0 and timestamps:
         func_num = 0
","@@ -9,6 +9,7 @@ import copy
 import time
 import math
 
+from collections import defaultdict
 from optparse import OptionParser, OptionValueError
 
 import memory_profiler as mp
@@ -195,6 +196,9 @@ def run_action():
     parser.add_option(""--include-children"", ""-C"", dest=""include_children"",
                       default=False, action=""store_true"",
                       help=""""""Monitors forked processes as well (sum up all process memory)"""""")
+    parser.add_option(""--multiprocess"", ""-M"", dest=""multiprocess"",
+                      default=False, action=""store_true"",
+                      help=""""""Monitors forked processes creating individual plots for each child"""""")
 
     (options, args) = parser.parse_args()
 
@@ -231,7 +235,8 @@ def run_action():
     with open(mprofile_output, ""a"") as f:
         f.write(""CMDLINE {0}\n"".format(cmd_line))
         mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
-                        include_children=options.include_children, stream=f)
+                        include_children=options.include_children,
+                        multiprocess=options.multiprocess, stream=f)
 
 
 def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
@@ -299,6 +304,7 @@ def read_mprofile_file(filename):
     func_ts = {}
     mem_usage = []
     timestamp = []
+    children  = defaultdict(list)
     cmd_line = None
     f = open(filename, ""r"")
     for l in f:
@@ -319,6 +325,13 @@ def read_mprofile_file(filename):
                        float(mem_start), float(mem_end)])
             func_ts[f_name] = ts
 
+        elif field == ""CHLD"":
+            values = value.split(' ')
+            chldnum = values[0]
+            children[chldnum].append(
+                (float(values[1]), float(values[2]))
+            )
+
         elif field == ""CMDLINE"":
             cmd_line = value
         else:
@@ -327,10 +340,10 @@ def read_mprofile_file(filename):
 
     return {""mem_usage"": mem_usage, ""timestamp"": timestamp,
             ""func_timestamp"": func_ts, 'filename': filename,
-            'cmd_line': cmd_line}
+            'cmd_line': cmd_line, 'children': children}
 
 
-def plot_file(filename, index=0, timestamps=True, options=None):
+def plot_file(filename, index=0, timestamps=True, children=True, options=None):
     try:
         import pylab as pl
     except ImportError:
@@ -351,6 +364,7 @@ def plot_file(filename, index=0, timestamps=True, options=None):
     ts = mprofile['func_timestamp']
     t = mprofile['timestamp']
     mem = mprofile['mem_usage']
+    chld = mprofile['children']
 
     if len(ts) > 0:
         for values in ts.values():
@@ -384,6 +398,17 @@ def plot_file(filename, index=0, timestamps=True, options=None):
     bottom += 0.001
     top -= 0.001
 
+    # plot children, if any
+    if len(chld) > 0 and children:
+        for idx, (proc, data) in enumerate(chld.items()):
+            # Create the numpy arrays from the series data
+            cts  = np.asarray([item[1] for item in data]) - global_start
+            cmem = np.asarray([item[0] for item in data])
+
+            # Plot the line to the figure
+            pl.plot(cts, cmem, ""+-""  + mem_line_colors[idx+1 % len(mem_line_colors)],
+                     label=""child {}"".format(proc))
+
     # plot timestamps, if any
     if len(ts) > 0 and timestamps:
         func_num = 0
",True,mprof,False
"@@ -107,10 +107,10 @@ decorator function.  Use as follows::
         del b
         return a
 
-If a python script with decorator ``@profile`` is called using ``-m 
+If a python script with decorator ``@profile`` is called using ``-m
 memory_profiler`` in the command line, the ``precision`` parameter is ignored.
 
-Time-based memory usage 
+Time-based memory usage
 ==========================
 Sometimes it is useful to have full memory usage reports as a function of
 time (not line-by-line) of external processes (be it Python scripts or not).
@@ -131,14 +131,14 @@ e.g. `mprof run -h`.
 In the case of a Python script, using the previous command does not
 give you any information on which function is executed at a given
 time. Depending on the case, it can be difficult to identify the part
-of the code that is causing the highest memory usage. 
+of the code that is causing the highest memory usage.
 
 Adding the `profile` decorator to a function and running the Python
-script with 
+script with
 
     mprof run <script>
 
-will record timestamps when entering/leaving the profiled function. Runnning
+will record timestamps when entering/leaving the profiled function. Running
 
     mprof plot
 
@@ -152,9 +152,9 @@ A discussion of these capabilities can be found `here <http://fa.bianp.net/blog/
 
 .. warning:: If your Python file imports the memory profiler `from memory_profiler import profile` these timestamps will not be recorded. Comment out the import, leave your functions decorated, and re-run.
 
-The available commands for `mprof` are: 
+The available commands for `mprof` are:
 
-  - ``mprof run``: running an executable, recording memory usage  
+  - ``mprof run``: running an executable, recording memory usage
   - ``mprof plot``: plotting one the recorded memory usage (by default,
     the last one)
   - ``mprof list``: listing all recorded memory usage files in a
@@ -162,6 +162,39 @@ The available commands for `mprof` are:
   - ``mprof clean``: removing all recorded memory usage files.
   - ``mprof rm``: removing specific recorded memory usage files
 
+Tracking forked child processes
+===============================
+In a multiprocessing context the main process will spawn child processes whose
+system resources are allocated separately from the parent process. This can
+lead to an inaccurate report of memory usage since by default only the parent
+process is being tracked. The ``mprof`` utility provides two mechanisms to
+track the usage of child processes: sum the memory of all children to the
+parent's usage and track each child individual.
+
+To create a report that combines memory usage of all the children and the
+parent, use the ``include_children`` flag in either the ``profile`` decorator or
+ass a command line argument to ``mprof``::
+
+    mprof run --include-children <script>
+
+The second method tracks each child independently of the main process,
+serializing child rows by index to the output stream. Use the ``multiprocess``
+flag and plot as follows::
+
+    mprof run --multiprocess <script>
+    mprof plot
+
+This will create a plot using matplotlib similar to this:
+
+.. image:: https://cloud.githubusercontent.com/assets/745966/24075879/2e85b43a-0bfa-11e7-8dfe-654320dbd2ce.png
+    : target: https://github.com/fabianp/memory_profiler/pull/134
+    : height: 350px
+
+You can combine both the ``include_children`` and ``multiprocess`` flags to show
+the total memory of the program as well as each child individually.
+
+.. warning:: currently the child tracking only works if a ``stream`` is provided to the ``profile`` (e.g. from the command line or in the decorator).
+
 Setting debugger breakpoints
 =============================
 It is possible to set breakpoints depending on the amount of memory used.
@@ -260,7 +293,7 @@ LogFile of memory profiler module.
     >>> import sys
     >>> sys.stdout = LogFile('memory_profile_log')
 
-``Customised reporting:``
+``Customized reporting:``
 
 Sending everything to the log file while running the memory_profiler
 could be cumbersome and one can choose only entries with increments
@@ -412,6 +445,8 @@ cleanup.
 
 `Dmitriy Novozhilov <https://github.com/demiurg906>`_ and `Sergei Lebedev <https://github.com/superbobry>`_ added support for `tracemalloc <https://docs.python.org/3/library/tracemalloc.html>`_.
 
+`Benjamin Bengfort <https://github.com/bbengfort>`_ added support for tracking the usage of individual child processes and plotting them.
+
 =========
  License
 =========
","@@ -107,10 +107,10 @@ decorator function.  Use as follows::
         del b
         return a
 
-If a python script with decorator ``@profile`` is called using ``-m 
+If a python script with decorator ``@profile`` is called using ``-m
 memory_profiler`` in the command line, the ``precision`` parameter is ignored.
 
-Time-based memory usage 
+Time-based memory usage
 ==========================
 Sometimes it is useful to have full memory usage reports as a function of
 time (not line-by-line) of external processes (be it Python scripts or not).
@@ -131,14 +131,14 @@ e.g. `mprof run -h`.
 In the case of a Python script, using the previous command does not
 give you any information on which function is executed at a given
 time. Depending on the case, it can be difficult to identify the part
-of the code that is causing the highest memory usage. 
+of the code that is causing the highest memory usage.
 
 Adding the `profile` decorator to a function and running the Python
-script with 
+script with
 
     mprof run <script>
 
-will record timestamps when entering/leaving the profiled function. Runnning
+will record timestamps when entering/leaving the profiled function. Running
 
     mprof plot
 
@@ -152,9 +152,9 @@ A discussion of these capabilities can be found `here <http://fa.bianp.net/blog/
 
 .. warning:: If your Python file imports the memory profiler `from memory_profiler import profile` these timestamps will not be recorded. Comment out the import, leave your functions decorated, and re-run.
 
-The available commands for `mprof` are: 
+The available commands for `mprof` are:
 
-  - ``mprof run``: running an executable, recording memory usage  
+  - ``mprof run``: running an executable, recording memory usage
   - ``mprof plot``: plotting one the recorded memory usage (by default,
     the last one)
   - ``mprof list``: listing all recorded memory usage files in a
@@ -162,6 +162,39 @@ The available commands for `mprof` are:
   - ``mprof clean``: removing all recorded memory usage files.
   - ``mprof rm``: removing specific recorded memory usage files
 
+Tracking forked child processes
+===============================
+In a multiprocessing context the main process will spawn child processes whose
+system resources are allocated separately from the parent process. This can
+lead to an inaccurate report of memory usage since by default only the parent
+process is being tracked. The ``mprof`` utility provides two mechanisms to
+track the usage of child processes: sum the memory of all children to the
+parent's usage and track each child individual.
+
+To create a report that combines memory usage of all the children and the
+parent, use the ``include_children`` flag in either the ``profile`` decorator or
+ass a command line argument to ``mprof``::
+
+    mprof run --include-children <script>
+
+The second method tracks each child independently of the main process,
+serializing child rows by index to the output stream. Use the ``multiprocess``
+flag and plot as follows::
+
+    mprof run --multiprocess <script>
+    mprof plot
+
+This will create a plot using matplotlib similar to this:
+
+.. image:: https://cloud.githubusercontent.com/assets/745966/24075879/2e85b43a-0bfa-11e7-8dfe-654320dbd2ce.png
+    : target: https://github.com/fabianp/memory_profiler/pull/134
+    : height: 350px
+
+You can combine both the ``include_children`` and ``multiprocess`` flags to show
+the total memory of the program as well as each child individually.
+
+.. warning:: currently the child tracking only works if a ``stream`` is provided to the ``profile`` (e.g. from the command line or in the decorator).
+
 Setting debugger breakpoints
 =============================
 It is possible to set breakpoints depending on the amount of memory used.
@@ -260,7 +293,7 @@ LogFile of memory profiler module.
     >>> import sys
     >>> sys.stdout = LogFile('memory_profile_log')
 
-``Customised reporting:``
+``Customized reporting:``
 
 Sending everything to the log file while running the memory_profiler
 could be cumbersome and one can choose only entries with increments
@@ -412,6 +445,8 @@ cleanup.
 
 `Dmitriy Novozhilov <https://github.com/demiurg906>`_ and `Sergei Lebedev <https://github.com/superbobry>`_ added support for `tracemalloc <https://docs.python.org/3/library/tracemalloc.html>`_.
 
+`Benjamin Bengfort <https://github.com/bbengfort>`_ added support for tracking the usage of individual child processes and plotting them.
+
 =========
  License
 =========
",True,README.rst,False
"@@ -400,6 +400,8 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
 
     # plot children, if any
     if len(chld) > 0 and children:
+        cmpoint = (0,0) # maximal child memory
+
         for idx, (proc, data) in enumerate(chld.items()):
             # Create the numpy arrays from the series data
             cts  = np.asarray([item[1] for item in data]) - global_start
@@ -409,6 +411,15 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
             pl.plot(cts, cmem, ""+-""  + mem_line_colors[idx+1 % len(mem_line_colors)],
                      label=""child {}"".format(proc))
 
+            # Detect the maximal child memory point
+            cmax_mem = cmem.max()
+            if cmax_mem > cmpoint[1]:
+                cmpoint = (cts[cmem.argmax()], cmax_mem)
+
+        # Add the marker lines for the maximal child memory usage
+        pl.vlines(cmpoint[0], pl.ylim()[0]+0.001, pl.ylim()[1] - 0.001, 'r', '--')
+        pl.hlines(cmpoint[1], pl.xlim()[0]+0.001, pl.xlim()[1] - 0.001, 'r', '--')
+
     # plot timestamps, if any
     if len(ts) > 0 and timestamps:
         func_num = 0
","@@ -400,6 +400,8 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
 
     # plot children, if any
     if len(chld) > 0 and children:
+        cmpoint = (0,0) # maximal child memory
+
         for idx, (proc, data) in enumerate(chld.items()):
             # Create the numpy arrays from the series data
             cts  = np.asarray([item[1] for item in data]) - global_start
@@ -409,6 +411,15 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
             pl.plot(cts, cmem, ""+-""  + mem_line_colors[idx+1 % len(mem_line_colors)],
                      label=""child {}"".format(proc))
 
+            # Detect the maximal child memory point
+            cmax_mem = cmem.max()
+            if cmax_mem > cmpoint[1]:
+                cmpoint = (cts[cmem.argmax()], cmax_mem)
+
+        # Add the marker lines for the maximal child memory usage
+        pl.vlines(cmpoint[0], pl.ylim()[0]+0.001, pl.ylim()[1] - 0.001, 'r', '--')
+        pl.hlines(cmpoint[1], pl.xlim()[0]+0.001, pl.xlim()[1] - 0.001, 'r', '--')
+
     # plot timestamps, if any
     if len(ts) > 0 and timestamps:
         func_num = 0
",True,mprof,False
"@@ -187,13 +187,13 @@ flag and plot as follows::
 This will create a plot using matplotlib similar to this:
 
 .. image:: https://cloud.githubusercontent.com/assets/745966/24075879/2e85b43a-0bfa-11e7-8dfe-654320dbd2ce.png
-    : target: https://github.com/fabianp/memory_profiler/pull/134
-    : height: 350px
+    :target: https://github.com/fabianp/memory_profiler/pull/134
+    :height: 350px
 
 You can combine both the ``include_children`` and ``multiprocess`` flags to show
 the total memory of the program as well as each child individually.
 
-.. warning:: currently the child tracking only works if a ``stream`` is provided to the ``profile`` (e.g. from the command line or in the decorator).
+.. warning:: Currently the child tracking only works if a ``stream`` is provided to the ``profile`` (e.g. from the command line or in the decorator). If you are using the API to retrieve values then the flag will not do anything.
 
 Setting debugger breakpoints
 =============================
","@@ -187,13 +187,13 @@ flag and plot as follows::
 This will create a plot using matplotlib similar to this:
 
 .. image:: https://cloud.githubusercontent.com/assets/745966/24075879/2e85b43a-0bfa-11e7-8dfe-654320dbd2ce.png
-    : target: https://github.com/fabianp/memory_profiler/pull/134
-    : height: 350px
+    :target: https://github.com/fabianp/memory_profiler/pull/134
+    :height: 350px
 
 You can combine both the ``include_children`` and ``multiprocess`` flags to show
 the total memory of the program as well as each child individually.
 
-.. warning:: currently the child tracking only works if a ``stream`` is provided to the ``profile`` (e.g. from the command line or in the decorator).
+.. warning:: Currently the child tracking only works if a ``stream`` is provided to the ``profile`` (e.g. from the command line or in the decorator). If you are using the API to retrieve values then the flag will not do anything.
 
 Setting debugger breakpoints
 =============================
",True,README.rst,False
"@@ -191,9 +191,9 @@ This will create a plot using matplotlib similar to this:
     :height: 350px
 
 You can combine both the ``include_children`` and ``multiprocess`` flags to show
-the total memory of the program as well as each child individually.
-
-.. warning:: Currently the child tracking only works if a ``stream`` is provided to the ``profile`` (e.g. from the command line or in the decorator). If you are using the API to retrieve values then the flag will not do anything.
+the total memory of the program as well as each child individually. If using
+the API directly, note that the return from ``memory_usage`` will include the
+child memory along with an index identifying the specific child.
 
 Setting debugger breakpoints
 =============================
","@@ -191,9 +191,9 @@ This will create a plot using matplotlib similar to this:
     :height: 350px
 
 You can combine both the ``include_children`` and ``multiprocess`` flags to show
-the total memory of the program as well as each child individually.
-
-.. warning:: Currently the child tracking only works if a ``stream`` is provided to the ``profile`` (e.g. from the command line or in the decorator). If you are using the API to retrieve values then the flag will not do anything.
+the total memory of the program as well as each child individually. If using
+the API directly, note that the return from ``memory_usage`` will include the
+child memory along with an index identifying the specific child.
 
 Setting debugger breakpoints
 =============================
",True,README.rst,False
"@@ -353,14 +353,19 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
 
-                    # Only write children to the stream file, warn if appending to the return.
+                    # Write children to the stream file
                     if multiprocess:
                         for idx, chldmem in enumerate(_get_child_memory(proc.pid)):
                             stream.write(""CHLD {0} {1:.6f} {2:.4f}\n"".format(idx, chldmem, time.time()))
                 else:
-                    ret.append(mem_usage)
+                    # Create a nested list with the child memory
                     if multiprocess:
-                        warnings.warn(""use include_children not multiprocess without a stream"")
+                        mem_usage = [mem_usage]
+                        for chldmem in _get_child_memory(proc.pid):
+                            mem_usage.append(chldmem)
+
+                    # Append the memory usage to the return value
+                    ret.append(mem_usage)
             else:
                 ret = max(ret,
                           _get_memory(
@@ -392,15 +397,19 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
 
-                    # Only write children to the stream file, warn if appending to the return.
+                    # Write children to the stream file
                     if multiprocess:
                         for idx, chldmem in enumerate(_get_child_memory(proc.pid)):
                             stream.write(""CHLD {0} {1:.6f} {2:.4f}\n"".format(idx, chldmem, time.time()))
                 else:
-                    ret.append(mem_usage)
-
+                    # Create a nested list with the child memory
                     if multiprocess:
-                        warnings.warn(""use include_children not multiprocess without a stream"")
+                        mem_usage = [mem_usage]
+                        for chldmem in _get_child_memory(proc.pid):
+                            mem_usage.append(chldmem)
+
+                    # Append the memory usage to the return value
+                    ret.append(mem_usage)
             else:
                 ret = max([ret,
                            _get_memory(proc, backend, include_children=include_children)
","@@ -353,14 +353,19 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
 
-                    # Only write children to the stream file, warn if appending to the return.
+                    # Write children to the stream file
                     if multiprocess:
                         for idx, chldmem in enumerate(_get_child_memory(proc.pid)):
                             stream.write(""CHLD {0} {1:.6f} {2:.4f}\n"".format(idx, chldmem, time.time()))
                 else:
-                    ret.append(mem_usage)
+                    # Create a nested list with the child memory
                     if multiprocess:
-                        warnings.warn(""use include_children not multiprocess without a stream"")
+                        mem_usage = [mem_usage]
+                        for chldmem in _get_child_memory(proc.pid):
+                            mem_usage.append(chldmem)
+
+                    # Append the memory usage to the return value
+                    ret.append(mem_usage)
             else:
                 ret = max(ret,
                           _get_memory(
@@ -392,15 +397,19 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
 
-                    # Only write children to the stream file, warn if appending to the return.
+                    # Write children to the stream file
                     if multiprocess:
                         for idx, chldmem in enumerate(_get_child_memory(proc.pid)):
                             stream.write(""CHLD {0} {1:.6f} {2:.4f}\n"".format(idx, chldmem, time.time()))
                 else:
-                    ret.append(mem_usage)
-
+                    # Create a nested list with the child memory
                     if multiprocess:
-                        warnings.warn(""use include_children not multiprocess without a stream"")
+                        mem_usage = [mem_usage]
+                        for chldmem in _get_child_memory(proc.pid):
+                            mem_usage.append(chldmem)
+
+                    # Append the memory usage to the return value
+                    ret.append(mem_usage)
             else:
                 ret = max([ret,
                            _get_memory(proc, backend, include_children=include_children)
",True,memory_profiler.py,True
"@@ -193,7 +193,7 @@ This will create a plot using matplotlib similar to this:
 You can combine both the ``include_children`` and ``multiprocess`` flags to show
 the total memory of the program as well as each child individually. If using
 the API directly, note that the return from ``memory_usage`` will include the
-child memory along with an index identifying the specific child.
+child memory in a nested list along with the main process memory.
 
 Setting debugger breakpoints
 =============================
","@@ -193,7 +193,7 @@ This will create a plot using matplotlib similar to this:
 You can combine both the ``include_children`` and ``multiprocess`` flags to show
 the total memory of the program as well as each child individually. If using
 the API directly, note that the return from ``memory_usage`` will include the
-child memory along with an index identifying the specific child.
+child memory in a nested list along with the main process memory.
 
 Setting debugger breakpoints
 =============================
",True,README.rst,False
"@@ -2,7 +2,7 @@
 An undecorated example of a script that allocates memory in multiprocessing
 workers to demonstrate the use of memory_profiler with multiple processes.
 
-Run this script with mprof run -M python multiprocessing_example.py
+Run this script with mprof run -M multiprocessing_example.py
 You can then visualize the usage with mprof plot.
 """"""
 
","@@ -2,7 +2,7 @@
 An undecorated example of a script that allocates memory in multiprocessing
 workers to demonstrate the use of memory_profiler with multiple processes.
 
-Run this script with mprof run -M python multiprocessing_example.py
+Run this script with mprof run -M multiprocessing_example.py
 You can then visualize the usage with mprof plot.
 """"""
 
",True,examples/multiprocessing_example.py,True
"@@ -219,7 +219,15 @@ def run_action():
 
     # .. TODO: more than one script as argument ? ..
     if args[0].endswith('.py') and not options.nopython:
-        options.python = True
+        if options.multiprocess and not args[0].startswith(""python""):
+            # in multiprocessing mode you want to spawn a separate
+            # python process
+            args.insert(0, ""python"")
+        else:
+            options.python = True
+    if options.multiprocess:
+        # multiprocess can't work in python mode
+        options.python = False
     if options.python:
         print(""running as a Python program..."")
         if not args[0].startswith(""python""):
","@@ -219,7 +219,15 @@ def run_action():
 
     # .. TODO: more than one script as argument ? ..
     if args[0].endswith('.py') and not options.nopython:
-        options.python = True
+        if options.multiprocess and not args[0].startswith(""python""):
+            # in multiprocessing mode you want to spawn a separate
+            # python process
+            args.insert(0, ""python"")
+        else:
+            options.python = True
+    if options.multiprocess:
+        # multiprocess can't work in python mode
+        options.python = False
     if options.python:
         print(""running as a Python program..."")
         if not args[0].startswith(""python""):
",True,mprof,False
"@@ -223,11 +223,7 @@ def run_action():
             # in multiprocessing mode you want to spawn a separate
             # python process
             args.insert(0, ""python"")
-        else:
-            options.python = True
-    if options.multiprocess:
-        # multiprocess can't work in python mode
-        options.python = False
+            options.python = False
     if options.python:
         print(""running as a Python program..."")
         if not args[0].startswith(""python""):
","@@ -223,11 +223,7 @@ def run_action():
             # in multiprocessing mode you want to spawn a separate
             # python process
             args.insert(0, ""python"")
-        else:
-            options.python = True
-    if options.multiprocess:
-        # multiprocess can't work in python mode
-        options.python = False
+            options.python = False
     if options.python:
         print(""running as a Python program..."")
         if not args[0].startswith(""python""):
",True,mprof,False
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.43'
+__version__ = '0.44'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.43'
+__version__ = '0.44'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -219,10 +219,11 @@ def run_action():
 
     # .. TODO: more than one script as argument ? ..
     if args[0].endswith('.py') and not options.nopython:
-        if options.multiprocess and not args[0].startswith(""python""):
+        if not args[0].startswith(""python""):
+            args.insert(0, ""python"")
+        if options.multiprocess:
             # in multiprocessing mode you want to spawn a separate
             # python process
-            args.insert(0, ""python"")
             options.python = False
     if options.python:
         print(""running as a Python program..."")
","@@ -219,10 +219,11 @@ def run_action():
 
     # .. TODO: more than one script as argument ? ..
     if args[0].endswith('.py') and not options.nopython:
-        if options.multiprocess and not args[0].startswith(""python""):
+        if not args[0].startswith(""python""):
+            args.insert(0, ""python"")
+        if options.multiprocess:
             # in multiprocessing mode you want to spawn a separate
             # python process
-            args.insert(0, ""python"")
             options.python = False
     if options.python:
         print(""running as a Python program..."")
",True,mprof,False
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.44'
+__version__ = '0.45'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.44'
+__version__ = '0.45'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -1077,7 +1077,7 @@ def choose_backend(new_backend=None):
         ('tracemalloc', has_tracemalloc),
         ('no_backend', True)
     ]
-    backends_indices = {b[0]: i for i, b in enumerate(all_backends)}
+    backends_indices = dict((b[0], i) for i, b in enumerate(all_backends))
 
     if new_backend is not None:
         all_backends.insert(0, all_backends.pop(backends_indices[new_backend]))
","@@ -1077,7 +1077,7 @@ def choose_backend(new_backend=None):
         ('tracemalloc', has_tracemalloc),
         ('no_backend', True)
     ]
-    backends_indices = {b[0]: i for i, b in enumerate(all_backends)}
+    backends_indices = dict((b[0], i) for i, b in enumerate(all_backends))
 
     if new_backend is not None:
         all_backends.insert(0, all_backends.pop(backends_indices[new_backend]))
",True,memory_profiler.py,True
"@@ -10,8 +10,8 @@ def my_func():
 @profile
 def test_comprehension():
     # Dict comprehension
-    d_comp = {str(k*k): [v] * (1<<17)
-              for (v, k) in enumerate(range(99, 111))}
+    d_comp = dict((str(k*k), [v] * (1<<17))
+                  for (v, k) in enumerate(range(99, 111)))
 
     # List comprehension
     l_comp = [[i] * (i<<9) for i in range(99)]
@@ -20,7 +20,7 @@ def test_comprehension():
 
     def hh(x=1):
         # Set comprehension
-        s_comp = {('Z',) * (k<<13) for k in range(x, 19 + 2*x)}
+        s_comp = set(('Z',) * (k<<13) for k in range(x, 19 + 2*x))
         return s_comp
 
     val = [range(1, 4), max(1, 4), 42 + len(hh())]
","@@ -10,8 +10,8 @@ def my_func():
 @profile
 def test_comprehension():
     # Dict comprehension
-    d_comp = {str(k*k): [v] * (1<<17)
-              for (v, k) in enumerate(range(99, 111))}
+    d_comp = dict((str(k*k), [v] * (1<<17))
+                  for (v, k) in enumerate(range(99, 111)))
 
     # List comprehension
     l_comp = [[i] * (i<<9) for i in range(99)]
@@ -20,7 +20,7 @@ def test_comprehension():
 
     def hh(x=1):
         # Set comprehension
-        s_comp = {('Z',) * (k<<13) for k in range(x, 19 + 2*x)}
+        s_comp = set(('Z',) * (k<<13) for k in range(x, 19 + 2*x))
         return s_comp
 
     val = [range(1, 4), max(1, 4), 42 + len(hh())]
",True,test/test_gen.py,True
"@@ -1,5 +1,4 @@
 PYTHON ?= python
-IPYTHON ?= ipython
 
 .PHONY: test
 
@@ -15,5 +14,3 @@ test:
 	$(PYTHON) test/test_import.py
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
-	$(IPYTHON) test/test_ipython.py
-
","@@ -1,5 +1,4 @@
 PYTHON ?= python
-IPYTHON ?= ipython
 
 .PHONY: test
 
@@ -15,5 +14,3 @@ test:
 	$(PYTHON) test/test_import.py
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
-	$(IPYTHON) test/test_ipython.py
-
",True,Makefile,False
"@@ -413,7 +413,7 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
             cmem = np.asarray([item[0] for item in data])
 
             # Plot the line to the figure
-            pl.plot(cts, cmem, ""+-""  + mem_line_colors[idx+1 % len(mem_line_colors)],
+            pl.plot(cts, cmem, ""+-""  + mem_line_colors[(idx+1) % len(mem_line_colors)],
                      label=""child {}"".format(proc))
 
             # Detect the maximal child memory point
","@@ -413,7 +413,7 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
             cmem = np.asarray([item[0] for item in data])
 
             # Plot the line to the figure
-            pl.plot(cts, cmem, ""+-""  + mem_line_colors[idx+1 % len(mem_line_colors)],
+            pl.plot(cts, cmem, ""+-""  + mem_line_colors[(idx+1) % len(mem_line_colors)],
                      label=""child {}"".format(proc))
 
             # Detect the maximal child memory point
",True,mprof,False
"@@ -220,7 +220,7 @@ def run_action():
     # .. TODO: more than one script as argument ? ..
     if args[0].endswith('.py') and not options.nopython:
         if not args[0].startswith(""python""):
-            args.insert(0, ""python"")
+            args.insert(0, sys.executable)
         if options.multiprocess:
             # in multiprocessing mode you want to spawn a separate
             # python process
","@@ -220,7 +220,7 @@ def run_action():
     # .. TODO: more than one script as argument ? ..
     if args[0].endswith('.py') and not options.nopython:
         if not args[0].startswith(""python""):
-            args.insert(0, ""python"")
+            args.insert(0, sys.executable)
         if options.multiprocess:
             # in multiprocessing mode you want to spawn a separate
             # python process
",True,mprof,False
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.45'
+__version__ = '0.46'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.45'
+__version__ = '0.46'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -228,7 +228,7 @@ def run_action():
     if options.python:
         print(""running as a Python program..."")
         if not args[0].startswith(""python""):
-            args.insert(0, ""python"")
+            args.insert(0, sys.executable)
         cmd_line = get_cmd_line(args)
         args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
                      ""-o"", mprofile_output)
","@@ -228,7 +228,7 @@ def run_action():
     if options.python:
         print(""running as a Python program..."")
         if not args[0].startswith(""python""):
-            args.insert(0, ""python"")
+            args.insert(0, sys.executable)
         cmd_line = get_cmd_line(args)
         args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
                      ""-o"", mprofile_output)
",True,mprof,False
"@@ -460,8 +460,10 @@ def plot_action():
     except ImportError:
         print(""matplotlib is needed for plotting."")
         sys.exit(1)
-
-    parser = OptionParser(version=mp.__version__)
+    desc = """"""Plots using matplotlib the data file `file.dat` generated
+using `mprof run`. If no .dat file is given, it will take the most recent
+such file in the current directory.""""""
+    parser = OptionParser(version=mp.__version__, usage=""mprof plot [options] [file.dat]"", description=desc)
     parser.disable_interspersed_args()
     parser.add_option(""--title"", ""-t"", dest=""title"", default=None,
                       type=""str"", action=""store"",
","@@ -460,8 +460,10 @@ def plot_action():
     except ImportError:
         print(""matplotlib is needed for plotting."")
         sys.exit(1)
-
-    parser = OptionParser(version=mp.__version__)
+    desc = """"""Plots using matplotlib the data file `file.dat` generated
+using `mprof run`. If no .dat file is given, it will take the most recent
+such file in the current directory.""""""
+    parser = OptionParser(version=mp.__version__, usage=""mprof plot [options] [file.dat]"", description=desc)
     parser.disable_interspersed_args()
     parser.add_option(""--title"", ""-t"", dest=""title"", default=None,
                       type=""str"", action=""store"",
",True,mprof,False
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.46'
+__version__ = '0.47'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.46'
+__version__ = '0.47'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -1108,7 +1108,7 @@ if PY2:
         execfile(filename, ns, ns)
 else:
     def exec_with_profiler(filename, profiler, backend):
-        choose_backend(backend)
+        _backend = choose_backend(backend)
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
         builtins.__dict__['profile'] = profiler
","@@ -1108,7 +1108,7 @@ if PY2:
         execfile(filename, ns, ns)
 else:
     def exec_with_profiler(filename, profiler, backend):
-        choose_backend(backend)
+        _backend = choose_backend(backend)
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
         builtins.__dict__['profile'] = profiler
",True,memory_profiler.py,True
"@@ -351,8 +351,9 @@ def read_mprofile_file(filename):
 def plot_file(filename, index=0, timestamps=True, children=True, options=None):
     try:
         import pylab as pl
-    except ImportError:
+    except ImportError as e:
         print(""matplotlib is needed for plotting."")
+        print(e)
         sys.exit(1)
     import numpy as np  # pylab requires numpy anyway
     mprofile = read_mprofile_file(filename)
@@ -455,11 +456,6 @@ def plot_action():
             raise OptionValueError(""'%s' option must contain two numbers separated with a comma"" % value)
         setattr(parser.values, option.dest, newvalue)
 
-    try:
-        import pylab as pl
-    except ImportError:
-        print(""matplotlib is needed for plotting."")
-        sys.exit(1)
     desc = """"""Plots using matplotlib the data file `file.dat` generated
 using `mprof run`. If no .dat file is given, it will take the most recent
 such file in the current directory.""""""
@@ -477,8 +473,21 @@ such file in the current directory.""""""
                       type=""str"", action=""callback"",
                       callback=get_comma_separated_args,
                       help=""Plot a time-subset of the data. E.g. to plot between 0 and 20.5 seconds: --window 0,20.5"")
+    parser.add_option(""--backend"", 
+                      help=""Specify the Matplotlib backend to use"")
     (options, args) = parser.parse_args()
 
+    try:
+        if options.backend is not None:
+            import matplotlib
+            matplotlib.use(options.backend)
+
+        import pylab as pl
+    except ImportError as e:
+        print(""matplotlib is needed for plotting."")
+        print(e)
+        sys.exit(1)
+
     profiles = glob.glob(""mprofile_??????????????.dat"")
     profiles.sort()
 
","@@ -351,8 +351,9 @@ def read_mprofile_file(filename):
 def plot_file(filename, index=0, timestamps=True, children=True, options=None):
     try:
         import pylab as pl
-    except ImportError:
+    except ImportError as e:
         print(""matplotlib is needed for plotting."")
+        print(e)
         sys.exit(1)
     import numpy as np  # pylab requires numpy anyway
     mprofile = read_mprofile_file(filename)
@@ -455,11 +456,6 @@ def plot_action():
             raise OptionValueError(""'%s' option must contain two numbers separated with a comma"" % value)
         setattr(parser.values, option.dest, newvalue)
 
-    try:
-        import pylab as pl
-    except ImportError:
-        print(""matplotlib is needed for plotting."")
-        sys.exit(1)
     desc = """"""Plots using matplotlib the data file `file.dat` generated
 using `mprof run`. If no .dat file is given, it will take the most recent
 such file in the current directory.""""""
@@ -477,8 +473,21 @@ such file in the current directory.""""""
                       type=""str"", action=""callback"",
                       callback=get_comma_separated_args,
                       help=""Plot a time-subset of the data. E.g. to plot between 0 and 20.5 seconds: --window 0,20.5"")
+    parser.add_option(""--backend"", 
+                      help=""Specify the Matplotlib backend to use"")
     (options, args) = parser.parse_args()
 
+    try:
+        if options.backend is not None:
+            import matplotlib
+            matplotlib.use(options.backend)
+
+        import pylab as pl
+    except ImportError as e:
+        print(""matplotlib is needed for plotting."")
+        print(e)
+        sys.exit(1)
+
     profiles = glob.glob(""mprofile_??????????????.dat"")
     profiles.sort()
 
",True,mprof,False
"@@ -16,6 +16,8 @@ import linecache
 import inspect
 import subprocess
 import logging
+import traceback
+from signal import SIGKILL
 
 
 # TODO: provide alternative when multiprocessing is not available
@@ -239,9 +241,9 @@ class MemTimer(Process):
         self.pipe.send(self.n_measurements)
 
 
-def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
-                 include_children=False, multiprocess=False, max_usage=False,
-                 retval=False, stream=None, backend=None):
+def memory_usage_actual(proc=-1, interval=.1, timeout=None, timestamps=False,
+                        include_children=False, multiprocess=False, max_usage=False,
+                        retval=False, stream=None, backend=None):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -424,6 +426,27 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     return ret
 
 
+def memory_usage(*args, **kwargs):
+    """"""
+    The wrapper function that calls the memory_usage_actual (see above) function!
+
+    When there is an exception in the ""proc"" - the (spawned) monitoring processes don't get killed.
+    Therefore, the whole process hangs indefinitely. Here, we are ensuring that the process gets killed!
+    """"""
+    try:
+        return memory_usage_actual(*args, **kwargs)
+    except Exception:
+        print(traceback.format_exc(), file=sys.stderr)
+        try:  # catch ImportError for psutil
+            import psutil
+            parent = psutil.Process(os.getpid())
+            for child in parent.children(recursive=True):
+                os.kill(child.pid, SIGKILL)
+            os.kill(os.getpid(), SIGKILL)
+        except ImportError:
+            sys.exit()
+
+
 # ..
 # .. utility functions for line-by-line ..
 
","@@ -16,6 +16,8 @@ import linecache
 import inspect
 import subprocess
 import logging
+import traceback
+from signal import SIGKILL
 
 
 # TODO: provide alternative when multiprocessing is not available
@@ -239,9 +241,9 @@ class MemTimer(Process):
         self.pipe.send(self.n_measurements)
 
 
-def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
-                 include_children=False, multiprocess=False, max_usage=False,
-                 retval=False, stream=None, backend=None):
+def memory_usage_actual(proc=-1, interval=.1, timeout=None, timestamps=False,
+                        include_children=False, multiprocess=False, max_usage=False,
+                        retval=False, stream=None, backend=None):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -424,6 +426,27 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     return ret
 
 
+def memory_usage(*args, **kwargs):
+    """"""
+    The wrapper function that calls the memory_usage_actual (see above) function!
+
+    When there is an exception in the ""proc"" - the (spawned) monitoring processes don't get killed.
+    Therefore, the whole process hangs indefinitely. Here, we are ensuring that the process gets killed!
+    """"""
+    try:
+        return memory_usage_actual(*args, **kwargs)
+    except Exception:
+        print(traceback.format_exc(), file=sys.stderr)
+        try:  # catch ImportError for psutil
+            import psutil
+            parent = psutil.Process(os.getpid())
+            for child in parent.children(recursive=True):
+                os.kill(child.pid, SIGKILL)
+            os.kill(os.getpid(), SIGKILL)
+        except ImportError:
+            sys.exit()
+
+
 # ..
 # .. utility functions for line-by-line ..
 
",True,memory_profiler.py,True
"@@ -437,13 +437,12 @@ def memory_usage(*args, **kwargs):
         return memory_usage_actual(*args, **kwargs)
     except Exception:
         print(traceback.format_exc(), file=sys.stderr)
-        try:  # catch ImportError for psutil
-            import psutil
+        if has_psutil:
             parent = psutil.Process(os.getpid())
             for child in parent.children(recursive=True):
                 os.kill(child.pid, SIGKILL)
             os.kill(os.getpid(), SIGKILL)
-        except ImportError:
+        else:
             sys.exit()
 
 
","@@ -437,13 +437,12 @@ def memory_usage(*args, **kwargs):
         return memory_usage_actual(*args, **kwargs)
     except Exception:
         print(traceback.format_exc(), file=sys.stderr)
-        try:  # catch ImportError for psutil
-            import psutil
+        if has_psutil:
             parent = psutil.Process(os.getpid())
             for child in parent.children(recursive=True):
                 os.kill(child.pid, SIGKILL)
             os.kill(os.getpid(), SIGKILL)
-        except ImportError:
+        else:
             sys.exit()
 
 
",True,memory_profiler.py,True
"@@ -1,3 +1,5 @@
+from __future__ import print_function
+
 """"""Profile the memory usage of a Python program""""""
 
 # .. we'll use this to pass it to the child script ..
","@@ -1,3 +1,5 @@
+from __future__ import print_function
+
 """"""Profile the memory usage of a Python program""""""
 
 # .. we'll use this to pass it to the child script ..
",True,memory_profiler.py,True
"@@ -1,5 +1,3 @@
-from __future__ import print_function
-
 """"""Profile the memory usage of a Python program""""""
 
 # .. we'll use this to pass it to the child script ..
@@ -243,9 +241,9 @@ class MemTimer(Process):
         self.pipe.send(self.n_measurements)
 
 
-def memory_usage_actual(proc=-1, interval=.1, timeout=None, timestamps=False,
-                        include_children=False, multiprocess=False, max_usage=False,
-                        retval=False, stream=None, backend=None):
+def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
+                 include_children=False, multiprocess=False, max_usage=False,
+                 retval=False, stream=None, backend=None):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -335,7 +333,21 @@ def memory_usage_actual(proc=-1, interval=.1, timeout=None, timestamps=False,
                          include_children=include_children)
             p.start()
             parent_conn.recv()  # wait until we start getting memory
-            returned = f(*args, **kw)
+
+            # When there is an exception in the ""proc"" - the (spawned) monitoring processes don't get killed.
+            # Therefore, the whole process hangs indefinitely. Here, we are ensuring that the process gets killed!
+            try:
+                returned = f(*args, **kw)
+            except Exception:
+                sys.stderr.write(traceback.format_exc())
+                if has_psutil:
+                    parent = psutil.Process(os.getpid())
+                    for child in parent.children(recursive=True):
+                        os.kill(child.pid, SIGKILL)
+                    os.kill(os.getpid(), SIGKILL)
+                else:
+                    sys.exit()
+
             parent_conn.send(0)  # finish timing
             ret = parent_conn.recv()
             n_measurements = parent_conn.recv()
@@ -428,26 +440,6 @@ def memory_usage_actual(proc=-1, interval=.1, timeout=None, timestamps=False,
     return ret
 
 
-def memory_usage(*args, **kwargs):
-    """"""
-    The wrapper function that calls the memory_usage_actual (see above) function!
-
-    When there is an exception in the ""proc"" - the (spawned) monitoring processes don't get killed.
-    Therefore, the whole process hangs indefinitely. Here, we are ensuring that the process gets killed!
-    """"""
-    try:
-        return memory_usage_actual(*args, **kwargs)
-    except Exception:
-        print(traceback.format_exc(), file=sys.stderr)
-        if has_psutil:
-            parent = psutil.Process(os.getpid())
-            for child in parent.children(recursive=True):
-                os.kill(child.pid, SIGKILL)
-            os.kill(os.getpid(), SIGKILL)
-        else:
-            sys.exit()
-
-
 # ..
 # .. utility functions for line-by-line ..
 
","@@ -1,5 +1,3 @@
-from __future__ import print_function
-
 """"""Profile the memory usage of a Python program""""""
 
 # .. we'll use this to pass it to the child script ..
@@ -243,9 +241,9 @@ class MemTimer(Process):
         self.pipe.send(self.n_measurements)
 
 
-def memory_usage_actual(proc=-1, interval=.1, timeout=None, timestamps=False,
-                        include_children=False, multiprocess=False, max_usage=False,
-                        retval=False, stream=None, backend=None):
+def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
+                 include_children=False, multiprocess=False, max_usage=False,
+                 retval=False, stream=None, backend=None):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -335,7 +333,21 @@ def memory_usage_actual(proc=-1, interval=.1, timeout=None, timestamps=False,
                          include_children=include_children)
             p.start()
             parent_conn.recv()  # wait until we start getting memory
-            returned = f(*args, **kw)
+
+            # When there is an exception in the ""proc"" - the (spawned) monitoring processes don't get killed.
+            # Therefore, the whole process hangs indefinitely. Here, we are ensuring that the process gets killed!
+            try:
+                returned = f(*args, **kw)
+            except Exception:
+                sys.stderr.write(traceback.format_exc())
+                if has_psutil:
+                    parent = psutil.Process(os.getpid())
+                    for child in parent.children(recursive=True):
+                        os.kill(child.pid, SIGKILL)
+                    os.kill(os.getpid(), SIGKILL)
+                else:
+                    sys.exit()
+
             parent_conn.send(0)  # finish timing
             ret = parent_conn.recv()
             n_measurements = parent_conn.recv()
@@ -428,26 +440,6 @@ def memory_usage_actual(proc=-1, interval=.1, timeout=None, timestamps=False,
     return ret
 
 
-def memory_usage(*args, **kwargs):
-    """"""
-    The wrapper function that calls the memory_usage_actual (see above) function!
-
-    When there is an exception in the ""proc"" - the (spawned) monitoring processes don't get killed.
-    Therefore, the whole process hangs indefinitely. Here, we are ensuring that the process gets killed!
-    """"""
-    try:
-        return memory_usage_actual(*args, **kwargs)
-    except Exception:
-        print(traceback.format_exc(), file=sys.stderr)
-        if has_psutil:
-            parent = psutil.Process(os.getpid())
-            for child in parent.children(recursive=True):
-                os.kill(child.pid, SIGKILL)
-            os.kill(os.getpid(), SIGKILL)
-        else:
-            sys.exit()
-
-
 # ..
 # .. utility functions for line-by-line ..
 
",True,memory_profiler.py,True
"@@ -14,3 +14,4 @@ test:
 	$(PYTHON) test/test_import.py
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
+	$(PYTHON) test/test_exception.py
","@@ -14,3 +14,4 @@ test:
 	$(PYTHON) test/test_import.py
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
+	$(PYTHON) test/test_exception.py
",True,Makefile,False
"@@ -447,6 +447,8 @@ cleanup.
 
 `Benjamin Bengfort <https://github.com/bbengfort>`_ added support for tracking the usage of individual child processes and plotting them.
 
+`Muhammad Haseeb Tariq <https://github.com/mhaseebtariq>`_ fixed issue #152, which made the whole interpreter hang on functions that launched an exception.
+
 =========
  License
 =========
","@@ -447,6 +447,8 @@ cleanup.
 
 `Benjamin Bengfort <https://github.com/bbengfort>`_ added support for tracking the usage of individual child processes and plotting them.
 
+`Muhammad Haseeb Tariq <https://github.com/mhaseebtariq>`_ fixed issue #152, which made the whole interpreter hang on functions that launched an exception.
+
 =========
  License
 =========
",True,README.rst,False
"@@ -326,6 +326,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             raise ValueError
 
         while True:
+            exit_block = False
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
             p = MemTimer(os.getpid(), interval, child_conn, backend,
                          timestamps=timestamps,
@@ -338,23 +339,21 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             # Therefore, the whole process hangs indefinitely. Here, we are ensuring that the process gets killed!
             try:
                 returned = f(*args, **kw)
+                parent_conn.send(0)  # finish timing
+                ret = parent_conn.recv()
+                n_measurements = parent_conn.recv()
+                if retval:
+                    ret = ret, returned
             except Exception:
-                sys.stderr.write(traceback.format_exc())
                 if has_psutil:
                     parent = psutil.Process(os.getpid())
                     for child in parent.children(recursive=True):
                         os.kill(child.pid, SIGKILL)
-                    os.kill(os.getpid(), SIGKILL)
-                else:
-                    sys.exit()
+                p.join(0)
+                raise
 
-            parent_conn.send(0)  # finish timing
-            ret = parent_conn.recv()
-            n_measurements = parent_conn.recv()
-            if retval:
-                ret = ret, returned
             p.join(5 * interval)
-            if n_measurements > 4 or interval < 1e-6:
+            if exit_block or n_measurements > 4 or interval < 1e-6:
                 break
             interval /= 10.
     elif isinstance(proc, subprocess.Popen):
","@@ -326,6 +326,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             raise ValueError
 
         while True:
+            exit_block = False
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
             p = MemTimer(os.getpid(), interval, child_conn, backend,
                          timestamps=timestamps,
@@ -338,23 +339,21 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             # Therefore, the whole process hangs indefinitely. Here, we are ensuring that the process gets killed!
             try:
                 returned = f(*args, **kw)
+                parent_conn.send(0)  # finish timing
+                ret = parent_conn.recv()
+                n_measurements = parent_conn.recv()
+                if retval:
+                    ret = ret, returned
             except Exception:
-                sys.stderr.write(traceback.format_exc())
                 if has_psutil:
                     parent = psutil.Process(os.getpid())
                     for child in parent.children(recursive=True):
                         os.kill(child.pid, SIGKILL)
-                    os.kill(os.getpid(), SIGKILL)
-                else:
-                    sys.exit()
+                p.join(0)
+                raise
 
-            parent_conn.send(0)  # finish timing
-            ret = parent_conn.recv()
-            n_measurements = parent_conn.recv()
-            if retval:
-                ret = ret, returned
             p.join(5 * interval)
-            if n_measurements > 4 or interval < 1e-6:
+            if exit_block or n_measurements > 4 or interval < 1e-6:
                 break
             interval /= 10.
     elif isinstance(proc, subprocess.Popen):
",True,memory_profiler.py,True
"@@ -0,0 +1,12 @@
+
+# make sure that memory profiler does not hang on exception
+from memory_profiler import memory_usage
+
+def foo():
+    raise NotImplementedError('Error')
+
+try:
+    out = memory_usage((foo, tuple(), {}), timeout=1)
+except NotImplementedError:
+    pass
+print('Success')
","@@ -0,0 +1,12 @@
+
+# make sure that memory profiler does not hang on exception
+from memory_profiler import memory_usage
+
+def foo():
+    raise NotImplementedError('Error')
+
+try:
+    out = memory_usage((foo, tuple(), {}), timeout=1)
+except NotImplementedError:
+    pass
+print('Success')
",True,test/test_exception.py,True
"@@ -326,7 +326,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             raise ValueError
 
         while True:
-            exit_block = False
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
             p = MemTimer(os.getpid(), interval, child_conn, backend,
                          timestamps=timestamps,
@@ -353,7 +352,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 raise
 
             p.join(5 * interval)
-            if exit_block or n_measurements > 4 or interval < 1e-6:
+            if n_measurements > 4 or interval < 1e-6:
                 break
             interval /= 10.
     elif isinstance(proc, subprocess.Popen):
","@@ -326,7 +326,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             raise ValueError
 
         while True:
-            exit_block = False
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
             p = MemTimer(os.getpid(), interval, child_conn, backend,
                          timestamps=timestamps,
@@ -353,7 +352,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 raise
 
             p.join(5 * interval)
-            if exit_block or n_measurements > 4 or interval < 1e-6:
+            if n_measurements > 4 or interval < 1e-6:
                 break
             interval /= 10.
     elif isinstance(proc, subprocess.Popen):
",True,memory_profiler.py,True
"@@ -139,7 +139,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
         # .. cross-platform but but requires psutil ..
         process = psutil.Process(pid)
         try:
-            # avoid useing get_memory_info since it does not exists
+            # avoid using get_memory_info since it does not exists
             # in psutil > 2.0 and accessing it will cause exception.
             meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') \
                 else 'get_memory_info'
","@@ -139,7 +139,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
         # .. cross-platform but but requires psutil ..
         process = psutil.Process(pid)
         try:
-            # avoid useing get_memory_info since it does not exists
+            # avoid using get_memory_info since it does not exists
             # in psutil > 2.0 and accessing it will cause exception.
             meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') \
                 else 'get_memory_info'
",True,memory_profiler.py,True
"@@ -173,7 +173,7 @@ parent's usage and track each child individual.
 
 To create a report that combines memory usage of all the children and the
 parent, use the ``include_children`` flag in either the ``profile`` decorator or
-ass a command line argument to ``mprof``::
+as a command line argument to ``mprof``::
 
     mprof run --include-children <script>
 
","@@ -173,7 +173,7 @@ parent's usage and track each child individual.
 
 To create a report that combines memory usage of all the children and the
 parent, use the ``include_children`` flag in either the ``profile`` decorator or
-ass a command line argument to ``mprof``::
+as a command line argument to ``mprof``::
 
     mprof run --include-children <script>
 
",True,README.rst,False
"@@ -7,9 +7,8 @@
 
 This is a python module for monitoring memory consumption of a process
 as well as line-by-line analysis of memory consumption for python
-programs. It is a pure python module and has the `psutil
-<http://pypi.python.org/pypi/psutil>`_ module as optional (but highly
-recommended) dependencies.
+programs. It is a pure python module which depends on the `psutil
+<http://pypi.python.org/pypi/psutil>`_ module.
 
 
 ==============
@@ -385,7 +384,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
       between runs.
 
     * Q: Does it work under windows ?
-    * A: Yes, but you will need the
+    * A: Yes, thanks to the
       `psutil <http://pypi.python.org/pypi/psutil>`_ module.
 
 
","@@ -7,9 +7,8 @@
 
 This is a python module for monitoring memory consumption of a process
 as well as line-by-line analysis of memory consumption for python
-programs. It is a pure python module and has the `psutil
-<http://pypi.python.org/pypi/psutil>`_ module as optional (but highly
-recommended) dependencies.
+programs. It is a pure python module which depends on the `psutil
+<http://pypi.python.org/pypi/psutil>`_ module.
 
 
 ==============
@@ -385,7 +384,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
       between runs.
 
     * Q: Does it work under windows ?
-    * A: Yes, but you will need the
+    * A: Yes, thanks to the
       `psutil <http://pypi.python.org/pypi/psutil>`_ module.
 
 
",True,README.rst,False
"@@ -19,6 +19,8 @@ import logging
 import traceback
 from signal import SIGKILL
 
+import psutil
+
 
 # TODO: provide alternative when multiprocessing is not available
 try:
@@ -48,13 +50,6 @@ else:
         return str(x)
 
 # .. get available packages ..
-try:
-    import psutil
-
-    has_psutil = True
-except ImportError:
-    has_psutil = False
-
 try:
     import tracemalloc
 
@@ -92,12 +87,6 @@ def _get_child_memory(process, meminfo_attr=None):
     """"""
     Returns a generator that yields memory for all child processes.
     """"""
-    if not has_psutil:
-        raise NotImplementedError((
-            ""The psutil module is required to monitor the ""
-            ""memory usage of child processes.""
-        ))
-
     # Convert a pid to a process
     if isinstance(process, int):
         if process == -1: process = os.getpid()
@@ -344,10 +333,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 if retval:
                     ret = ret, returned
             except Exception:
-                if has_psutil:
-                    parent = psutil.Process(os.getpid())
-                    for child in parent.children(recursive=True):
-                        os.kill(child.pid, SIGKILL)
+                parent = psutil.Process(os.getpid())
+                for child in parent.children(recursive=True):
+                    os.kill(child.pid, SIGKILL)
                 p.join(0)
                 raise
 
@@ -1086,10 +1074,9 @@ def choose_backend(new_backend=None):
 
     _backend = 'no_backend'
     all_backends = [
-        ('psutil', has_psutil),
+        ('psutil', True),
         ('posix', os.name == 'posix'),
         ('tracemalloc', has_tracemalloc),
-        ('no_backend', True)
     ]
     backends_indices = dict((b[0], i) for i, b in enumerate(all_backends))
 
@@ -1100,10 +1087,6 @@ def choose_backend(new_backend=None):
         if is_available:
             _backend = n_backend
             break
-    if _backend == 'no_backend':
-        raise NotImplementedError(
-            'Tracemalloc or psutil module is required for non-unix '
-            'platforms')
     if _backend != new_backend and new_backend is not None:
         warnings.warn('{0} can not be used, {1} used instead'.format(
             new_backend, _backend))
","@@ -19,6 +19,8 @@ import logging
 import traceback
 from signal import SIGKILL
 
+import psutil
+
 
 # TODO: provide alternative when multiprocessing is not available
 try:
@@ -48,13 +50,6 @@ else:
         return str(x)
 
 # .. get available packages ..
-try:
-    import psutil
-
-    has_psutil = True
-except ImportError:
-    has_psutil = False
-
 try:
     import tracemalloc
 
@@ -92,12 +87,6 @@ def _get_child_memory(process, meminfo_attr=None):
     """"""
     Returns a generator that yields memory for all child processes.
     """"""
-    if not has_psutil:
-        raise NotImplementedError((
-            ""The psutil module is required to monitor the ""
-            ""memory usage of child processes.""
-        ))
-
     # Convert a pid to a process
     if isinstance(process, int):
         if process == -1: process = os.getpid()
@@ -344,10 +333,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 if retval:
                     ret = ret, returned
             except Exception:
-                if has_psutil:
-                    parent = psutil.Process(os.getpid())
-                    for child in parent.children(recursive=True):
-                        os.kill(child.pid, SIGKILL)
+                parent = psutil.Process(os.getpid())
+                for child in parent.children(recursive=True):
+                    os.kill(child.pid, SIGKILL)
                 p.join(0)
                 raise
 
@@ -1086,10 +1074,9 @@ def choose_backend(new_backend=None):
 
     _backend = 'no_backend'
     all_backends = [
-        ('psutil', has_psutil),
+        ('psutil', True),
         ('posix', os.name == 'posix'),
         ('tracemalloc', has_tracemalloc),
-        ('no_backend', True)
     ]
     backends_indices = dict((b[0], i) for i, b in enumerate(all_backends))
 
@@ -1100,10 +1087,6 @@ def choose_backend(new_backend=None):
         if is_available:
             _backend = n_backend
             break
-    if _backend == 'no_backend':
-        raise NotImplementedError(
-            'Tracemalloc or psutil module is required for non-unix '
-            'platforms')
     if _backend != new_backend and new_backend is not None:
         warnings.warn('{0} can not be used, {1} used instead'.format(
             new_backend, _backend))
",True,memory_profiler.py,True
"@@ -30,6 +30,7 @@ setup(
     url='http://pypi.python.org/pypi/memory_profiler',
     py_modules=['memory_profiler'],
     scripts=['mprof'],
+    install_requires=['psutil'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='BSD'
 
","@@ -30,6 +30,7 @@ setup(
     url='http://pypi.python.org/pypi/memory_profiler',
     py_modules=['memory_profiler'],
     scripts=['mprof'],
+    install_requires=['psutil'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='BSD'
 
",True,setup.py,True
"@@ -1,7 +1,27 @@
-import memory_profiler
+import os
+import io
+import re
 from distutils.core import setup
 import setuptools
 
+
+# https://packaging.python.org/guides/single-sourcing-package-version/
+def read(*names, **kwargs):
+    with io.open(
+        os.path.join(os.path.dirname(__file__), *names),
+        encoding=kwargs.get(""encoding"", ""utf8"")
+    ) as fp:
+        return fp.read()
+
+
+def find_version(*file_paths):
+    version_file = read(*file_paths)
+    version_match = re.search(r""^__version__ = ['\""]([^'\""]*)['\""]"",
+                              version_file, re.M)
+    if version_match:
+        return version_match.group(1)
+
+
 CLASSIFIERS = """"""\
 Development Status :: 5 - Production/Stable
 Intended Audience :: Science/Research
@@ -24,7 +44,7 @@ setup(
     name='memory_profiler',
     description='A module for monitoring memory usage of a python program',
     long_description=open('README.rst').read(),
-    version=memory_profiler.__version__,
+    version=find_version(""memory_profiler.py""),
     author='Fabian Pedregosa',
     author_email='f@bianp.net',
     url='http://pypi.python.org/pypi/memory_profiler',
","@@ -1,7 +1,27 @@
-import memory_profiler
+import os
+import io
+import re
 from distutils.core import setup
 import setuptools
 
+
+# https://packaging.python.org/guides/single-sourcing-package-version/
+def read(*names, **kwargs):
+    with io.open(
+        os.path.join(os.path.dirname(__file__), *names),
+        encoding=kwargs.get(""encoding"", ""utf8"")
+    ) as fp:
+        return fp.read()
+
+
+def find_version(*file_paths):
+    version_file = read(*file_paths)
+    version_match = re.search(r""^__version__ = ['\""]([^'\""]*)['\""]"",
+                              version_file, re.M)
+    if version_match:
+        return version_match.group(1)
+
+
 CLASSIFIERS = """"""\
 Development Status :: 5 - Production/Stable
 Intended Audience :: Science/Research
@@ -24,7 +44,7 @@ setup(
     name='memory_profiler',
     description='A module for monitoring memory usage of a python program',
     long_description=open('README.rst').read(),
-    version=memory_profiler.__version__,
+    version=find_version(""memory_profiler.py""),
     author='Fabian Pedregosa',
     author_email='f@bianp.net',
     url='http://pypi.python.org/pypi/memory_profiler',
",True,setup.py,True
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.47'
+__version__ = '0.48.dev0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.47'
+__version__ = '0.48.dev0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -1,8 +1,7 @@
 import os
 import io
 import re
-from distutils.core import setup
-import setuptools
+from setuptools import setup
 
 
 # https://packaging.python.org/guides/single-sourcing-package-version/
@@ -53,5 +52,4 @@ setup(
     install_requires=['psutil'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='BSD'
-
 )
","@@ -1,8 +1,7 @@
 import os
 import io
 import re
-from distutils.core import setup
-import setuptools
+from setuptools import setup
 
 
 # https://packaging.python.org/guides/single-sourcing-package-version/
@@ -53,5 +52,4 @@ setup(
     install_requires=['psutil'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='BSD'
-
 )
",True,setup.py,True
"@@ -3,7 +3,6 @@ python:
   - ""2.7""
   - ""3.3""
 install:
-  - sudo apt-get update
   # We do this conditionally because it saves us some downloading if the
   # version is the same.
   - if [[ ""$TRAVIS_PYTHON_VERSION"" == ""2.7"" ]]; then
@@ -24,4 +23,6 @@ install:
   - source activate test-environment
   - python setup.py install
 script:
-  - make test
\ No newline at end of file
+  - make test
+
+sudo: false
","@@ -3,7 +3,6 @@ python:
   - ""2.7""
   - ""3.3""
 install:
-  - sudo apt-get update
   # We do this conditionally because it saves us some downloading if the
   # version is the same.
   - if [[ ""$TRAVIS_PYTHON_VERSION"" == ""2.7"" ]]; then
@@ -24,4 +23,6 @@ install:
   - source activate test-environment
   - python setup.py install
 script:
-  - make test
\ No newline at end of file
+  - make test
+
+sudo: false
",True,.travis.yml,False
"@@ -0,0 +1,27 @@
+from memory_profiler import profile
+
+
+def gen(count):
+    r = list(range(0,count))
+    return r
+
+_global_var = []
+def _gen_cache():
+    global _global_var
+    if not _global_var:
+        _global_var = gen(1000000)
+
+@profile(precision=4)
+def test():
+    a = gen(90000)
+    for i in range(0,3):
+        b = i
+        def _inner_gen():
+            gen(1024*1024*20)
+        h = i
+        _gen_cache()
+        _inner_gen()
+        g = i
+
+if __name__ == ""__main__"":
+    test()
","@@ -0,0 +1,27 @@
+from memory_profiler import profile
+
+
+def gen(count):
+    r = list(range(0,count))
+    return r
+
+_global_var = []
+def _gen_cache():
+    global _global_var
+    if not _global_var:
+        _global_var = gen(1000000)
+
+@profile(precision=4)
+def test():
+    a = gen(90000)
+    for i in range(0,3):
+        b = i
+        def _inner_gen():
+            gen(1024*1024*20)
+        h = i
+        _gen_cache()
+        _inner_gen()
+        g = i
+
+if __name__ == ""__main__"":
+    test()
",True,delta_memory_test.py,True
"@@ -581,12 +581,18 @@ class CodeMap(dict):
         for subcode in filter(inspect.iscode, code.co_consts):
             self.add(subcode, toplevel_code=toplevel_code)
 
-    def trace(self, code, lineno):
+    def trace(self, code, lineno, prev_lineno):
         memory = _get_memory(-1, self.backend, include_children=self.include_children,
                              filename=code.co_filename)
-        # if there is already a measurement for that line get the max
-        previous_memory = self[code].get(lineno, 0)
-        self[code][lineno] = max(memory, previous_memory)
+        prev_value = self[code].get(lineno, None)
+        previous_memory = prev_value[1] if prev_value else 0
+        previous_inc = prev_value[0] if prev_value else 0
+
+        prev_line_value = self[code].get(prev_lineno, None) if prev_lineno else None
+        prev_line_memory = prev_line_value[1] if prev_line_value else 0
+        #inc = (memory-prev_line_memory)
+        #print('trace lineno=%(lineno)s prev_lineno=%(prev_lineno)s mem=%(memory)s prev_inc=%(previous_inc)s inc=%(inc)s' % locals())
+        self[code][lineno] = (previous_inc + (memory-prev_line_memory), max(memory, previous_memory))
 
     def items(self):
         """"""Iterate on the toplevel code blocks.""""""
@@ -610,6 +616,7 @@ class LineProfiler(object):
         self.max_mem = kw.get('max_mem', None)
         self.prevlines = []
         self.backend = choose_backend(kw.get('backend', None))
+        self.prev_lineno = None
 
     def __call__(self, func=None, precision=1):
         if func is not None:
@@ -684,10 +691,15 @@ class LineProfiler(object):
                 # ""call"" event just saves the lineno but not the memory
                 self.prevlines.append(frame.f_lineno)
             elif event == 'line':
-                self.code_map.trace(frame.f_code, self.prevlines[-1])
+                # trace needs current line and previous line
+                self.code_map.trace(frame.f_code, self.prevlines[-1], self.prev_lineno)
+                # saving previous line
+                self.prev_lineno = self.prevlines[-1]
                 self.prevlines[-1] = frame.f_lineno
             elif event == 'return':
-                self.code_map.trace(frame.f_code, self.prevlines.pop())
+                lineno = self.prevlines.pop()
+                self.code_map.trace(frame.f_code, lineno, self.prev_lineno)
+                self.prev_lineno = lineno
 
         if self._original_trace_function is not None:
             self._original_trace_function(frame, event, arg)
@@ -748,20 +760,20 @@ def show_results(prof, stream=None, precision=1):
         stream.write(u'=' * len(header) + '\n')
 
         all_lines = linecache.getlines(filename)
-        mem_old = None
+
         float_format = u'{0}.{1}f'.format(precision + 4, precision)
         template_mem = u'{0:' + float_format + '} MiB'
         for (lineno, mem) in lines:
             if mem:
-                inc = (mem - mem_old) if mem_old else 0
-                mem_old = mem
+                inc = mem[0]
+                mem = mem[1]
                 mem = template_mem.format(mem)
                 inc = template_mem.format(inc)
             else:
                 mem = u''
                 inc = u''
             tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
-            stream.write(unicode(tmp, 'UTF-8'))
+            stream.write(unicode(tmp))
         stream.write(u'\n\n')
 
 
","@@ -581,12 +581,18 @@ class CodeMap(dict):
         for subcode in filter(inspect.iscode, code.co_consts):
             self.add(subcode, toplevel_code=toplevel_code)
 
-    def trace(self, code, lineno):
+    def trace(self, code, lineno, prev_lineno):
         memory = _get_memory(-1, self.backend, include_children=self.include_children,
                              filename=code.co_filename)
-        # if there is already a measurement for that line get the max
-        previous_memory = self[code].get(lineno, 0)
-        self[code][lineno] = max(memory, previous_memory)
+        prev_value = self[code].get(lineno, None)
+        previous_memory = prev_value[1] if prev_value else 0
+        previous_inc = prev_value[0] if prev_value else 0
+
+        prev_line_value = self[code].get(prev_lineno, None) if prev_lineno else None
+        prev_line_memory = prev_line_value[1] if prev_line_value else 0
+        #inc = (memory-prev_line_memory)
+        #print('trace lineno=%(lineno)s prev_lineno=%(prev_lineno)s mem=%(memory)s prev_inc=%(previous_inc)s inc=%(inc)s' % locals())
+        self[code][lineno] = (previous_inc + (memory-prev_line_memory), max(memory, previous_memory))
 
     def items(self):
         """"""Iterate on the toplevel code blocks.""""""
@@ -610,6 +616,7 @@ class LineProfiler(object):
         self.max_mem = kw.get('max_mem', None)
         self.prevlines = []
         self.backend = choose_backend(kw.get('backend', None))
+        self.prev_lineno = None
 
     def __call__(self, func=None, precision=1):
         if func is not None:
@@ -684,10 +691,15 @@ class LineProfiler(object):
                 # ""call"" event just saves the lineno but not the memory
                 self.prevlines.append(frame.f_lineno)
             elif event == 'line':
-                self.code_map.trace(frame.f_code, self.prevlines[-1])
+                # trace needs current line and previous line
+                self.code_map.trace(frame.f_code, self.prevlines[-1], self.prev_lineno)
+                # saving previous line
+                self.prev_lineno = self.prevlines[-1]
                 self.prevlines[-1] = frame.f_lineno
             elif event == 'return':
-                self.code_map.trace(frame.f_code, self.prevlines.pop())
+                lineno = self.prevlines.pop()
+                self.code_map.trace(frame.f_code, lineno, self.prev_lineno)
+                self.prev_lineno = lineno
 
         if self._original_trace_function is not None:
             self._original_trace_function(frame, event, arg)
@@ -748,20 +760,20 @@ def show_results(prof, stream=None, precision=1):
         stream.write(u'=' * len(header) + '\n')
 
         all_lines = linecache.getlines(filename)
-        mem_old = None
+
         float_format = u'{0}.{1}f'.format(precision + 4, precision)
         template_mem = u'{0:' + float_format + '} MiB'
         for (lineno, mem) in lines:
             if mem:
-                inc = (mem - mem_old) if mem_old else 0
-                mem_old = mem
+                inc = mem[0]
+                mem = mem[1]
                 mem = template_mem.format(mem)
                 inc = template_mem.format(inc)
             else:
                 mem = u''
                 inc = u''
             tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
-            stream.write(unicode(tmp, 'UTF-8'))
+            stream.write(unicode(tmp))
         stream.write(u'\n\n')
 
 
",True,memory_profiler.py,True
"@@ -773,7 +773,7 @@ def show_results(prof, stream=None, precision=1):
                 mem = u''
                 inc = u''
             tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
-            stream.write(unicode(tmp))
+            stream.write(unicode(tmp, 'UTF-8'))
         stream.write(u'\n\n')
 
 
","@@ -773,7 +773,7 @@ def show_results(prof, stream=None, precision=1):
                 mem = u''
                 inc = u''
             tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
-            stream.write(unicode(tmp))
+            stream.write(unicode(tmp, 'UTF-8'))
         stream.write(u'\n\n')
 
 
",True,memory_profiler.py,True
"@@ -2,26 +2,10 @@ language: python
 python:
   - ""2.7""
   - ""3.3""
-install:
-  # We do this conditionally because it saves us some downloading if the
-  # version is the same.
-  - if [[ ""$TRAVIS_PYTHON_VERSION"" == ""2.7"" ]]; then
-      wget https://repo.continuum.io/miniconda/Miniconda-latest-Linux-x86_64.sh -O miniconda.sh;
-    else
-      wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh -O miniconda.sh;
-    fi
-  - bash miniconda.sh -b -p $HOME/miniconda
-  - export PATH=""$HOME/miniconda/bin:$PATH""
-  - hash -r
-  - conda config --set always_yes yes --set changeps1 no
-  - conda update -q conda
-  # Useful for debugging any issues with conda
-  - conda info -a
 
-  # Replace dep1 dep2 ... with your dependencies
-  - conda create -q -n test-environment python=$TRAVIS_PYTHON_VERSION numpy nose ipython
-  - source activate test-environment
-  - python setup.py install
+install:
+  - python -m pip install numpy ipython
+  - python -m pip install .
 script:
   - make test
 
","@@ -2,26 +2,10 @@ language: python
 python:
   - ""2.7""
   - ""3.3""
-install:
-  # We do this conditionally because it saves us some downloading if the
-  # version is the same.
-  - if [[ ""$TRAVIS_PYTHON_VERSION"" == ""2.7"" ]]; then
-      wget https://repo.continuum.io/miniconda/Miniconda-latest-Linux-x86_64.sh -O miniconda.sh;
-    else
-      wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh -O miniconda.sh;
-    fi
-  - bash miniconda.sh -b -p $HOME/miniconda
-  - export PATH=""$HOME/miniconda/bin:$PATH""
-  - hash -r
-  - conda config --set always_yes yes --set changeps1 no
-  - conda update -q conda
-  # Useful for debugging any issues with conda
-  - conda info -a
 
-  # Replace dep1 dep2 ... with your dependencies
-  - conda create -q -n test-environment python=$TRAVIS_PYTHON_VERSION numpy nose ipython
-  - source activate test-environment
-  - python setup.py install
+install:
+  - python -m pip install numpy ipython
+  - python -m pip install .
 script:
   - make test
 
",True,.travis.yml,False
"@@ -2,6 +2,9 @@ language: python
 python:
   - ""2.7""
   - ""3.3""
+  - ""3.4""
+  - ""3.5""
+  - ""3.6""
 
 install:
   - python -m pip install numpy ipython
","@@ -2,6 +2,9 @@ language: python
 python:
   - ""2.7""
   - ""3.3""
+  - ""3.4""
+  - ""3.5""
+  - ""3.6""
 
 install:
   - python -m pip install numpy ipython
",True,.travis.yml,False
"@@ -6,6 +6,11 @@ python:
   - ""3.5""
   - ""3.6""
 
+matrix:
+  allow_failures:
+    - python: ""pypy3""
+    - python: ""3.7-dev""
+
 install:
   - python -m pip install numpy ipython
   - python -m pip install .
","@@ -6,6 +6,11 @@ python:
   - ""3.5""
   - ""3.6""
 
+matrix:
+  allow_failures:
+    - python: ""pypy3""
+    - python: ""3.7-dev""
+
 install:
   - python -m pip install numpy ipython
   - python -m pip install .
",True,.travis.yml,False
"@@ -448,6 +448,8 @@ cleanup.
 
 `Muhammad Haseeb Tariq <https://github.com/mhaseebtariq>`_ fixed issue #152, which made the whole interpreter hang on functions that launched an exception.
 
+`Juan Luis Cano <https://github.com/Juanlu001>`_ modernized the infrastructure and helped with various things.
+
 =========
  License
 =========
","@@ -448,6 +448,8 @@ cleanup.
 
 `Muhammad Haseeb Tariq <https://github.com/mhaseebtariq>`_ fixed issue #152, which made the whole interpreter hang on functions that launched an exception.
 
+`Juan Luis Cano <https://github.com/Juanlu001>`_ modernized the infrastructure and helped with various things.
+
 =========
  License
 =========
",True,README.rst,False
"@@ -5,6 +5,8 @@ python:
   - ""3.4""
   - ""3.5""
   - ""3.6""
+  - ""3.7-dev""
+  - ""pypy3""
 
 matrix:
   allow_failures:
","@@ -5,6 +5,8 @@ python:
   - ""3.4""
   - ""3.5""
   - ""3.6""
+  - ""3.7-dev""
+  - ""pypy3""
 
 matrix:
   allow_failures:
",True,.travis.yml,False
"@@ -1164,55 +1164,48 @@ class LogFile(object):
 
 
 if __name__ == '__main__':
-    from optparse import OptionParser
+    from argparse import ArgumentParser
 
-    parser = OptionParser(usage=_CMD_USAGE, version=__version__)
-    parser.disable_interspersed_args()
-    parser.add_option(
+    parser = ArgumentParser(usage=_CMD_USAGE)
+    parser.add_argument('--version', action='version', version=__version__)
+    parser.add_argument(
         '--pdb-mmem', dest='max_mem', metavar='MAXMEM',
-        type='float', action='store',
+        type=float, action='store',
         help='step into the debugger when memory exceeds MAXMEM')
-    parser.add_option(
-        '--precision', dest='precision', type='int',
+    parser.add_argument(
+        '--precision', dest='precision', type=int,
         action='store', default=3,
         help='precision of memory output in number of significant digits')
-    parser.add_option('-o', dest='out_filename', type='str',
-                      action='store', default=None,
-                      help='path to a file where results will be written')
-    parser.add_option('--timestamp', dest='timestamp', default=False,
-                      action='store_true',
-                      help='''print timestamp instead of memory measurement for
-                      decorated functions''')
-    parser.add_option('--backend', dest='backend', type='choice',
-                      action='store',
-                      choices=['tracemalloc', 'psutil', 'posix'],
-                      default='psutil',
-                      help='backend using for getting memory info '
-                           '(one of the {tracemalloc, psutil, posix})')
-
-    if not sys.argv[1:]:
-        parser.print_help()
-        sys.exit(2)
-
-    (options, args) = parser.parse_args()
-    sys.argv[:] = args  # Remove every memory_profiler arguments
-
-    script_filename = _find_script(args[0])
-    _backend = choose_backend(options.backend)
-    if options.timestamp:
+    parser.add_argument('-o', dest='out_filename', type=str,
+        action='store', default=None,
+        help='path to a file where results will be written')
+    parser.add_argument('--timestamp', dest='timestamp', default=False,
+        action='store_true',
+        help='''print timestamp instead of memory measurement for
+        decorated functions''')
+    parser.add_argument('--backend', dest='backend', type=str, action='store',
+        choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
+        help='backend using for getting memory info '
+             '(one of the {tracemalloc, psutil, posix})')
+    parser.add_argument('script', help='script file run on memory_profiler')
+    args = parser.parse_args()
+
+    script_filename = _find_script(args.script)
+    _backend = choose_backend(args.backend)
+    if args.timestamp:
         prof = TimeStamper(_backend)
     else:
-        prof = LineProfiler(max_mem=options.max_mem, backend=_backend)
+        prof = LineProfiler(max_mem=args.max_mem, backend=_backend)
 
     try:
-        exec_with_profiler(script_filename, prof, options.backend)
+        exec_with_profiler(script_filename, prof, args.backend)
     finally:
-        if options.out_filename is not None:
-            out_file = open(options.out_filename, ""a"")
+        if args.out_filename is not None:
+            out_file = open(args.out_filename, ""a"")
         else:
             out_file = sys.stdout
 
-        if options.timestamp:
+        if args.timestamp:
             prof.show_results(stream=out_file)
         else:
-            show_results(prof, precision=options.precision, stream=out_file)
+            show_results(prof, precision=args.precision, stream=out_file)
","@@ -1164,55 +1164,48 @@ class LogFile(object):
 
 
 if __name__ == '__main__':
-    from optparse import OptionParser
+    from argparse import ArgumentParser
 
-    parser = OptionParser(usage=_CMD_USAGE, version=__version__)
-    parser.disable_interspersed_args()
-    parser.add_option(
+    parser = ArgumentParser(usage=_CMD_USAGE)
+    parser.add_argument('--version', action='version', version=__version__)
+    parser.add_argument(
         '--pdb-mmem', dest='max_mem', metavar='MAXMEM',
-        type='float', action='store',
+        type=float, action='store',
         help='step into the debugger when memory exceeds MAXMEM')
-    parser.add_option(
-        '--precision', dest='precision', type='int',
+    parser.add_argument(
+        '--precision', dest='precision', type=int,
         action='store', default=3,
         help='precision of memory output in number of significant digits')
-    parser.add_option('-o', dest='out_filename', type='str',
-                      action='store', default=None,
-                      help='path to a file where results will be written')
-    parser.add_option('--timestamp', dest='timestamp', default=False,
-                      action='store_true',
-                      help='''print timestamp instead of memory measurement for
-                      decorated functions''')
-    parser.add_option('--backend', dest='backend', type='choice',
-                      action='store',
-                      choices=['tracemalloc', 'psutil', 'posix'],
-                      default='psutil',
-                      help='backend using for getting memory info '
-                           '(one of the {tracemalloc, psutil, posix})')
+    parser.add_argument('-o', dest='out_filename', type=str,
+        action='store', default=None,
+        help='path to a file where results will be written')
+    parser.add_argument('--timestamp', dest='timestamp', default=False,
+        action='store_true',
+        help='''print timestamp instead of memory measurement for
+        decorated functions''')
+    parser.add_argument('--backend', dest='backend', type=str, action='store',
+        choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
+        help='backend using for getting memory info '
+             '(one of the {tracemalloc, psutil, posix})')
+    parser.add_argument('script', help='script file run on memory_profiler')
+    args = parser.parse_args()
 
-    if not sys.argv[1:]:
-        parser.print_help()
-        sys.exit(2)
-
-    (options, args) = parser.parse_args()
-    sys.argv[:] = args  # Remove every memory_profiler arguments
-
-    script_filename = _find_script(args[0])
-    _backend = choose_backend(options.backend)
-    if options.timestamp:
+    script_filename = _find_script(args.script)
+    _backend = choose_backend(args.backend)
+    if args.timestamp:
         prof = TimeStamper(_backend)
     else:
-        prof = LineProfiler(max_mem=options.max_mem, backend=_backend)
+        prof = LineProfiler(max_mem=args.max_mem, backend=_backend)
 
     try:
-        exec_with_profiler(script_filename, prof, options.backend)
+        exec_with_profiler(script_filename, prof, args.backend)
     finally:
-        if options.out_filename is not None:
-            out_file = open(options.out_filename, ""a"")
+        if args.out_filename is not None:
+            out_file = open(args.out_filename, ""a"")
         else:
             out_file = sys.stdout
 
-        if options.timestamp:
+        if args.timestamp:
             prof.show_results(stream=out_file)
         else:
-            show_results(prof, precision=options.precision, stream=out_file)
+            show_results(prof, precision=args.precision, stream=out_file)
",False,memory_profiler.py,True
"@@ -10,7 +10,7 @@ import time
 import math
 
 from collections import defaultdict
-from optparse import OptionParser, OptionValueError
+from argparse import ArgumentParser, ArgumentError
 
 import memory_profiler as mp
 
@@ -107,14 +107,10 @@ def get_profile_filenames(args):
 
 def list_action():
     """"""Display existing profiles, with indices.""""""
-    parser = OptionParser(version=mp.__version__)
-    parser.disable_interspersed_args()
-
-    (options, args) = parser.parse_args()
-
-    if len(args) > 0:
-        print(""This command takes no argument."")
-        sys.exit(1)
+    parser = ArgumentParser(
+            usage='mprof list\nThis command takes no argument.')
+    parser.add_argument('--version', action='version', version=mp.__version__)
+    args = parser.parse_args()
 
     filenames = get_profile_filenames(""all"")
     for n, filename in enumerate(filenames):
@@ -127,20 +123,21 @@ def list_action():
 
 def rm_action():
     """"""TODO: merge with clean_action (@pgervais)""""""
-    parser = OptionParser(version=mp.__version__)
-    parser.disable_interspersed_args()
-    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
-                      action=""store_true"",
-                      help=""""""Show what will be done, without actually doing it."""""")
-
-    (options, args) = parser.parse_args()
-
-    if len(args) == 0:
+    parser = ArgumentParser(usage='mprof rm [options] numbers_or_filenames')
+    parser.add_argument('--version', action='version', version=mp.__version__)
+    parser.add_argument(""--dry-run"", dest=""dry_run"", default=False,
+                        action=""store_true"",
+                        help=""""""Show what will be done, without actually doing it."""""")
+    parser.add_argument(""numbers_or_filenames"", nargs='*',
+                        help=""""""numbers or filenames removed"""""")
+    args = parser.parse_args()
+
+    if len(args.numbers_or_filenames) == 0:
         print(""A profile to remove must be provided (number or filename)"")
         sys.exit(1)
 
-    filenames = get_profile_filenames(args)
-    if options.dry_run:
+    filenames = get_profile_filenames(args.numbers_or_filenames)
+    if args.dry_run:
         print(""Files to be removed: "")
         for filename in filenames:
             print(filename)
@@ -151,20 +148,16 @@ def rm_action():
 
 def clean_action():
     """"""Remove every profile file in current directory.""""""
-    parser = OptionParser(version=mp.__version__)
-    parser.disable_interspersed_args()
-    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
-                      action=""store_true"",
-                      help=""""""Show what will be done, without actually doing it."""""")
-
-    (options, args) = parser.parse_args()
-
-    if len(args) > 0:
-        print(""This command takes no argument."")
-        sys.exit(1)
+    parser = ArgumentParser(
+            usage='mprof clean\nThis command takes no argument.')
+    parser.add_argument('--version', action='version', version=mp.__version__)
+    parser.add_argument(""--dry-run"", dest=""dry_run"", default=False,
+                        action=""store_true"",
+                        help=""""""Show what will be done, without actually doing it."""""")
+    args = parser.parse_args()
 
     filenames = get_profile_filenames(""all"")
-    if options.dry_run:
+    if args.dry_run:
         print(""Files to be removed: "")
         for filename in filenames:
             print(filename)
@@ -182,32 +175,27 @@ def get_cmd_line(args):
 
 def run_action():
     import time, subprocess
-    parser = OptionParser(version=mp.__version__, usage=""mprof run [options]"")
-    parser.disable_interspersed_args()
-    parser.add_option(""--python"", dest=""python"", default=False,
-                      action=""store_true"",
-                      help=""""""Activates extra features when the profiling executable is a Python program (currently: function timestamping.)"""""")
-    parser.add_option(""--nopython"", dest=""nopython"", default=False,
-                      action=""store_true"",
-                      help=""""""Disables extra features when the profiled executable is a Python program (currently: function timestamping.)"""""")
-    parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.1"",
-                      type=""float"", action=""store"",
-                      help=""Sampling period (in seconds), defaults to 0.1"")
-    parser.add_option(""--include-children"", ""-C"", dest=""include_children"",
-                      default=False, action=""store_true"",
-                      help=""""""Monitors forked processes as well (sum up all process memory)"""""")
-    parser.add_option(""--multiprocess"", ""-M"", dest=""multiprocess"",
-                      default=False, action=""store_true"",
-                      help=""""""Monitors forked processes creating individual plots for each child"""""")
-
-    (options, args) = parser.parse_args()
-
-    if len(args) == 0:
+    parser = ArgumentParser(usage=""mprof run [options] program"")
+    parser.add_argument('--version', action='version', version=mp.__version__)
+    parser.add_argument(""--python"", dest=""python"", action=""store_true"",
+                        help=""""""Activates extra features when the profiling executable is a Python program (currently: function timestamping.)"""""")
+    parser.add_argument(""--nopython"", dest=""nopython"", action=""store_true"",
+                        help=""""""Disables extra features when the profiled executable is a Python program (currently: function timestamping.)"""""")
+    parser.add_argument(""--interval"", ""-T"", dest=""interval"", default=""0.1"", type=float, action=""store"",
+                        help=""Sampling period (in seconds), defaults to 0.1"")
+    parser.add_argument(""--include-children"", ""-C"", dest=""include_children"", action=""store_true"",
+                        help=""""""Monitors forked processes as well (sum up all process memory)"""""")
+    parser.add_argument(""--multiprocess"", ""-M"", dest=""multiprocess"", action=""store_true"",
+                        help=""""""Monitors forked processes creating individual plots for each child"""""")
+    parser.add_argument(""program"", nargs='*')
+    args = parser.parse_args()
+
+    if len(args.program) == 0:
         print(""A program to run must be provided. Use -h for help"")
         sys.exit(1)
 
-    print(""{1}: Sampling memory every {0.interval}s"".format(
-        options, osp.basename(sys.argv[0])))
+    print(""{1}: Sampling memory every {0}s"".format(
+        args.interval, osp.basename(sys.argv[0])))
 
     ## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
     ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
@@ -218,30 +206,31 @@ def run_action():
     mprofile_output = ""mprofile_%s.dat"" % suffix
 
     # .. TODO: more than one script as argument ? ..
-    if args[0].endswith('.py') and not options.nopython:
-        if not args[0].startswith(""python""):
-            args.insert(0, sys.executable)
-        if options.multiprocess:
+    program = args.program
+    if program[0].endswith('.py') and not args.nopython:
+        if not program[0].startswith(""python""):
+            program.insert(0, sys.executable)
+        if args.multiprocess:
             # in multiprocessing mode you want to spawn a separate
             # python process
-            options.python = False
-    if options.python:
+            args.python = False
+    if args.python:
         print(""running as a Python program..."")
-        if not args[0].startswith(""python""):
-            args.insert(0, sys.executable)
-        cmd_line = get_cmd_line(args)
-        args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
-                     ""-o"", mprofile_output)
-        p = subprocess.Popen(args)
+        if not program[0].startswith(""python""):
+            program.insert(0, sys.executable)
+        cmd_line = get_cmd_line(program)
+        program[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
+                        ""-o"", mprofile_output)
+        p = subprocess.Popen(program)
     else:
-        cmd_line = get_cmd_line(args)
-        p = subprocess.Popen(args)
+        cmd_line = get_cmd_line(program)
+        p = subprocess.Popen(program)
 
     with open(mprofile_output, ""a"") as f:
         f.write(""CMDLINE {0}\n"".format(cmd_line))
-        mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
-                        include_children=options.include_children,
-                        multiprocess=options.multiprocess, stream=f)
+        mp.memory_usage(proc=p, interval=args.interval, timestamps=True,
+                        include_children=args.include_children,
+                        multiprocess=args.multiprocess, stream=f)
 
 
 def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
@@ -447,40 +436,39 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
 
 
 def plot_action():
-    def get_comma_separated_args(option, opt, value, parser):
+    def xlim_type(value):
         try:
             newvalue = [float(x) for x in value.split(',')]
         except:
-            raise OptionValueError(""'%s' option must contain two numbers separated with a comma"" % value)
+            raise ArgumentError(""'%s' option must contain two numbers separated with a comma"" % value)
         if len(newvalue) != 2:
-            raise OptionValueError(""'%s' option must contain two numbers separated with a comma"" % value)
-        setattr(parser.values, option.dest, newvalue)
+            raise ArgumentError(""'%s' option must contain two numbers separated with a comma"" % value)
+        return newvalue
 
     desc = """"""Plots using matplotlib the data file `file.dat` generated
 using `mprof run`. If no .dat file is given, it will take the most recent
 such file in the current directory.""""""
-    parser = OptionParser(version=mp.__version__, usage=""mprof plot [options] [file.dat]"", description=desc)
-    parser.disable_interspersed_args()
-    parser.add_option(""--title"", ""-t"", dest=""title"", default=None,
-                      type=""str"", action=""store"",
-                      help=""String shown as plot title"")
-    parser.add_option(""--no-function-ts"", ""-n"", dest=""no_timestamps"",
-                      default=False, action=""store_true"",
-                      help=""Do not display function timestamps on plot."")
-    parser.add_option(""--output"", ""-o"",
-                      help=""Save plot to file instead of displaying it."")
-    parser.add_option(""--window"", ""-w"", dest=""xlim"",
-                      type=""str"", action=""callback"",
-                      callback=get_comma_separated_args,
-                      help=""Plot a time-subset of the data. E.g. to plot between 0 and 20.5 seconds: --window 0,20.5"")
-    parser.add_option(""--backend"", 
+    parser = ArgumentParser(usage=""mprof plot [options] [file.dat]"", description=desc)
+    parser.add_argument('--version', action='version', version=mp.__version__)
+    parser.add_argument(""--title"", ""-t"", dest=""title"", default=None,
+                        type=str, action=""store"",
+                        help=""String shown as plot title"")
+    parser.add_argument(""--no-function-ts"", ""-n"", dest=""no_timestamps"", action=""store_true"",
+                        help=""Do not display function timestamps on plot."")
+    parser.add_argument(""--output"", ""-o"",
+                        help=""Save plot to file instead of displaying it."")
+    parser.add_argument(""--window"", ""-w"", dest=""xlim"", type=xlim_type,
+                        help=""Plot a time-subset of the data. E.g. to plot between 0 and 20.5 seconds: --window 0,20.5"")
+    parser.add_argument(""--backend"", 
                       help=""Specify the Matplotlib backend to use"")
-    (options, args) = parser.parse_args()
+    parser.add_argument(""profiles"", nargs=""*"",
+                        help=""profiles made by mprof run"")
+    args = parser.parse_args()
 
     try:
-        if options.backend is not None:
+        if args.backend is not None:
             import matplotlib
-            matplotlib.use(options.backend)
+            matplotlib.use(args.backend)
 
         import pylab as pl
     except ImportError as e:
@@ -491,7 +479,7 @@ such file in the current directory.""""""
     profiles = glob.glob(""mprofile_??????????????.dat"")
     profiles.sort()
 
-    if len(args) == 0:
+    if len(args.profiles) == 0:
         if len(profiles) == 0:
             print(""No input file found. \nThis program looks for ""
                   ""mprofile_*.dat files, generated by the ""
@@ -501,48 +489,48 @@ such file in the current directory.""""""
         filenames = [profiles[-1]]
     else:
         filenames = []
-        for arg in args:
-            if osp.exists(arg):
-                if not arg in filenames:
-                    filenames.append(arg)
+        for prof in args.profiles:
+            if osp.exists(prof):
+                if not prof in filenames:
+                    filenames.append(prof)
             else:
                 try:
-                    n = int(arg)
+                    n = int(prof)
                     if not profiles[n] in filenames:
                         filenames.append(profiles[n])
                 except ValueError:
-                    print(""Input file not found: "" + arg)
+                    print(""Input file not found: "" + prof)
     if not len(filenames):
         print(""No files found from given input."")
         sys.exit(-1)
 
     fig = pl.figure(figsize=(14, 6), dpi=90)
     ax = fig.add_axes([0.1, 0.1, 0.6, 0.75])
-    if options.xlim is not None:
-        pl.xlim(options.xlim[0], options.xlim[1])
+    if args.xlim is not None:
+        pl.xlim(args.xlim[0], args.xlim[1])
 
-    if len(filenames) > 1 or options.no_timestamps:
+    if len(filenames) > 1 or args.no_timestamps:
         timestamps = False
     else:
         timestamps = True
     for n, filename in enumerate(filenames):
-        mprofile = plot_file(filename, index=n, timestamps=timestamps, options=options)
+        mprofile = plot_file(filename, index=n, timestamps=timestamps, options=args)
     pl.xlabel(""time (in seconds)"")
     pl.ylabel(""memory used (in MiB)"")
 
-    if options.title is None and len(filenames) == 1:
+    if args.title is None and len(filenames) == 1:
         pl.title(mprofile['cmd_line'])
     else:
-        if options.title is not None:
-            pl.title(options.title)
+        if args.title is not None:
+            pl.title(args.title)
 
     # place legend within the plot, make partially transparent in
     # case it obscures part of the lineplot
     leg = ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))
     leg.get_frame().set_alpha(0.5)
     pl.grid()
-    if options.output:
-        pl.savefig(options.output)
+    if args.output:
+        pl.savefig(args.output)
     else:
         pl.show()
 
","@@ -10,7 +10,7 @@ import time
 import math
 
 from collections import defaultdict
-from optparse import OptionParser, OptionValueError
+from argparse import ArgumentParser, ArgumentError
 
 import memory_profiler as mp
 
@@ -107,14 +107,10 @@ def get_profile_filenames(args):
 
 def list_action():
     """"""Display existing profiles, with indices.""""""
-    parser = OptionParser(version=mp.__version__)
-    parser.disable_interspersed_args()
-
-    (options, args) = parser.parse_args()
-
-    if len(args) > 0:
-        print(""This command takes no argument."")
-        sys.exit(1)
+    parser = ArgumentParser(
+            usage='mprof list\nThis command takes no argument.')
+    parser.add_argument('--version', action='version', version=mp.__version__)
+    args = parser.parse_args()
 
     filenames = get_profile_filenames(""all"")
     for n, filename in enumerate(filenames):
@@ -127,20 +123,21 @@ def list_action():
 
 def rm_action():
     """"""TODO: merge with clean_action (@pgervais)""""""
-    parser = OptionParser(version=mp.__version__)
-    parser.disable_interspersed_args()
-    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
-                      action=""store_true"",
-                      help=""""""Show what will be done, without actually doing it."""""")
+    parser = ArgumentParser(usage='mprof rm [options] numbers_or_filenames')
+    parser.add_argument('--version', action='version', version=mp.__version__)
+    parser.add_argument(""--dry-run"", dest=""dry_run"", default=False,
+                        action=""store_true"",
+                        help=""""""Show what will be done, without actually doing it."""""")
+    parser.add_argument(""numbers_or_filenames"", nargs='*',
+                        help=""""""numbers or filenames removed"""""")
+    args = parser.parse_args()
 
-    (options, args) = parser.parse_args()
-
-    if len(args) == 0:
+    if len(args.numbers_or_filenames) == 0:
         print(""A profile to remove must be provided (number or filename)"")
         sys.exit(1)
 
-    filenames = get_profile_filenames(args)
-    if options.dry_run:
+    filenames = get_profile_filenames(args.numbers_or_filenames)
+    if args.dry_run:
         print(""Files to be removed: "")
         for filename in filenames:
             print(filename)
@@ -151,20 +148,16 @@ def rm_action():
 
 def clean_action():
     """"""Remove every profile file in current directory.""""""
-    parser = OptionParser(version=mp.__version__)
-    parser.disable_interspersed_args()
-    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
-                      action=""store_true"",
-                      help=""""""Show what will be done, without actually doing it."""""")
-
-    (options, args) = parser.parse_args()
-
-    if len(args) > 0:
-        print(""This command takes no argument."")
-        sys.exit(1)
+    parser = ArgumentParser(
+            usage='mprof clean\nThis command takes no argument.')
+    parser.add_argument('--version', action='version', version=mp.__version__)
+    parser.add_argument(""--dry-run"", dest=""dry_run"", default=False,
+                        action=""store_true"",
+                        help=""""""Show what will be done, without actually doing it."""""")
+    args = parser.parse_args()
 
     filenames = get_profile_filenames(""all"")
-    if options.dry_run:
+    if args.dry_run:
         print(""Files to be removed: "")
         for filename in filenames:
             print(filename)
@@ -182,32 +175,27 @@ def get_cmd_line(args):
 
 def run_action():
     import time, subprocess
-    parser = OptionParser(version=mp.__version__, usage=""mprof run [options]"")
-    parser.disable_interspersed_args()
-    parser.add_option(""--python"", dest=""python"", default=False,
-                      action=""store_true"",
-                      help=""""""Activates extra features when the profiling executable is a Python program (currently: function timestamping.)"""""")
-    parser.add_option(""--nopython"", dest=""nopython"", default=False,
-                      action=""store_true"",
-                      help=""""""Disables extra features when the profiled executable is a Python program (currently: function timestamping.)"""""")
-    parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.1"",
-                      type=""float"", action=""store"",
-                      help=""Sampling period (in seconds), defaults to 0.1"")
-    parser.add_option(""--include-children"", ""-C"", dest=""include_children"",
-                      default=False, action=""store_true"",
-                      help=""""""Monitors forked processes as well (sum up all process memory)"""""")
-    parser.add_option(""--multiprocess"", ""-M"", dest=""multiprocess"",
-                      default=False, action=""store_true"",
-                      help=""""""Monitors forked processes creating individual plots for each child"""""")
+    parser = ArgumentParser(usage=""mprof run [options] program"")
+    parser.add_argument('--version', action='version', version=mp.__version__)
+    parser.add_argument(""--python"", dest=""python"", action=""store_true"",
+                        help=""""""Activates extra features when the profiling executable is a Python program (currently: function timestamping.)"""""")
+    parser.add_argument(""--nopython"", dest=""nopython"", action=""store_true"",
+                        help=""""""Disables extra features when the profiled executable is a Python program (currently: function timestamping.)"""""")
+    parser.add_argument(""--interval"", ""-T"", dest=""interval"", default=""0.1"", type=float, action=""store"",
+                        help=""Sampling period (in seconds), defaults to 0.1"")
+    parser.add_argument(""--include-children"", ""-C"", dest=""include_children"", action=""store_true"",
+                        help=""""""Monitors forked processes as well (sum up all process memory)"""""")
+    parser.add_argument(""--multiprocess"", ""-M"", dest=""multiprocess"", action=""store_true"",
+                        help=""""""Monitors forked processes creating individual plots for each child"""""")
+    parser.add_argument(""program"", nargs='*')
+    args = parser.parse_args()
 
-    (options, args) = parser.parse_args()
-
-    if len(args) == 0:
+    if len(args.program) == 0:
         print(""A program to run must be provided. Use -h for help"")
         sys.exit(1)
 
-    print(""{1}: Sampling memory every {0.interval}s"".format(
-        options, osp.basename(sys.argv[0])))
+    print(""{1}: Sampling memory every {0}s"".format(
+        args.interval, osp.basename(sys.argv[0])))
 
     ## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
     ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
@@ -218,30 +206,31 @@ def run_action():
     mprofile_output = ""mprofile_%s.dat"" % suffix
 
     # .. TODO: more than one script as argument ? ..
-    if args[0].endswith('.py') and not options.nopython:
-        if not args[0].startswith(""python""):
-            args.insert(0, sys.executable)
-        if options.multiprocess:
+    program = args.program
+    if program[0].endswith('.py') and not args.nopython:
+        if not program[0].startswith(""python""):
+            program.insert(0, sys.executable)
+        if args.multiprocess:
             # in multiprocessing mode you want to spawn a separate
             # python process
-            options.python = False
-    if options.python:
+            args.python = False
+    if args.python:
         print(""running as a Python program..."")
-        if not args[0].startswith(""python""):
-            args.insert(0, sys.executable)
-        cmd_line = get_cmd_line(args)
-        args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
-                     ""-o"", mprofile_output)
-        p = subprocess.Popen(args)
+        if not program[0].startswith(""python""):
+            program.insert(0, sys.executable)
+        cmd_line = get_cmd_line(program)
+        program[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
+                        ""-o"", mprofile_output)
+        p = subprocess.Popen(program)
     else:
-        cmd_line = get_cmd_line(args)
-        p = subprocess.Popen(args)
+        cmd_line = get_cmd_line(program)
+        p = subprocess.Popen(program)
 
     with open(mprofile_output, ""a"") as f:
         f.write(""CMDLINE {0}\n"".format(cmd_line))
-        mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
-                        include_children=options.include_children,
-                        multiprocess=options.multiprocess, stream=f)
+        mp.memory_usage(proc=p, interval=args.interval, timestamps=True,
+                        include_children=args.include_children,
+                        multiprocess=args.multiprocess, stream=f)
 
 
 def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
@@ -447,40 +436,39 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
 
 
 def plot_action():
-    def get_comma_separated_args(option, opt, value, parser):
+    def xlim_type(value):
         try:
             newvalue = [float(x) for x in value.split(',')]
         except:
-            raise OptionValueError(""'%s' option must contain two numbers separated with a comma"" % value)
+            raise ArgumentError(""'%s' option must contain two numbers separated with a comma"" % value)
         if len(newvalue) != 2:
-            raise OptionValueError(""'%s' option must contain two numbers separated with a comma"" % value)
-        setattr(parser.values, option.dest, newvalue)
+            raise ArgumentError(""'%s' option must contain two numbers separated with a comma"" % value)
+        return newvalue
 
     desc = """"""Plots using matplotlib the data file `file.dat` generated
 using `mprof run`. If no .dat file is given, it will take the most recent
 such file in the current directory.""""""
-    parser = OptionParser(version=mp.__version__, usage=""mprof plot [options] [file.dat]"", description=desc)
-    parser.disable_interspersed_args()
-    parser.add_option(""--title"", ""-t"", dest=""title"", default=None,
-                      type=""str"", action=""store"",
-                      help=""String shown as plot title"")
-    parser.add_option(""--no-function-ts"", ""-n"", dest=""no_timestamps"",
-                      default=False, action=""store_true"",
-                      help=""Do not display function timestamps on plot."")
-    parser.add_option(""--output"", ""-o"",
-                      help=""Save plot to file instead of displaying it."")
-    parser.add_option(""--window"", ""-w"", dest=""xlim"",
-                      type=""str"", action=""callback"",
-                      callback=get_comma_separated_args,
-                      help=""Plot a time-subset of the data. E.g. to plot between 0 and 20.5 seconds: --window 0,20.5"")
-    parser.add_option(""--backend"", 
+    parser = ArgumentParser(usage=""mprof plot [options] [file.dat]"", description=desc)
+    parser.add_argument('--version', action='version', version=mp.__version__)
+    parser.add_argument(""--title"", ""-t"", dest=""title"", default=None,
+                        type=str, action=""store"",
+                        help=""String shown as plot title"")
+    parser.add_argument(""--no-function-ts"", ""-n"", dest=""no_timestamps"", action=""store_true"",
+                        help=""Do not display function timestamps on plot."")
+    parser.add_argument(""--output"", ""-o"",
+                        help=""Save plot to file instead of displaying it."")
+    parser.add_argument(""--window"", ""-w"", dest=""xlim"", type=xlim_type,
+                        help=""Plot a time-subset of the data. E.g. to plot between 0 and 20.5 seconds: --window 0,20.5"")
+    parser.add_argument(""--backend"", 
                       help=""Specify the Matplotlib backend to use"")
-    (options, args) = parser.parse_args()
+    parser.add_argument(""profiles"", nargs=""*"",
+                        help=""profiles made by mprof run"")
+    args = parser.parse_args()
 
     try:
-        if options.backend is not None:
+        if args.backend is not None:
             import matplotlib
-            matplotlib.use(options.backend)
+            matplotlib.use(args.backend)
 
         import pylab as pl
     except ImportError as e:
@@ -491,7 +479,7 @@ such file in the current directory.""""""
     profiles = glob.glob(""mprofile_??????????????.dat"")
     profiles.sort()
 
-    if len(args) == 0:
+    if len(args.profiles) == 0:
         if len(profiles) == 0:
             print(""No input file found. \nThis program looks for ""
                   ""mprofile_*.dat files, generated by the ""
@@ -501,48 +489,48 @@ such file in the current directory.""""""
         filenames = [profiles[-1]]
     else:
         filenames = []
-        for arg in args:
-            if osp.exists(arg):
-                if not arg in filenames:
-                    filenames.append(arg)
+        for prof in args.profiles:
+            if osp.exists(prof):
+                if not prof in filenames:
+                    filenames.append(prof)
             else:
                 try:
-                    n = int(arg)
+                    n = int(prof)
                     if not profiles[n] in filenames:
                         filenames.append(profiles[n])
                 except ValueError:
-                    print(""Input file not found: "" + arg)
+                    print(""Input file not found: "" + prof)
     if not len(filenames):
         print(""No files found from given input."")
         sys.exit(-1)
 
     fig = pl.figure(figsize=(14, 6), dpi=90)
     ax = fig.add_axes([0.1, 0.1, 0.6, 0.75])
-    if options.xlim is not None:
-        pl.xlim(options.xlim[0], options.xlim[1])
+    if args.xlim is not None:
+        pl.xlim(args.xlim[0], args.xlim[1])
 
-    if len(filenames) > 1 or options.no_timestamps:
+    if len(filenames) > 1 or args.no_timestamps:
         timestamps = False
     else:
         timestamps = True
     for n, filename in enumerate(filenames):
-        mprofile = plot_file(filename, index=n, timestamps=timestamps, options=options)
+        mprofile = plot_file(filename, index=n, timestamps=timestamps, options=args)
     pl.xlabel(""time (in seconds)"")
     pl.ylabel(""memory used (in MiB)"")
 
-    if options.title is None and len(filenames) == 1:
+    if args.title is None and len(filenames) == 1:
         pl.title(mprofile['cmd_line'])
     else:
-        if options.title is not None:
-            pl.title(options.title)
+        if args.title is not None:
+            pl.title(args.title)
 
     # place legend within the plot, make partially transparent in
     # case it obscures part of the lineplot
     leg = ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))
     leg.get_frame().set_alpha(0.5)
     pl.grid()
-    if options.output:
-        pl.savefig(options.output)
+    if args.output:
+        pl.savefig(args.output)
     else:
         pl.show()
 
",False,mprof,False
"@@ -1,5 +1,5 @@
-.. image:: https://travis-ci.org/fabianp/memory_profiler.svg?branch=master
-    :target: https://travis-ci.org/fabianp/memory_profiler
+.. image:: https://travis-ci.org/pythonprofilers/memory_profiler.svg?branch=master
+    :target: https://travis-ci.org/pythonprofilers/memory_profiler
 
 =================
  Memory Profiler
@@ -186,7 +186,7 @@ flag and plot as follows::
 This will create a plot using matplotlib similar to this:
 
 .. image:: https://cloud.githubusercontent.com/assets/745966/24075879/2e85b43a-0bfa-11e7-8dfe-654320dbd2ce.png
-    :target: https://github.com/fabianp/memory_profiler/pull/134
+    :target: https://github.com/pythonprofilers/memory_profiler/pull/134
     :height: 350px
 
 You can combine both the ``include_children`` and ``multiprocess`` flags to show
@@ -395,7 +395,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
 For support, please ask your question on `stack overflow
 <http://stackoverflow.com/>`_ and add the `*memory-profiling* tag <http://stackoverflow.com/questions/tagged/memory-profiling>`_.
 Send issues, proposals, etc. to `github's issue tracker
-<https://github.com/fabianp/memory_profiler/issues>`_ .
+<https://github.com/pythonprofilers/memory_profiler/issues>`_ .
 
 If you've got questions regarding development, you can email me
 directly at fabian@fseoane.net
@@ -408,7 +408,7 @@ directly at fabian@fseoane.net
 =============
 Latest sources are available from github:
 
-    https://github.com/fabianp/memory_profiler
+    https://github.com/pythonprofilers/memory_profiler
 
 ===============================
 Projects using memory_profiler
","@@ -1,5 +1,5 @@
-.. image:: https://travis-ci.org/fabianp/memory_profiler.svg?branch=master
-    :target: https://travis-ci.org/fabianp/memory_profiler
+.. image:: https://travis-ci.org/pythonprofilers/memory_profiler.svg?branch=master
+    :target: https://travis-ci.org/pythonprofilers/memory_profiler
 
 =================
  Memory Profiler
@@ -186,7 +186,7 @@ flag and plot as follows::
 This will create a plot using matplotlib similar to this:
 
 .. image:: https://cloud.githubusercontent.com/assets/745966/24075879/2e85b43a-0bfa-11e7-8dfe-654320dbd2ce.png
-    :target: https://github.com/fabianp/memory_profiler/pull/134
+    :target: https://github.com/pythonprofilers/memory_profiler/pull/134
     :height: 350px
 
 You can combine both the ``include_children`` and ``multiprocess`` flags to show
@@ -395,7 +395,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
 For support, please ask your question on `stack overflow
 <http://stackoverflow.com/>`_ and add the `*memory-profiling* tag <http://stackoverflow.com/questions/tagged/memory-profiling>`_.
 Send issues, proposals, etc. to `github's issue tracker
-<https://github.com/fabianp/memory_profiler/issues>`_ .
+<https://github.com/pythonprofilers/memory_profiler/issues>`_ .
 
 If you've got questions regarding development, you can email me
 directly at fabian@fseoane.net
@@ -408,7 +408,7 @@ directly at fabian@fseoane.net
 =============
 Latest sources are available from github:
 
-    https://github.com/fabianp/memory_profiler
+    https://github.com/pythonprofilers/memory_profiler
 
 ===============================
 Projects using memory_profiler
",True,README.rst,False
"@@ -104,7 +104,7 @@ def _get_child_memory(process, meminfo_attr=None):
     try:
         for child in getattr(process, children_attr)(recursive=True):
             yield getattr(child, meminfo_attr)()[0] / _TWO_20
-    except psutil.NoSuchProcess:
+    except (psutil.NoSuchProcess, psutil.AccessDenied):
         # https://github.com/fabianp/memory_profiler/issues/71
         yield 0.0
 
","@@ -104,7 +104,7 @@ def _get_child_memory(process, meminfo_attr=None):
     try:
         for child in getattr(process, children_attr)(recursive=True):
             yield getattr(child, meminfo_attr)()[0] / _TWO_20
-    except psutil.NoSuchProcess:
+    except (psutil.NoSuchProcess, psutil.AccessDenied):
         # https://github.com/fabianp/memory_profiler/issues/71
         yield 0.0
 
",True,memory_profiler.py,True
"@@ -17,8 +17,12 @@ import inspect
 import subprocess
 import logging
 import traceback
-from signal import SIGKILL
-
+if sys.platform == ""win32"":
+    # any value except signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT
+    # can be used to kill a process unconditionally in Windows
+    SIGKILL = -1
+else:
+    from signal import SIGKILL
 import psutil
 
 
","@@ -17,8 +17,12 @@ import inspect
 import subprocess
 import logging
 import traceback
-from signal import SIGKILL
-
+if sys.platform == ""win32"":
+    # any value except signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT
+    # can be used to kill a process unconditionally in Windows
+    SIGKILL = -1
+else:
+    from signal import SIGKILL
 import psutil
 
 
",True,memory_profiler.py,True
"@@ -0,0 +1,2 @@
+@echo off
+python %~dpn0 %*
\ No newline at end of file
","@@ -0,0 +1,2 @@
+@echo off
+python %~dpn0 %*
\ No newline at end of file
",True,mprof.bat,False
"@@ -1,6 +1,7 @@
 import os
 import io
 import re
+import sys
 from setuptools import setup
 
 
@@ -39,6 +40,10 @@ Operating System :: Unix
 
 """"""
 
+scripts = ['mprof']
+if sys.platform == ""win32"":
+    scripts.append('mprof.bat')
+
 setup(
     name='memory_profiler',
     description='A module for monitoring memory usage of a python program',
@@ -48,7 +53,7 @@ setup(
     author_email='f@bianp.net',
     url='http://pypi.python.org/pypi/memory_profiler',
     py_modules=['memory_profiler'],
-    scripts=['mprof'],
+    scripts=scripts,
     install_requires=['psutil'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='BSD'
","@@ -1,6 +1,7 @@
 import os
 import io
 import re
+import sys
 from setuptools import setup
 
 
@@ -39,6 +40,10 @@ Operating System :: Unix
 
 """"""
 
+scripts = ['mprof']
+if sys.platform == ""win32"":
+    scripts.append('mprof.bat')
+
 setup(
     name='memory_profiler',
     description='A module for monitoring memory usage of a python program',
@@ -48,7 +53,7 @@ setup(
     author_email='f@bianp.net',
     url='http://pypi.python.org/pypi/memory_profiler',
     py_modules=['memory_profiler'],
-    scripts=['mprof'],
+    scripts=scripts,
     install_requires=['psutil'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='BSD'
",True,setup.py,True
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.48.dev0'
+__version__ = '0.48.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.48.dev0'
+__version__ = '0.48.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -8,4 +8,4 @@ def test_1(i):
 
 if __name__ == '__main__':
     test_1(10)
-    test_1(10000)
+    test_1(100)
","@@ -8,4 +8,4 @@ def test_1(i):
 
 if __name__ == '__main__':
     test_1(10)
-    test_1(10000)
+    test_1(100)
",True,test/test_func.py,True
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.48.0'
+__version__ = '0.49.dev0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.48.0'
+__version__ = '0.49.dev0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -8,4 +8,4 @@ def test_1(i):
 
 if __name__ == '__main__':
     test_1(10)
-    test_1(100)
+    test_1(10000)
","@@ -8,4 +8,4 @@ def test_1(i):
 
 if __name__ == '__main__':
     test_1(10)
-    test_1(100)
+    test_1(10000)
",True,test/test_func.py,True
"@@ -1,2 +1,3 @@
 include README.rst
 include COPYING
+include mprof.bat
","@@ -1,2 +1,3 @@
 include README.rst
 include COPYING
+include mprof.bat
",True,MANIFEST.in,False
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.49.dev0'
+__version__ = '0.49.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.49.dev0'
+__version__ = '0.49.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.49.0'
+__version__ = '0.50.dev0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.49.0'
+__version__ = '0.50.dev0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.50.dev0'
+__version__ = '0.50.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.50.dev0'
+__version__ = '0.50.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -208,12 +208,14 @@ def run_action():
     # .. TODO: more than one script as argument ? ..
     program = args.program
     if program[0].endswith('.py') and not args.nopython:
-        if not program[0].startswith(""python""):
-            program.insert(0, sys.executable)
         if args.multiprocess:
             # in multiprocessing mode you want to spawn a separate
             # python process
+            if not program[0].startswith(""python""):
+                program.insert(0, sys.executable)
             args.python = False
+        else:
+            args.python = True
     if args.python:
         print(""running as a Python program..."")
         if not program[0].startswith(""python""):
@@ -221,6 +223,7 @@ def run_action():
         cmd_line = get_cmd_line(program)
         program[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
                         ""-o"", mprofile_output)
+        print(program)
         p = subprocess.Popen(program)
     else:
         cmd_line = get_cmd_line(program)
","@@ -208,12 +208,14 @@ def run_action():
     # .. TODO: more than one script as argument ? ..
     program = args.program
     if program[0].endswith('.py') and not args.nopython:
-        if not program[0].startswith(""python""):
-            program.insert(0, sys.executable)
         if args.multiprocess:
             # in multiprocessing mode you want to spawn a separate
             # python process
+            if not program[0].startswith(""python""):
+                program.insert(0, sys.executable)
             args.python = False
+        else:
+            args.python = True
     if args.python:
         print(""running as a Python program..."")
         if not program[0].startswith(""python""):
@@ -221,6 +223,7 @@ def run_action():
         cmd_line = get_cmd_line(program)
         program[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
                         ""-o"", mprofile_output)
+        print(program)
         p = subprocess.Popen(program)
     else:
         cmd_line = get_cmd_line(program)
",True,mprof,False
"@@ -223,7 +223,6 @@ def run_action():
         cmd_line = get_cmd_line(program)
         program[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
                         ""-o"", mprofile_output)
-        print(program)
         p = subprocess.Popen(program)
     else:
         cmd_line = get_cmd_line(program)
","@@ -223,7 +223,6 @@ def run_action():
         cmd_line = get_cmd_line(program)
         program[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
                         ""-o"", mprofile_output)
-        print(program)
         p = subprocess.Popen(program)
     else:
         cmd_line = get_cmd_line(program)
",True,mprof,False
"@@ -416,7 +416,7 @@ Projects using memory_profiler
 
 `Benchy <https://github.com/python-recsys/benchy>`_
 
-`IPython memory usage <https://github.com/ianozsvald/ipython_memory_usage_>`_
+`IPython memory usage <https://github.com/ianozsvald/ipython_memory_usage>`_
 
 `PySpeedIT <https://github.com/peter1000/PySpeedIT>`_ (uses a reduced version of memory_profiler)
 
","@@ -416,7 +416,7 @@ Projects using memory_profiler
 
 `Benchy <https://github.com/python-recsys/benchy>`_
 
-`IPython memory usage <https://github.com/ianozsvald/ipython_memory_usage_>`_
+`IPython memory usage <https://github.com/ianozsvald/ipython_memory_usage>`_
 
 `PySpeedIT <https://github.com/peter1000/PySpeedIT>`_ (uses a reduced version of memory_profiler)
 
",True,README.rst,False
"@@ -1113,20 +1113,17 @@ def choose_backend(new_backend=None):
 # globally defined (global variables is not enough
 # for all cases, e.g. a script that imports another
 # script where @profile is used)
-if PY2:
-    def exec_with_profiler(filename, profiler, backend):
-        builtins.__dict__['profile'] = profiler
-        ns = dict(_CLEAN_GLOBALS, profile=profiler)
-        choose_backend(backend)
+def exec_with_profiler(filename, profiler, backend, passed_args=[]):
+    from runpy import run_module
+    builtins.__dict__['profile'] = profiler
+    ns = dict(_CLEAN_GLOBALS, profile=profiler)
+    _backend = choose_backend(backend)
+    sys.argv = [filename] + passed_args
+    if PY2:
         execfile(filename, ns, ns)
-else:
-    def exec_with_profiler(filename, profiler, backend):
-        _backend = choose_backend(backend)
+    else:
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
-        builtins.__dict__['profile'] = profiler
-        # shadow the profile decorator defined above
-        ns = dict(_CLEAN_GLOBALS, profile=profiler)
         try:
             with open(filename) as f:
                 exec(compile(f.read(), filename, 'exec'), ns, ns)
@@ -1135,6 +1132,24 @@ else:
                 tracemalloc.stop()
 
 
+def run_module_with_profiler(module, profiler, backend, passed_args=[]):
+    from runpy import run_module
+    builtins.__dict__['profile'] = profiler
+    ns = dict(_CLEAN_GLOBALS, profile=profiler)
+    _backend = choose_backend(backend)
+    sys.argv = [module] + passed_args
+    if PY2:
+        run_module(module, run_name=""__main__"", init_globals=ns)
+    else:
+        if _backend == 'tracemalloc' and has_tracemalloc:
+            tracemalloc.start()
+        try:
+            run_module(module, run_name=""__main__"", init_globals=ns)
+        finally:
+            if has_tracemalloc and tracemalloc.is_tracing():
+                tracemalloc.stop()
+
+
 class LogFile(object):
     """"""File-like object to log text using the `logging` module and the log
     report can be customised.""""""
@@ -1168,7 +1183,7 @@ class LogFile(object):
 
 
 if __name__ == '__main__':
-    from argparse import ArgumentParser
+    from argparse import ArgumentParser, REMAINDER
 
     parser = ArgumentParser(usage=_CMD_USAGE)
     parser.add_argument('--version', action='version', version=__version__)
@@ -1191,10 +1206,16 @@ if __name__ == '__main__':
         choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
         help='backend using for getting memory info '
              '(one of the {tracemalloc, psutil, posix})')
-    parser.add_argument('script', help='script file run on memory_profiler')
+    parser.add_argument(""program"", nargs=REMAINDER,
+        help='python script or module followed by command line arguements to run')
     args = parser.parse_args()
 
-    script_filename = _find_script(args.script)
+    if len(args.program) == 0:
+        print(""A program to run must be provided. Use -h for help"")
+        sys.exit(1)
+
+    target = args.program[0]
+    script_args = args.program[1:]
     _backend = choose_backend(args.backend)
     if args.timestamp:
         prof = TimeStamper(_backend)
@@ -1202,7 +1223,11 @@ if __name__ == '__main__':
         prof = LineProfiler(max_mem=args.max_mem, backend=_backend)
 
     try:
-        exec_with_profiler(script_filename, prof, args.backend)
+        if args.program[0].endswith('.py'):
+            script_filename = _find_script(args.program[0])
+            exec_with_profiler(script_filename, prof, args.backend, script_args)
+        else:
+            run_module_with_profiler(target, prof, args.backend, script_args)
     finally:
         if args.out_filename is not None:
             out_file = open(args.out_filename, ""a"")
","@@ -1113,20 +1113,17 @@ def choose_backend(new_backend=None):
 # globally defined (global variables is not enough
 # for all cases, e.g. a script that imports another
 # script where @profile is used)
-if PY2:
-    def exec_with_profiler(filename, profiler, backend):
-        builtins.__dict__['profile'] = profiler
-        ns = dict(_CLEAN_GLOBALS, profile=profiler)
-        choose_backend(backend)
+def exec_with_profiler(filename, profiler, backend, passed_args=[]):
+    from runpy import run_module
+    builtins.__dict__['profile'] = profiler
+    ns = dict(_CLEAN_GLOBALS, profile=profiler)
+    _backend = choose_backend(backend)
+    sys.argv = [filename] + passed_args
+    if PY2:
         execfile(filename, ns, ns)
-else:
-    def exec_with_profiler(filename, profiler, backend):
-        _backend = choose_backend(backend)
+    else:
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
-        builtins.__dict__['profile'] = profiler
-        # shadow the profile decorator defined above
-        ns = dict(_CLEAN_GLOBALS, profile=profiler)
         try:
             with open(filename) as f:
                 exec(compile(f.read(), filename, 'exec'), ns, ns)
@@ -1135,6 +1132,24 @@ else:
                 tracemalloc.stop()
 
 
+def run_module_with_profiler(module, profiler, backend, passed_args=[]):
+    from runpy import run_module
+    builtins.__dict__['profile'] = profiler
+    ns = dict(_CLEAN_GLOBALS, profile=profiler)
+    _backend = choose_backend(backend)
+    sys.argv = [module] + passed_args
+    if PY2:
+        run_module(module, run_name=""__main__"", init_globals=ns)
+    else:
+        if _backend == 'tracemalloc' and has_tracemalloc:
+            tracemalloc.start()
+        try:
+            run_module(module, run_name=""__main__"", init_globals=ns)
+        finally:
+            if has_tracemalloc and tracemalloc.is_tracing():
+                tracemalloc.stop()
+
+
 class LogFile(object):
     """"""File-like object to log text using the `logging` module and the log
     report can be customised.""""""
@@ -1168,7 +1183,7 @@ class LogFile(object):
 
 
 if __name__ == '__main__':
-    from argparse import ArgumentParser
+    from argparse import ArgumentParser, REMAINDER
 
     parser = ArgumentParser(usage=_CMD_USAGE)
     parser.add_argument('--version', action='version', version=__version__)
@@ -1191,10 +1206,16 @@ if __name__ == '__main__':
         choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
         help='backend using for getting memory info '
              '(one of the {tracemalloc, psutil, posix})')
-    parser.add_argument('script', help='script file run on memory_profiler')
+    parser.add_argument(""program"", nargs=REMAINDER,
+        help='python script or module followed by command line arguements to run')
     args = parser.parse_args()
 
-    script_filename = _find_script(args.script)
+    if len(args.program) == 0:
+        print(""A program to run must be provided. Use -h for help"")
+        sys.exit(1)
+
+    target = args.program[0]
+    script_args = args.program[1:]
     _backend = choose_backend(args.backend)
     if args.timestamp:
         prof = TimeStamper(_backend)
@@ -1202,7 +1223,11 @@ if __name__ == '__main__':
         prof = LineProfiler(max_mem=args.max_mem, backend=_backend)
 
     try:
-        exec_with_profiler(script_filename, prof, args.backend)
+        if args.program[0].endswith('.py'):
+            script_filename = _find_script(args.program[0])
+            exec_with_profiler(script_filename, prof, args.backend, script_args)
+        else:
+            run_module_with_profiler(target, prof, args.backend, script_args)
     finally:
         if args.out_filename is not None:
             out_file = open(args.out_filename, ""a"")
",True,memory_profiler.py,True
"@@ -10,7 +10,7 @@ import time
 import math
 
 from collections import defaultdict
-from argparse import ArgumentParser, ArgumentError
+from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormatter
 
 import memory_profiler as mp
 
@@ -175,7 +175,7 @@ def get_cmd_line(args):
 
 def run_action():
     import time, subprocess
-    parser = ArgumentParser(usage=""mprof run [options] program"")
+    parser = ArgumentParser(usage=""mprof run [options] program"", formatter_class=RawTextHelpFormatter)
     parser.add_argument('--version', action='version', version=mp.__version__)
     parser.add_argument(""--python"", dest=""python"", action=""store_true"",
                         help=""""""Activates extra features when the profiling executable is a Python program (currently: function timestamping.)"""""")
@@ -186,8 +186,13 @@ def run_action():
     parser.add_argument(""--include-children"", ""-C"", dest=""include_children"", action=""store_true"",
                         help=""""""Monitors forked processes as well (sum up all process memory)"""""")
     parser.add_argument(""--multiprocess"", ""-M"", dest=""multiprocess"", action=""store_true"",
-                        help=""""""Monitors forked processes creating individual plots for each child"""""")
-    parser.add_argument(""program"", nargs='*')
+                        help=""""""Monitors forked processes creating individual plots for each child (disables --python features)"""""")
+    parser.add_argument(""program"", nargs=REMAINDER,
+                        help='Option 1: ""<EXECUTABLE> <ARG1> <ARG2>..."" - profile executable\n'
+                             'Option 2: ""<PYTHON_SCRIPT> <ARG1> <ARG2>..."" - profile python script\n'
+                             'Option 3: (--python flag present) ""<PYTHON_EXECUTABLE> <PYTHON_SCRIPT> <ARG1> <ARG2>..."" - profile python script with specified interpreter\n'
+                             'Option 4: (--python flag present) ""<PYTHON_MODULE> <ARG1> <ARG2>..."" - profile python module\n'
+                        )
     args = parser.parse_args()
 
     if len(args.program) == 0:
","@@ -10,7 +10,7 @@ import time
 import math
 
 from collections import defaultdict
-from argparse import ArgumentParser, ArgumentError
+from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormatter
 
 import memory_profiler as mp
 
@@ -175,7 +175,7 @@ def get_cmd_line(args):
 
 def run_action():
     import time, subprocess
-    parser = ArgumentParser(usage=""mprof run [options] program"")
+    parser = ArgumentParser(usage=""mprof run [options] program"", formatter_class=RawTextHelpFormatter)
     parser.add_argument('--version', action='version', version=mp.__version__)
     parser.add_argument(""--python"", dest=""python"", action=""store_true"",
                         help=""""""Activates extra features when the profiling executable is a Python program (currently: function timestamping.)"""""")
@@ -186,8 +186,13 @@ def run_action():
     parser.add_argument(""--include-children"", ""-C"", dest=""include_children"", action=""store_true"",
                         help=""""""Monitors forked processes as well (sum up all process memory)"""""")
     parser.add_argument(""--multiprocess"", ""-M"", dest=""multiprocess"", action=""store_true"",
-                        help=""""""Monitors forked processes creating individual plots for each child"""""")
-    parser.add_argument(""program"", nargs='*')
+                        help=""""""Monitors forked processes creating individual plots for each child (disables --python features)"""""")
+    parser.add_argument(""program"", nargs=REMAINDER,
+                        help='Option 1: ""<EXECUTABLE> <ARG1> <ARG2>..."" - profile executable\n'
+                             'Option 2: ""<PYTHON_SCRIPT> <ARG1> <ARG2>..."" - profile python script\n'
+                             'Option 3: (--python flag present) ""<PYTHON_EXECUTABLE> <PYTHON_SCRIPT> <ARG1> <ARG2>..."" - profile python script with specified interpreter\n'
+                             'Option 4: (--python flag present) ""<PYTHON_MODULE> <ARG1> <ARG2>..."" - profile python module\n'
+                        )
     args = parser.parse_args()
 
     if len(args.program) == 0:
",True,mprof,False
"@@ -46,12 +46,10 @@ _TWO_20 = float(2 ** 20)
 
 if PY2:
     import __builtin__ as builtins
+    to_str = lambda x: x
 else:
     import builtins
-
-
-    def unicode(x, *args):
-        return str(x)
+    to_str = lambda x: str(x)
 
 # .. get available packages ..
 try:
@@ -777,7 +775,7 @@ def show_results(prof, stream=None, precision=1):
                 mem = u''
                 inc = u''
             tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
-            stream.write(unicode(tmp, 'UTF-8'))
+            stream.write(to_str(tmp))
         stream.write(u'\n\n')
 
 
","@@ -46,12 +46,10 @@ _TWO_20 = float(2 ** 20)
 
 if PY2:
     import __builtin__ as builtins
+    to_str = lambda x: x
 else:
     import builtins
-
-
-    def unicode(x, *args):
-        return str(x)
+    to_str = lambda x: str(x)
 
 # .. get available packages ..
 try:
@@ -777,7 +775,7 @@ def show_results(prof, stream=None, precision=1):
                 mem = u''
                 inc = u''
             tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
-            stream.write(unicode(tmp, 'UTF-8'))
+            stream.write(to_str(tmp))
         stream.write(u'\n\n')
 
 
",True,memory_profiler.py,True
"@@ -0,0 +1,14 @@
+# -*- coding: utf-8  -*-
+
+from memory_profiler import profile
+
+f = open('/dev/null', 'w')
+@profile(stream=f)
+def test_unicode(txt):
+    # test when unicode is present
+    txt = txt.replace (u"""", u"""") #Arabic Yah = 
+    return txt
+
+
+if __name__ == '__main__':
+	test_unicode (u"""")
","@@ -0,0 +1,14 @@
+# -*- coding: utf-8  -*-
+
+from memory_profiler import profile
+
+f = open('/dev/null', 'w')
+@profile(stream=f)
+def test_unicode(txt):
+    # test when unicode is present
+    txt = txt.replace (u"""", u"""") #Arabic Yah = 
+    return txt
+
+
+if __name__ == '__main__':
+	test_unicode (u"""")
",True,test/test_stream_unicode.py,True
"@@ -187,6 +187,10 @@ def run_action():
                         help=""""""Monitors forked processes as well (sum up all process memory)"""""")
     parser.add_argument(""--multiprocess"", ""-M"", dest=""multiprocess"", action=""store_true"",
                         help=""""""Monitors forked processes creating individual plots for each child (disables --python features)"""""")
+    parser.add_argument(""--output"", ""-o"", dest=""filename"",
+                        default=""mprofile_<YYYYMMDDhhmmss>.dat"",
+                        help=""""""File to store results in, defaults to 'mprofile_<YYYYMMDDhhmmss>.dat',
+(where <YYYYMMDDhhmmss> is the date-time of the program start)"""""")
     parser.add_argument(""program"", nargs=REMAINDER,
                         help='Option 1: ""<EXECUTABLE> <ARG1> <ARG2>..."" - profile executable\n'
                              'Option 2: ""<PYTHON_SCRIPT> <ARG1> <ARG2>..."" - profile python script\n'
@@ -202,13 +206,16 @@ def run_action():
     print(""{1}: Sampling memory every {0}s"".format(
         args.interval, osp.basename(sys.argv[0])))
 
-    ## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
-    ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
-    ## directory. This file contains the process memory consumption, in Mb (one
-    ## value per line). Memory is sampled twice each second.""""""
+    if args.filename is None:
+        ## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
+        ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
+        ## directory. This file contains the process memory consumption, in Mb (one
+        ## value per line). Memory is sampled twice each second.""""""
 
-    suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
-    mprofile_output = ""mprofile_%s.dat"" % suffix
+        suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
+        mprofile_output = ""mprofile_%s.dat"" % suffix
+    else:
+        mprofile_output = args.filename
 
     # .. TODO: more than one script as argument ? ..
     program = args.program
","@@ -187,6 +187,10 @@ def run_action():
                         help=""""""Monitors forked processes as well (sum up all process memory)"""""")
     parser.add_argument(""--multiprocess"", ""-M"", dest=""multiprocess"", action=""store_true"",
                         help=""""""Monitors forked processes creating individual plots for each child (disables --python features)"""""")
+    parser.add_argument(""--output"", ""-o"", dest=""filename"",
+                        default=""mprofile_<YYYYMMDDhhmmss>.dat"",
+                        help=""""""File to store results in, defaults to 'mprofile_<YYYYMMDDhhmmss>.dat',
+(where <YYYYMMDDhhmmss> is the date-time of the program start)"""""")
     parser.add_argument(""program"", nargs=REMAINDER,
                         help='Option 1: ""<EXECUTABLE> <ARG1> <ARG2>..."" - profile executable\n'
                              'Option 2: ""<PYTHON_SCRIPT> <ARG1> <ARG2>..."" - profile python script\n'
@@ -202,13 +206,16 @@ def run_action():
     print(""{1}: Sampling memory every {0}s"".format(
         args.interval, osp.basename(sys.argv[0])))
 
-    ## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
-    ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
-    ## directory. This file contains the process memory consumption, in Mb (one
-    ## value per line). Memory is sampled twice each second.""""""
+    if args.filename is None:
+        ## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
+        ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
+        ## directory. This file contains the process memory consumption, in Mb (one
+        ## value per line). Memory is sampled twice each second.""""""
 
-    suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
-    mprofile_output = ""mprofile_%s.dat"" % suffix
+        suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
+        mprofile_output = ""mprofile_%s.dat"" % suffix
+    else:
+        mprofile_output = args.filename
 
     # .. TODO: more than one script as argument ? ..
     program = args.program
",True,mprof,False
"@@ -405,13 +405,13 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
                     # Write children to the stream file
                     if multiprocess:
-                        for idx, chldmem in enumerate(_get_child_memory(proc.pid)):
+                        for idx, chldmem in enumerate(_get_child_memory(proc)):
                             stream.write(""CHLD {0} {1:.6f} {2:.4f}\n"".format(idx, chldmem, time.time()))
                 else:
                     # Create a nested list with the child memory
                     if multiprocess:
                         mem_usage = [mem_usage]
-                        for chldmem in _get_child_memory(proc.pid):
+                        for chldmem in _get_child_memory(proc):
                             mem_usage.append(chldmem)
 
                     # Append the memory usage to the return value
","@@ -405,13 +405,13 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
                     # Write children to the stream file
                     if multiprocess:
-                        for idx, chldmem in enumerate(_get_child_memory(proc.pid)):
+                        for idx, chldmem in enumerate(_get_child_memory(proc)):
                             stream.write(""CHLD {0} {1:.6f} {2:.4f}\n"".format(idx, chldmem, time.time()))
                 else:
                     # Create a nested list with the child memory
                     if multiprocess:
                         mem_usage = [mem_usage]
-                        for chldmem in _get_child_memory(proc.pid):
+                        for chldmem in _get_child_memory(proc):
                             mem_usage.append(chldmem)
 
                     # Append the memory usage to the return value
",True,memory_profiler.py,True
"@@ -188,9 +188,10 @@ def run_action():
     parser.add_argument(""--multiprocess"", ""-M"", dest=""multiprocess"", action=""store_true"",
                         help=""""""Monitors forked processes creating individual plots for each child (disables --python features)"""""")
     parser.add_argument(""--output"", ""-o"", dest=""filename"",
-                        default=""mprofile_<YYYYMMDDhhmmss>.dat"",
-                        help=""""""File to store results in, defaults to 'mprofile_<YYYYMMDDhhmmss>.dat',
-(where <YYYYMMDDhhmmss> is the date-time of the program start)"""""")
+                        default=""mprofile_%s.dat"" % time.strftime(""%Y%m%d%H%M%S"", time.localtime()),
+                        help=""""""File to store results in, defaults to 'mprofile_<YYYYMMDDhhmmss>.dat' in the current directory,
+(where <YYYYMMDDhhmmss> is the date-time of the program start).
+This file contains the process memory consumption, in Mb (one value per line)."""""")
     parser.add_argument(""program"", nargs=REMAINDER,
                         help='Option 1: ""<EXECUTABLE> <ARG1> <ARG2>..."" - profile executable\n'
                              'Option 2: ""<PYTHON_SCRIPT> <ARG1> <ARG2>..."" - profile python script\n'
@@ -206,16 +207,7 @@ def run_action():
     print(""{1}: Sampling memory every {0}s"".format(
         args.interval, osp.basename(sys.argv[0])))
 
-    if args.filename is None:
-        ## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
-        ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
-        ## directory. This file contains the process memory consumption, in Mb (one
-        ## value per line). Memory is sampled twice each second.""""""
-
-        suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
-        mprofile_output = ""mprofile_%s.dat"" % suffix
-    else:
-        mprofile_output = args.filename
+    mprofile_output = args.filename
 
     # .. TODO: more than one script as argument ? ..
     program = args.program
","@@ -188,9 +188,10 @@ def run_action():
     parser.add_argument(""--multiprocess"", ""-M"", dest=""multiprocess"", action=""store_true"",
                         help=""""""Monitors forked processes creating individual plots for each child (disables --python features)"""""")
     parser.add_argument(""--output"", ""-o"", dest=""filename"",
-                        default=""mprofile_<YYYYMMDDhhmmss>.dat"",
-                        help=""""""File to store results in, defaults to 'mprofile_<YYYYMMDDhhmmss>.dat',
-(where <YYYYMMDDhhmmss> is the date-time of the program start)"""""")
+                        default=""mprofile_%s.dat"" % time.strftime(""%Y%m%d%H%M%S"", time.localtime()),
+                        help=""""""File to store results in, defaults to 'mprofile_<YYYYMMDDhhmmss>.dat' in the current directory,
+(where <YYYYMMDDhhmmss> is the date-time of the program start).
+This file contains the process memory consumption, in Mb (one value per line)."""""")
     parser.add_argument(""program"", nargs=REMAINDER,
                         help='Option 1: ""<EXECUTABLE> <ARG1> <ARG2>..."" - profile executable\n'
                              'Option 2: ""<PYTHON_SCRIPT> <ARG1> <ARG2>..."" - profile python script\n'
@@ -206,16 +207,7 @@ def run_action():
     print(""{1}: Sampling memory every {0}s"".format(
         args.interval, osp.basename(sys.argv[0])))
 
-    if args.filename is None:
-        ## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
-        ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
-        ## directory. This file contains the process memory consumption, in Mb (one
-        ## value per line). Memory is sampled twice each second.""""""
-
-        suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
-        mprofile_output = ""mprofile_%s.dat"" % suffix
-    else:
-        mprofile_output = args.filename
+    mprofile_output = args.filename
 
     # .. TODO: more than one script as argument ? ..
     program = args.program
",True,mprof,False
"@@ -8,3 +8,6 @@ MANIFEST
 
 # Ignore mprof generated files
 mprofile_*.dat
+
+# virtual environment
+venv/
","@@ -8,3 +8,6 @@ MANIFEST
 
 # Ignore mprof generated files
 mprofile_*.dat
+
+# virtual environment
+venv/
",True,.gitignore,False
"@@ -15,3 +15,6 @@ test:
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
 	$(PYTHON) test/test_exception.py
+
+develop:
+	pip install -e .
","@@ -15,3 +15,6 @@ test:
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
 	$(PYTHON) test/test_exception.py
+
+develop:
+	pip install -e .
",True,Makefile,False
"@@ -3,20 +3,22 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.50.0'
+__version__ = '0.53.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
-import time
-import sys
+from functools import wraps
+import inspect
+import linecache
+import logging
 import os
 import pdb
-import warnings
-import linecache
-import inspect
 import subprocess
-import logging
+import sys
+import time
 import traceback
+import warnings
+
 if sys.platform == ""win32"":
     # any value except signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT
     # can be used to kill a process unconditionally in Windows
@@ -1067,6 +1069,7 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
         if not tracemalloc.is_tracing():
             tracemalloc.start()
     if func is not None:
+        @wraps(func)
         def wrapper(*args, **kwargs):
             prof = LineProfiler(backend=backend)
             val = prof(func)(*args, **kwargs)
","@@ -3,20 +3,22 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.50.0'
+__version__ = '0.53.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
-import time
-import sys
+from functools import wraps
+import inspect
+import linecache
+import logging
 import os
 import pdb
-import warnings
-import linecache
-import inspect
 import subprocess
-import logging
+import sys
+import time
 import traceback
+import warnings
+
 if sys.platform == ""win32"":
     # any value except signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT
     # can be used to kill a process unconditionally in Windows
@@ -1067,6 +1069,7 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
         if not tracemalloc.is_tracing():
             tracemalloc.start()
     if func is not None:
+        @wraps(func)
         def wrapper(*args, **kwargs):
             prof = LineProfiler(backend=backend)
             val = prof(func)(*args, **kwargs)
",True,memory_profiler.py,True
"@@ -5,6 +5,7 @@ PYTHON ?= python
 test:
 	$(PYTHON) -m memory_profiler test/test_func.py
 	$(PYTHON) -m memory_profiler test/test_loop.py
+	$(PYTHON) -m memory_profiler test/test_mprofile.py
 	$(PYTHON) -m memory_profiler test/test_as.py
 	$(PYTHON) -m memory_profiler test/test_global.py
 	$(PYTHON) -m memory_profiler test/test_precision_command_line.py
","@@ -5,6 +5,7 @@ PYTHON ?= python
 test:
 	$(PYTHON) -m memory_profiler test/test_func.py
 	$(PYTHON) -m memory_profiler test/test_loop.py
+	$(PYTHON) -m memory_profiler test/test_mprofile.py
 	$(PYTHON) -m memory_profiler test/test_as.py
 	$(PYTHON) -m memory_profiler test/test_global.py
 	$(PYTHON) -m memory_profiler test/test_precision_command_line.py
",True,Makefile,False
"@@ -4,6 +4,7 @@ import time
 
 @profile
 def test1(l):
+    """"""test1 docstring""""""
     a = [1] * l
     time.sleep(1)
     return a
@@ -14,8 +15,22 @@ def test2(l):
     time.sleep(1)
     return b
 
+def test3(l):
+    """"""test3 docstring""""""
+    return l
+
 if __name__ == ""__main__"":
     l = 100000
     test1(l)
     test2(2 * l)
 
+    # make sure that the function name and docstring are set
+    # by functools.wraps
+    # memory_profile.py def profile func is not None case
+    assert (test1.__name__ == 'test1'), 'function name is incorrect'
+    assert (test1.__doc__ == 'test1 docstring'), 'function docstring is incorrect'
+    # memory_profile.py def profile func is None case
+    profile_maker = profile()
+    profiled_test3 = profile_maker(test3)
+    assert (profiled_test3.__name__ == 'test3'), 'function name is incorrect'
+    assert (profiled_test3.__doc__ == 'test3 docstring'), 'function docstring is incorrect'
","@@ -4,6 +4,7 @@ import time
 
 @profile
 def test1(l):
+    """"""test1 docstring""""""
     a = [1] * l
     time.sleep(1)
     return a
@@ -14,8 +15,22 @@ def test2(l):
     time.sleep(1)
     return b
 
+def test3(l):
+    """"""test3 docstring""""""
+    return l
+
 if __name__ == ""__main__"":
     l = 100000
     test1(l)
     test2(2 * l)
 
+    # make sure that the function name and docstring are set
+    # by functools.wraps
+    # memory_profile.py def profile func is not None case
+    assert (test1.__name__ == 'test1'), 'function name is incorrect'
+    assert (test1.__doc__ == 'test1 docstring'), 'function docstring is incorrect'
+    # memory_profile.py def profile func is None case
+    profile_maker = profile()
+    profiled_test3 = profile_maker(test3)
+    assert (profiled_test3.__name__ == 'test3'), 'function name is incorrect'
+    assert (profiled_test3.__doc__ == 'test3 docstring'), 'function docstring is incorrect'
",True,test/test_mprofile.py,True
"@@ -48,6 +48,7 @@ _TWO_20 = float(2 ** 20)
 
 if PY2:
     import __builtin__ as builtins
+    from future_builtins import filter
 else:
     import builtins
 
@@ -1122,11 +1123,11 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     ns = dict(_CLEAN_GLOBALS, profile=profiler)
     _backend = choose_backend(backend)
     sys.argv = [filename] + passed_args
+    if _backend == 'tracemalloc' and has_tracemalloc:
+        tracemalloc.start()
     if PY2:
         execfile(filename, ns, ns)
     else:
-        if _backend == 'tracemalloc' and has_tracemalloc:
-            tracemalloc.start()
         try:
             with open(filename) as f:
                 exec(compile(f.read(), filename, 'exec'), ns, ns)
","@@ -48,6 +48,7 @@ _TWO_20 = float(2 ** 20)
 
 if PY2:
     import __builtin__ as builtins
+    from future_builtins import filter
 else:
     import builtins
 
@@ -1122,11 +1123,11 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     ns = dict(_CLEAN_GLOBALS, profile=profiler)
     _backend = choose_backend(backend)
     sys.argv = [filename] + passed_args
+    if _backend == 'tracemalloc' and has_tracemalloc:
+        tracemalloc.start()
     if PY2:
         execfile(filename, ns, ns)
     else:
-        if _backend == 'tracemalloc' and has_tracemalloc:
-            tracemalloc.start()
         try:
             with open(filename) as f:
                 exec(compile(f.read(), filename, 'exec'), ns, ns)
",True,memory_profiler.py,True
"@@ -1123,17 +1123,17 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     ns = dict(_CLEAN_GLOBALS, profile=profiler)
     _backend = choose_backend(backend)
     sys.argv = [filename] + passed_args
-    if _backend == 'tracemalloc' and has_tracemalloc:
-        tracemalloc.start()
-    if PY2:
-        execfile(filename, ns, ns)
-    else:
-        try:
+    try:
+        if _backend == 'tracemalloc' and has_tracemalloc:
+            tracemalloc.start()
+        if PY2:
+            execfile(filename, ns, ns)
+        else:
             with open(filename) as f:
                 exec(compile(f.read(), filename, 'exec'), ns, ns)
-        finally:
-            if has_tracemalloc and tracemalloc.is_tracing():
-                tracemalloc.stop()
+    finally:
+        if has_tracemalloc and tracemalloc.is_tracing():
+            tracemalloc.stop()
 
 
 def run_module_with_profiler(module, profiler, backend, passed_args=[]):
","@@ -1123,17 +1123,17 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     ns = dict(_CLEAN_GLOBALS, profile=profiler)
     _backend = choose_backend(backend)
     sys.argv = [filename] + passed_args
-    if _backend == 'tracemalloc' and has_tracemalloc:
-        tracemalloc.start()
-    if PY2:
-        execfile(filename, ns, ns)
-    else:
-        try:
+    try:
+        if _backend == 'tracemalloc' and has_tracemalloc:
+            tracemalloc.start()
+        if PY2:
+            execfile(filename, ns, ns)
+        else:
             with open(filename) as f:
                 exec(compile(f.read(), filename, 'exec'), ns, ns)
-        finally:
-            if has_tracemalloc and tracemalloc.is_tracing():
-                tracemalloc.stop()
+    finally:
+        if has_tracemalloc and tracemalloc.is_tracing():
+            tracemalloc.stop()
 
 
 def run_module_with_profiler(module, profiler, backend, passed_args=[]):
",True,memory_profiler.py,True
"@@ -1126,11 +1126,8 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     try:
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
-        if PY2:
-            execfile(filename, ns, ns)
-        else:
-            with open(filename) as f:
-                exec(compile(f.read(), filename, 'exec'), ns, ns)
+        with open(filename) as f:
+            exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
         if has_tracemalloc and tracemalloc.is_tracing():
             tracemalloc.stop()
","@@ -1126,11 +1126,8 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     try:
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
-        if PY2:
-            execfile(filename, ns, ns)
-        else:
-            with open(filename) as f:
-                exec(compile(f.read(), filename, 'exec'), ns, ns)
+        with open(filename) as f:
+            exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
         if has_tracemalloc and tracemalloc.is_tracing():
             tracemalloc.stop()
",True,memory_profiler.py,True
"@@ -1,27 +0,0 @@
-from memory_profiler import profile
-
-
-def gen(count):
-    r = list(range(0,count))
-    return r
-
-_global_var = []
-def _gen_cache():
-    global _global_var
-    if not _global_var:
-        _global_var = gen(1000000)
-
-@profile(precision=4)
-def test():
-    a = gen(90000)
-    for i in range(0,3):
-        b = i
-        def _inner_gen():
-            gen(1024*1024*20)
-        h = i
-        _gen_cache()
-        _inner_gen()
-        g = i
-
-if __name__ == ""__main__"":
-    test()
","@@ -1,27 +0,0 @@
-from memory_profiler import profile
-
-
-def gen(count):
-    r = list(range(0,count))
-    return r
-
-_global_var = []
-def _gen_cache():
-    global _global_var
-    if not _global_var:
-        _global_var = gen(1000000)
-
-@profile(precision=4)
-def test():
-    a = gen(90000)
-    for i in range(0,3):
-        b = i
-        def _inner_gen():
-            gen(1024*1024*20)
-        h = i
-        _gen_cache()
-        _inner_gen()
-        g = i
-
-if __name__ == ""__main__"":
-    test()
",True,,False
"@@ -597,9 +597,7 @@ class CodeMap(dict):
 
         prev_line_value = self[code].get(prev_lineno, None) if prev_lineno else None
         prev_line_memory = prev_line_value[1] if prev_line_value else 0
-        #inc = (memory-prev_line_memory)
-        #print('trace lineno=%(lineno)s prev_lineno=%(prev_lineno)s mem=%(memory)s prev_inc=%(previous_inc)s inc=%(inc)s' % locals())
-        self[code][lineno] = (previous_inc + (memory-prev_line_memory), max(memory, previous_memory))
+        self[code][lineno] = (max(previous_inc, memory-prev_line_memory), max(memory, previous_memory))
 
     def items(self):
         """"""Iterate on the toplevel code blocks.""""""
","@@ -597,9 +597,7 @@ class CodeMap(dict):
 
         prev_line_value = self[code].get(prev_lineno, None) if prev_lineno else None
         prev_line_memory = prev_line_value[1] if prev_line_value else 0
-        #inc = (memory-prev_line_memory)
-        #print('trace lineno=%(lineno)s prev_lineno=%(prev_lineno)s mem=%(memory)s prev_inc=%(previous_inc)s inc=%(inc)s' % locals())
-        self[code][lineno] = (previous_inc + (memory-prev_line_memory), max(memory, previous_memory))
+        self[code][lineno] = (max(previous_inc, memory-prev_line_memory), max(memory, previous_memory))
 
     def items(self):
         """"""Iterate on the toplevel code blocks.""""""
",True,memory_profiler.py,True
"@@ -18,8 +18,6 @@ EPSILON = 0.0001
 def test_memory_profiler(test_input, expected):
     mem_prof(test_input)
     inc, dec = parse_mem_prof()
-    assert abs(inc - dec) <= EPSILON, \
-        'inc = {}, dec = {}, err = {}'.format(inc, dec, abs(inc - dec))
     assert abs(inc - expected) <= EPSILON, \
         'inc = {}, size = {}, err = {}'.format(
             inc, expected, abs(inc - expected)
","@@ -18,8 +18,6 @@ EPSILON = 0.0001
 def test_memory_profiler(test_input, expected):
     mem_prof(test_input)
     inc, dec = parse_mem_prof()
-    assert abs(inc - dec) <= EPSILON, \
-        'inc = {}, dec = {}, err = {}'.format(inc, dec, abs(inc - dec))
     assert abs(inc - expected) <= EPSILON, \
         'inc = {}, size = {}, err = {}'.format(
             inc, expected, abs(inc - expected)
",True,test/test_tracemalloc.py,True
"@@ -1,5 +1,3 @@
-#!/usr/bin/env python
-
 import glob
 import os
 import os.path as osp
@@ -465,7 +463,7 @@ such file in the current directory.""""""
                         help=""Save plot to file instead of displaying it."")
     parser.add_argument(""--window"", ""-w"", dest=""xlim"", type=xlim_type,
                         help=""Plot a time-subset of the data. E.g. to plot between 0 and 20.5 seconds: --window 0,20.5"")
-    parser.add_argument(""--backend"", 
+    parser.add_argument(""--backend"",
                       help=""Specify the Matplotlib backend to use"")
     parser.add_argument(""profiles"", nargs=""*"",
                         help=""profiles made by mprof run"")
@@ -540,8 +538,7 @@ such file in the current directory.""""""
     else:
         pl.show()
 
-
-if __name__ == ""__main__"":
+def main():
     # Workaround for optparse limitation: insert -- before first negative
     # number found.
     negint = re.compile(""-[0-9]+"")
@@ -555,3 +552,6 @@ if __name__ == ""__main__"":
                ""run"": run_action,
                ""plot"": plot_action}
     actions[get_action()]()
+
+if __name__ == ""__main__"":
+    main()
","@@ -1,5 +1,3 @@
-#!/usr/bin/env python
-
 import glob
 import os
 import os.path as osp
@@ -465,7 +463,7 @@ such file in the current directory.""""""
                         help=""Save plot to file instead of displaying it."")
     parser.add_argument(""--window"", ""-w"", dest=""xlim"", type=xlim_type,
                         help=""Plot a time-subset of the data. E.g. to plot between 0 and 20.5 seconds: --window 0,20.5"")
-    parser.add_argument(""--backend"", 
+    parser.add_argument(""--backend"",
                       help=""Specify the Matplotlib backend to use"")
     parser.add_argument(""profiles"", nargs=""*"",
                         help=""profiles made by mprof run"")
@@ -540,8 +538,7 @@ such file in the current directory.""""""
     else:
         pl.show()
 
-
-if __name__ == ""__main__"":
+def main():
     # Workaround for optparse limitation: insert -- before first negative
     # number found.
     negint = re.compile(""-[0-9]+"")
@@ -555,3 +552,6 @@ if __name__ == ""__main__"":
                ""run"": run_action,
                ""plot"": plot_action}
     actions[get_action()]()
+
+if __name__ == ""__main__"":
+    main()
",True,mprof.py,True
"@@ -1,7 +1,6 @@
 import os
 import io
 import re
-import sys
 from setuptools import setup
 
 
@@ -40,10 +39,6 @@ Operating System :: Unix
 
 """"""
 
-scripts = ['mprof']
-if sys.platform == ""win32"":
-    scripts.append('mprof.bat')
-
 setup(
     name='memory_profiler',
     description='A module for monitoring memory usage of a python program',
@@ -52,8 +47,10 @@ setup(
     author='Fabian Pedregosa',
     author_email='f@bianp.net',
     url='http://pypi.python.org/pypi/memory_profiler',
-    py_modules=['memory_profiler'],
-    scripts=scripts,
+    py_modules=['memory_profiler', 'mprof'],
+    entry_points={
+        'console_scripts' : ['mprof:main'],
+    },
     install_requires=['psutil'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='BSD'
","@@ -1,7 +1,6 @@
 import os
 import io
 import re
-import sys
 from setuptools import setup
 
 
@@ -40,10 +39,6 @@ Operating System :: Unix
 
 """"""
 
-scripts = ['mprof']
-if sys.platform == ""win32"":
-    scripts.append('mprof.bat')
-
 setup(
     name='memory_profiler',
     description='A module for monitoring memory usage of a python program',
@@ -52,8 +47,10 @@ setup(
     author='Fabian Pedregosa',
     author_email='f@bianp.net',
     url='http://pypi.python.org/pypi/memory_profiler',
-    py_modules=['memory_profiler'],
-    scripts=scripts,
+    py_modules=['memory_profiler', 'mprof'],
+    entry_points={
+        'console_scripts' : ['mprof:main'],
+    },
     install_requires=['psutil'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='BSD'
",True,setup.py,True
"@@ -49,7 +49,7 @@ setup(
     url='http://pypi.python.org/pypi/memory_profiler',
     py_modules=['memory_profiler', 'mprof'],
     entry_points={
-        'console_scripts' : ['mprof:main'],
+        'console_scripts' : ['mprof = mprof:main'],
     },
     install_requires=['psutil'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
","@@ -49,7 +49,7 @@ setup(
     url='http://pypi.python.org/pypi/memory_profiler',
     py_modules=['memory_profiler', 'mprof'],
     entry_points={
-        'console_scripts' : ['mprof:main'],
+        'console_scripts' : ['mprof = mprof:main'],
     },
     install_requires=['psutil'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
",True,setup.py,True
"@@ -1,2 +0,0 @@
-@echo off
-python %~dpn0 %*
\ No newline at end of file
","@@ -1,2 +0,0 @@
-@echo off
-python %~dpn0 %*
\ No newline at end of file
",True,,False
"@@ -10,6 +10,7 @@ python:
 
 matrix:
   allow_failures:
+    - python: ""3.3""
     - python: ""pypy3""
     - python: ""3.7-dev""
 
","@@ -10,6 +10,7 @@ python:
 
 matrix:
   allow_failures:
+    - python: ""3.3""
     - python: ""pypy3""
     - python: ""3.7-dev""
 
",True,.travis.yml,False
"@@ -1,7 +1,6 @@
 language: python
 python:
   - ""2.7""
-  - ""3.3""
   - ""3.4""
   - ""3.5""
   - ""3.6""
@@ -10,7 +9,6 @@ python:
 
 matrix:
   allow_failures:
-    - python: ""3.3""
     - python: ""pypy3""
     - python: ""3.7-dev""
 
","@@ -1,7 +1,6 @@
 language: python
 python:
   - ""2.7""
-  - ""3.3""
   - ""3.4""
   - ""3.5""
   - ""3.6""
@@ -10,7 +9,6 @@ python:
 
 matrix:
   allow_failures:
-    - python: ""3.3""
     - python: ""pypy3""
     - python: ""3.7-dev""
 
",True,.travis.yml,False
"@@ -18,6 +18,9 @@ To install through easy_install or pip::
 
     $ easy_install -U memory_profiler # pip install -U memory_profiler
 
+The package is also available on ```conda-forge`` 
+<https://github.com/conda-forge/memory_profiler-feedstock>`_.
+
 To install from source, download the package, extract and type::
 
     $ python setup.py install
","@@ -18,6 +18,9 @@ To install through easy_install or pip::
 
     $ easy_install -U memory_profiler # pip install -U memory_profiler
 
+The package is also available on ```conda-forge`` 
+<https://github.com/conda-forge/memory_profiler-feedstock>`_.
+
 To install from source, download the package, extract and type::
 
     $ python setup.py install
",True,README.rst,False
"@@ -18,7 +18,7 @@ To install through easy_install or pip::
 
     $ easy_install -U memory_profiler # pip install -U memory_profiler
 
-The package is also available on ```conda-forge`` 
+The package is also available on `conda-forge
 <https://github.com/conda-forge/memory_profiler-feedstock>`_.
 
 To install from source, download the package, extract and type::
","@@ -18,7 +18,7 @@ To install through easy_install or pip::
 
     $ easy_install -U memory_profiler # pip install -U memory_profiler
 
-The package is also available on ```conda-forge`` 
+The package is also available on `conda-forge
 <https://github.com/conda-forge/memory_profiler-feedstock>`_.
 
 To install from source, download the package, extract and type::
",True,README.rst,False
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.53.0'
+__version__ = '0.54.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.53.0'
+__version__ = '0.54.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -14,9 +14,9 @@ programs. It is a pure python module which depends on the `psutil
 ==============
  Installation
 ==============
-To install through easy_install or pip::
+Install via pip::
 
-    $ easy_install -U memory_profiler # pip install -U memory_profiler
+    $ pip install -U memory_profiler
 
 The package is also available on `conda-forge
 <https://github.com/conda-forge/memory_profiler-feedstock>`_.
","@@ -14,9 +14,9 @@ programs. It is a pure python module which depends on the `psutil
 ==============
  Installation
 ==============
-To install through easy_install or pip::
+Install via pip::
 
-    $ easy_install -U memory_profiler # pip install -U memory_profiler
+    $ pip install -U memory_profiler
 
 The package is also available on `conda-forge
 <https://github.com/conda-forge/memory_profiler-feedstock>`_.
",True,README.rst,False
"@@ -16,6 +16,7 @@ test:
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
 	$(PYTHON) test/test_exception.py
+	$(PYTHON) test/test_mprof.py
 
 develop:
 	pip install -e .
","@@ -16,6 +16,7 @@ test:
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
 	$(PYTHON) test/test_exception.py
+	$(PYTHON) test/test_mprof.py
 
 develop:
 	pip install -e .
",True,Makefile,False
"@@ -422,11 +422,12 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
     # plot timestamps, if any
     if len(ts) > 0 and timestamps:
         func_num = 0
+        f_labels = function_labels(ts.keys())
         for f, exec_ts in ts.items():
             for execution in exec_ts:
                 add_brackets(execution[:2], execution[2:], xshift=global_start,
                              color=all_colors[func_num % len(all_colors)],
-                             label=f.split(""."")[-1]
+                             label=f_labels[f]
                                    + "" %.3fs"" % (execution[1] - execution[0]), options=options)
             func_num += 1
 
@@ -439,6 +440,33 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
     return mprofile
 
 
+def function_labels(dotted_function_names):
+    state = {}
+
+    def set_state_for(function_names, level):
+        for fn in function_names:
+            label = ""."".join(fn.split(""."")[-level:])
+            label_state = state.setdefault(label, {""functions"": [],
+                                                   ""level"": level})
+            label_state[""functions""].append(fn)`
+
+    set_state_for(dotted_function_names, 1)
+
+    while True:
+        ambiguous_labels = [label for label in state if len(state[label][""functions""]) > 1]
+        for ambiguous_label in ambiguous_labels:
+            function_names = state[ambiguous_label][""functions""]
+            new_level = state[ambiguous_label][""level""] + 1
+            del state[ambiguous_label]
+            set_state_for(function_names, new_level)
+        if len(ambiguous_labels) == 0:
+            break
+
+    fn_to_label = { label_state[""functions""][0] : label for label, label_state in state.items() }
+
+    return fn_to_label
+
+
 def plot_action():
     def xlim_type(value):
         try:
","@@ -422,11 +422,12 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
     # plot timestamps, if any
     if len(ts) > 0 and timestamps:
         func_num = 0
+        f_labels = function_labels(ts.keys())
         for f, exec_ts in ts.items():
             for execution in exec_ts:
                 add_brackets(execution[:2], execution[2:], xshift=global_start,
                              color=all_colors[func_num % len(all_colors)],
-                             label=f.split(""."")[-1]
+                             label=f_labels[f]
                                    + "" %.3fs"" % (execution[1] - execution[0]), options=options)
             func_num += 1
 
@@ -439,6 +440,33 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
     return mprofile
 
 
+def function_labels(dotted_function_names):
+    state = {}
+
+    def set_state_for(function_names, level):
+        for fn in function_names:
+            label = ""."".join(fn.split(""."")[-level:])
+            label_state = state.setdefault(label, {""functions"": [],
+                                                   ""level"": level})
+            label_state[""functions""].append(fn)`
+
+    set_state_for(dotted_function_names, 1)
+
+    while True:
+        ambiguous_labels = [label for label in state if len(state[label][""functions""]) > 1]
+        for ambiguous_label in ambiguous_labels:
+            function_names = state[ambiguous_label][""functions""]
+            new_level = state[ambiguous_label][""level""] + 1
+            del state[ambiguous_label]
+            set_state_for(function_names, new_level)
+        if len(ambiguous_labels) == 0:
+            break
+
+    fn_to_label = { label_state[""functions""][0] : label for label, label_state in state.items() }
+
+    return fn_to_label
+
+
 def plot_action():
     def xlim_type(value):
         try:
",True,mprof.py,True
"@@ -0,0 +1,20 @@
+import unittest
+
+import mprof
+
+class Test_function_labels(unittest.TestCase):
+    def test(self):
+        expected = {
+            ""x.z"": ""z"",
+            ""x.y"": ""y"",
+            ""x.b"": ""x.b"",
+            ""f.a.b"": ""f.a.b"",
+            ""g.a.b"": ""g.a.b"",
+            ""g.a.c"": ""a.c"",
+            ""b.c"": ""b.c"",
+        }
+        result = mprof.function_labels(expected.keys())
+        self.assertEqual(expected,result)
+
+if __name__ == ""__main__"":
+    unittest.main()
\ No newline at end of file
","@@ -0,0 +1,20 @@
+import unittest
+
+import mprof
+
+class Test_function_labels(unittest.TestCase):
+    def test(self):
+        expected = {
+            ""x.z"": ""z"",
+            ""x.y"": ""y"",
+            ""x.b"": ""x.b"",
+            ""f.a.b"": ""f.a.b"",
+            ""g.a.b"": ""g.a.b"",
+            ""g.a.c"": ""a.c"",
+            ""b.c"": ""b.c"",
+        }
+        result = mprof.function_labels(expected.keys())
+        self.assertEqual(expected,result)
+
+if __name__ == ""__main__"":
+    unittest.main()
\ No newline at end of file
",True,test/test_mprof.py,True
"@@ -448,7 +448,7 @@ def function_labels(dotted_function_names):
             label = ""."".join(fn.split(""."")[-level:])
             label_state = state.setdefault(label, {""functions"": [],
                                                    ""level"": level})
-            label_state[""functions""].append(fn)`
+            label_state[""functions""].append(fn)
 
     set_state_for(dotted_function_names, 1)
 
","@@ -448,7 +448,7 @@ def function_labels(dotted_function_names):
             label = ""."".join(fn.split(""."")[-level:])
             label_state = state.setdefault(label, {""functions"": [],
                                                    ""level"": level})
-            label_state[""functions""].append(fn)`
+            label_state[""functions""].append(fn)
 
     set_state_for(dotted_function_names, 1)
 
",True,mprof.py,True
"@@ -6,6 +6,7 @@ import re
 import copy
 import time
 import math
+import logging
 
 from collections import defaultdict
 from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormatter
@@ -26,6 +27,9 @@ Type mprof <command> --help for usage help on a specific command.
 For example, mprof plot --help will list all plotting options.
 """"""
 
+logger = logging.getLogger(__name__)
+logging.basicConfig()
+
 
 def print_usage():
     print(""Usage: %s <command> <options> <arguments>""
@@ -185,6 +189,8 @@ def run_action():
                         help=""""""Monitors forked processes as well (sum up all process memory)"""""")
     parser.add_argument(""--multiprocess"", ""-M"", dest=""multiprocess"", action=""store_true"",
                         help=""""""Monitors forked processes creating individual plots for each child (disables --python features)"""""")
+    parser.add_argument(""--exit-code"", ""-E"", dest=""exit_code"", action=""store_true"",
+                        help=""""""Propagate the exit code"""""")
     parser.add_argument(""--output"", ""-o"", dest=""filename"",
                         default=""mprofile_%s.dat"" % time.strftime(""%Y%m%d%H%M%S"", time.localtime()),
                         help=""""""File to store results in, defaults to 'mprofile_<YYYYMMDDhhmmss>.dat' in the current directory,
@@ -236,6 +242,11 @@ This file contains the process memory consumption, in Mb (one value per line).""""
                         include_children=args.include_children,
                         multiprocess=args.multiprocess, stream=f)
 
+    if args.exit_code:
+        if p.returncode != 0:
+            logger.error('Program resulted with a non-zero exit code: %s', p.returncode)
+        sys.exit(p.returncode)
+
 
 def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
     """"""Add two brackets on the memory line plot.
","@@ -6,6 +6,7 @@ import re
 import copy
 import time
 import math
+import logging
 
 from collections import defaultdict
 from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormatter
@@ -26,6 +27,9 @@ Type mprof <command> --help for usage help on a specific command.
 For example, mprof plot --help will list all plotting options.
 """"""
 
+logger = logging.getLogger(__name__)
+logging.basicConfig()
+
 
 def print_usage():
     print(""Usage: %s <command> <options> <arguments>""
@@ -185,6 +189,8 @@ def run_action():
                         help=""""""Monitors forked processes as well (sum up all process memory)"""""")
     parser.add_argument(""--multiprocess"", ""-M"", dest=""multiprocess"", action=""store_true"",
                         help=""""""Monitors forked processes creating individual plots for each child (disables --python features)"""""")
+    parser.add_argument(""--exit-code"", ""-E"", dest=""exit_code"", action=""store_true"",
+                        help=""""""Propagate the exit code"""""")
     parser.add_argument(""--output"", ""-o"", dest=""filename"",
                         default=""mprofile_%s.dat"" % time.strftime(""%Y%m%d%H%M%S"", time.localtime()),
                         help=""""""File to store results in, defaults to 'mprofile_<YYYYMMDDhhmmss>.dat' in the current directory,
@@ -236,6 +242,11 @@ This file contains the process memory consumption, in Mb (one value per line).""""
                         include_children=args.include_children,
                         multiprocess=args.multiprocess, stream=f)
 
+    if args.exit_code:
+        if p.returncode != 0:
+            logger.error('Program resulted with a non-zero exit code: %s', p.returncode)
+        sys.exit(p.returncode)
+
 
 def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
     """"""Add two brackets on the memory line plot.
",True,mprof.py,True
"@@ -16,6 +16,7 @@ test:
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
 	$(PYTHON) test/test_exception.py
+	$(PYTHON) test/test_exit_code.py
 
 develop:
 	pip install -e .
","@@ -16,6 +16,7 @@ test:
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
 	$(PYTHON) test/test_exception.py
+	$(PYTHON) test/test_exit_code.py
 
 develop:
 	pip install -e .
",True,Makefile,False
"@@ -189,8 +189,7 @@ def run_action():
                         help=""""""Monitors forked processes as well (sum up all process memory)"""""")
     parser.add_argument(""--multiprocess"", ""-M"", dest=""multiprocess"", action=""store_true"",
                         help=""""""Monitors forked processes creating individual plots for each child (disables --python features)"""""")
-    parser.add_argument(""--exit-code"", ""-E"", dest=""exit_code"", action=""store_true"",
-                        help=""""""Propagate the exit code"""""")
+    parser.add_argument(""--exit-code"", ""-E"", dest=""exit_code"", action=""store_true"", help=""""""Propagate the exit code"""""")
     parser.add_argument(""--output"", ""-o"", dest=""filename"",
                         default=""mprofile_%s.dat"" % time.strftime(""%Y%m%d%H%M%S"", time.localtime()),
                         help=""""""File to store results in, defaults to 'mprofile_<YYYYMMDDhhmmss>.dat' in the current directory,
@@ -203,7 +202,7 @@ This file contains the process memory consumption, in Mb (one value per line).""""
                              'Option 4: (--python flag present) ""<PYTHON_MODULE> <ARG1> <ARG2>..."" - profile python module\n'
                         )
     args = parser.parse_args()
-
+    print(args)
     if len(args.program) == 0:
         print(""A program to run must be provided. Use -h for help"")
         sys.exit(1)
","@@ -189,8 +189,7 @@ def run_action():
                         help=""""""Monitors forked processes as well (sum up all process memory)"""""")
     parser.add_argument(""--multiprocess"", ""-M"", dest=""multiprocess"", action=""store_true"",
                         help=""""""Monitors forked processes creating individual plots for each child (disables --python features)"""""")
-    parser.add_argument(""--exit-code"", ""-E"", dest=""exit_code"", action=""store_true"",
-                        help=""""""Propagate the exit code"""""")
+    parser.add_argument(""--exit-code"", ""-E"", dest=""exit_code"", action=""store_true"", help=""""""Propagate the exit code"""""")
     parser.add_argument(""--output"", ""-o"", dest=""filename"",
                         default=""mprofile_%s.dat"" % time.strftime(""%Y%m%d%H%M%S"", time.localtime()),
                         help=""""""File to store results in, defaults to 'mprofile_<YYYYMMDDhhmmss>.dat' in the current directory,
@@ -203,7 +202,7 @@ This file contains the process memory consumption, in Mb (one value per line).""""
                              'Option 4: (--python flag present) ""<PYTHON_MODULE> <ARG1> <ARG2>..."" - profile python module\n'
                         )
     args = parser.parse_args()
-
+    print(args)
     if len(args.program) == 0:
         print(""A program to run must be provided. Use -h for help"")
         sys.exit(1)
",True,mprof.py,True
"@@ -0,0 +1,33 @@
+import unittest
+import sys
+import tempfile
+
+class TestExitCode(unittest.TestCase):
+
+    def setUp(self):
+        # to be able to import mprof
+        sys.path.append('.')
+        from mprof import run_action
+        self.run_action = run_action
+
+    def test_exit_code_success(self):
+        s = ""1+1""
+        tmpfile = tempfile.NamedTemporaryFile('w', suffix='.py')
+        with tmpfile as ofile:
+            ofile.write(s)
+            ofile.flush()
+            sys.argv = ['<ignored>', '--exit-code', tmpfile.name]
+            self.assertRaisesRegex(SystemExit, '0', self.run_action)
+
+    def test_exit_code_fail(self):
+        s = ""raise RuntimeError('I am not working nicely')""
+        tmpfile = tempfile.NamedTemporaryFile('w', suffix='.py')
+        with tmpfile as ofile:
+            ofile.write(s)
+            ofile.flush()
+            sys.argv = ['<ignored>', '--exit-code', tmpfile.name]
+            self.assertRaisesRegex(SystemExit, '1', self.run_action)
+
+
+if __name__ == '__main__':
+    unittest.main()
","@@ -0,0 +1,33 @@
+import unittest
+import sys
+import tempfile
+
+class TestExitCode(unittest.TestCase):
+
+    def setUp(self):
+        # to be able to import mprof
+        sys.path.append('.')
+        from mprof import run_action
+        self.run_action = run_action
+
+    def test_exit_code_success(self):
+        s = ""1+1""
+        tmpfile = tempfile.NamedTemporaryFile('w', suffix='.py')
+        with tmpfile as ofile:
+            ofile.write(s)
+            ofile.flush()
+            sys.argv = ['<ignored>', '--exit-code', tmpfile.name]
+            self.assertRaisesRegex(SystemExit, '0', self.run_action)
+
+    def test_exit_code_fail(self):
+        s = ""raise RuntimeError('I am not working nicely')""
+        tmpfile = tempfile.NamedTemporaryFile('w', suffix='.py')
+        with tmpfile as ofile:
+            ofile.write(s)
+            ofile.flush()
+            sys.argv = ['<ignored>', '--exit-code', tmpfile.name]
+            self.assertRaisesRegex(SystemExit, '1', self.run_action)
+
+
+if __name__ == '__main__':
+    unittest.main()
",True,test/test_exit_code.py,True
"@@ -2,6 +2,7 @@ import unittest
 import sys
 import tempfile
 
+
 class TestExitCode(unittest.TestCase):
 
     def setUp(self):
@@ -28,6 +29,14 @@ class TestExitCode(unittest.TestCase):
             sys.argv = ['<ignored>', '--exit-code', tmpfile.name]
             self.assertRaisesRegex(SystemExit, '1', self.run_action)
 
+    def test_no_exit_code_success(self):
+        s = ""raise RuntimeError('I am not working nicely')""
+        tmpfile = tempfile.NamedTemporaryFile('w', suffix='.py')
+        with tmpfile as ofile:
+            ofile.write(s)
+            ofile.flush()
+            sys.argv = ['<ignored>', tmpfile.name]
+            self.run_action()
 
 if __name__ == '__main__':
     unittest.main()
","@@ -2,6 +2,7 @@ import unittest
 import sys
 import tempfile
 
+
 class TestExitCode(unittest.TestCase):
 
     def setUp(self):
@@ -28,6 +29,14 @@ class TestExitCode(unittest.TestCase):
             sys.argv = ['<ignored>', '--exit-code', tmpfile.name]
             self.assertRaisesRegex(SystemExit, '1', self.run_action)
 
+    def test_no_exit_code_success(self):
+        s = ""raise RuntimeError('I am not working nicely')""
+        tmpfile = tempfile.NamedTemporaryFile('w', suffix='.py')
+        with tmpfile as ofile:
+            ofile.write(s)
+            ofile.flush()
+            sys.argv = ['<ignored>', tmpfile.name]
+            self.run_action()
 
 if __name__ == '__main__':
     unittest.main()
",True,test/test_exit_code.py,True
"@@ -18,7 +18,7 @@ class TestExitCode(unittest.TestCase):
             ofile.write(s)
             ofile.flush()
             sys.argv = ['<ignored>', '--exit-code', tmpfile.name]
-            self.assertRaisesRegex(SystemExit, '0', self.run_action)
+            self.assertRaisesRegexp(SystemExit, '0', self.run_action)
 
     def test_exit_code_fail(self):
         s = ""raise RuntimeError('I am not working nicely')""
@@ -27,7 +27,7 @@ class TestExitCode(unittest.TestCase):
             ofile.write(s)
             ofile.flush()
             sys.argv = ['<ignored>', '--exit-code', tmpfile.name]
-            self.assertRaisesRegex(SystemExit, '1', self.run_action)
+            self.assertRaisesRegexp(SystemExit, '1', self.run_action)
 
     def test_no_exit_code_success(self):
         s = ""raise RuntimeError('I am not working nicely')""
","@@ -18,7 +18,7 @@ class TestExitCode(unittest.TestCase):
             ofile.write(s)
             ofile.flush()
             sys.argv = ['<ignored>', '--exit-code', tmpfile.name]
-            self.assertRaisesRegex(SystemExit, '0', self.run_action)
+            self.assertRaisesRegexp(SystemExit, '0', self.run_action)
 
     def test_exit_code_fail(self):
         s = ""raise RuntimeError('I am not working nicely')""
@@ -27,7 +27,7 @@ class TestExitCode(unittest.TestCase):
             ofile.write(s)
             ofile.flush()
             sys.argv = ['<ignored>', '--exit-code', tmpfile.name]
-            self.assertRaisesRegex(SystemExit, '1', self.run_action)
+            self.assertRaisesRegexp(SystemExit, '1', self.run_action)
 
     def test_no_exit_code_success(self):
         s = ""raise RuntimeError('I am not working nicely')""
",True,test/test_exit_code.py,True
"@@ -17,4 +17,4 @@ class Test_function_labels(unittest.TestCase):
         self.assertEqual(expected,result)
 
 if __name__ == ""__main__"":
-    unittest.main()
\ No newline at end of file
+    unittest.main()
","@@ -17,4 +17,4 @@ class Test_function_labels(unittest.TestCase):
         self.assertEqual(expected,result)
 
 if __name__ == ""__main__"":
-    unittest.main()
\ No newline at end of file
+    unittest.main()
",True,test/test_mprof.py,True
"@@ -202,7 +202,7 @@ This file contains the process memory consumption, in Mb (one value per line).""""
                              'Option 4: (--python flag present) ""<PYTHON_MODULE> <ARG1> <ARG2>..."" - profile python module\n'
                         )
     args = parser.parse_args()
-    print(args)
+    
     if len(args.program) == 0:
         print(""A program to run must be provided. Use -h for help"")
         sys.exit(1)
","@@ -202,7 +202,7 @@ This file contains the process memory consumption, in Mb (one value per line).""""
                              'Option 4: (--python flag present) ""<PYTHON_MODULE> <ARG1> <ARG2>..."" - profile python module\n'
                         )
     args = parser.parse_args()
-    print(args)
+    
     if len(args.program) == 0:
         print(""A program to run must be provided. Use -h for help"")
         sys.exit(1)
",True,mprof.py,True
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.54.0'
+__version__ = '0.55.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.54.0'
+__version__ = '0.55.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -301,7 +301,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         ret = -1
 
     if timeout is not None:
-        max_iter = int(timeout / interval)
+        max_iter = int(round(timeout / interval))
     elif isinstance(proc, int):
         # external process and no timeout
         max_iter = 1
","@@ -301,7 +301,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         ret = -1
 
     if timeout is not None:
-        max_iter = int(timeout / interval)
+        max_iter = int(round(timeout / interval))
     elif isinstance(proc, int):
         # external process and no timeout
         max_iter = 1
",True,memory_profiler.py,True
"@@ -339,6 +339,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 n_measurements = parent_conn.recv()
                 if retval:
                     ret = ret, returned
+                if max_usage:
+                    ret = ret[0]
             except Exception:
                 parent = psutil.Process(os.getpid())
                 for child in parent.children(recursive=True):
","@@ -339,6 +339,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 n_measurements = parent_conn.recv()
                 if retval:
                     ret = ret, returned
+                if max_usage:
+                    ret = ret[0]
             except Exception:
                 parent = psutil.Process(os.getpid())
                 for child in parent.children(recursive=True):
",True,memory_profiler.py,True
"@@ -340,6 +340,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 if retval:
                     ret = ret, returned
                 if max_usage:
+                    # Convert the one element list produced by MemTimer to a singular value
                     ret = ret[0]
             except Exception:
                 parent = psutil.Process(os.getpid())
","@@ -340,6 +340,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 if retval:
                     ret = ret, returned
                 if max_usage:
+                    # Convert the one element list produced by MemTimer to a singular value
                     ret = ret[0]
             except Exception:
                 parent = psutil.Process(os.getpid())
",True,memory_profiler.py,True
"@@ -11,5 +11,20 @@ def test_memory_usage():
     assert ret[0] == (1, 2)
     assert ret[1] == dict(a=1)
 
+
+def test_return_value_consistency():
+    # Test return values when watching process by PID
+    pid_mem_list = memory_usage(timeout=1)
+    assert type(pid_mem_list) == list, ""Memory usage of process should be a list""
+    pid_mem_max = memory_usage(timeout=1, max_usage=True)
+    assert type(pid_mem_max) == float, ""Max memory usage of process should be a number""
+    # Test return values when watching callable
+    func_mem_list = memory_usage((some_func, (42,), dict(a=42)))
+    assert type(func_mem_list) == list, ""Memory usage of callable should be a list""
+    func_mem_max = memory_usage((some_func, (42,), dict(a=42)), max_usage=True)
+    assert type(func_mem_max) == float, ""Max memory usage of callable should be a number""
+
+
 if __name__ == ""__main__"":
     test_memory_usage()
+    test_return_value_consistency()
","@@ -11,5 +11,20 @@ def test_memory_usage():
     assert ret[0] == (1, 2)
     assert ret[1] == dict(a=1)
 
+
+def test_return_value_consistency():
+    # Test return values when watching process by PID
+    pid_mem_list = memory_usage(timeout=1)
+    assert type(pid_mem_list) == list, ""Memory usage of process should be a list""
+    pid_mem_max = memory_usage(timeout=1, max_usage=True)
+    assert type(pid_mem_max) == float, ""Max memory usage of process should be a number""
+    # Test return values when watching callable
+    func_mem_list = memory_usage((some_func, (42,), dict(a=42)))
+    assert type(func_mem_list) == list, ""Memory usage of callable should be a list""
+    func_mem_max = memory_usage((some_func, (42,), dict(a=42)), max_usage=True)
+    assert type(func_mem_max) == float, ""Max memory usage of callable should be a number""
+
+
 if __name__ == ""__main__"":
     test_memory_usage()
+    test_return_value_consistency()
",True,test/test_memory_usage.py,True
"@@ -18,6 +18,7 @@ import sys
 import time
 import traceback
 import warnings
+import contextlib
 
 if sys.platform == ""win32"":
     # any value except signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT
@@ -482,6 +483,8 @@ class TimeStamper:
     def __init__(self, backend):
         self.functions = {}
         self.backend = backend
+        self.current_stack_level = -1
+        self.stack = {}
 
     def __call__(self, func=None, precision=None):
         if func is not None:
@@ -521,6 +524,7 @@ class TimeStamper:
     def add_function(self, func):
         if func not in self.functions:
             self.functions[func] = []
+            self.stack[func] = []
 
     def wrap_function(self, func):
         """""" Wrap a function to timestamp it.
@@ -536,7 +540,8 @@ class TimeStamper:
                 _get_memory(os.getpid(), self.backend, timestamps=True, filename=filename)]
             self.functions[func].append(timestamps)
             try:
-                return func(*args, **kwds)
+                with self.call_on_stack(*args, **kwds) as result:
+                    return result
             finally:
                 # end time
                 timestamps.append(_get_memory(os.getpid(), self.backend, timestamps=True,
@@ -544,6 +549,15 @@ class TimeStamper:
 
         return f
 
+    @contextlib.contextmanager
+    def call_on_stack(self, func, *args, **kwds):
+        self.current_stack_level += 1
+        self.stack[func].append(self.current_stack_level)
+
+        yield func(*args, **kwds)
+
+        self.current_stack_level -= 1
+
     def show_results(self, stream=None):
         if stream is None:
             stream = sys.stdout
","@@ -18,6 +18,7 @@ import sys
 import time
 import traceback
 import warnings
+import contextlib
 
 if sys.platform == ""win32"":
     # any value except signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT
@@ -482,6 +483,8 @@ class TimeStamper:
     def __init__(self, backend):
         self.functions = {}
         self.backend = backend
+        self.current_stack_level = -1
+        self.stack = {}
 
     def __call__(self, func=None, precision=None):
         if func is not None:
@@ -521,6 +524,7 @@ class TimeStamper:
     def add_function(self, func):
         if func not in self.functions:
             self.functions[func] = []
+            self.stack[func] = []
 
     def wrap_function(self, func):
         """""" Wrap a function to timestamp it.
@@ -536,7 +540,8 @@ class TimeStamper:
                 _get_memory(os.getpid(), self.backend, timestamps=True, filename=filename)]
             self.functions[func].append(timestamps)
             try:
-                return func(*args, **kwds)
+                with self.call_on_stack(*args, **kwds) as result:
+                    return result
             finally:
                 # end time
                 timestamps.append(_get_memory(os.getpid(), self.backend, timestamps=True,
@@ -544,6 +549,15 @@ class TimeStamper:
 
         return f
 
+    @contextlib.contextmanager
+    def call_on_stack(self, func, *args, **kwds):
+        self.current_stack_level += 1
+        self.stack[func].append(self.current_stack_level)
+
+        yield func(*args, **kwds)
+
+        self.current_stack_level -= 1
+
     def show_results(self, stream=None):
         if stream is None:
             stream = sys.stdout
",True,memory_profiler.py,True
"@@ -461,16 +461,25 @@ def _find_script(script_name):
 class _TimeStamperCM(object):
     """"""Time-stamping context manager.""""""
 
-    def __init__(self, timestamps, filename, backend):
+    def __init__(self, timestamps, filename, backend, timestamper=None, func=None):
         self.timestamps = timestamps
         self.filename = filename
         self.backend = backend
+        self.ts = timestamper
+        self.func = func
 
     def __enter__(self):
+        if self.ts is not None:
+            self.ts.current_stack_level += 1
+            self.ts.stack[self.func].append(self.ts.current_stack_level)
+
         self.timestamps.append(
             _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
 
     def __exit__(self, *args):
+        if self.ts is not None:
+            self.ts.current_stack_level -= 1
+
         self.timestamps.append(
             _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
 
@@ -519,7 +528,13 @@ class TimeStamper:
             filename = inspect.getsourcefile(func)
         except TypeError:
             filename = '<unknown>'
-        return _TimeStamperCM(timestamps, filename, self.backend)
+        return _TimeStamperCM(
+            timestamps,
+            filename,
+            self.backend,
+            timestamper=self,
+            func=func
+        )
 
     def add_function(self, func):
         if func not in self.functions:
","@@ -461,16 +461,25 @@ def _find_script(script_name):
 class _TimeStamperCM(object):
     """"""Time-stamping context manager.""""""
 
-    def __init__(self, timestamps, filename, backend):
+    def __init__(self, timestamps, filename, backend, timestamper=None, func=None):
         self.timestamps = timestamps
         self.filename = filename
         self.backend = backend
+        self.ts = timestamper
+        self.func = func
 
     def __enter__(self):
+        if self.ts is not None:
+            self.ts.current_stack_level += 1
+            self.ts.stack[self.func].append(self.ts.current_stack_level)
+
         self.timestamps.append(
             _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
 
     def __exit__(self, *args):
+        if self.ts is not None:
+            self.ts.current_stack_level -= 1
+
         self.timestamps.append(
             _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
 
@@ -519,7 +528,13 @@ class TimeStamper:
             filename = inspect.getsourcefile(func)
         except TypeError:
             filename = '<unknown>'
-        return _TimeStamperCM(timestamps, filename, self.backend)
+        return _TimeStamperCM(
+            timestamps,
+            filename,
+            self.backend,
+            timestamper=self,
+            func=func
+        )
 
     def add_function(self, func):
         if func not in self.functions:
",True,memory_profiler.py,True
"@@ -579,9 +579,9 @@ class TimeStamper:
 
         for func, timestamps in self.functions.items():
             function_name = ""%s.%s"" % (func.__module__, func.__name__)
-            for ts in timestamps:
-                stream.write(""FUNC %s %.4f %.4f %.4f %.4f\n"" % (
-                    (function_name,) + ts[0] + ts[1]))
+            for ts, level in zip(timestamps, self.stack[func]):
+                stream.write(""FUNC %s %.4f %.4f %.4f %.4f %d\n"" % (
+                    (function_name,) + ts[0] + ts[1] + (level,)))
 
 
 class CodeMap(dict):
","@@ -579,9 +579,9 @@ class TimeStamper:
 
         for func, timestamps in self.functions.items():
             function_name = ""%s.%s"" % (func.__module__, func.__name__)
-            for ts in timestamps:
-                stream.write(""FUNC %s %.4f %.4f %.4f %.4f\n"" % (
-                    (function_name,) + ts[0] + ts[1]))
+            for ts, level in zip(timestamps, self.stack[func]):
+                stream.write(""FUNC %s %.4f %.4f %.4f %.4f %d\n"" % (
+                    (function_name,) + ts[0] + ts[1] + (level,)))
 
 
 class CodeMap(dict):
",True,memory_profiler.py,True
"@@ -555,7 +555,7 @@ class TimeStamper:
                 _get_memory(os.getpid(), self.backend, timestamps=True, filename=filename)]
             self.functions[func].append(timestamps)
             try:
-                with self.call_on_stack(*args, **kwds) as result:
+                with self.call_on_stack(func, *args, **kwds) as result:
                     return result
             finally:
                 # end time
","@@ -555,7 +555,7 @@ class TimeStamper:
                 _get_memory(os.getpid(), self.backend, timestamps=True, filename=filename)]
             self.functions[func].append(timestamps)
             try:
-                with self.call_on_stack(*args, **kwds) as result:
+                with self.call_on_stack(func, *args, **kwds) as result:
                     return result
             finally:
                 # end time
",True,memory_profiler.py,True
"@@ -11,7 +11,9 @@ import logging
 from collections import defaultdict
 from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormatter
 
-import memory_profiler as mp
+import importlib
+mp = importlib.import_module(""memory_profiler"", __file__)
+# import memory_profiler as mp
 
 ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"")
 help_msg = """"""
@@ -202,7 +204,7 @@ This file contains the process memory consumption, in Mb (one value per line).""""
                              'Option 4: (--python flag present) ""<PYTHON_MODULE> <ARG1> <ARG2>..."" - profile python module\n'
                         )
     args = parser.parse_args()
-    
+
     if len(args.program) == 0:
         print(""A program to run must be provided. Use -h for help"")
         sys.exit(1)
@@ -329,8 +331,12 @@ def read_mprofile_file(filename):
             values = value.split(' ')
             f_name, mem_start, start, mem_end, end = values[:5]
             ts = func_ts.get(f_name, [])
-            ts.append([float(start), float(end),
-                       float(mem_start), float(mem_end)])
+            to_append = [float(start), float(end), float(mem_start), float(mem_end)]
+            if len(values) >= 6:
+                # There is a stack level field
+                stack_level = values[5]
+                to_append.append(int(stack_level))
+            ts.append(to_append)
             func_ts[f_name] = ts
 
         elif field == ""CHLD"":
","@@ -11,7 +11,9 @@ import logging
 from collections import defaultdict
 from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormatter
 
-import memory_profiler as mp
+import importlib
+mp = importlib.import_module(""memory_profiler"", __file__)
+# import memory_profiler as mp
 
 ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"")
 help_msg = """"""
@@ -202,7 +204,7 @@ This file contains the process memory consumption, in Mb (one value per line).""""
                              'Option 4: (--python flag present) ""<PYTHON_MODULE> <ARG1> <ARG2>..."" - profile python module\n'
                         )
     args = parser.parse_args()
-    
+
     if len(args.program) == 0:
         print(""A program to run must be provided. Use -h for help"")
         sys.exit(1)
@@ -329,8 +331,12 @@ def read_mprofile_file(filename):
             values = value.split(' ')
             f_name, mem_start, start, mem_end, end = values[:5]
             ts = func_ts.get(f_name, [])
-            ts.append([float(start), float(end),
-                       float(mem_start), float(mem_end)])
+            to_append = [float(start), float(end), float(mem_start), float(mem_end)]
+            if len(values) >= 6:
+                # There is a stack level field
+                stack_level = values[5]
+                to_append.append(int(stack_level))
+            ts.append(to_append)
             func_ts[f_name] = ts
 
         elif field == ""CHLD"":
",True,mprof.py,True
"@@ -456,6 +456,105 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
     return mprofile
 
 
+def flame_plotter(filename, index=0, timestamps=True, children=True, options=None):
+    try:
+        import pylab as pl
+    except ImportError as e:
+        print(""matplotlib is needed for plotting."")
+        print(e)
+        sys.exit(1)
+    import numpy as np  # pylab requires numpy anyway
+    mprofile = read_mprofile_file(filename)
+
+    if len(mprofile['timestamp']) == 0:
+        print('** No memory usage values have been found in the profile '
+              'file.**\nFile path: {0}\n'
+              'File may be empty or invalid.\n'
+              'It can be deleted with ""mprof rm {0}""'.format(
+            mprofile['filename']))
+        sys.exit(0)
+
+    # Merge function timestamps and memory usage together
+    ts = mprofile['func_timestamp']
+    t = mprofile['timestamp']
+    mem = mprofile['mem_usage']
+    chld = mprofile['children']
+
+    if len(ts) > 0:
+        for values in ts.values():
+            for v in values:
+                t.extend(v[:2])
+                mem.extend(v[2:4])
+
+    mem = np.asarray(mem)
+    t = np.asarray(t)
+    ind = t.argsort()
+    mem = mem[ind]
+    t = t[ind]
+
+    # Plot curves
+    global_start = float(t[0])
+    t = t - global_start
+
+    max_mem = mem.max()
+    max_mem_ind = mem.argmax()
+
+    all_colors = (""c"", ""y"", ""g"", ""r"", ""b"")
+    mem_line_colors = (""k"", ""b"", ""r"", ""g"", ""c"", ""y"", ""m"")
+    mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
+                                   time.localtime(global_start)) \
+                     + "".{0:03d}"".format(int(round(math.modf(global_start)[0] * 1000)))
+
+    pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
+            label=mem_line_label)
+
+    bottom, top = pl.ylim()
+    bottom += 0.001
+    top -= 0.001
+
+    # plot children, if any
+    if len(chld) > 0 and children:
+        cmpoint = (0,0) # maximal child memory
+
+        for idx, (proc, data) in enumerate(chld.items()):
+            # Create the numpy arrays from the series data
+            cts  = np.asarray([item[1] for item in data]) - global_start
+            cmem = np.asarray([item[0] for item in data])
+
+            # Plot the line to the figure
+            pl.plot(cts, cmem, ""+-""  + mem_line_colors[(idx+1) % len(mem_line_colors)],
+                     label=""child {}"".format(proc))
+
+            # Detect the maximal child memory point
+            cmax_mem = cmem.max()
+            if cmax_mem > cmpoint[1]:
+                cmpoint = (cts[cmem.argmax()], cmax_mem)
+
+        # Add the marker lines for the maximal child memory usage
+        pl.vlines(cmpoint[0], pl.ylim()[0]+0.001, pl.ylim()[1] - 0.001, 'r', '--')
+        pl.hlines(cmpoint[1], pl.xlim()[0]+0.001, pl.xlim()[1] - 0.001, 'r', '--')
+
+    # plot timestamps, if any
+    if len(ts) > 0 and timestamps:
+        func_num = 0
+        f_labels = function_labels(ts.keys())
+        for f, exec_ts in ts.items():
+            for execution in exec_ts:
+                add_brackets(execution[:2], execution[2:], xshift=global_start,
+                             color=all_colors[func_num % len(all_colors)],
+                             label=f_labels[f]
+                                   + "" %.3fs"" % (execution[1] - execution[0]), options=options)
+            func_num += 1
+
+    if timestamps:
+        pl.hlines(max_mem,
+                  pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
+                  colors=""r"", linestyles=""--"")
+        pl.vlines(t[max_mem_ind], bottom, top,
+                  colors=""r"", linestyles=""--"")
+    return mprofile
+
+
 def function_labels(dotted_function_names):
     state = {}
 
@@ -507,6 +606,8 @@ such file in the current directory.""""""
                         help=""Save plot to file instead of displaying it."")
     parser.add_argument(""--window"", ""-w"", dest=""xlim"", type=xlim_type,
                         help=""Plot a time-subset of the data. E.g. to plot between 0 and 20.5 seconds: --window 0,20.5"")
+    parser.add_argument(""--flame"", ""-f"", dest=""flame_mode"", action=""store_true"",
+                        help=""Plot the timestamps as a flame-graph instead of the default brackets"")
     parser.add_argument(""--backend"",
                       help=""Specify the Matplotlib backend to use"")
     parser.add_argument(""profiles"", nargs=""*"",
@@ -561,8 +662,11 @@ such file in the current directory.""""""
         timestamps = False
     else:
         timestamps = True
+    plotter = plot_file
+    if args.flame_mode:
+        plotter = flame_plotter
     for n, filename in enumerate(filenames):
-        mprofile = plot_file(filename, index=n, timestamps=timestamps, options=args)
+        mprofile = plotter(filename, index=n, timestamps=timestamps, options=args)
     pl.xlabel(""time (in seconds)"")
     pl.ylabel(""memory used (in MiB)"")
 
","@@ -456,6 +456,105 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
     return mprofile
 
 
+def flame_plotter(filename, index=0, timestamps=True, children=True, options=None):
+    try:
+        import pylab as pl
+    except ImportError as e:
+        print(""matplotlib is needed for plotting."")
+        print(e)
+        sys.exit(1)
+    import numpy as np  # pylab requires numpy anyway
+    mprofile = read_mprofile_file(filename)
+
+    if len(mprofile['timestamp']) == 0:
+        print('** No memory usage values have been found in the profile '
+              'file.**\nFile path: {0}\n'
+              'File may be empty or invalid.\n'
+              'It can be deleted with ""mprof rm {0}""'.format(
+            mprofile['filename']))
+        sys.exit(0)
+
+    # Merge function timestamps and memory usage together
+    ts = mprofile['func_timestamp']
+    t = mprofile['timestamp']
+    mem = mprofile['mem_usage']
+    chld = mprofile['children']
+
+    if len(ts) > 0:
+        for values in ts.values():
+            for v in values:
+                t.extend(v[:2])
+                mem.extend(v[2:4])
+
+    mem = np.asarray(mem)
+    t = np.asarray(t)
+    ind = t.argsort()
+    mem = mem[ind]
+    t = t[ind]
+
+    # Plot curves
+    global_start = float(t[0])
+    t = t - global_start
+
+    max_mem = mem.max()
+    max_mem_ind = mem.argmax()
+
+    all_colors = (""c"", ""y"", ""g"", ""r"", ""b"")
+    mem_line_colors = (""k"", ""b"", ""r"", ""g"", ""c"", ""y"", ""m"")
+    mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
+                                   time.localtime(global_start)) \
+                     + "".{0:03d}"".format(int(round(math.modf(global_start)[0] * 1000)))
+
+    pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
+            label=mem_line_label)
+
+    bottom, top = pl.ylim()
+    bottom += 0.001
+    top -= 0.001
+
+    # plot children, if any
+    if len(chld) > 0 and children:
+        cmpoint = (0,0) # maximal child memory
+
+        for idx, (proc, data) in enumerate(chld.items()):
+            # Create the numpy arrays from the series data
+            cts  = np.asarray([item[1] for item in data]) - global_start
+            cmem = np.asarray([item[0] for item in data])
+
+            # Plot the line to the figure
+            pl.plot(cts, cmem, ""+-""  + mem_line_colors[(idx+1) % len(mem_line_colors)],
+                     label=""child {}"".format(proc))
+
+            # Detect the maximal child memory point
+            cmax_mem = cmem.max()
+            if cmax_mem > cmpoint[1]:
+                cmpoint = (cts[cmem.argmax()], cmax_mem)
+
+        # Add the marker lines for the maximal child memory usage
+        pl.vlines(cmpoint[0], pl.ylim()[0]+0.001, pl.ylim()[1] - 0.001, 'r', '--')
+        pl.hlines(cmpoint[1], pl.xlim()[0]+0.001, pl.xlim()[1] - 0.001, 'r', '--')
+
+    # plot timestamps, if any
+    if len(ts) > 0 and timestamps:
+        func_num = 0
+        f_labels = function_labels(ts.keys())
+        for f, exec_ts in ts.items():
+            for execution in exec_ts:
+                add_brackets(execution[:2], execution[2:], xshift=global_start,
+                             color=all_colors[func_num % len(all_colors)],
+                             label=f_labels[f]
+                                   + "" %.3fs"" % (execution[1] - execution[0]), options=options)
+            func_num += 1
+
+    if timestamps:
+        pl.hlines(max_mem,
+                  pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
+                  colors=""r"", linestyles=""--"")
+        pl.vlines(t[max_mem_ind], bottom, top,
+                  colors=""r"", linestyles=""--"")
+    return mprofile
+
+
 def function_labels(dotted_function_names):
     state = {}
 
@@ -507,6 +606,8 @@ such file in the current directory.""""""
                         help=""Save plot to file instead of displaying it."")
     parser.add_argument(""--window"", ""-w"", dest=""xlim"", type=xlim_type,
                         help=""Plot a time-subset of the data. E.g. to plot between 0 and 20.5 seconds: --window 0,20.5"")
+    parser.add_argument(""--flame"", ""-f"", dest=""flame_mode"", action=""store_true"",
+                        help=""Plot the timestamps as a flame-graph instead of the default brackets"")
     parser.add_argument(""--backend"",
                       help=""Specify the Matplotlib backend to use"")
     parser.add_argument(""profiles"", nargs=""*"",
@@ -561,8 +662,11 @@ such file in the current directory.""""""
         timestamps = False
     else:
         timestamps = True
+    plotter = plot_file
+    if args.flame_mode:
+        plotter = flame_plotter
     for n, filename in enumerate(filenames):
-        mprofile = plot_file(filename, index=n, timestamps=timestamps, options=args)
+        mprofile = plotter(filename, index=n, timestamps=timestamps, options=args)
     pl.xlabel(""time (in seconds)"")
     pl.ylabel(""memory used (in MiB)"")
 
",True,mprof.py,True
"@@ -491,6 +491,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     ind = t.argsort()
     mem = mem[ind]
     t = t[ind]
+    stack_size = 1 + max(ex[4] for executions in ts.values() for ex in executions)
 
     # Plot curves
     global_start = float(t[0])
@@ -499,7 +500,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     max_mem = mem.max()
     max_mem_ind = mem.argmax()
 
-    all_colors = (""c"", ""y"", ""g"", ""r"", ""b"")
+    cmap = pl.cm.get_cmap('gist_rainbow')
     mem_line_colors = (""k"", ""b"", ""r"", ""g"", ""c"", ""y"", ""m"")
     mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
                                    time.localtime(global_start)) \
@@ -512,6 +513,9 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     bottom += 0.001
     top -= 0.001
 
+    timestamp_ax = pl.twinx()
+    timestamp_ax.set_ylim((0, stack_size))
+
     # plot children, if any
     if len(chld) > 0 and children:
         cmpoint = (0,0) # maximal child memory
@@ -540,10 +544,16 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
         f_labels = function_labels(ts.keys())
         for f, exec_ts in ts.items():
             for execution in exec_ts:
-                add_brackets(execution[:2], execution[2:], xshift=global_start,
-                             color=all_colors[func_num % len(all_colors)],
-                             label=f_labels[f]
-                                   + "" %.3fs"" % (execution[1] - execution[0]), options=options)
+                x0, x1 = execution[:2]
+                y0 = execution[4]
+                y1 = y0 + 1
+                color = cmap(0.5)
+                add_timestamp_rectangle(
+                    timestamp_ax,
+                    x0, x1, y0, y1,
+                    xshift=global_start,
+                    color=color
+                )
             func_num += 1
 
     if timestamps:
@@ -555,6 +565,14 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     return mprofile
 
 
+def add_timestamp_rectangle(ax, x0, x1, y0, y1, *, xshift=0, color='none'):
+    x0 -= xshift
+    x1 -= xshift
+    print(f""Drawing rectangle ({x0}, {y0}, {x1}, {y1})"")
+    print(color)
+    ax.fill_betweenx((y0, y1), x0, x1, color=color, alpha=0.5, linewidth=1)
+
+
 def function_labels(dotted_function_names):
     state = {}
 
","@@ -491,6 +491,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     ind = t.argsort()
     mem = mem[ind]
     t = t[ind]
+    stack_size = 1 + max(ex[4] for executions in ts.values() for ex in executions)
 
     # Plot curves
     global_start = float(t[0])
@@ -499,7 +500,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     max_mem = mem.max()
     max_mem_ind = mem.argmax()
 
-    all_colors = (""c"", ""y"", ""g"", ""r"", ""b"")
+    cmap = pl.cm.get_cmap('gist_rainbow')
     mem_line_colors = (""k"", ""b"", ""r"", ""g"", ""c"", ""y"", ""m"")
     mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
                                    time.localtime(global_start)) \
@@ -512,6 +513,9 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     bottom += 0.001
     top -= 0.001
 
+    timestamp_ax = pl.twinx()
+    timestamp_ax.set_ylim((0, stack_size))
+
     # plot children, if any
     if len(chld) > 0 and children:
         cmpoint = (0,0) # maximal child memory
@@ -540,10 +544,16 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
         f_labels = function_labels(ts.keys())
         for f, exec_ts in ts.items():
             for execution in exec_ts:
-                add_brackets(execution[:2], execution[2:], xshift=global_start,
-                             color=all_colors[func_num % len(all_colors)],
-                             label=f_labels[f]
-                                   + "" %.3fs"" % (execution[1] - execution[0]), options=options)
+                x0, x1 = execution[:2]
+                y0 = execution[4]
+                y1 = y0 + 1
+                color = cmap(0.5)
+                add_timestamp_rectangle(
+                    timestamp_ax,
+                    x0, x1, y0, y1,
+                    xshift=global_start,
+                    color=color
+                )
             func_num += 1
 
     if timestamps:
@@ -555,6 +565,14 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     return mprofile
 
 
+def add_timestamp_rectangle(ax, x0, x1, y0, y1, *, xshift=0, color='none'):
+    x0 -= xshift
+    x1 -= xshift
+    print(f""Drawing rectangle ({x0}, {y0}, {x1}, {y1})"")
+    print(color)
+    ax.fill_betweenx((y0, y1), x0, x1, color=color, alpha=0.5, linewidth=1)
+
+
 def function_labels(dotted_function_names):
     state = {}
 
",True,mprof.py,True
"@@ -7,6 +7,7 @@ import copy
 import time
 import math
 import logging
+import itertools
 
 from collections import defaultdict
 from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormatter
@@ -492,6 +493,15 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     mem = mem[ind]
     t = t[ind]
     stack_size = 1 + max(ex[4] for executions in ts.values() for ex in executions)
+    def level_to_saturation(level):
+        return 1 - 0.75 * level / stack_size
+
+    colors = [
+        itertools.cycle([
+            pl.matplotlib.colors.hsv_to_rgb((0, level_to_saturation(level), 1)),
+            pl.matplotlib.colors.hsv_to_rgb((0.1, level_to_saturation(level), 1)),
+        ]) for level in range(stack_size)
+    ]
 
     # Plot curves
     global_start = float(t[0])
@@ -500,7 +510,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     max_mem = mem.max()
     max_mem_ind = mem.argmax()
 
-    cmap = pl.cm.get_cmap('gist_rainbow')
+    # cmap = pl.cm.get_cmap('gist_rainbow')
     mem_line_colors = (""k"", ""b"", ""r"", ""g"", ""c"", ""y"", ""m"")
     mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
                                    time.localtime(global_start)) \
@@ -547,7 +557,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                 x0, x1 = execution[:2]
                 y0 = execution[4]
                 y1 = y0 + 1
-                color = cmap(0.5)
+                color = next(colors[y0])
                 add_timestamp_rectangle(
                     timestamp_ax,
                     x0, x1, y0, y1,
","@@ -7,6 +7,7 @@ import copy
 import time
 import math
 import logging
+import itertools
 
 from collections import defaultdict
 from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormatter
@@ -492,6 +493,15 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     mem = mem[ind]
     t = t[ind]
     stack_size = 1 + max(ex[4] for executions in ts.values() for ex in executions)
+    def level_to_saturation(level):
+        return 1 - 0.75 * level / stack_size
+
+    colors = [
+        itertools.cycle([
+            pl.matplotlib.colors.hsv_to_rgb((0, level_to_saturation(level), 1)),
+            pl.matplotlib.colors.hsv_to_rgb((0.1, level_to_saturation(level), 1)),
+        ]) for level in range(stack_size)
+    ]
 
     # Plot curves
     global_start = float(t[0])
@@ -500,7 +510,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     max_mem = mem.max()
     max_mem_ind = mem.argmax()
 
-    cmap = pl.cm.get_cmap('gist_rainbow')
+    # cmap = pl.cm.get_cmap('gist_rainbow')
     mem_line_colors = (""k"", ""b"", ""r"", ""g"", ""c"", ""y"", ""m"")
     mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
                                    time.localtime(global_start)) \
@@ -547,7 +557,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                 x0, x1 = execution[:2]
                 y0 = execution[4]
                 y1 = y0 + 1
-                color = cmap(0.5)
+                color = next(colors[y0])
                 add_timestamp_rectangle(
                     timestamp_ax,
                     x0, x1, y0, y1,
",True,mprof.py,True
"@@ -492,6 +492,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     ind = t.argsort()
     mem = mem[ind]
     t = t[ind]
+
     stack_size = 1 + max(ex[4] for executions in ts.values() for ex in executions)
     def level_to_saturation(level):
         return 1 - 0.75 * level / stack_size
@@ -516,15 +517,17 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                                    time.localtime(global_start)) \
                      + "".{0:03d}"".format(int(round(math.modf(global_start)[0] * 1000)))
 
-    pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
+    pl.plot(t, mem, ""-"" + mem_line_colors[index % len(mem_line_colors)],
             label=mem_line_label)
 
     bottom, top = pl.ylim()
     bottom += 0.001
     top -= 0.001
 
+    pl.gca().grid(True)
     timestamp_ax = pl.twinx()
     timestamp_ax.set_ylim((0, stack_size))
+    timestamp_ax.grid(False)
 
     # plot children, if any
     if len(chld) > 0 and children:
@@ -578,8 +581,6 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
 def add_timestamp_rectangle(ax, x0, x1, y0, y1, *, xshift=0, color='none'):
     x0 -= xshift
     x1 -= xshift
-    print(f""Drawing rectangle ({x0}, {y0}, {x1}, {y1})"")
-    print(color)
     ax.fill_betweenx((y0, y1), x0, x1, color=color, alpha=0.5, linewidth=1)
 
 
@@ -682,7 +683,10 @@ such file in the current directory.""""""
         sys.exit(-1)
 
     fig = pl.figure(figsize=(14, 6), dpi=90)
-    ax = fig.add_axes([0.1, 0.1, 0.6, 0.75])
+    if not args.flame_mode:
+        ax = fig.add_axes([0.1, 0.1, 0.6, 0.75])
+    else:
+        ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])
     if args.xlim is not None:
         pl.xlim(args.xlim[0], args.xlim[1])
 
@@ -706,9 +710,11 @@ such file in the current directory.""""""
 
     # place legend within the plot, make partially transparent in
     # case it obscures part of the lineplot
-    leg = ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))
-    leg.get_frame().set_alpha(0.5)
-    pl.grid()
+    if not args.flame_mode:
+        leg = ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))
+        leg.get_frame().set_alpha(0.5)
+        pl.grid()
+
     if args.output:
         pl.savefig(args.output)
     else:
","@@ -492,6 +492,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     ind = t.argsort()
     mem = mem[ind]
     t = t[ind]
+
     stack_size = 1 + max(ex[4] for executions in ts.values() for ex in executions)
     def level_to_saturation(level):
         return 1 - 0.75 * level / stack_size
@@ -516,15 +517,17 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                                    time.localtime(global_start)) \
                      + "".{0:03d}"".format(int(round(math.modf(global_start)[0] * 1000)))
 
-    pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
+    pl.plot(t, mem, ""-"" + mem_line_colors[index % len(mem_line_colors)],
             label=mem_line_label)
 
     bottom, top = pl.ylim()
     bottom += 0.001
     top -= 0.001
 
+    pl.gca().grid(True)
     timestamp_ax = pl.twinx()
     timestamp_ax.set_ylim((0, stack_size))
+    timestamp_ax.grid(False)
 
     # plot children, if any
     if len(chld) > 0 and children:
@@ -578,8 +581,6 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
 def add_timestamp_rectangle(ax, x0, x1, y0, y1, *, xshift=0, color='none'):
     x0 -= xshift
     x1 -= xshift
-    print(f""Drawing rectangle ({x0}, {y0}, {x1}, {y1})"")
-    print(color)
     ax.fill_betweenx((y0, y1), x0, x1, color=color, alpha=0.5, linewidth=1)
 
 
@@ -682,7 +683,10 @@ such file in the current directory.""""""
         sys.exit(-1)
 
     fig = pl.figure(figsize=(14, 6), dpi=90)
-    ax = fig.add_axes([0.1, 0.1, 0.6, 0.75])
+    if not args.flame_mode:
+        ax = fig.add_axes([0.1, 0.1, 0.6, 0.75])
+    else:
+        ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])
     if args.xlim is not None:
         pl.xlim(args.xlim[0], args.xlim[1])
 
@@ -706,9 +710,11 @@ such file in the current directory.""""""
 
     # place legend within the plot, make partially transparent in
     # case it obscures part of the lineplot
-    leg = ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))
-    leg.get_frame().set_alpha(0.5)
-    pl.grid()
+    if not args.flame_mode:
+        leg = ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))
+        leg.get_frame().set_alpha(0.5)
+        pl.grid()
+
     if args.output:
         pl.savefig(args.output)
     else:
",True,mprof.py,True
"@@ -555,20 +555,41 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     if len(ts) > 0 and timestamps:
         func_num = 0
         f_labels = function_labels(ts.keys())
+        rectangles = {}
         for f, exec_ts in ts.items():
             for execution in exec_ts:
                 x0, x1 = execution[:2]
                 y0 = execution[4]
                 y1 = y0 + 1
+                x0 -= global_start
+                x1 -= global_start
                 color = next(colors[y0])
-                add_timestamp_rectangle(
+                rect = add_timestamp_rectangle(
                     timestamp_ax,
                     x0, x1, y0, y1,
-                    xshift=global_start,
                     color=color
                 )
+                rectangles[(x0, y0, x1, y1)] = f
             func_num += 1
 
+    label = pl.text(0, 0, """")
+    def mouse_motion_handler(event):
+        x, y = event.xdata, event.ydata
+        if x is None or y is None:
+            return
+
+        for rect, func_name in rectangles.items():
+            x0, y0, x1, y1 = rect
+            if x0 < x < x1 and y0 < y < y1:
+                print(x, y)
+                label.set_position((x, y))
+                label.set_text(func_name)
+                pl.draw()
+                return
+            label.set_text("""")
+
+    pl.gcf().canvas.mpl_connect('motion_notify_event', mouse_motion_handler)
+
     if timestamps:
         pl.hlines(max_mem,
                   pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
@@ -578,10 +599,8 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     return mprofile
 
 
-def add_timestamp_rectangle(ax, x0, x1, y0, y1, *, xshift=0, color='none'):
-    x0 -= xshift
-    x1 -= xshift
-    ax.fill_betweenx((y0, y1), x0, x1, color=color, alpha=0.5, linewidth=1)
+def add_timestamp_rectangle(ax, x0, x1, y0, y1, *, color='none'):
+    return ax.fill_betweenx((y0, y1), x0, x1, color=color, alpha=0.5, linewidth=1)
 
 
 def function_labels(dotted_function_names):
","@@ -555,20 +555,41 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     if len(ts) > 0 and timestamps:
         func_num = 0
         f_labels = function_labels(ts.keys())
+        rectangles = {}
         for f, exec_ts in ts.items():
             for execution in exec_ts:
                 x0, x1 = execution[:2]
                 y0 = execution[4]
                 y1 = y0 + 1
+                x0 -= global_start
+                x1 -= global_start
                 color = next(colors[y0])
-                add_timestamp_rectangle(
+                rect = add_timestamp_rectangle(
                     timestamp_ax,
                     x0, x1, y0, y1,
-                    xshift=global_start,
                     color=color
                 )
+                rectangles[(x0, y0, x1, y1)] = f
             func_num += 1
 
+    label = pl.text(0, 0, """")
+    def mouse_motion_handler(event):
+        x, y = event.xdata, event.ydata
+        if x is None or y is None:
+            return
+
+        for rect, func_name in rectangles.items():
+            x0, y0, x1, y1 = rect
+            if x0 < x < x1 and y0 < y < y1:
+                print(x, y)
+                label.set_position((x, y))
+                label.set_text(func_name)
+                pl.draw()
+                return
+            label.set_text("""")
+
+    pl.gcf().canvas.mpl_connect('motion_notify_event', mouse_motion_handler)
+
     if timestamps:
         pl.hlines(max_mem,
                   pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
@@ -578,10 +599,8 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     return mprofile
 
 
-def add_timestamp_rectangle(ax, x0, x1, y0, y1, *, xshift=0, color='none'):
-    x0 -= xshift
-    x1 -= xshift
-    ax.fill_betweenx((y0, y1), x0, x1, color=color, alpha=0.5, linewidth=1)
+def add_timestamp_rectangle(ax, x0, x1, y0, y1, *, color='none'):
+    return ax.fill_betweenx((y0, y1), x0, x1, color=color, alpha=0.5, linewidth=1)
 
 
 def function_labels(dotted_function_names):
",True,mprof.py,True
"@@ -332,6 +332,7 @@ def read_mprofile_file(filename):
             values = value.split(' ')
             f_name, mem_start, start, mem_end, end = values[:5]
             ts = func_ts.get(f_name, [])
+            print(f_name, mem_start, start, mem_end, end)
             to_append = [float(start), float(end), float(mem_start), float(mem_end)]
             if len(values) >= 6:
                 # There is a stack level field
@@ -526,7 +527,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
 
     pl.gca().grid(True)
     timestamp_ax = pl.twinx()
-    timestamp_ax.set_ylim((0, stack_size))
+    timestamp_ax.set_ylim((0, stack_size + 1))
     timestamp_ax.grid(False)
 
     # plot children, if any
@@ -564,15 +565,14 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                 x0 -= global_start
                 x1 -= global_start
                 color = next(colors[y0])
-                rect = add_timestamp_rectangle(
+                _rect, text = add_timestamp_rectangle(
                     timestamp_ax,
-                    x0, x1, y0, y1,
+                    x0, x1, y0, y1, f,
                     color=color
                 )
-                rectangles[(x0, y0, x1, y1)] = f
+                rectangles[(x0, y0, x1, y1)] = (f, text)
             func_num += 1
 
-    label = pl.text(0, 0, """")
     def mouse_motion_handler(event):
         x, y = event.xdata, event.ydata
         if x is None or y is None:
@@ -581,14 +581,26 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
         for rect, func_name in rectangles.items():
             x0, y0, x1, y1 = rect
             if x0 < x < x1 and y0 < y < y1:
-                print(x, y)
-                label.set_position((x, y))
-                label.set_text(func_name)
+                # pl.draw()
+                return
+
+    def mouse_click_handler(event):
+        x, y = event.xdata, event.ydata
+        if x is None or y is None:
+            return
+
+        for rect, func_name in rectangles.items():
+            x0, y0, x1, y1 = rect
+            if x0 < x < x1 and y0 < y < y1:
+                toolbar = pl.gcf().canvas.toolbar
+                toolbar.push_current()
+                timestamp_ax.set_xlim(x0, x1)
+                toolbar.push_current()
                 pl.draw()
                 return
-            label.set_text("""")
 
     pl.gcf().canvas.mpl_connect('motion_notify_event', mouse_motion_handler)
+    pl.gcf().canvas.mpl_connect('button_press_event', mouse_click_handler)
 
     if timestamps:
         pl.hlines(max_mem,
@@ -599,8 +611,13 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     return mprofile
 
 
-def add_timestamp_rectangle(ax, x0, x1, y0, y1, *, color='none'):
-    return ax.fill_betweenx((y0, y1), x0, x1, color=color, alpha=0.5, linewidth=1)
+def add_timestamp_rectangle(ax, x0, x1, y0, y1, func_name, color='none'):
+    rect = ax.fill_betweenx((y0, y1), x0, x1, color=color, alpha=0.5, linewidth=1)
+    text = ax.text(x0, y1, func_name,
+        horizontalalignment='left',
+        verticalalignment='top',
+    )
+    return rect, text
 
 
 def function_labels(dotted_function_names):
","@@ -332,6 +332,7 @@ def read_mprofile_file(filename):
             values = value.split(' ')
             f_name, mem_start, start, mem_end, end = values[:5]
             ts = func_ts.get(f_name, [])
+            print(f_name, mem_start, start, mem_end, end)
             to_append = [float(start), float(end), float(mem_start), float(mem_end)]
             if len(values) >= 6:
                 # There is a stack level field
@@ -526,7 +527,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
 
     pl.gca().grid(True)
     timestamp_ax = pl.twinx()
-    timestamp_ax.set_ylim((0, stack_size))
+    timestamp_ax.set_ylim((0, stack_size + 1))
     timestamp_ax.grid(False)
 
     # plot children, if any
@@ -564,15 +565,14 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                 x0 -= global_start
                 x1 -= global_start
                 color = next(colors[y0])
-                rect = add_timestamp_rectangle(
+                _rect, text = add_timestamp_rectangle(
                     timestamp_ax,
-                    x0, x1, y0, y1,
+                    x0, x1, y0, y1, f,
                     color=color
                 )
-                rectangles[(x0, y0, x1, y1)] = f
+                rectangles[(x0, y0, x1, y1)] = (f, text)
             func_num += 1
 
-    label = pl.text(0, 0, """")
     def mouse_motion_handler(event):
         x, y = event.xdata, event.ydata
         if x is None or y is None:
@@ -581,14 +581,26 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
         for rect, func_name in rectangles.items():
             x0, y0, x1, y1 = rect
             if x0 < x < x1 and y0 < y < y1:
-                print(x, y)
-                label.set_position((x, y))
-                label.set_text(func_name)
+                # pl.draw()
+                return
+
+    def mouse_click_handler(event):
+        x, y = event.xdata, event.ydata
+        if x is None or y is None:
+            return
+
+        for rect, func_name in rectangles.items():
+            x0, y0, x1, y1 = rect
+            if x0 < x < x1 and y0 < y < y1:
+                toolbar = pl.gcf().canvas.toolbar
+                toolbar.push_current()
+                timestamp_ax.set_xlim(x0, x1)
+                toolbar.push_current()
                 pl.draw()
                 return
-            label.set_text("""")
 
     pl.gcf().canvas.mpl_connect('motion_notify_event', mouse_motion_handler)
+    pl.gcf().canvas.mpl_connect('button_press_event', mouse_click_handler)
 
     if timestamps:
         pl.hlines(max_mem,
@@ -599,8 +611,13 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     return mprofile
 
 
-def add_timestamp_rectangle(ax, x0, x1, y0, y1, *, color='none'):
-    return ax.fill_betweenx((y0, y1), x0, x1, color=color, alpha=0.5, linewidth=1)
+def add_timestamp_rectangle(ax, x0, x1, y0, y1, func_name, color='none'):
+    rect = ax.fill_betweenx((y0, y1), x0, x1, color=color, alpha=0.5, linewidth=1)
+    text = ax.text(x0, y1, func_name,
+        horizontalalignment='left',
+        verticalalignment='top',
+    )
+    return rect, text
 
 
 def function_labels(dotted_function_names):
",True,mprof.py,True
"@@ -332,7 +332,6 @@ def read_mprofile_file(filename):
             values = value.split(' ')
             f_name, mem_start, start, mem_end, end = values[:5]
             ts = func_ts.get(f_name, [])
-            print(f_name, mem_start, start, mem_end, end)
             to_append = [float(start), float(end), float(mem_start), float(mem_end)]
             if len(values) >= 6:
                 # There is a stack level field
@@ -458,6 +457,12 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
     return mprofile
 
 
+
+FLAME_PLOTTER_VARS = {
+    'hovered_rect': None,
+    'alpha': None
+}
+
 def flame_plotter(filename, index=0, timestamps=True, children=True, options=None):
     try:
         import pylab as pl
@@ -565,32 +570,48 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                 x0 -= global_start
                 x1 -= global_start
                 color = next(colors[y0])
-                _rect, text = add_timestamp_rectangle(
+                rect, text = add_timestamp_rectangle(
                     timestamp_ax,
                     x0, x1, y0, y1, f,
                     color=color
                 )
-                rectangles[(x0, y0, x1, y1)] = (f, text)
+                rectangles[(x0, y0, x1, y1)] = (f, text, rect)
             func_num += 1
 
     def mouse_motion_handler(event):
+        print(FLAME_PLOTTER_VARS['hovered_rect'])
         x, y = event.xdata, event.ydata
-        if x is None or y is None:
-            return
-
-        for rect, func_name in rectangles.items():
-            x0, y0, x1, y1 = rect
-            if x0 < x < x1 and y0 < y < y1:
-                # pl.draw()
-                return
+        if x is not None and y is not None:
+            for coord, (name, text, rect) in rectangles.items():
+                x0, y0, x1, y1 = coord
+                if x0 < x < x1 and y0 < y < y1:
+                    if FLAME_PLOTTER_VARS['hovered_rect'] == rect:
+                        return
+
+                    if FLAME_PLOTTER_VARS['hovered_rect'] is not None:
+                        FLAME_PLOTTER_VARS['hovered_rect'].set_alpha(FLAME_PLOTTER_VARS['alpha'])
+                        FLAME_PLOTTER_VARS['hovered_rect'].set_linewidth(1)
+
+                    FLAME_PLOTTER_VARS['hovered_rect'] = rect
+                    FLAME_PLOTTER_VARS['alpha'] = rect.get_alpha()
+                    FLAME_PLOTTER_VARS['hovered_rect'].set_alpha(0.8)
+                    FLAME_PLOTTER_VARS['hovered_rect'].set_linewidth(3)
+                    pl.draw()
+                    return
+
+        if FLAME_PLOTTER_VARS['hovered_rect'] is not None:
+            FLAME_PLOTTER_VARS['hovered_rect'].set_alpha(FLAME_PLOTTER_VARS['alpha'])
+            FLAME_PLOTTER_VARS['hovered_rect'].set_linewidth(1)
+            pl.draw()
+            FLAME_PLOTTER_VARS['hovered_rect'] = None
 
     def mouse_click_handler(event):
         x, y = event.xdata, event.ydata
         if x is None or y is None:
             return
 
-        for rect, func_name in rectangles.items():
-            x0, y0, x1, y1 = rect
+        for coord, _ in rectangles.items():
+            x0, y0, x1, y1 = coord
             if x0 < x < x1 and y0 < y < y1:
                 toolbar = pl.gcf().canvas.toolbar
                 toolbar.push_current()
@@ -600,7 +621,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                 return
 
     pl.gcf().canvas.mpl_connect('motion_notify_event', mouse_motion_handler)
-    pl.gcf().canvas.mpl_connect('button_press_event', mouse_click_handler)
+    pl.gcf().canvas.mpl_connect('button_release_event', mouse_click_handler)
 
     if timestamps:
         pl.hlines(max_mem,
","@@ -332,7 +332,6 @@ def read_mprofile_file(filename):
             values = value.split(' ')
             f_name, mem_start, start, mem_end, end = values[:5]
             ts = func_ts.get(f_name, [])
-            print(f_name, mem_start, start, mem_end, end)
             to_append = [float(start), float(end), float(mem_start), float(mem_end)]
             if len(values) >= 6:
                 # There is a stack level field
@@ -458,6 +457,12 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
     return mprofile
 
 
+
+FLAME_PLOTTER_VARS = {
+    'hovered_rect': None,
+    'alpha': None
+}
+
 def flame_plotter(filename, index=0, timestamps=True, children=True, options=None):
     try:
         import pylab as pl
@@ -565,32 +570,48 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                 x0 -= global_start
                 x1 -= global_start
                 color = next(colors[y0])
-                _rect, text = add_timestamp_rectangle(
+                rect, text = add_timestamp_rectangle(
                     timestamp_ax,
                     x0, x1, y0, y1, f,
                     color=color
                 )
-                rectangles[(x0, y0, x1, y1)] = (f, text)
+                rectangles[(x0, y0, x1, y1)] = (f, text, rect)
             func_num += 1
 
     def mouse_motion_handler(event):
+        print(FLAME_PLOTTER_VARS['hovered_rect'])
         x, y = event.xdata, event.ydata
-        if x is None or y is None:
-            return
+        if x is not None and y is not None:
+            for coord, (name, text, rect) in rectangles.items():
+                x0, y0, x1, y1 = coord
+                if x0 < x < x1 and y0 < y < y1:
+                    if FLAME_PLOTTER_VARS['hovered_rect'] == rect:
+                        return
 
-        for rect, func_name in rectangles.items():
-            x0, y0, x1, y1 = rect
-            if x0 < x < x1 and y0 < y < y1:
-                # pl.draw()
-                return
+                    if FLAME_PLOTTER_VARS['hovered_rect'] is not None:
+                        FLAME_PLOTTER_VARS['hovered_rect'].set_alpha(FLAME_PLOTTER_VARS['alpha'])
+                        FLAME_PLOTTER_VARS['hovered_rect'].set_linewidth(1)
+
+                    FLAME_PLOTTER_VARS['hovered_rect'] = rect
+                    FLAME_PLOTTER_VARS['alpha'] = rect.get_alpha()
+                    FLAME_PLOTTER_VARS['hovered_rect'].set_alpha(0.8)
+                    FLAME_PLOTTER_VARS['hovered_rect'].set_linewidth(3)
+                    pl.draw()
+                    return
+
+        if FLAME_PLOTTER_VARS['hovered_rect'] is not None:
+            FLAME_PLOTTER_VARS['hovered_rect'].set_alpha(FLAME_PLOTTER_VARS['alpha'])
+            FLAME_PLOTTER_VARS['hovered_rect'].set_linewidth(1)
+            pl.draw()
+            FLAME_PLOTTER_VARS['hovered_rect'] = None
 
     def mouse_click_handler(event):
         x, y = event.xdata, event.ydata
         if x is None or y is None:
             return
 
-        for rect, func_name in rectangles.items():
-            x0, y0, x1, y1 = rect
+        for coord, _ in rectangles.items():
+            x0, y0, x1, y1 = coord
             if x0 < x < x1 and y0 < y < y1:
                 toolbar = pl.gcf().canvas.toolbar
                 toolbar.push_current()
@@ -600,7 +621,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                 return
 
     pl.gcf().canvas.mpl_connect('motion_notify_event', mouse_motion_handler)
-    pl.gcf().canvas.mpl_connect('button_press_event', mouse_click_handler)
+    pl.gcf().canvas.mpl_connect('button_release_event', mouse_click_handler)
 
     if timestamps:
         pl.hlines(max_mem,
",False,mprof.py,True
"@@ -579,7 +579,6 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
             func_num += 1
 
     def mouse_motion_handler(event):
-        print(FLAME_PLOTTER_VARS['hovered_rect'])
         x, y = event.xdata, event.ydata
         if x is not None and y is not None:
             for coord, (name, text, rect) in rectangles.items():
","@@ -579,7 +579,6 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
             func_num += 1
 
     def mouse_motion_handler(event):
-        print(FLAME_PLOTTER_VARS['hovered_rect'])
         x, y = event.xdata, event.ydata
         if x is not None and y is not None:
             for coord, (name, text, rect) in rectangles.items():
",True,mprof.py,True
"@@ -615,6 +615,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                 toolbar = pl.gcf().canvas.toolbar
                 toolbar.push_current()
                 timestamp_ax.set_xlim(x0, x1)
+                timestamp_ax.set_ylim(y0, stack_size + 1)
                 toolbar.push_current()
                 pl.draw()
                 return
","@@ -615,6 +615,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                 toolbar = pl.gcf().canvas.toolbar
                 toolbar.push_current()
                 timestamp_ax.set_xlim(x0, x1)
+                timestamp_ax.set_ylim(y0, stack_size + 1)
                 toolbar.push_current()
                 pl.draw()
                 return
",True,mprof.py,True
"@@ -620,7 +620,9 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                 pl.draw()
                 return
 
-    pl.gcf().canvas.mpl_connect('motion_notify_event', mouse_motion_handler)
+    # Disable hovering if there are too many rectangle to prevent slow down
+    if len(rectangles) < 100:
+        pl.gcf().canvas.mpl_connect('motion_notify_event', mouse_motion_handler)
     pl.gcf().canvas.mpl_connect('button_release_event', mouse_click_handler)
 
     if timestamps:
","@@ -620,7 +620,9 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                 pl.draw()
                 return
 
-    pl.gcf().canvas.mpl_connect('motion_notify_event', mouse_motion_handler)
+    # Disable hovering if there are too many rectangle to prevent slow down
+    if len(rectangles) < 100:
+        pl.gcf().canvas.mpl_connect('motion_notify_event', mouse_motion_handler)
     pl.gcf().canvas.mpl_connect('button_release_event', mouse_click_handler)
 
     if timestamps:
",True,mprof.py,True
"@@ -13,8 +13,7 @@ from collections import defaultdict
 from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormatter
 
 import importlib
-mp = importlib.import_module(""memory_profiler"", __file__)
-# import memory_profiler as mp
+import memory_profiler as mp
 
 ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"")
 help_msg = """"""
","@@ -13,8 +13,7 @@ from collections import defaultdict
 from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormatter
 
 import importlib
-mp = importlib.import_module(""memory_profiler"", __file__)
-# import memory_profiler as mp
+import memory_profiler as mp
 
 ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"")
 help_msg = """"""
",True,mprof.py,True
"@@ -1119,7 +1119,15 @@ def choose_backend(new_backend=None):
 def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     from runpy import run_module
     builtins.__dict__['profile'] = profiler
-    ns = dict(_CLEAN_GLOBALS, profile=profiler)
+    ns = dict(_CLEAN_GLOBALS,
+              profile=profiler, 
+             # Make sure the __file__ variable is usable
+             # by the script we're profiling
+              __file__=filename)
+    # Make sure the script's directory in on sys.path
+    # credit to line_profiler
+    sys.path.insert(0, os.path.dirname(script_filename))
+    
     _backend = choose_backend(backend)
     sys.argv = [filename] + passed_args
     try:
","@@ -1119,7 +1119,15 @@ def choose_backend(new_backend=None):
 def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     from runpy import run_module
     builtins.__dict__['profile'] = profiler
-    ns = dict(_CLEAN_GLOBALS, profile=profiler)
+    ns = dict(_CLEAN_GLOBALS,
+              profile=profiler, 
+             # Make sure the __file__ variable is usable
+             # by the script we're profiling
+              __file__=filename)
+    # Make sure the script's directory in on sys.path
+    # credit to line_profiler
+    sys.path.insert(0, os.path.dirname(script_filename))
+    
     _backend = choose_backend(backend)
     sys.argv = [filename] + passed_args
     try:
",True,memory_profiler.py,True
"@@ -459,6 +459,7 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
 
 FLAME_PLOTTER_VARS = {
     'hovered_rect': None,
+    'hovered_text': None,
     'alpha': None
 }
 
@@ -498,7 +499,10 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     mem = mem[ind]
     t = t[ind]
 
-    stack_size = 1 + max(ex[4] for executions in ts.values() for ex in executions)
+    if ts:
+        stack_size = 1 + max(ex[4] for executions in ts.values() for ex in executions)
+    else:
+        stack_size = 0
     def level_to_saturation(level):
         return 1 - 0.75 * level / stack_size
 
@@ -588,20 +592,25 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
 
                     if FLAME_PLOTTER_VARS['hovered_rect'] is not None:
                         FLAME_PLOTTER_VARS['hovered_rect'].set_alpha(FLAME_PLOTTER_VARS['alpha'])
+                        FLAME_PLOTTER_VARS['hovered_text'].set_color((0, 0, 0, 0))
                         FLAME_PLOTTER_VARS['hovered_rect'].set_linewidth(1)
 
+                    FLAME_PLOTTER_VARS['hovered_text'] = text
                     FLAME_PLOTTER_VARS['hovered_rect'] = rect
                     FLAME_PLOTTER_VARS['alpha'] = rect.get_alpha()
                     FLAME_PLOTTER_VARS['hovered_rect'].set_alpha(0.8)
                     FLAME_PLOTTER_VARS['hovered_rect'].set_linewidth(3)
+                    FLAME_PLOTTER_VARS['hovered_text'].set_color((0, 0, 0, 1))
                     pl.draw()
                     return
 
         if FLAME_PLOTTER_VARS['hovered_rect'] is not None:
+            FLAME_PLOTTER_VARS['hovered_text'].set_color((0, 0, 0, 0))
             FLAME_PLOTTER_VARS['hovered_rect'].set_alpha(FLAME_PLOTTER_VARS['alpha'])
             FLAME_PLOTTER_VARS['hovered_rect'].set_linewidth(1)
             pl.draw()
             FLAME_PLOTTER_VARS['hovered_rect'] = None
+            FLAME_PLOTTER_VARS['hovered_text'] = None
 
     def mouse_click_handler(event):
         x, y = event.xdata, event.ydata
@@ -638,6 +647,7 @@ def add_timestamp_rectangle(ax, x0, x1, y0, y1, func_name, color='none'):
     text = ax.text(x0, y1, func_name,
         horizontalalignment='left',
         verticalalignment='top',
+        color=(0, 0, 0, 0)
     )
     return rect, text
 
","@@ -459,6 +459,7 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
 
 FLAME_PLOTTER_VARS = {
     'hovered_rect': None,
+    'hovered_text': None,
     'alpha': None
 }
 
@@ -498,7 +499,10 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     mem = mem[ind]
     t = t[ind]
 
-    stack_size = 1 + max(ex[4] for executions in ts.values() for ex in executions)
+    if ts:
+        stack_size = 1 + max(ex[4] for executions in ts.values() for ex in executions)
+    else:
+        stack_size = 0
     def level_to_saturation(level):
         return 1 - 0.75 * level / stack_size
 
@@ -588,20 +592,25 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
 
                     if FLAME_PLOTTER_VARS['hovered_rect'] is not None:
                         FLAME_PLOTTER_VARS['hovered_rect'].set_alpha(FLAME_PLOTTER_VARS['alpha'])
+                        FLAME_PLOTTER_VARS['hovered_text'].set_color((0, 0, 0, 0))
                         FLAME_PLOTTER_VARS['hovered_rect'].set_linewidth(1)
 
+                    FLAME_PLOTTER_VARS['hovered_text'] = text
                     FLAME_PLOTTER_VARS['hovered_rect'] = rect
                     FLAME_PLOTTER_VARS['alpha'] = rect.get_alpha()
                     FLAME_PLOTTER_VARS['hovered_rect'].set_alpha(0.8)
                     FLAME_PLOTTER_VARS['hovered_rect'].set_linewidth(3)
+                    FLAME_PLOTTER_VARS['hovered_text'].set_color((0, 0, 0, 1))
                     pl.draw()
                     return
 
         if FLAME_PLOTTER_VARS['hovered_rect'] is not None:
+            FLAME_PLOTTER_VARS['hovered_text'].set_color((0, 0, 0, 0))
             FLAME_PLOTTER_VARS['hovered_rect'].set_alpha(FLAME_PLOTTER_VARS['alpha'])
             FLAME_PLOTTER_VARS['hovered_rect'].set_linewidth(1)
             pl.draw()
             FLAME_PLOTTER_VARS['hovered_rect'] = None
+            FLAME_PLOTTER_VARS['hovered_text'] = None
 
     def mouse_click_handler(event):
         x, y = event.xdata, event.ydata
@@ -638,6 +647,7 @@ def add_timestamp_rectangle(ax, x0, x1, y0, y1, func_name, color='none'):
     text = ax.text(x0, y1, func_name,
         horizontalalignment='left',
         verticalalignment='top',
+        color=(0, 0, 0, 0)
     )
     return rect, text
 
",True,mprof.py,True
"@@ -533,8 +533,10 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     bottom += 0.001
     top -= 0.001
 
-    pl.gca().grid(True)
-    timestamp_ax = pl.twinx()
+    ax = pl.gca()
+    ax.grid(True)
+    timestamp_ax = ax.twinx()
+    timestamp_ax.set_yticks([])
     timestamp_ax.set_ylim((0, stack_size + 1))
     timestamp_ax.grid(False)
 
@@ -639,6 +641,9 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                   colors=""r"", linestyles=""--"")
         pl.vlines(t[max_mem_ind], bottom, top,
                   colors=""r"", linestyles=""--"")
+
+    pl.sca(ax)
+
     return mprofile
 
 
","@@ -533,8 +533,10 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     bottom += 0.001
     top -= 0.001
 
-    pl.gca().grid(True)
-    timestamp_ax = pl.twinx()
+    ax = pl.gca()
+    ax.grid(True)
+    timestamp_ax = ax.twinx()
+    timestamp_ax.set_yticks([])
     timestamp_ax.set_ylim((0, stack_size + 1))
     timestamp_ax.grid(False)
 
@@ -639,6 +641,9 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                   colors=""r"", linestyles=""--"")
         pl.vlines(t[max_mem_ind], bottom, top,
                   colors=""r"", linestyles=""--"")
+
+    pl.sca(ax)
+
     return mprofile
 
 
",True,mprof.py,True
"@@ -150,6 +150,11 @@ afterward will plot the result, making plots (using matplotlib) similar to these
    :target: https://github.com/scikit-learn/scikit-learn/pull/2248
    :height: 350px
 
+or, with the ``--flame`` option (``mprof plot --flame``):
+
+.. image:: images/flamegraph.py
+   :height: 350px
+
 A discussion of these capabilities can be found `here <http://fa.bianp.net/blog/2014/plot-memory-usage-as-a-function-of-time/>`_.
 
 .. warning:: If your Python file imports the memory profiler `from memory_profiler import profile` these timestamps will not be recorded. Comment out the import, leave your functions decorated, and re-run.
","@@ -150,6 +150,11 @@ afterward will plot the result, making plots (using matplotlib) similar to these
    :target: https://github.com/scikit-learn/scikit-learn/pull/2248
    :height: 350px
 
+or, with the ``--flame`` option (``mprof plot --flame``):
+
+.. image:: images/flamegraph.py
+   :height: 350px
+
 A discussion of these capabilities can be found `here <http://fa.bianp.net/blog/2014/plot-memory-usage-as-a-function-of-time/>`_.
 
 .. warning:: If your Python file imports the memory profiler `from memory_profiler import profile` these timestamps will not be recorded. Comment out the import, leave your functions decorated, and re-run.
",True,README.rst,False
"Binary files /dev/null and b/images/flamegraph.png differ
","Binary files /dev/null and b/images/flamegraph.png differ
",True,images/flamegraph.png,False
"@@ -150,9 +150,9 @@ afterward will plot the result, making plots (using matplotlib) similar to these
    :target: https://github.com/scikit-learn/scikit-learn/pull/2248
    :height: 350px
 
-or, with the ``--flame`` option (``mprof plot --flame``):
+or, with ``mprof plot --flame`` (the function and timestamp names will appear on hover):
 
-.. image:: images/flamegraph.py
+.. image:: ./images/flamegraph.png
    :height: 350px
 
 A discussion of these capabilities can be found `here <http://fa.bianp.net/blog/2014/plot-memory-usage-as-a-function-of-time/>`_.
","@@ -150,9 +150,9 @@ afterward will plot the result, making plots (using matplotlib) similar to these
    :target: https://github.com/scikit-learn/scikit-learn/pull/2248
    :height: 350px
 
-or, with the ``--flame`` option (``mprof plot --flame``):
+or, with ``mprof plot --flame`` (the function and timestamp names will appear on hover):
 
-.. image:: images/flamegraph.py
+.. image:: ./images/flamegraph.png
    :height: 350px
 
 A discussion of these capabilities can be found `here <http://fa.bianp.net/blog/2014/plot-memory-usage-as-a-function-of-time/>`_.
",True,README.rst,False
"@@ -562,27 +562,6 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
         pl.vlines(cmpoint[0], pl.ylim()[0]+0.001, pl.ylim()[1] - 0.001, 'r', '--')
         pl.hlines(cmpoint[1], pl.xlim()[0]+0.001, pl.xlim()[1] - 0.001, 'r', '--')
 
-    # plot timestamps, if any
-    if len(ts) > 0 and timestamps:
-        func_num = 0
-        f_labels = function_labels(ts.keys())
-        rectangles = {}
-        for f, exec_ts in ts.items():
-            for execution in exec_ts:
-                x0, x1 = execution[:2]
-                y0 = execution[4]
-                y1 = y0 + 1
-                x0 -= global_start
-                x1 -= global_start
-                color = next(colors[y0])
-                rect, text = add_timestamp_rectangle(
-                    timestamp_ax,
-                    x0, x1, y0, y1, f,
-                    color=color
-                )
-                rectangles[(x0, y0, x1, y1)] = (f, text, rect)
-            func_num += 1
-
     def mouse_motion_handler(event):
         x, y = event.xdata, event.ydata
         if x is not None and y is not None:
@@ -630,10 +609,31 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                 pl.draw()
                 return
 
-    # Disable hovering if there are too many rectangle to prevent slow down
-    if len(rectangles) < 100:
-        pl.gcf().canvas.mpl_connect('motion_notify_event', mouse_motion_handler)
-    pl.gcf().canvas.mpl_connect('button_release_event', mouse_click_handler)
+    # plot timestamps, if any
+    if len(ts) > 0 and timestamps:
+        func_num = 0
+        f_labels = function_labels(ts.keys())
+        rectangles = {}
+        for f, exec_ts in ts.items():
+            for execution in exec_ts:
+                x0, x1 = execution[:2]
+                y0 = execution[4]
+                y1 = y0 + 1
+                x0 -= global_start
+                x1 -= global_start
+                color = next(colors[y0])
+                rect, text = add_timestamp_rectangle(
+                    timestamp_ax,
+                    x0, x1, y0, y1, f,
+                    color=color
+                )
+                rectangles[(x0, y0, x1, y1)] = (f, text, rect)
+            func_num += 1
+
+        # Disable hovering if there are too many rectangle to prevent slow down
+        if len(rectangles) < 100:
+            pl.gcf().canvas.mpl_connect('motion_notify_event', mouse_motion_handler)
+        pl.gcf().canvas.mpl_connect('button_release_event', mouse_click_handler)
 
     if timestamps:
         pl.hlines(max_mem,
","@@ -562,27 +562,6 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
         pl.vlines(cmpoint[0], pl.ylim()[0]+0.001, pl.ylim()[1] - 0.001, 'r', '--')
         pl.hlines(cmpoint[1], pl.xlim()[0]+0.001, pl.xlim()[1] - 0.001, 'r', '--')
 
-    # plot timestamps, if any
-    if len(ts) > 0 and timestamps:
-        func_num = 0
-        f_labels = function_labels(ts.keys())
-        rectangles = {}
-        for f, exec_ts in ts.items():
-            for execution in exec_ts:
-                x0, x1 = execution[:2]
-                y0 = execution[4]
-                y1 = y0 + 1
-                x0 -= global_start
-                x1 -= global_start
-                color = next(colors[y0])
-                rect, text = add_timestamp_rectangle(
-                    timestamp_ax,
-                    x0, x1, y0, y1, f,
-                    color=color
-                )
-                rectangles[(x0, y0, x1, y1)] = (f, text, rect)
-            func_num += 1
-
     def mouse_motion_handler(event):
         x, y = event.xdata, event.ydata
         if x is not None and y is not None:
@@ -630,10 +609,31 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                 pl.draw()
                 return
 
-    # Disable hovering if there are too many rectangle to prevent slow down
-    if len(rectangles) < 100:
-        pl.gcf().canvas.mpl_connect('motion_notify_event', mouse_motion_handler)
-    pl.gcf().canvas.mpl_connect('button_release_event', mouse_click_handler)
+    # plot timestamps, if any
+    if len(ts) > 0 and timestamps:
+        func_num = 0
+        f_labels = function_labels(ts.keys())
+        rectangles = {}
+        for f, exec_ts in ts.items():
+            for execution in exec_ts:
+                x0, x1 = execution[:2]
+                y0 = execution[4]
+                y1 = y0 + 1
+                x0 -= global_start
+                x1 -= global_start
+                color = next(colors[y0])
+                rect, text = add_timestamp_rectangle(
+                    timestamp_ax,
+                    x0, x1, y0, y1, f,
+                    color=color
+                )
+                rectangles[(x0, y0, x1, y1)] = (f, text, rect)
+            func_num += 1
+
+        # Disable hovering if there are too many rectangle to prevent slow down
+        if len(rectangles) < 100:
+            pl.gcf().canvas.mpl_connect('motion_notify_event', mouse_motion_handler)
+        pl.gcf().canvas.mpl_connect('button_release_event', mouse_click_handler)
 
     if timestamps:
         pl.hlines(max_mem,
",True,mprof.py,True
"@@ -202,7 +202,7 @@ This file contains the process memory consumption, in Mb (one value per line).""""
                              'Option 4: (--python flag present) ""<PYTHON_MODULE> <ARG1> <ARG2>..."" - profile python module\n'
                         )
     args = parser.parse_args()
-    
+
     if len(args.program) == 0:
         print(""A program to run must be provided. Use -h for help"")
         sys.exit(1)
@@ -517,6 +517,7 @@ such file in the current directory.""""""
         print(""matplotlib is needed for plotting."")
         print(e)
         sys.exit(1)
+    pl.ioff()
 
     profiles = glob.glob(""mprofile_??????????????.dat"")
     profiles.sort()
","@@ -202,7 +202,7 @@ This file contains the process memory consumption, in Mb (one value per line).""""
                              'Option 4: (--python flag present) ""<PYTHON_MODULE> <ARG1> <ARG2>..."" - profile python module\n'
                         )
     args = parser.parse_args()
-    
+
     if len(args.program) == 0:
         print(""A program to run must be provided. Use -h for help"")
         sys.exit(1)
@@ -517,6 +517,7 @@ such file in the current directory.""""""
         print(""matplotlib is needed for plotting."")
         print(e)
         sys.exit(1)
+    pl.ioff()
 
     profiles = glob.glob(""mprofile_??????????????.dat"")
     profiles.sort()
",True,mprof.py,True
"@@ -335,11 +335,11 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 parent_conn.send(0)  # finish timing
                 ret = parent_conn.recv()
                 n_measurements = parent_conn.recv()
-                if retval:
-                    ret = ret, returned
                 if max_usage:
                     # Convert the one element list produced by MemTimer to a singular value
                     ret = ret[0]
+                if retval:
+                    ret = ret, returned
             except Exception:
                 parent = psutil.Process(os.getpid())
                 for child in parent.children(recursive=True):
@@ -1120,14 +1120,14 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     from runpy import run_module
     builtins.__dict__['profile'] = profiler
     ns = dict(_CLEAN_GLOBALS,
-              profile=profiler, 
+              profile=profiler,
              # Make sure the __file__ variable is usable
              # by the script we're profiling
               __file__=filename)
     # Make sure the script's directory in on sys.path
     # credit to line_profiler
     sys.path.insert(0, os.path.dirname(script_filename))
-    
+
     _backend = choose_backend(backend)
     sys.argv = [filename] + passed_args
     try:
","@@ -335,11 +335,11 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 parent_conn.send(0)  # finish timing
                 ret = parent_conn.recv()
                 n_measurements = parent_conn.recv()
-                if retval:
-                    ret = ret, returned
                 if max_usage:
                     # Convert the one element list produced by MemTimer to a singular value
                     ret = ret[0]
+                if retval:
+                    ret = ret, returned
             except Exception:
                 parent = psutil.Process(os.getpid())
                 for child in parent.children(recursive=True):
@@ -1120,14 +1120,14 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     from runpy import run_module
     builtins.__dict__['profile'] = profiler
     ns = dict(_CLEAN_GLOBALS,
-              profile=profiler, 
+              profile=profiler,
              # Make sure the __file__ variable is usable
              # by the script we're profiling
               __file__=filename)
     # Make sure the script's directory in on sys.path
     # credit to line_profiler
     sys.path.insert(0, os.path.dirname(script_filename))
-    
+
     _backend = choose_backend(backend)
     sys.argv = [filename] + passed_args
     try:
",True,memory_profiler.py,True
"@@ -202,6 +202,19 @@ the total memory of the program as well as each child individually. If using
 the API directly, note that the return from ``memory_usage`` will include the
 child memory in a nested list along with the main process memory.
 
+Plot settings
+===============================
+
+By default, the command line call is set as the graph title. If you wish to customize it, you can use the ``-t`` option to manually set the figure title.
+
+
+    mprof plot -t 'Recorded memory usage'
+
+You can also hide the function timestamps using the ``n`` flag, such as
+
+    mprof plot -n
+
+
 Setting debugger breakpoints
 =============================
 It is possible to set breakpoints depending on the amount of memory used.
","@@ -202,6 +202,19 @@ the total memory of the program as well as each child individually. If using
 the API directly, note that the return from ``memory_usage`` will include the
 child memory in a nested list along with the main process memory.
 
+Plot settings
+===============================
+
+By default, the command line call is set as the graph title. If you wish to customize it, you can use the ``-t`` option to manually set the figure title.
+
+
+    mprof plot -t 'Recorded memory usage'
+
+You can also hide the function timestamps using the ``n`` flag, such as
+
+    mprof plot -n
+
+
 Setting debugger breakpoints
 =============================
 It is possible to set breakpoints depending on the amount of memory used.
",True,README.rst,False
"@@ -12,6 +12,7 @@ import inspect
 import linecache
 import logging
 import os
+from io import open
 import pdb
 import subprocess
 import sys
@@ -20,6 +21,7 @@ import traceback
 import warnings
 import contextlib
 
+
 if sys.platform == ""win32"":
     # any value except signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT
     # can be used to kill a process unconditionally in Windows
","@@ -12,6 +12,7 @@ import inspect
 import linecache
 import logging
 import os
+from io import open
 import pdb
 import subprocess
 import sys
@@ -20,6 +21,7 @@ import traceback
 import warnings
 import contextlib
 
+
 if sys.platform == ""win32"":
     # any value except signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT
     # can be used to kill a process unconditionally in Windows
",True,memory_profiler.py,True
"@@ -1,5 +1,4 @@
 # -*- coding: utf-8  -*-
-# run only for Python 2.xx
 @profile
 def test_unicode(txt):
     # test when unicode is present
","@@ -1,5 +1,4 @@
 # -*- coding: utf-8  -*-
-# run only for Python 2.xx
 @profile
 def test_unicode(txt):
     # test when unicode is present
",True,test/test_unicode.py,True
"@@ -1164,7 +1164,7 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     try:
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
-        with open(filename) as f:
+        with open(filename, 'rb') as f:
             exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
         if has_tracemalloc and tracemalloc.is_tracing():
","@@ -1164,7 +1164,7 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     try:
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
-        with open(filename) as f:
+        with open(filename, 'rb') as f:
             exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
         if has_tracemalloc and tracemalloc.is_tracing():
",True,memory_profiler.py,True
"@@ -238,7 +238,7 @@ class MemTimer(Process):
 
 def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                  include_children=False, multiprocess=False, max_usage=False,
-                 retval=False, stream=None, backend=None):
+                 retval=False, stream=None, backend=None, max_iterations=None):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -307,6 +307,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     else:
         # for a Python function wait until it finishes
         max_iter = float('inf')
+        if max_iterations is not None:
+            max_iter = max_iterations
 
     if callable(proc):
         proc = (proc, (), {})
@@ -320,7 +322,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         else:
             raise ValueError
 
+        current_iter = 0
         while True:
+            current_iter += 1
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
             p = MemTimer(os.getpid(), interval, child_conn, backend,
                          timestamps=timestamps,
@@ -349,7 +353,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 raise
 
             p.join(5 * interval)
-            if n_measurements > 4 or interval < 1e-6:
+            
+            if (n_measurements > 4) or (current_iter == max_iter) or (interval < 1e-6):
                 break
             interval /= 10.
     elif isinstance(proc, subprocess.Popen):
","@@ -238,7 +238,7 @@ class MemTimer(Process):
 
 def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                  include_children=False, multiprocess=False, max_usage=False,
-                 retval=False, stream=None, backend=None):
+                 retval=False, stream=None, backend=None, max_iterations=None):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -307,6 +307,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     else:
         # for a Python function wait until it finishes
         max_iter = float('inf')
+        if max_iterations is not None:
+            max_iter = max_iterations
 
     if callable(proc):
         proc = (proc, (), {})
@@ -320,7 +322,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         else:
             raise ValueError
 
+        current_iter = 0
         while True:
+            current_iter += 1
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
             p = MemTimer(os.getpid(), interval, child_conn, backend,
                          timestamps=timestamps,
@@ -349,7 +353,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 raise
 
             p.join(5 * interval)
-            if n_measurements > 4 or interval < 1e-6:
+            
+            if (n_measurements > 4) or (current_iter == max_iter) or (interval < 1e-6):
                 break
             interval /= 10.
     elif isinstance(proc, subprocess.Popen):
",True,memory_profiler.py,True
"@@ -1,4 +1,5 @@
 from memory_profiler import memory_usage
+import os
 
 
 def some_func(*args, **kwargs):
@@ -10,6 +11,20 @@ def test_memory_usage():
     mem, ret = memory_usage((some_func, (1, 2), dict(a=1)), retval=True)
     assert ret[0] == (1, 2)
     assert ret[1] == dict(a=1)
+    
+    
+def write_line(filepath):
+    with open(filepath, 'a') as the_file:
+        the_file.write('Testing\n')
+
+def test_max_iterations():
+    # Check that memory_usage works with max_iterations set (for python functions).
+    this_dir = os.path.dirname(os.path.realpath(__file__))
+    file = os.path.join(this_dir, 'temp_test_max_iterations_file.txt')
+    mem = memory_usage((write_line, (file, ), dict()), max_usage=True, max_iterations=1)
+    n_lines = sum(1 for line in open(file))
+    os.remove(file)
+    assert n_lines == 1
 
 
 def test_return_value_consistency():
@@ -27,4 +42,5 @@ def test_return_value_consistency():
 
 if __name__ == ""__main__"":
     test_memory_usage()
+    test_max_iterations()
     test_return_value_consistency()
","@@ -1,4 +1,5 @@
 from memory_profiler import memory_usage
+import os
 
 
 def some_func(*args, **kwargs):
@@ -10,6 +11,20 @@ def test_memory_usage():
     mem, ret = memory_usage((some_func, (1, 2), dict(a=1)), retval=True)
     assert ret[0] == (1, 2)
     assert ret[1] == dict(a=1)
+    
+    
+def write_line(filepath):
+    with open(filepath, 'a') as the_file:
+        the_file.write('Testing\n')
+
+def test_max_iterations():
+    # Check that memory_usage works with max_iterations set (for python functions).
+    this_dir = os.path.dirname(os.path.realpath(__file__))
+    file = os.path.join(this_dir, 'temp_test_max_iterations_file.txt')
+    mem = memory_usage((write_line, (file, ), dict()), max_usage=True, max_iterations=1)
+    n_lines = sum(1 for line in open(file))
+    os.remove(file)
+    assert n_lines == 1
 
 
 def test_return_value_consistency():
@@ -27,4 +42,5 @@ def test_return_value_consistency():
 
 if __name__ == ""__main__"":
     test_memory_usage()
+    test_max_iterations()
     test_return_value_consistency()
",True,test/test_memory_usage.py,True
"@@ -280,6 +280,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         to this file instead of stored in memory and returned at the end of
         the subprocess. Useful for long-running processes.
         Implies timestamps=True.
+        
+    max_iterations : int
+        Limits the number of iterations (calls to the process being monitored). Relevent
+        when the process is a python function. 
 
     Returns
     -------
","@@ -280,6 +280,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         to this file instead of stored in memory and returned at the end of
         the subprocess. Useful for long-running processes.
         Implies timestamps=True.
+        
+    max_iterations : int
+        Limits the number of iterations (calls to the process being monitored). Relevent
+        when the process is a python function. 
 
     Returns
     -------
",True,memory_profiler.py,True
"@@ -46,7 +46,7 @@ setup(
     version=find_version(""memory_profiler.py""),
     author='Fabian Pedregosa',
     author_email='f@bianp.net',
-    url='http://pypi.python.org/pypi/memory_profiler',
+    url='https://github.com/pythonprofilers/memory_profiler',
     py_modules=['memory_profiler', 'mprof'],
     entry_points={
         'console_scripts' : ['mprof = mprof:main'],
","@@ -46,7 +46,7 @@ setup(
     version=find_version(""memory_profiler.py""),
     author='Fabian Pedregosa',
     author_email='f@bianp.net',
-    url='http://pypi.python.org/pypi/memory_profiler',
+    url='https://github.com/pythonprofilers/memory_profiler',
     py_modules=['memory_profiler', 'mprof'],
     entry_points={
         'console_scripts' : ['mprof = mprof:main'],
",True,setup.py,True
"@@ -29,6 +29,16 @@ else:
 import psutil
 
 
+if sys.version_info > (3, 3):
+    if sys.version_info < (3, 5):
+        from asyncio import iscoroutinefunction
+    else:
+        from inspect import iscoroutinefunction
+else:
+    def iscoroutinefunction(_):
+        return False
+
+
 # TODO: provide alternative when multiprocessing is not available
 try:
     from multiprocessing import Process, Pipe
","@@ -29,6 +29,16 @@ else:
 import psutil
 
 
+if sys.version_info > (3, 3):
+    if sys.version_info < (3, 5):
+        from asyncio import iscoroutinefunction
+    else:
+        from inspect import iscoroutinefunction
+else:
+    def iscoroutinefunction(_):
+        return False
+
+
 # TODO: provide alternative when multiprocessing is not available
 try:
     from multiprocessing import Process, Pipe
",True,memory_profiler.py,True
"@@ -1,6 +1,7 @@
 import os
 import io
 import re
+import sys
 from setuptools import setup
 
 
@@ -21,6 +22,14 @@ def find_version(*file_paths):
         return version_match.group(1)
 
 
+async_modules = []
+if sys.version_info > (3, 3):
+    if sys.version_info < (3, 5):
+        async_modules = ['_aio_34']
+    else:
+        async_modules = ['_aio_35']
+
+
 CLASSIFIERS = """"""\
 Development Status :: 5 - Production/Stable
 Intended Audience :: Science/Research
@@ -39,6 +48,7 @@ Operating System :: Unix
 
 """"""
 
+
 setup(
     name='memory_profiler',
     description='A module for monitoring memory usage of a python program',
@@ -47,7 +57,7 @@ setup(
     author='Fabian Pedregosa',
     author_email='f@bianp.net',
     url='https://github.com/pythonprofilers/memory_profiler',
-    py_modules=['memory_profiler', 'mprof'],
+    py_modules=['memory_profiler', 'mprof'] + async_modules,
     entry_points={
         'console_scripts' : ['mprof = mprof:main'],
     },
","@@ -1,6 +1,7 @@
 import os
 import io
 import re
+import sys
 from setuptools import setup
 
 
@@ -21,6 +22,14 @@ def find_version(*file_paths):
         return version_match.group(1)
 
 
+async_modules = []
+if sys.version_info > (3, 3):
+    if sys.version_info < (3, 5):
+        async_modules = ['_aio_34']
+    else:
+        async_modules = ['_aio_35']
+
+
 CLASSIFIERS = """"""\
 Development Status :: 5 - Production/Stable
 Intended Audience :: Science/Research
@@ -39,6 +48,7 @@ Operating System :: Unix
 
 """"""
 
+
 setup(
     name='memory_profiler',
     description='A module for monitoring memory usage of a python program',
@@ -47,7 +57,7 @@ setup(
     author='Fabian Pedregosa',
     author_email='f@bianp.net',
     url='https://github.com/pythonprofilers/memory_profiler',
-    py_modules=['memory_profiler', 'mprof'],
+    py_modules=['memory_profiler', 'mprof'] + async_modules,
     entry_points={
         'console_scripts' : ['mprof = mprof:main'],
     },
",True,setup.py,True
"@@ -0,0 +1,35 @@
+from asyncio import coroutine, iscoroutinefunction
+from contextlib import contextmanager
+from functools import wraps
+
+from memory_profiler import LineProfiler, show_results
+
+
+class CoroLineProfiler(LineProfiler):
+    @contextmanager
+    def count_contextmgr(self):
+        self.enable_by_count()
+        try:
+            yield
+        finally:
+            self.disable_by_count()
+
+    def wrap_function(self, func):
+        if iscoroutinefunction(func):
+            @coroutine
+            def f(*args, **kwargs):
+                with self.count_contextmgr():
+                    yield from func(*args, **kwargs)
+            return f
+        else:
+            return super(CoroLineProfiler, self).wrap_function(func)
+
+
+def _get_coro_wrapper(coro, backend, stream, precision):
+    @wraps(coro)
+    @coroutine
+    def wrapper(*args, **kwargs):
+        prof = CoroLineProfiler(backend=backend)
+        val = yield from prof(coro)(*args, **kwargs)
+        show_results(prof, stream=stream, precision=precision)
+        return val
","@@ -0,0 +1,35 @@
+from asyncio import coroutine, iscoroutinefunction
+from contextlib import contextmanager
+from functools import wraps
+
+from memory_profiler import LineProfiler, show_results
+
+
+class CoroLineProfiler(LineProfiler):
+    @contextmanager
+    def count_contextmgr(self):
+        self.enable_by_count()
+        try:
+            yield
+        finally:
+            self.disable_by_count()
+
+    def wrap_function(self, func):
+        if iscoroutinefunction(func):
+            @coroutine
+            def f(*args, **kwargs):
+                with self.count_contextmgr():
+                    yield from func(*args, **kwargs)
+            return f
+        else:
+            return super(CoroLineProfiler, self).wrap_function(func)
+
+
+def _get_coro_wrapper(coro, backend, stream, precision):
+    @wraps(coro)
+    @coroutine
+    def wrapper(*args, **kwargs):
+        prof = CoroLineProfiler(backend=backend)
+        val = yield from prof(coro)(*args, **kwargs)
+        show_results(prof, stream=stream, precision=precision)
+        return val
",True,_aio_34.py,True
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.55.0'
+__version__ = '0.56.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.55.0'
+__version__ = '0.56.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -470,12 +470,14 @@ def _find_script(script_name):
 class _TimeStamperCM(object):
     """"""Time-stamping context manager.""""""
 
-    def __init__(self, timestamps, filename, backend, timestamper=None, func=None):
+    def __init__(self, timestamps, filename, backend, timestamper=None, func=None,
+                 include_children=False):
         self.timestamps = timestamps
         self.filename = filename
         self.backend = backend
         self.ts = timestamper
         self.func = func
+        self.include_children = include_children
 
     def __enter__(self):
         if self.ts is not None:
@@ -483,14 +485,16 @@ class _TimeStamperCM(object):
             self.ts.stack[self.func].append(self.ts.current_stack_level)
 
         self.timestamps.append(
-            _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
+            _get_memory(os.getpid(), self.backend, timestamps=True,
+                        include_children=self.include_children, filename=self.filename))
 
     def __exit__(self, *args):
         if self.ts is not None:
             self.ts.current_stack_level -= 1
 
         self.timestamps.append(
-            _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
+            _get_memory(os.getpid(), self.backend, timestamps=True,
+                        include_children=self.include_children, filename=self.filename))
 
 
 class TimeStamper:
@@ -498,9 +502,10 @@ class TimeStamper:
     any decorated function.
     """"""
 
-    def __init__(self, backend):
+    def __init__(self, backend, include_children=False):
         self.functions = {}
         self.backend = backend
+        self.include_children = include_children
         self.current_stack_level = -1
         self.stack = {}
 
@@ -561,7 +566,8 @@ class TimeStamper:
             except TypeError:
                 filename = '<unknown>'
             timestamps = [
-                _get_memory(os.getpid(), self.backend, timestamps=True, filename=filename)]
+                _get_memory(os.getpid(), self.backend, timestamps=True,
+                            include_children=self.include_children, filename=filename)]
             self.functions[func].append(timestamps)
             try:
                 with self.call_on_stack(func, *args, **kwds) as result:
@@ -569,6 +575,7 @@ class TimeStamper:
             finally:
                 # end time
                 timestamps.append(_get_memory(os.getpid(), self.backend, timestamps=True,
+                                              include_children=self.include_children,
                                               filename=filename))
 
         return f
@@ -1248,6 +1255,9 @@ if __name__ == '__main__':
         action='store_true',
         help='''print timestamp instead of memory measurement for
         decorated functions''')
+    parser.add_argument('--include-children', dest='include_children',
+        default=False, action='store_true',
+        help='also include memory used by child processes')
     parser.add_argument('--backend', dest='backend', type=str, action='store',
         choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
         help='backend using for getting memory info '
@@ -1264,7 +1274,7 @@ if __name__ == '__main__':
     script_args = args.program[1:]
     _backend = choose_backend(args.backend)
     if args.timestamp:
-        prof = TimeStamper(_backend)
+        prof = TimeStamper(_backend, include_children=args.include_children)
     else:
         prof = LineProfiler(max_mem=args.max_mem, backend=_backend)
 
","@@ -470,12 +470,14 @@ def _find_script(script_name):
 class _TimeStamperCM(object):
     """"""Time-stamping context manager.""""""
 
-    def __init__(self, timestamps, filename, backend, timestamper=None, func=None):
+    def __init__(self, timestamps, filename, backend, timestamper=None, func=None,
+                 include_children=False):
         self.timestamps = timestamps
         self.filename = filename
         self.backend = backend
         self.ts = timestamper
         self.func = func
+        self.include_children = include_children
 
     def __enter__(self):
         if self.ts is not None:
@@ -483,14 +485,16 @@ class _TimeStamperCM(object):
             self.ts.stack[self.func].append(self.ts.current_stack_level)
 
         self.timestamps.append(
-            _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
+            _get_memory(os.getpid(), self.backend, timestamps=True,
+                        include_children=self.include_children, filename=self.filename))
 
     def __exit__(self, *args):
         if self.ts is not None:
             self.ts.current_stack_level -= 1
 
         self.timestamps.append(
-            _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
+            _get_memory(os.getpid(), self.backend, timestamps=True,
+                        include_children=self.include_children, filename=self.filename))
 
 
 class TimeStamper:
@@ -498,9 +502,10 @@ class TimeStamper:
     any decorated function.
     """"""
 
-    def __init__(self, backend):
+    def __init__(self, backend, include_children=False):
         self.functions = {}
         self.backend = backend
+        self.include_children = include_children
         self.current_stack_level = -1
         self.stack = {}
 
@@ -561,7 +566,8 @@ class TimeStamper:
             except TypeError:
                 filename = '<unknown>'
             timestamps = [
-                _get_memory(os.getpid(), self.backend, timestamps=True, filename=filename)]
+                _get_memory(os.getpid(), self.backend, timestamps=True,
+                            include_children=self.include_children, filename=filename)]
             self.functions[func].append(timestamps)
             try:
                 with self.call_on_stack(func, *args, **kwds) as result:
@@ -569,6 +575,7 @@ class TimeStamper:
             finally:
                 # end time
                 timestamps.append(_get_memory(os.getpid(), self.backend, timestamps=True,
+                                              include_children=self.include_children,
                                               filename=filename))
 
         return f
@@ -1248,6 +1255,9 @@ if __name__ == '__main__':
         action='store_true',
         help='''print timestamp instead of memory measurement for
         decorated functions''')
+    parser.add_argument('--include-children', dest='include_children',
+        default=False, action='store_true',
+        help='also include memory used by child processes')
     parser.add_argument('--backend', dest='backend', type=str, action='store',
         choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
         help='backend using for getting memory info '
@@ -1264,7 +1274,7 @@ if __name__ == '__main__':
     script_args = args.program[1:]
     _backend = choose_backend(args.backend)
     if args.timestamp:
-        prof = TimeStamper(_backend)
+        prof = TimeStamper(_backend, include_children=args.include_children)
     else:
         prof = LineProfiler(max_mem=args.max_mem, backend=_backend)
 
",True,memory_profiler.py,True
"@@ -230,8 +230,10 @@ This file contains the process memory consumption, in Mb (one value per line).""""
         if not program[0].startswith(""python""):
             program.insert(0, sys.executable)
         cmd_line = get_cmd_line(program)
-        program[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
-                        ""-o"", mprofile_output)
+        extra_args = [""-m"", ""memory_profiler"", ""--timestamp"", ""-o"", mprofile_output]
+        if args.include_children:
+            extra_args.append(""--include-children"")
+        program[1:1] = extra_args
         p = subprocess.Popen(program)
     else:
         cmd_line = get_cmd_line(program)
","@@ -230,8 +230,10 @@ This file contains the process memory consumption, in Mb (one value per line).""""
         if not program[0].startswith(""python""):
             program.insert(0, sys.executable)
         cmd_line = get_cmd_line(program)
-        program[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
-                        ""-o"", mprofile_output)
+        extra_args = [""-m"", ""memory_profiler"", ""--timestamp"", ""-o"", mprofile_output]
+        if args.include_children:
+            extra_args.append(""--include-children"")
+        program[1:1] = extra_args
         p = subprocess.Popen(program)
     else:
         cmd_line = get_cmd_line(program)
",True,mprof.py,True
"@@ -5,14 +5,11 @@ _CLEAN_GLOBALS = globals().copy()
 
 __version__ = '0.55.0'
 
-_CMD_USAGE = ""python -m memory_profiler script_file.py""
 
 from functools import wraps
 import inspect
-import linecache
 import logging
 import os
-import pdb
 import subprocess
 import sys
 import time
@@ -20,6 +17,16 @@ import traceback
 import warnings
 import contextlib
 
+from .common import PY2, HAS_TRACEMALLOC
+from .utils import (
+    show_results,
+    choose_backend,
+    get_memory as _get_memory,
+    get_child_memory as _get_child_memory,
+)
+from .line_profiler import LineProfiler
+
+
 if sys.platform == ""win32"":
     # any value except signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT
     # can be used to kill a process unconditionally in Windows
@@ -29,16 +36,6 @@ else:
 import psutil
 
 
-if sys.version_info > (3, 3):
-    if sys.version_info < (3, 5):
-        from asyncio import iscoroutinefunction
-    else:
-        from inspect import iscoroutinefunction
-else:
-    def iscoroutinefunction(_):
-        return False
-
-
 # TODO: provide alternative when multiprocessing is not available
 try:
     from multiprocessing import Process, Pipe
@@ -53,10 +50,6 @@ except ImportError:
     line_cell_magic = lambda func: func
     magics_class = lambda cls: cls
 
-PY2 = sys.version_info[0] == 2
-
-_TWO_20 = float(2 ** 20)
-
 if PY2:
     import __builtin__ as builtins
     to_str = lambda x: x
@@ -65,14 +58,9 @@ else:
     import builtins
     to_str = lambda x: str(x)
 
-# .. get available packages ..
-try:
+if HAS_TRACEMALLOC:
     import tracemalloc
 
-    has_tracemalloc = True
-except ImportError:
-    has_tracemalloc = False
-
 
 class MemitResult(object):
     """"""memit magic run details.
@@ -99,108 +87,6 @@ class MemitResult(object):
         p.text(u'<MemitResult : ' + msg + u'>')
 
 
-def _get_child_memory(process, meminfo_attr=None):
-    """"""
-    Returns a generator that yields memory for all child processes.
-    """"""
-    # Convert a pid to a process
-    if isinstance(process, int):
-        if process == -1: process = os.getpid()
-        process = psutil.Process(process)
-
-    if not meminfo_attr:
-        # Use the psutil 2.0 attr if the older version isn't passed in.
-        meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
-
-    # Select the psutil function get the children similar to how we selected
-    # the memory_info attr (a change from excepting the AttributeError).
-    children_attr = 'children' if hasattr(process, 'children') else 'get_children'
-
-    # Loop over the child processes and yield their memory
-    try:
-        for child in getattr(process, children_attr)(recursive=True):
-            yield getattr(child, meminfo_attr)()[0] / _TWO_20
-    except (psutil.NoSuchProcess, psutil.AccessDenied):
-        # https://github.com/fabianp/memory_profiler/issues/71
-        yield 0.0
-
-
-def _get_memory(pid, backend, timestamps=False, include_children=False, filename=None):
-    # .. low function to get memory consumption ..
-    if pid == -1:
-        pid = os.getpid()
-
-    def tracemalloc_tool():
-        # .. cross-platform but but requires Python 3.4 or higher ..
-        stat = next(filter(lambda item: str(item).startswith(filename),
-                           tracemalloc.take_snapshot().statistics('filename')))
-        mem = stat.size / _TWO_20
-        if timestamps:
-            return mem, time.time()
-        else:
-            return mem
-
-    def ps_util_tool():
-        # .. cross-platform but but requires psutil ..
-        process = psutil.Process(pid)
-        try:
-            # avoid using get_memory_info since it does not exists
-            # in psutil > 2.0 and accessing it will cause exception.
-            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') \
-                else 'get_memory_info'
-            mem = getattr(process, meminfo_attr)()[0] / _TWO_20
-            if include_children:
-                mem +=  sum(_get_child_memory(process, meminfo_attr))
-            if timestamps:
-                return mem, time.time()
-            else:
-                return mem
-        except psutil.AccessDenied:
-            pass
-            # continue and try to get this from ps
-
-    def posix_tool():
-        # .. scary stuff ..
-        if include_children:
-            raise NotImplementedError((
-                ""The psutil module is required to monitor the ""
-                ""memory usage of child processes.""
-            ))
-
-        warnings.warn(""psutil module not found. memory_profiler will be slow"")
-        # ..
-        # .. memory usage in MiB ..
-        # .. this should work on both Mac and Linux ..
-        # .. subprocess.check_output appeared in 2.7, using Popen ..
-        # .. for backwards compatibility ..
-        out = subprocess.Popen(['ps', 'v', '-p', str(pid)],
-                               stdout=subprocess.PIPE
-                               ).communicate()[0].split(b'\n')
-        try:
-            vsz_index = out[0].split().index(b'RSS')
-            mem = float(out[1].split()[vsz_index]) / 1024
-            if timestamps:
-                return mem, time.time()
-            else:
-                return mem
-        except:
-            if timestamps:
-                return -1, time.time()
-            else:
-                return -1
-
-    if backend == 'tracemalloc' and \
-            (filename is None or filename == '<unknown>'):
-        raise RuntimeError(
-            'There is no access to source file of the profiled function'
-        )
-
-    tools = {'tracemalloc': tracemalloc_tool,
-             'psutil': ps_util_tool,
-             'posix': posix_tool}
-    return tools[backend]()
-
-
 class MemTimer(Process):
     """"""
     Fetch memory consumption from over a time interval
@@ -458,23 +344,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 # .. utility functions for line-by-line ..
 
 
-def _find_script(script_name):
-    """""" Find the script.
-
-    If the input is not a file, then $PATH will be searched.
-    """"""
-    if os.path.isfile(script_name):
-        return script_name
-    path = os.getenv('PATH', os.defpath).split(os.pathsep)
-    for folder in path:
-        if not folder:
-            continue
-        fn = os.path.join(folder, script_name)
-        if os.path.isfile(fn):
-            return fn
-
-    sys.stderr.write('Could not find script {0}\n'.format(script_name))
-    raise SystemExit(1)
 
 
 class _TimeStamperCM(object):
@@ -603,234 +472,6 @@ class TimeStamper:
                     (function_name,) + ts[0] + ts[1] + (level,)))
 
 
-class CodeMap(dict):
-    def __init__(self, include_children, backend):
-        self.include_children = include_children
-        self._toplevel = []
-        self.backend = backend
-
-    def add(self, code, toplevel_code=None):
-        if code in self:
-            return
-
-        if toplevel_code is None:
-            filename = code.co_filename
-            if filename.endswith(("".pyc"", "".pyo"")):
-                filename = filename[:-1]
-            if not os.path.exists(filename):
-                print('ERROR: Could not find file ' + filename)
-                if filename.startswith((""ipython-input"", ""<ipython-input"")):
-                    print(
-                        ""NOTE: %mprun can only be used on functions defined in""
-                        "" physical files, and not in the IPython environment."")
-                return
-
-            toplevel_code = code
-            (sub_lines, start_line) = inspect.getsourcelines(code)
-            linenos = range(start_line,
-                            start_line + len(sub_lines))
-            self._toplevel.append((filename, code, linenos))
-            self[code] = {}
-        else:
-            self[code] = self[toplevel_code]
-
-        for subcode in filter(inspect.iscode, code.co_consts):
-            self.add(subcode, toplevel_code=toplevel_code)
-
-    def trace(self, code, lineno, prev_lineno):
-        memory = _get_memory(-1, self.backend, include_children=self.include_children,
-                             filename=code.co_filename)
-        prev_value = self[code].get(lineno, None)
-        previous_memory = prev_value[1] if prev_value else 0
-        previous_inc = prev_value[0] if prev_value else 0
-
-        prev_line_value = self[code].get(prev_lineno, None) if prev_lineno else None
-        prev_line_memory = prev_line_value[1] if prev_line_value else 0
-        self[code][lineno] = (max(previous_inc, memory-prev_line_memory), max(memory, previous_memory))
-
-    def items(self):
-        """"""Iterate on the toplevel code blocks.""""""
-        for (filename, code, linenos) in self._toplevel:
-            measures = self[code]
-            if not measures:
-                continue  # skip if no measurement
-            line_iterator = ((line, measures.get(line)) for line in linenos)
-            yield (filename, line_iterator)
-
-
-class LineProfiler(object):
-    """""" A profiler that records the amount of memory for each line """"""
-
-    def __init__(self, **kw):
-        include_children = kw.get('include_children', False)
-        backend = kw.get('backend', 'psutil')
-        self.code_map = CodeMap(
-            include_children=include_children, backend=backend)
-        self.enable_count = 0
-        self.max_mem = kw.get('max_mem', None)
-        self.prevlines = []
-        self.backend = choose_backend(kw.get('backend', None))
-        self.prev_lineno = None
-
-    def __call__(self, func=None, precision=1):
-        if func is not None:
-            self.add_function(func)
-            f = self.wrap_function(func)
-            f.__module__ = func.__module__
-            f.__name__ = func.__name__
-            f.__doc__ = func.__doc__
-            f.__dict__.update(getattr(func, '__dict__', {}))
-            return f
-        else:
-            def inner_partial(f):
-                return self.__call__(f, precision=precision)
-
-            return inner_partial
-
-    def add_function(self, func):
-        """""" Record line profiling information for the given Python function.
-        """"""
-        try:
-            # func_code does not exist in Python3
-            code = func.__code__
-        except AttributeError:
-            warnings.warn(""Could not extract a code object for the object %r""
-                          % func)
-        else:
-            self.code_map.add(code)
-
-    def wrap_function(self, func):
-        """""" Wrap a function to profile it.
-        """"""
-
-        def f(*args, **kwds):
-            self.enable_by_count()
-            try:
-                return func(*args, **kwds)
-            finally:
-                self.disable_by_count()
-
-        return f
-
-    def runctx(self, cmd, globals, locals):
-        """""" Profile a single executable statement in the given namespaces.
-        """"""
-        self.enable_by_count()
-        try:
-            exec(cmd, globals, locals)
-        finally:
-            self.disable_by_count()
-        return self
-
-    def enable_by_count(self):
-        """""" Enable the profiler if it hasn't been enabled before.
-        """"""
-        if self.enable_count == 0:
-            self.enable()
-        self.enable_count += 1
-
-    def disable_by_count(self):
-        """""" Disable the profiler if the number of disable requests matches the
-        number of enable requests.
-        """"""
-        if self.enable_count > 0:
-            self.enable_count -= 1
-            if self.enable_count == 0:
-                self.disable()
-
-    def trace_memory_usage(self, frame, event, arg):
-        """"""Callback for sys.settrace""""""
-        if frame.f_code in self.code_map:
-            if event == 'call':
-                # ""call"" event just saves the lineno but not the memory
-                self.prevlines.append(frame.f_lineno)
-            elif event == 'line':
-                # trace needs current line and previous line
-                self.code_map.trace(frame.f_code, self.prevlines[-1], self.prev_lineno)
-                # saving previous line
-                self.prev_lineno = self.prevlines[-1]
-                self.prevlines[-1] = frame.f_lineno
-            elif event == 'return':
-                lineno = self.prevlines.pop()
-                self.code_map.trace(frame.f_code, lineno, self.prev_lineno)
-                self.prev_lineno = lineno
-
-        if self._original_trace_function is not None:
-            self._original_trace_function(frame, event, arg)
-
-        return self.trace_memory_usage
-
-    def trace_max_mem(self, frame, event, arg):
-        # run into PDB as soon as memory is higher than MAX_MEM
-        if event in ('line', 'return') and frame.f_code in self.code_map:
-            c = _get_memory(-1, self.backend, filename=frame.f_code.co_filename)
-            if c >= self.max_mem:
-                t = ('Current memory {0:.2f} MiB exceeded the '
-                     'maximum of {1:.2f} MiB\n'.format(c, self.max_mem))
-                sys.stdout.write(t)
-                sys.stdout.write('Stepping into the debugger \n')
-                frame.f_lineno -= 2
-                p = pdb.Pdb()
-                p.quitting = False
-                p.stopframe = frame
-                p.returnframe = None
-                p.stoplineno = frame.f_lineno - 3
-                p.botframe = None
-                return p.trace_dispatch
-
-        if self._original_trace_function is not None:
-            (self._original_trace_function)(frame, event, arg)
-
-        return self.trace_max_mem
-
-    def __enter__(self):
-        self.enable_by_count()
-
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        self.disable_by_count()
-
-    def enable(self):
-        self._original_trace_function = sys.gettrace()
-        if self.max_mem is not None:
-            sys.settrace(self.trace_max_mem)
-        else:
-            sys.settrace(self.trace_memory_usage)
-
-    def disable(self):
-        sys.settrace(self._original_trace_function)
-
-
-def show_results(prof, stream=None, precision=1):
-    if stream is None:
-        stream = sys.stdout
-    template = '{0:>6} {1:>12} {2:>12}   {3:<}'
-
-    for (filename, lines) in prof.code_map.items():
-        header = template.format('Line #', 'Mem usage', 'Increment',
-                                 'Line Contents')
-
-        stream.write(u'Filename: ' + filename + '\n\n')
-        stream.write(header + u'\n')
-        stream.write(u'=' * len(header) + '\n')
-
-        all_lines = linecache.getlines(filename)
-
-        float_format = u'{0}.{1}f'.format(precision + 4, precision)
-        template_mem = u'{0:' + float_format + '} MiB'
-        for (lineno, mem) in lines:
-            if mem:
-                inc = mem[0]
-                mem = mem[1]
-                mem = template_mem.format(mem)
-                inc = template_mem.format(inc)
-            else:
-                mem = u''
-                inc = u''
-            tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
-            stream.write(to_str(tmp))
-        stream.write(u'\n\n')
-
-
 def _func_exec(stmt, ns):
     # helper for magic_memit, just a function proxy for the exec
     # statement
@@ -1113,7 +754,7 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
     Decorator that will run the function and print a line-by-line profile
     """"""
     backend = choose_backend(backend)
-    if backend == 'tracemalloc' and has_tracemalloc:
+    if backend == 'tracemalloc' and HAS_TRACEMALLOC:
         if not tracemalloc.is_tracing():
             tracemalloc.start()
     if func is not None:
@@ -1133,58 +774,32 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
         return inner_wrapper
 
 
-def choose_backend(new_backend=None):
-    """"""
-    Function that tries to setup backend, chosen by user, and if failed,
-    setup one of the allowable backends
-    """"""
-
-    _backend = 'no_backend'
-    all_backends = [
-        ('psutil', True),
-        ('posix', os.name == 'posix'),
-        ('tracemalloc', has_tracemalloc),
-    ]
-    backends_indices = dict((b[0], i) for i, b in enumerate(all_backends))
-
-    if new_backend is not None:
-        all_backends.insert(0, all_backends.pop(backends_indices[new_backend]))
-
-    for n_backend, is_available in all_backends:
-        if is_available:
-            _backend = n_backend
-            break
-    if _backend != new_backend and new_backend is not None:
-        warnings.warn('{0} can not be used, {1} used instead'.format(
-            new_backend, _backend))
-    return _backend
-
-
 # Insert in the built-ins to have profile
 # globally defined (global variables is not enough
 # for all cases, e.g. a script that imports another
 # script where @profile is used)
 def exec_with_profiler(filename, profiler, backend, passed_args=[]):
-    from runpy import run_module
     builtins.__dict__['profile'] = profiler
-    ns = dict(_CLEAN_GLOBALS,
-              profile=profiler,
-             # Make sure the __file__ variable is usable
-             # by the script we're profiling
-              __file__=filename)
+    ns = dict(
+        _CLEAN_GLOBALS,
+        profile=profiler,
+        # Make sure the __file__ variable is usable
+        # by the script we're profiling
+        __file__=filename
+    )
     # Make sure the script's directory in on sys.path
     # credit to line_profiler
-    sys.path.insert(0, os.path.dirname(script_filename))
+    sys.path.insert(0, os.path.dirname(filename))
 
     _backend = choose_backend(backend)
     sys.argv = [filename] + passed_args
     try:
-        if _backend == 'tracemalloc' and has_tracemalloc:
+        if _backend == 'tracemalloc' and HAS_TRACEMALLOC:
             tracemalloc.start()
         with open(filename) as f:
             exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
-        if has_tracemalloc and tracemalloc.is_tracing():
+        if HAS_TRACEMALLOC and tracemalloc.is_tracing():
             tracemalloc.stop()
 
 
@@ -1197,12 +812,12 @@ def run_module_with_profiler(module, profiler, backend, passed_args=[]):
     if PY2:
         run_module(module, run_name=""__main__"", init_globals=ns)
     else:
-        if _backend == 'tracemalloc' and has_tracemalloc:
+        if _backend == 'tracemalloc' and HAS_TRACEMALLOC:
             tracemalloc.start()
         try:
             run_module(module, run_name=""__main__"", init_globals=ns)
         finally:
-            if has_tracemalloc and tracemalloc.is_tracing():
+            if HAS_TRACEMALLOC and tracemalloc.is_tracing():
                 tracemalloc.stop()
 
 
@@ -1236,61 +851,3 @@ class LogFile(object):
     def flush(self):
         for handler in self.logger.handlers:
             handler.flush()
-
-
-if __name__ == '__main__':
-    from argparse import ArgumentParser, REMAINDER
-
-    parser = ArgumentParser(usage=_CMD_USAGE)
-    parser.add_argument('--version', action='version', version=__version__)
-    parser.add_argument(
-        '--pdb-mmem', dest='max_mem', metavar='MAXMEM',
-        type=float, action='store',
-        help='step into the debugger when memory exceeds MAXMEM')
-    parser.add_argument(
-        '--precision', dest='precision', type=int,
-        action='store', default=3,
-        help='precision of memory output in number of significant digits')
-    parser.add_argument('-o', dest='out_filename', type=str,
-        action='store', default=None,
-        help='path to a file where results will be written')
-    parser.add_argument('--timestamp', dest='timestamp', default=False,
-        action='store_true',
-        help='''print timestamp instead of memory measurement for
-        decorated functions''')
-    parser.add_argument('--backend', dest='backend', type=str, action='store',
-        choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
-        help='backend using for getting memory info '
-             '(one of the {tracemalloc, psutil, posix})')
-    parser.add_argument(""program"", nargs=REMAINDER,
-        help='python script or module followed by command line arguements to run')
-    args = parser.parse_args()
-
-    if len(args.program) == 0:
-        print(""A program to run must be provided. Use -h for help"")
-        sys.exit(1)
-
-    target = args.program[0]
-    script_args = args.program[1:]
-    _backend = choose_backend(args.backend)
-    if args.timestamp:
-        prof = TimeStamper(_backend)
-    else:
-        prof = LineProfiler(max_mem=args.max_mem, backend=_backend)
-
-    try:
-        if args.program[0].endswith('.py'):
-            script_filename = _find_script(args.program[0])
-            exec_with_profiler(script_filename, prof, args.backend, script_args)
-        else:
-            run_module_with_profiler(target, prof, args.backend, script_args)
-    finally:
-        if args.out_filename is not None:
-            out_file = open(args.out_filename, ""a"")
-        else:
-            out_file = sys.stdout
-
-        if args.timestamp:
-            prof.show_results(stream=out_file)
-        else:
-            show_results(prof, precision=args.precision, stream=out_file)
","@@ -5,14 +5,11 @@ _CLEAN_GLOBALS = globals().copy()
 
 __version__ = '0.55.0'
 
-_CMD_USAGE = ""python -m memory_profiler script_file.py""
 
 from functools import wraps
 import inspect
-import linecache
 import logging
 import os
-import pdb
 import subprocess
 import sys
 import time
@@ -20,6 +17,16 @@ import traceback
 import warnings
 import contextlib
 
+from .common import PY2, HAS_TRACEMALLOC
+from .utils import (
+    show_results,
+    choose_backend,
+    get_memory as _get_memory,
+    get_child_memory as _get_child_memory,
+)
+from .line_profiler import LineProfiler
+
+
 if sys.platform == ""win32"":
     # any value except signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT
     # can be used to kill a process unconditionally in Windows
@@ -29,16 +36,6 @@ else:
 import psutil
 
 
-if sys.version_info > (3, 3):
-    if sys.version_info < (3, 5):
-        from asyncio import iscoroutinefunction
-    else:
-        from inspect import iscoroutinefunction
-else:
-    def iscoroutinefunction(_):
-        return False
-
-
 # TODO: provide alternative when multiprocessing is not available
 try:
     from multiprocessing import Process, Pipe
@@ -53,10 +50,6 @@ except ImportError:
     line_cell_magic = lambda func: func
     magics_class = lambda cls: cls
 
-PY2 = sys.version_info[0] == 2
-
-_TWO_20 = float(2 ** 20)
-
 if PY2:
     import __builtin__ as builtins
     to_str = lambda x: x
@@ -65,14 +58,9 @@ else:
     import builtins
     to_str = lambda x: str(x)
 
-# .. get available packages ..
-try:
+if HAS_TRACEMALLOC:
     import tracemalloc
 
-    has_tracemalloc = True
-except ImportError:
-    has_tracemalloc = False
-
 
 class MemitResult(object):
     """"""memit magic run details.
@@ -99,108 +87,6 @@ class MemitResult(object):
         p.text(u'<MemitResult : ' + msg + u'>')
 
 
-def _get_child_memory(process, meminfo_attr=None):
-    """"""
-    Returns a generator that yields memory for all child processes.
-    """"""
-    # Convert a pid to a process
-    if isinstance(process, int):
-        if process == -1: process = os.getpid()
-        process = psutil.Process(process)
-
-    if not meminfo_attr:
-        # Use the psutil 2.0 attr if the older version isn't passed in.
-        meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
-
-    # Select the psutil function get the children similar to how we selected
-    # the memory_info attr (a change from excepting the AttributeError).
-    children_attr = 'children' if hasattr(process, 'children') else 'get_children'
-
-    # Loop over the child processes and yield their memory
-    try:
-        for child in getattr(process, children_attr)(recursive=True):
-            yield getattr(child, meminfo_attr)()[0] / _TWO_20
-    except (psutil.NoSuchProcess, psutil.AccessDenied):
-        # https://github.com/fabianp/memory_profiler/issues/71
-        yield 0.0
-
-
-def _get_memory(pid, backend, timestamps=False, include_children=False, filename=None):
-    # .. low function to get memory consumption ..
-    if pid == -1:
-        pid = os.getpid()
-
-    def tracemalloc_tool():
-        # .. cross-platform but but requires Python 3.4 or higher ..
-        stat = next(filter(lambda item: str(item).startswith(filename),
-                           tracemalloc.take_snapshot().statistics('filename')))
-        mem = stat.size / _TWO_20
-        if timestamps:
-            return mem, time.time()
-        else:
-            return mem
-
-    def ps_util_tool():
-        # .. cross-platform but but requires psutil ..
-        process = psutil.Process(pid)
-        try:
-            # avoid using get_memory_info since it does not exists
-            # in psutil > 2.0 and accessing it will cause exception.
-            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') \
-                else 'get_memory_info'
-            mem = getattr(process, meminfo_attr)()[0] / _TWO_20
-            if include_children:
-                mem +=  sum(_get_child_memory(process, meminfo_attr))
-            if timestamps:
-                return mem, time.time()
-            else:
-                return mem
-        except psutil.AccessDenied:
-            pass
-            # continue and try to get this from ps
-
-    def posix_tool():
-        # .. scary stuff ..
-        if include_children:
-            raise NotImplementedError((
-                ""The psutil module is required to monitor the ""
-                ""memory usage of child processes.""
-            ))
-
-        warnings.warn(""psutil module not found. memory_profiler will be slow"")
-        # ..
-        # .. memory usage in MiB ..
-        # .. this should work on both Mac and Linux ..
-        # .. subprocess.check_output appeared in 2.7, using Popen ..
-        # .. for backwards compatibility ..
-        out = subprocess.Popen(['ps', 'v', '-p', str(pid)],
-                               stdout=subprocess.PIPE
-                               ).communicate()[0].split(b'\n')
-        try:
-            vsz_index = out[0].split().index(b'RSS')
-            mem = float(out[1].split()[vsz_index]) / 1024
-            if timestamps:
-                return mem, time.time()
-            else:
-                return mem
-        except:
-            if timestamps:
-                return -1, time.time()
-            else:
-                return -1
-
-    if backend == 'tracemalloc' and \
-            (filename is None or filename == '<unknown>'):
-        raise RuntimeError(
-            'There is no access to source file of the profiled function'
-        )
-
-    tools = {'tracemalloc': tracemalloc_tool,
-             'psutil': ps_util_tool,
-             'posix': posix_tool}
-    return tools[backend]()
-
-
 class MemTimer(Process):
     """"""
     Fetch memory consumption from over a time interval
@@ -458,23 +344,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 # .. utility functions for line-by-line ..
 
 
-def _find_script(script_name):
-    """""" Find the script.
-
-    If the input is not a file, then $PATH will be searched.
-    """"""
-    if os.path.isfile(script_name):
-        return script_name
-    path = os.getenv('PATH', os.defpath).split(os.pathsep)
-    for folder in path:
-        if not folder:
-            continue
-        fn = os.path.join(folder, script_name)
-        if os.path.isfile(fn):
-            return fn
-
-    sys.stderr.write('Could not find script {0}\n'.format(script_name))
-    raise SystemExit(1)
 
 
 class _TimeStamperCM(object):
@@ -603,234 +472,6 @@ class TimeStamper:
                     (function_name,) + ts[0] + ts[1] + (level,)))
 
 
-class CodeMap(dict):
-    def __init__(self, include_children, backend):
-        self.include_children = include_children
-        self._toplevel = []
-        self.backend = backend
-
-    def add(self, code, toplevel_code=None):
-        if code in self:
-            return
-
-        if toplevel_code is None:
-            filename = code.co_filename
-            if filename.endswith(("".pyc"", "".pyo"")):
-                filename = filename[:-1]
-            if not os.path.exists(filename):
-                print('ERROR: Could not find file ' + filename)
-                if filename.startswith((""ipython-input"", ""<ipython-input"")):
-                    print(
-                        ""NOTE: %mprun can only be used on functions defined in""
-                        "" physical files, and not in the IPython environment."")
-                return
-
-            toplevel_code = code
-            (sub_lines, start_line) = inspect.getsourcelines(code)
-            linenos = range(start_line,
-                            start_line + len(sub_lines))
-            self._toplevel.append((filename, code, linenos))
-            self[code] = {}
-        else:
-            self[code] = self[toplevel_code]
-
-        for subcode in filter(inspect.iscode, code.co_consts):
-            self.add(subcode, toplevel_code=toplevel_code)
-
-    def trace(self, code, lineno, prev_lineno):
-        memory = _get_memory(-1, self.backend, include_children=self.include_children,
-                             filename=code.co_filename)
-        prev_value = self[code].get(lineno, None)
-        previous_memory = prev_value[1] if prev_value else 0
-        previous_inc = prev_value[0] if prev_value else 0
-
-        prev_line_value = self[code].get(prev_lineno, None) if prev_lineno else None
-        prev_line_memory = prev_line_value[1] if prev_line_value else 0
-        self[code][lineno] = (max(previous_inc, memory-prev_line_memory), max(memory, previous_memory))
-
-    def items(self):
-        """"""Iterate on the toplevel code blocks.""""""
-        for (filename, code, linenos) in self._toplevel:
-            measures = self[code]
-            if not measures:
-                continue  # skip if no measurement
-            line_iterator = ((line, measures.get(line)) for line in linenos)
-            yield (filename, line_iterator)
-
-
-class LineProfiler(object):
-    """""" A profiler that records the amount of memory for each line """"""
-
-    def __init__(self, **kw):
-        include_children = kw.get('include_children', False)
-        backend = kw.get('backend', 'psutil')
-        self.code_map = CodeMap(
-            include_children=include_children, backend=backend)
-        self.enable_count = 0
-        self.max_mem = kw.get('max_mem', None)
-        self.prevlines = []
-        self.backend = choose_backend(kw.get('backend', None))
-        self.prev_lineno = None
-
-    def __call__(self, func=None, precision=1):
-        if func is not None:
-            self.add_function(func)
-            f = self.wrap_function(func)
-            f.__module__ = func.__module__
-            f.__name__ = func.__name__
-            f.__doc__ = func.__doc__
-            f.__dict__.update(getattr(func, '__dict__', {}))
-            return f
-        else:
-            def inner_partial(f):
-                return self.__call__(f, precision=precision)
-
-            return inner_partial
-
-    def add_function(self, func):
-        """""" Record line profiling information for the given Python function.
-        """"""
-        try:
-            # func_code does not exist in Python3
-            code = func.__code__
-        except AttributeError:
-            warnings.warn(""Could not extract a code object for the object %r""
-                          % func)
-        else:
-            self.code_map.add(code)
-
-    def wrap_function(self, func):
-        """""" Wrap a function to profile it.
-        """"""
-
-        def f(*args, **kwds):
-            self.enable_by_count()
-            try:
-                return func(*args, **kwds)
-            finally:
-                self.disable_by_count()
-
-        return f
-
-    def runctx(self, cmd, globals, locals):
-        """""" Profile a single executable statement in the given namespaces.
-        """"""
-        self.enable_by_count()
-        try:
-            exec(cmd, globals, locals)
-        finally:
-            self.disable_by_count()
-        return self
-
-    def enable_by_count(self):
-        """""" Enable the profiler if it hasn't been enabled before.
-        """"""
-        if self.enable_count == 0:
-            self.enable()
-        self.enable_count += 1
-
-    def disable_by_count(self):
-        """""" Disable the profiler if the number of disable requests matches the
-        number of enable requests.
-        """"""
-        if self.enable_count > 0:
-            self.enable_count -= 1
-            if self.enable_count == 0:
-                self.disable()
-
-    def trace_memory_usage(self, frame, event, arg):
-        """"""Callback for sys.settrace""""""
-        if frame.f_code in self.code_map:
-            if event == 'call':
-                # ""call"" event just saves the lineno but not the memory
-                self.prevlines.append(frame.f_lineno)
-            elif event == 'line':
-                # trace needs current line and previous line
-                self.code_map.trace(frame.f_code, self.prevlines[-1], self.prev_lineno)
-                # saving previous line
-                self.prev_lineno = self.prevlines[-1]
-                self.prevlines[-1] = frame.f_lineno
-            elif event == 'return':
-                lineno = self.prevlines.pop()
-                self.code_map.trace(frame.f_code, lineno, self.prev_lineno)
-                self.prev_lineno = lineno
-
-        if self._original_trace_function is not None:
-            self._original_trace_function(frame, event, arg)
-
-        return self.trace_memory_usage
-
-    def trace_max_mem(self, frame, event, arg):
-        # run into PDB as soon as memory is higher than MAX_MEM
-        if event in ('line', 'return') and frame.f_code in self.code_map:
-            c = _get_memory(-1, self.backend, filename=frame.f_code.co_filename)
-            if c >= self.max_mem:
-                t = ('Current memory {0:.2f} MiB exceeded the '
-                     'maximum of {1:.2f} MiB\n'.format(c, self.max_mem))
-                sys.stdout.write(t)
-                sys.stdout.write('Stepping into the debugger \n')
-                frame.f_lineno -= 2
-                p = pdb.Pdb()
-                p.quitting = False
-                p.stopframe = frame
-                p.returnframe = None
-                p.stoplineno = frame.f_lineno - 3
-                p.botframe = None
-                return p.trace_dispatch
-
-        if self._original_trace_function is not None:
-            (self._original_trace_function)(frame, event, arg)
-
-        return self.trace_max_mem
-
-    def __enter__(self):
-        self.enable_by_count()
-
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        self.disable_by_count()
-
-    def enable(self):
-        self._original_trace_function = sys.gettrace()
-        if self.max_mem is not None:
-            sys.settrace(self.trace_max_mem)
-        else:
-            sys.settrace(self.trace_memory_usage)
-
-    def disable(self):
-        sys.settrace(self._original_trace_function)
-
-
-def show_results(prof, stream=None, precision=1):
-    if stream is None:
-        stream = sys.stdout
-    template = '{0:>6} {1:>12} {2:>12}   {3:<}'
-
-    for (filename, lines) in prof.code_map.items():
-        header = template.format('Line #', 'Mem usage', 'Increment',
-                                 'Line Contents')
-
-        stream.write(u'Filename: ' + filename + '\n\n')
-        stream.write(header + u'\n')
-        stream.write(u'=' * len(header) + '\n')
-
-        all_lines = linecache.getlines(filename)
-
-        float_format = u'{0}.{1}f'.format(precision + 4, precision)
-        template_mem = u'{0:' + float_format + '} MiB'
-        for (lineno, mem) in lines:
-            if mem:
-                inc = mem[0]
-                mem = mem[1]
-                mem = template_mem.format(mem)
-                inc = template_mem.format(inc)
-            else:
-                mem = u''
-                inc = u''
-            tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
-            stream.write(to_str(tmp))
-        stream.write(u'\n\n')
-
-
 def _func_exec(stmt, ns):
     # helper for magic_memit, just a function proxy for the exec
     # statement
@@ -1113,7 +754,7 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
     Decorator that will run the function and print a line-by-line profile
     """"""
     backend = choose_backend(backend)
-    if backend == 'tracemalloc' and has_tracemalloc:
+    if backend == 'tracemalloc' and HAS_TRACEMALLOC:
         if not tracemalloc.is_tracing():
             tracemalloc.start()
     if func is not None:
@@ -1133,58 +774,32 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
         return inner_wrapper
 
 
-def choose_backend(new_backend=None):
-    """"""
-    Function that tries to setup backend, chosen by user, and if failed,
-    setup one of the allowable backends
-    """"""
-
-    _backend = 'no_backend'
-    all_backends = [
-        ('psutil', True),
-        ('posix', os.name == 'posix'),
-        ('tracemalloc', has_tracemalloc),
-    ]
-    backends_indices = dict((b[0], i) for i, b in enumerate(all_backends))
-
-    if new_backend is not None:
-        all_backends.insert(0, all_backends.pop(backends_indices[new_backend]))
-
-    for n_backend, is_available in all_backends:
-        if is_available:
-            _backend = n_backend
-            break
-    if _backend != new_backend and new_backend is not None:
-        warnings.warn('{0} can not be used, {1} used instead'.format(
-            new_backend, _backend))
-    return _backend
-
-
 # Insert in the built-ins to have profile
 # globally defined (global variables is not enough
 # for all cases, e.g. a script that imports another
 # script where @profile is used)
 def exec_with_profiler(filename, profiler, backend, passed_args=[]):
-    from runpy import run_module
     builtins.__dict__['profile'] = profiler
-    ns = dict(_CLEAN_GLOBALS,
-              profile=profiler,
-             # Make sure the __file__ variable is usable
-             # by the script we're profiling
-              __file__=filename)
+    ns = dict(
+        _CLEAN_GLOBALS,
+        profile=profiler,
+        # Make sure the __file__ variable is usable
+        # by the script we're profiling
+        __file__=filename
+    )
     # Make sure the script's directory in on sys.path
     # credit to line_profiler
-    sys.path.insert(0, os.path.dirname(script_filename))
+    sys.path.insert(0, os.path.dirname(filename))
 
     _backend = choose_backend(backend)
     sys.argv = [filename] + passed_args
     try:
-        if _backend == 'tracemalloc' and has_tracemalloc:
+        if _backend == 'tracemalloc' and HAS_TRACEMALLOC:
             tracemalloc.start()
         with open(filename) as f:
             exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
-        if has_tracemalloc and tracemalloc.is_tracing():
+        if HAS_TRACEMALLOC and tracemalloc.is_tracing():
             tracemalloc.stop()
 
 
@@ -1197,12 +812,12 @@ def run_module_with_profiler(module, profiler, backend, passed_args=[]):
     if PY2:
         run_module(module, run_name=""__main__"", init_globals=ns)
     else:
-        if _backend == 'tracemalloc' and has_tracemalloc:
+        if _backend == 'tracemalloc' and HAS_TRACEMALLOC:
             tracemalloc.start()
         try:
             run_module(module, run_name=""__main__"", init_globals=ns)
         finally:
-            if has_tracemalloc and tracemalloc.is_tracing():
+            if HAS_TRACEMALLOC and tracemalloc.is_tracing():
                 tracemalloc.stop()
 
 
@@ -1236,61 +851,3 @@ class LogFile(object):
     def flush(self):
         for handler in self.logger.handlers:
             handler.flush()
-
-
-if __name__ == '__main__':
-    from argparse import ArgumentParser, REMAINDER
-
-    parser = ArgumentParser(usage=_CMD_USAGE)
-    parser.add_argument('--version', action='version', version=__version__)
-    parser.add_argument(
-        '--pdb-mmem', dest='max_mem', metavar='MAXMEM',
-        type=float, action='store',
-        help='step into the debugger when memory exceeds MAXMEM')
-    parser.add_argument(
-        '--precision', dest='precision', type=int,
-        action='store', default=3,
-        help='precision of memory output in number of significant digits')
-    parser.add_argument('-o', dest='out_filename', type=str,
-        action='store', default=None,
-        help='path to a file where results will be written')
-    parser.add_argument('--timestamp', dest='timestamp', default=False,
-        action='store_true',
-        help='''print timestamp instead of memory measurement for
-        decorated functions''')
-    parser.add_argument('--backend', dest='backend', type=str, action='store',
-        choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
-        help='backend using for getting memory info '
-             '(one of the {tracemalloc, psutil, posix})')
-    parser.add_argument(""program"", nargs=REMAINDER,
-        help='python script or module followed by command line arguements to run')
-    args = parser.parse_args()
-
-    if len(args.program) == 0:
-        print(""A program to run must be provided. Use -h for help"")
-        sys.exit(1)
-
-    target = args.program[0]
-    script_args = args.program[1:]
-    _backend = choose_backend(args.backend)
-    if args.timestamp:
-        prof = TimeStamper(_backend)
-    else:
-        prof = LineProfiler(max_mem=args.max_mem, backend=_backend)
-
-    try:
-        if args.program[0].endswith('.py'):
-            script_filename = _find_script(args.program[0])
-            exec_with_profiler(script_filename, prof, args.backend, script_args)
-        else:
-            run_module_with_profiler(target, prof, args.backend, script_args)
-    finally:
-        if args.out_filename is not None:
-            out_file = open(args.out_filename, ""a"")
-        else:
-            out_file = sys.stdout
-
-        if args.timestamp:
-            prof.show_results(stream=out_file)
-        else:
-            show_results(prof, precision=args.precision, stream=out_file)
",True,memory_profiler/__init__.py,True
"@@ -0,0 +1,115 @@
+import os
+import sys
+from argparse import ArgumentParser, REMAINDER
+
+from . import exec_with_profiler, run_module_with_profiler, TimeStamper, __version__
+from .line_profiler import LineProfiler
+from .utils import choose_backend, show_results
+
+
+_CMD_USAGE = ""python -m memory_profiler script_file.py""
+
+
+def _find_script(script_name):
+    """""" Find the script.
+
+    If the input is not a file, then $PATH will be searched.
+    """"""
+    if os.path.isfile(script_name):
+        return script_name
+    path = os.getenv('PATH', os.defpath).split(os.pathsep)
+    for folder in path:
+        if not folder:
+            continue
+        fn = os.path.join(folder, script_name)
+        if os.path.isfile(fn):
+            return fn
+
+    sys.stderr.write('Could not find script {0}\n'.format(script_name))
+    raise SystemExit(1)
+
+
+if __name__ == '__main__':
+    parser = ArgumentParser(usage=_CMD_USAGE)
+    parser.add_argument('--version', action='version', version=__version__)
+    parser.add_argument(
+        '--pdb-mmem',
+        dest='max_mem',
+        metavar='MAXMEM',
+        type=float,
+        action='store',
+        help='step into the debugger when memory exceeds MAXMEM'
+    )
+    parser.add_argument(
+        '--precision',
+        dest='precision',
+        type=int,
+        action='store',
+        default=3,
+        help='precision of memory output in number of significant digits'
+    )
+    parser.add_argument(
+        '-o',
+        dest='out_filename',
+        type=str,
+        action='store',
+        default=None,
+        help='path to a file where results will be written'
+    )
+    parser.add_argument(
+        '--timestamp',
+        dest='timestamp',
+        default=False,
+        action='store_true',
+        help='''print timestamp instead of memory measurement for
+        decorated functions'''
+    )
+    parser.add_argument(
+        '--backend',
+        dest='backend',
+        type=str,
+        action='store',
+        choices=['tracemalloc', 'psutil', 'posix'],
+        default='psutil',
+        help='backend using for getting memory info '
+             '(one of the {tracemalloc, psutil, posix})'
+    )
+    parser.add_argument(
+        ""program"",
+        nargs=REMAINDER,
+        help='python script or module followed by '
+             'command line arguments to run'
+    )
+    args = parser.parse_args()
+
+    if len(args.program) == 0:
+        print(""A program to run must be provided. Use -h for help"")
+        sys.exit(1)
+
+    target = args.program[0]
+    script_args = args.program[1:]
+
+    _backend = choose_backend(args.backend)
+    if args.timestamp:
+        prof = TimeStamper(_backend)
+    else:
+        prof = LineProfiler(max_mem=args.max_mem, backend=_backend)
+
+    try:
+        if args.program[0].endswith('.py'):
+            script_filename = _find_script(args.program[0])
+            exec_with_profiler(
+                script_filename, prof, args.backend, script_args
+            )
+        else:
+            run_module_with_profiler(target, prof, args.backend, script_args)
+    finally:
+        if args.out_filename is not None:
+            out_file = open(args.out_filename, ""a"")
+        else:
+            out_file = sys.stdout
+
+        if args.timestamp:
+            prof.show_results(stream=out_file)
+        else:
+            show_results(prof, precision=args.precision, stream=out_file)
","@@ -0,0 +1,115 @@
+import os
+import sys
+from argparse import ArgumentParser, REMAINDER
+
+from . import exec_with_profiler, run_module_with_profiler, TimeStamper, __version__
+from .line_profiler import LineProfiler
+from .utils import choose_backend, show_results
+
+
+_CMD_USAGE = ""python -m memory_profiler script_file.py""
+
+
+def _find_script(script_name):
+    """""" Find the script.
+
+    If the input is not a file, then $PATH will be searched.
+    """"""
+    if os.path.isfile(script_name):
+        return script_name
+    path = os.getenv('PATH', os.defpath).split(os.pathsep)
+    for folder in path:
+        if not folder:
+            continue
+        fn = os.path.join(folder, script_name)
+        if os.path.isfile(fn):
+            return fn
+
+    sys.stderr.write('Could not find script {0}\n'.format(script_name))
+    raise SystemExit(1)
+
+
+if __name__ == '__main__':
+    parser = ArgumentParser(usage=_CMD_USAGE)
+    parser.add_argument('--version', action='version', version=__version__)
+    parser.add_argument(
+        '--pdb-mmem',
+        dest='max_mem',
+        metavar='MAXMEM',
+        type=float,
+        action='store',
+        help='step into the debugger when memory exceeds MAXMEM'
+    )
+    parser.add_argument(
+        '--precision',
+        dest='precision',
+        type=int,
+        action='store',
+        default=3,
+        help='precision of memory output in number of significant digits'
+    )
+    parser.add_argument(
+        '-o',
+        dest='out_filename',
+        type=str,
+        action='store',
+        default=None,
+        help='path to a file where results will be written'
+    )
+    parser.add_argument(
+        '--timestamp',
+        dest='timestamp',
+        default=False,
+        action='store_true',
+        help='''print timestamp instead of memory measurement for
+        decorated functions'''
+    )
+    parser.add_argument(
+        '--backend',
+        dest='backend',
+        type=str,
+        action='store',
+        choices=['tracemalloc', 'psutil', 'posix'],
+        default='psutil',
+        help='backend using for getting memory info '
+             '(one of the {tracemalloc, psutil, posix})'
+    )
+    parser.add_argument(
+        ""program"",
+        nargs=REMAINDER,
+        help='python script or module followed by '
+             'command line arguments to run'
+    )
+    args = parser.parse_args()
+
+    if len(args.program) == 0:
+        print(""A program to run must be provided. Use -h for help"")
+        sys.exit(1)
+
+    target = args.program[0]
+    script_args = args.program[1:]
+
+    _backend = choose_backend(args.backend)
+    if args.timestamp:
+        prof = TimeStamper(_backend)
+    else:
+        prof = LineProfiler(max_mem=args.max_mem, backend=_backend)
+
+    try:
+        if args.program[0].endswith('.py'):
+            script_filename = _find_script(args.program[0])
+            exec_with_profiler(
+                script_filename, prof, args.backend, script_args
+            )
+        else:
+            run_module_with_profiler(target, prof, args.backend, script_args)
+    finally:
+        if args.out_filename is not None:
+            out_file = open(args.out_filename, ""a"")
+        else:
+            out_file = sys.stdout
+
+        if args.timestamp:
+            prof.show_results(stream=out_file)
+        else:
+            show_results(prof, precision=args.precision, stream=out_file)
",True,memory_profiler/__main__.py,True
"@@ -0,0 +1,69 @@
+import inspect
+import os.path
+
+from .utils import get_memory
+
+
+class CodeMap(dict):
+    def __init__(self, include_children, backend):
+        self.include_children = include_children
+        self._toplevel = []
+        self.backend = backend
+
+    def add(self, code, toplevel_code=None):
+        if code in self:
+            return
+
+        if toplevel_code is None:
+            filename = code.co_filename
+            if filename.endswith(("".pyc"", "".pyo"")):
+                filename = filename[:-1]
+            if not os.path.exists(filename):
+                print('ERROR: Could not find file ' + filename)
+                if filename.startswith((""ipython-input"", ""<ipython-input"")):
+                    print(
+                        ""NOTE: %mprun can only be used on functions defined in""
+                        "" physical files, and not in the IPython environment."")
+                return
+
+            toplevel_code = code
+            (sub_lines, start_line) = inspect.getsourcelines(code)
+            linenos = range(start_line,
+                            start_line + len(sub_lines))
+            self._toplevel.append((filename, code, linenos))
+            self[code] = {}
+        else:
+            self[code] = self[toplevel_code]
+
+        for subcode in filter(inspect.iscode, code.co_consts):
+            self.add(subcode, toplevel_code=toplevel_code)
+
+    def trace(self, code, lineno, prev_lineno):
+        memory = get_memory(
+            -1,
+            self.backend,
+            include_children=self.include_children,
+            filename=code.co_filename
+        )
+        prev_value = self[code].get(lineno, None)
+        previous_memory = prev_value[1] if prev_value else 0
+        previous_inc = prev_value[0] if prev_value else 0
+
+        prev_line_value = (
+            self[code].get(prev_lineno, None)
+            if prev_lineno else None
+        )
+        prev_line_memory = prev_line_value[1] if prev_line_value else 0
+        self[code][lineno] = (
+            max(previous_inc, memory-prev_line_memory),
+            max(memory, previous_memory)
+        )
+
+    def items(self):
+        """"""Iterate on the toplevel code blocks.""""""
+        for (filename, code, linenos) in self._toplevel:
+            measures = self[code]
+            if not measures:
+                continue  # skip if no measurement
+            line_iterator = ((line, measures.get(line)) for line in linenos)
+            yield (filename, line_iterator)
","@@ -0,0 +1,69 @@
+import inspect
+import os.path
+
+from .utils import get_memory
+
+
+class CodeMap(dict):
+    def __init__(self, include_children, backend):
+        self.include_children = include_children
+        self._toplevel = []
+        self.backend = backend
+
+    def add(self, code, toplevel_code=None):
+        if code in self:
+            return
+
+        if toplevel_code is None:
+            filename = code.co_filename
+            if filename.endswith(("".pyc"", "".pyo"")):
+                filename = filename[:-1]
+            if not os.path.exists(filename):
+                print('ERROR: Could not find file ' + filename)
+                if filename.startswith((""ipython-input"", ""<ipython-input"")):
+                    print(
+                        ""NOTE: %mprun can only be used on functions defined in""
+                        "" physical files, and not in the IPython environment."")
+                return
+
+            toplevel_code = code
+            (sub_lines, start_line) = inspect.getsourcelines(code)
+            linenos = range(start_line,
+                            start_line + len(sub_lines))
+            self._toplevel.append((filename, code, linenos))
+            self[code] = {}
+        else:
+            self[code] = self[toplevel_code]
+
+        for subcode in filter(inspect.iscode, code.co_consts):
+            self.add(subcode, toplevel_code=toplevel_code)
+
+    def trace(self, code, lineno, prev_lineno):
+        memory = get_memory(
+            -1,
+            self.backend,
+            include_children=self.include_children,
+            filename=code.co_filename
+        )
+        prev_value = self[code].get(lineno, None)
+        previous_memory = prev_value[1] if prev_value else 0
+        previous_inc = prev_value[0] if prev_value else 0
+
+        prev_line_value = (
+            self[code].get(prev_lineno, None)
+            if prev_lineno else None
+        )
+        prev_line_memory = prev_line_value[1] if prev_line_value else 0
+        self[code][lineno] = (
+            max(previous_inc, memory-prev_line_memory),
+            max(memory, previous_memory)
+        )
+
+    def items(self):
+        """"""Iterate on the toplevel code blocks.""""""
+        for (filename, code, linenos) in self._toplevel:
+            measures = self[code]
+            if not measures:
+                continue  # skip if no measurement
+            line_iterator = ((line, measures.get(line)) for line in linenos)
+            yield (filename, line_iterator)
",True,memory_profiler/code_map.py,True
"@@ -0,0 +1,13 @@
+import sys
+
+
+PY2 = sys.version_info[0] == 2
+
+try:
+    import tracemalloc  # noqa
+except ImportError:
+    HAS_TRACEMALLOC = False
+else:
+    HAS_TRACEMALLOC = True
+
+TWO_20 = float(2 ** 20)
","@@ -0,0 +1,13 @@
+import sys
+
+
+PY2 = sys.version_info[0] == 2
+
+try:
+    import tracemalloc  # noqa
+except ImportError:
+    HAS_TRACEMALLOC = False
+else:
+    HAS_TRACEMALLOC = True
+
+TWO_20 = float(2 ** 20)
",True,memory_profiler/common.py,True
"@@ -0,0 +1,160 @@
+import pdb
+import sys
+import warnings
+from functools import wraps
+
+from .code_map import CodeMap
+from .utils import choose_backend, get_memory, show_results
+
+
+class LineProfiler(object):
+    """""" A profiler that records the amount of memory for each line """"""
+
+    def __init__(self, **kw):
+        include_children = kw.get('include_children', False)
+        backend = kw.get('backend', 'psutil')
+        self.code_map = CodeMap(
+            include_children=include_children, backend=backend)
+        self.enable_count = 0
+        self.max_mem = kw.get('max_mem', None)
+        self.prevlines = []
+        self.backend = choose_backend(kw.get('backend', None))
+        self.prev_lineno = None
+
+    def __call__(self, func=None, precision=1):
+        if func is not None:
+            self.add_function(func)
+            f = self.wrap_function(func)
+            f.__module__ = func.__module__
+            f.__name__ = func.__name__
+            f.__doc__ = func.__doc__
+            f.__dict__.update(getattr(func, '__dict__', {}))
+            return f
+        else:
+            def inner_partial(f):
+                return self.__call__(f, precision=precision)
+
+            return inner_partial
+
+    def add_function(self, func):
+        """""" Record line profiling information for the given Python function.
+        """"""
+        try:
+            # func_code does not exist in Python3
+            code = func.__code__
+        except AttributeError:
+            warnings.warn(""Could not extract a code object for the object %r""
+                          % func)
+        else:
+            self.code_map.add(code)
+
+    def wrap_function(self, func):
+        """""" Wrap a function to profile it.
+        """"""
+
+        def f(*args, **kwds):
+            self.enable_by_count()
+            try:
+                return func(*args, **kwds)
+            finally:
+                self.disable_by_count()
+
+        return f
+
+    def runctx(self, cmd, globals, locals):
+        """""" Profile a single executable statement in the given namespaces.
+        """"""
+        self.enable_by_count()
+        try:
+            exec(cmd, globals, locals)
+        finally:
+            self.disable_by_count()
+        return self
+
+    def enable_by_count(self):
+        """""" Enable the profiler if it hasn't been enabled before.
+        """"""
+        if self.enable_count == 0:
+            self.enable()
+        self.enable_count += 1
+
+    def disable_by_count(self):
+        """""" Disable the profiler if the number of disable requests matches the
+        number of enable requests.
+        """"""
+        if self.enable_count > 0:
+            self.enable_count -= 1
+            if self.enable_count == 0:
+                self.disable()
+
+    def trace_memory_usage(self, frame, event, arg):
+        """"""Callback for sys.settrace""""""
+        if frame.f_code in self.code_map:
+            if event == 'call':
+                # ""call"" event just saves the lineno but not the memory
+                self.prevlines.append(frame.f_lineno)
+            elif event == 'line':
+                # trace needs current line and previous line
+                self.code_map.trace(frame.f_code, self.prevlines[-1], self.prev_lineno)
+                # saving previous line
+                self.prev_lineno = self.prevlines[-1]
+                self.prevlines[-1] = frame.f_lineno
+            elif event == 'return':
+                lineno = self.prevlines.pop()
+                self.code_map.trace(frame.f_code, lineno, self.prev_lineno)
+                self.prev_lineno = lineno
+
+        if self._original_trace_function is not None:
+            self._original_trace_function(frame, event, arg)
+
+        return self.trace_memory_usage
+
+    def trace_max_mem(self, frame, event, arg):
+        # run into PDB as soon as memory is higher than MAX_MEM
+        if event in ('line', 'return') and frame.f_code in self.code_map:
+            c = get_memory(-1, self.backend, filename=frame.f_code.co_filename)
+            if c >= self.max_mem:
+                t = ('Current memory {0:.2f} MiB exceeded the '
+                     'maximum of {1:.2f} MiB\n'.format(c, self.max_mem))
+                sys.stdout.write(t)
+                sys.stdout.write('Stepping into the debugger \n')
+                frame.f_lineno -= 2
+                p = pdb.Pdb()
+                p.quitting = False
+                p.stopframe = frame
+                p.returnframe = None
+                p.stoplineno = frame.f_lineno - 3
+                p.botframe = None
+                return p.trace_dispatch
+
+        if self._original_trace_function is not None:
+            (self._original_trace_function)(frame, event, arg)
+
+        return self.trace_max_mem
+
+    def __enter__(self):
+        self.enable_by_count()
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        self.disable_by_count()
+
+    def enable(self):
+        self._original_trace_function = sys.gettrace()
+        if self.max_mem is not None:
+            sys.settrace(self.trace_max_mem)
+        else:
+            sys.settrace(self.trace_memory_usage)
+
+    def disable(self):
+        sys.settrace(self._original_trace_function)
+
+
+def get_profile_wrapper(func, precision, backend, stream):
+    @wraps(func)
+    def wrapper(*args, **kwargs):
+        prof = LineProfiler(backend=backend)
+        val = prof(func)(*args, **kwargs)
+        show_results(prof, stream=stream, precision=precision)
+        return val
+
+    return wrapper
","@@ -0,0 +1,160 @@
+import pdb
+import sys
+import warnings
+from functools import wraps
+
+from .code_map import CodeMap
+from .utils import choose_backend, get_memory, show_results
+
+
+class LineProfiler(object):
+    """""" A profiler that records the amount of memory for each line """"""
+
+    def __init__(self, **kw):
+        include_children = kw.get('include_children', False)
+        backend = kw.get('backend', 'psutil')
+        self.code_map = CodeMap(
+            include_children=include_children, backend=backend)
+        self.enable_count = 0
+        self.max_mem = kw.get('max_mem', None)
+        self.prevlines = []
+        self.backend = choose_backend(kw.get('backend', None))
+        self.prev_lineno = None
+
+    def __call__(self, func=None, precision=1):
+        if func is not None:
+            self.add_function(func)
+            f = self.wrap_function(func)
+            f.__module__ = func.__module__
+            f.__name__ = func.__name__
+            f.__doc__ = func.__doc__
+            f.__dict__.update(getattr(func, '__dict__', {}))
+            return f
+        else:
+            def inner_partial(f):
+                return self.__call__(f, precision=precision)
+
+            return inner_partial
+
+    def add_function(self, func):
+        """""" Record line profiling information for the given Python function.
+        """"""
+        try:
+            # func_code does not exist in Python3
+            code = func.__code__
+        except AttributeError:
+            warnings.warn(""Could not extract a code object for the object %r""
+                          % func)
+        else:
+            self.code_map.add(code)
+
+    def wrap_function(self, func):
+        """""" Wrap a function to profile it.
+        """"""
+
+        def f(*args, **kwds):
+            self.enable_by_count()
+            try:
+                return func(*args, **kwds)
+            finally:
+                self.disable_by_count()
+
+        return f
+
+    def runctx(self, cmd, globals, locals):
+        """""" Profile a single executable statement in the given namespaces.
+        """"""
+        self.enable_by_count()
+        try:
+            exec(cmd, globals, locals)
+        finally:
+            self.disable_by_count()
+        return self
+
+    def enable_by_count(self):
+        """""" Enable the profiler if it hasn't been enabled before.
+        """"""
+        if self.enable_count == 0:
+            self.enable()
+        self.enable_count += 1
+
+    def disable_by_count(self):
+        """""" Disable the profiler if the number of disable requests matches the
+        number of enable requests.
+        """"""
+        if self.enable_count > 0:
+            self.enable_count -= 1
+            if self.enable_count == 0:
+                self.disable()
+
+    def trace_memory_usage(self, frame, event, arg):
+        """"""Callback for sys.settrace""""""
+        if frame.f_code in self.code_map:
+            if event == 'call':
+                # ""call"" event just saves the lineno but not the memory
+                self.prevlines.append(frame.f_lineno)
+            elif event == 'line':
+                # trace needs current line and previous line
+                self.code_map.trace(frame.f_code, self.prevlines[-1], self.prev_lineno)
+                # saving previous line
+                self.prev_lineno = self.prevlines[-1]
+                self.prevlines[-1] = frame.f_lineno
+            elif event == 'return':
+                lineno = self.prevlines.pop()
+                self.code_map.trace(frame.f_code, lineno, self.prev_lineno)
+                self.prev_lineno = lineno
+
+        if self._original_trace_function is not None:
+            self._original_trace_function(frame, event, arg)
+
+        return self.trace_memory_usage
+
+    def trace_max_mem(self, frame, event, arg):
+        # run into PDB as soon as memory is higher than MAX_MEM
+        if event in ('line', 'return') and frame.f_code in self.code_map:
+            c = get_memory(-1, self.backend, filename=frame.f_code.co_filename)
+            if c >= self.max_mem:
+                t = ('Current memory {0:.2f} MiB exceeded the '
+                     'maximum of {1:.2f} MiB\n'.format(c, self.max_mem))
+                sys.stdout.write(t)
+                sys.stdout.write('Stepping into the debugger \n')
+                frame.f_lineno -= 2
+                p = pdb.Pdb()
+                p.quitting = False
+                p.stopframe = frame
+                p.returnframe = None
+                p.stoplineno = frame.f_lineno - 3
+                p.botframe = None
+                return p.trace_dispatch
+
+        if self._original_trace_function is not None:
+            (self._original_trace_function)(frame, event, arg)
+
+        return self.trace_max_mem
+
+    def __enter__(self):
+        self.enable_by_count()
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        self.disable_by_count()
+
+    def enable(self):
+        self._original_trace_function = sys.gettrace()
+        if self.max_mem is not None:
+            sys.settrace(self.trace_max_mem)
+        else:
+            sys.settrace(self.trace_memory_usage)
+
+    def disable(self):
+        sys.settrace(self._original_trace_function)
+
+
+def get_profile_wrapper(func, precision, backend, stream):
+    @wraps(func)
+    def wrapper(*args, **kwargs):
+        prof = LineProfiler(backend=backend)
+        val = prof(func)(*args, **kwargs)
+        show_results(prof, stream=stream, precision=precision)
+        return val
+
+    return wrapper
",True,memory_profiler/line_profiler.py,True
"@@ -0,0 +1,183 @@
+import linecache
+import os
+import sys
+import warnings
+import subprocess
+import time
+
+import psutil
+
+from .common import HAS_TRACEMALLOC, PY2, TWO_20
+
+if HAS_TRACEMALLOC:
+    import tracemalloc
+
+
+if PY2:
+    def to_str(x):
+        return x
+
+    from future_builtins import filter
+else:
+    def to_str(x):
+        return str(x)
+
+
+def show_results(prof, stream=None, precision=1):
+    if stream is None:
+        stream = sys.stdout
+    template = '{0:>6} {1:>12} {2:>12}   {3:<}'
+
+    for (filename, lines) in prof.code_map.items():
+        header = template.format('Line #', 'Mem usage', 'Increment',
+                                 'Line Contents')
+
+        stream.write(u'Filename: ' + filename + '\n\n')
+        stream.write(header + u'\n')
+        stream.write(u'=' * len(header) + '\n')
+
+        all_lines = linecache.getlines(filename)
+
+        float_format = u'{0}.{1}f'.format(precision + 4, precision)
+        template_mem = u'{0:' + float_format + '} MiB'
+        for (lineno, mem) in lines:
+            if mem:
+                inc = mem[0]
+                mem = mem[1]
+                mem = template_mem.format(mem)
+                inc = template_mem.format(inc)
+            else:
+                mem = u''
+                inc = u''
+            tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
+            stream.write(to_str(tmp))
+        stream.write(u'\n\n')
+
+
+def choose_backend(new_backend=None):
+    """"""
+    Function that tries to setup backend, chosen by user, and if failed,
+    setup one of the allowable backends
+    """"""
+
+    _backend = 'no_backend'
+    all_backends = [
+        ('psutil', True),
+        ('posix', os.name == 'posix'),
+        ('tracemalloc', HAS_TRACEMALLOC),
+    ]
+    backends_indices = dict((b[0], i) for i, b in enumerate(all_backends))
+
+    if new_backend is not None:
+        all_backends.insert(0, all_backends.pop(backends_indices[new_backend]))
+
+    for n_backend, is_available in all_backends:
+        if is_available:
+            _backend = n_backend
+            break
+    if _backend != new_backend and new_backend is not None:
+        warnings.warn('{0} can not be used, {1} used instead'.format(
+            new_backend, _backend))
+    return _backend
+
+
+def get_child_memory(process, meminfo_attr=None):
+    """"""
+    Returns a generator that yields memory for all child processes.
+    """"""
+    # Convert a pid to a process
+    if isinstance(process, int):
+        if process == -1: process = os.getpid()
+        process = psutil.Process(process)
+
+    if not meminfo_attr:
+        # Use the psutil 2.0 attr if the older version isn't passed in.
+        meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
+
+    # Select the psutil function get the children similar to how we selected
+    # the memory_info attr (a change from excepting the AttributeError).
+    children_attr = 'children' if hasattr(process, 'children') else 'get_children'
+
+    # Loop over the child processes and yield their memory
+    try:
+        for child in getattr(process, children_attr)(recursive=True):
+            yield getattr(child, meminfo_attr)()[0] / TWO_20
+    except (psutil.NoSuchProcess, psutil.AccessDenied):
+        # https://github.com/fabianp/memory_profiler/issues/71
+        yield 0.0
+
+
+def get_memory(pid, backend, timestamps=False, include_children=False, filename=None):
+    # .. low function to get memory consumption ..
+    if pid == -1:
+        pid = os.getpid()
+
+    def tracemalloc_tool():
+        # .. cross-platform but but requires Python 3.4 or higher ..
+        stat = next(filter(lambda item: str(item).startswith(filename),
+                           tracemalloc.take_snapshot().statistics('filename')))
+        mem = stat.size / TWO_20
+        if timestamps:
+            return mem, time.time()
+        else:
+            return mem
+
+    def ps_util_tool():
+        # .. cross-platform but but requires psutil ..
+        process = psutil.Process(pid)
+        try:
+            # avoid using get_memory_info since it does not exists
+            # in psutil > 2.0 and accessing it will cause exception.
+            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') \
+                else 'get_memory_info'
+            mem = getattr(process, meminfo_attr)()[0] / TWO_20
+            if include_children:
+                mem += sum(get_child_memory(process, meminfo_attr))
+            if timestamps:
+                return mem, time.time()
+            else:
+                return mem
+        except psutil.AccessDenied:
+            pass
+            # continue and try to get this from ps
+
+    def posix_tool():
+        # .. scary stuff ..
+        if include_children:
+            raise NotImplementedError((
+                ""The psutil module is required to monitor the ""
+                ""memory usage of child processes.""
+            ))
+
+        warnings.warn(""psutil module not found. memory_profiler will be slow"")
+        # ..
+        # .. memory usage in MiB ..
+        # .. this should work on both Mac and Linux ..
+        # .. subprocess.check_output appeared in 2.7, using Popen ..
+        # .. for backwards compatibility ..
+        out = subprocess.Popen(['ps', 'v', '-p', str(pid)],
+                               stdout=subprocess.PIPE
+                               ).communicate()[0].split(b'\n')
+        try:
+            vsz_index = out[0].split().index(b'RSS')
+            mem = float(out[1].split()[vsz_index]) / 1024
+            if timestamps:
+                return mem, time.time()
+            else:
+                return mem
+        except:
+            if timestamps:
+                return -1, time.time()
+            else:
+                return -1
+
+    if backend == 'tracemalloc' and \
+            (filename is None or filename == '<unknown>'):
+        raise RuntimeError(
+            'There is no access to source file of the profiled function'
+        )
+
+    tools = {'tracemalloc': tracemalloc_tool,
+             'psutil': ps_util_tool,
+             'posix': posix_tool}
+    return tools[backend]()
","@@ -0,0 +1,183 @@
+import linecache
+import os
+import sys
+import warnings
+import subprocess
+import time
+
+import psutil
+
+from .common import HAS_TRACEMALLOC, PY2, TWO_20
+
+if HAS_TRACEMALLOC:
+    import tracemalloc
+
+
+if PY2:
+    def to_str(x):
+        return x
+
+    from future_builtins import filter
+else:
+    def to_str(x):
+        return str(x)
+
+
+def show_results(prof, stream=None, precision=1):
+    if stream is None:
+        stream = sys.stdout
+    template = '{0:>6} {1:>12} {2:>12}   {3:<}'
+
+    for (filename, lines) in prof.code_map.items():
+        header = template.format('Line #', 'Mem usage', 'Increment',
+                                 'Line Contents')
+
+        stream.write(u'Filename: ' + filename + '\n\n')
+        stream.write(header + u'\n')
+        stream.write(u'=' * len(header) + '\n')
+
+        all_lines = linecache.getlines(filename)
+
+        float_format = u'{0}.{1}f'.format(precision + 4, precision)
+        template_mem = u'{0:' + float_format + '} MiB'
+        for (lineno, mem) in lines:
+            if mem:
+                inc = mem[0]
+                mem = mem[1]
+                mem = template_mem.format(mem)
+                inc = template_mem.format(inc)
+            else:
+                mem = u''
+                inc = u''
+            tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
+            stream.write(to_str(tmp))
+        stream.write(u'\n\n')
+
+
+def choose_backend(new_backend=None):
+    """"""
+    Function that tries to setup backend, chosen by user, and if failed,
+    setup one of the allowable backends
+    """"""
+
+    _backend = 'no_backend'
+    all_backends = [
+        ('psutil', True),
+        ('posix', os.name == 'posix'),
+        ('tracemalloc', HAS_TRACEMALLOC),
+    ]
+    backends_indices = dict((b[0], i) for i, b in enumerate(all_backends))
+
+    if new_backend is not None:
+        all_backends.insert(0, all_backends.pop(backends_indices[new_backend]))
+
+    for n_backend, is_available in all_backends:
+        if is_available:
+            _backend = n_backend
+            break
+    if _backend != new_backend and new_backend is not None:
+        warnings.warn('{0} can not be used, {1} used instead'.format(
+            new_backend, _backend))
+    return _backend
+
+
+def get_child_memory(process, meminfo_attr=None):
+    """"""
+    Returns a generator that yields memory for all child processes.
+    """"""
+    # Convert a pid to a process
+    if isinstance(process, int):
+        if process == -1: process = os.getpid()
+        process = psutil.Process(process)
+
+    if not meminfo_attr:
+        # Use the psutil 2.0 attr if the older version isn't passed in.
+        meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
+
+    # Select the psutil function get the children similar to how we selected
+    # the memory_info attr (a change from excepting the AttributeError).
+    children_attr = 'children' if hasattr(process, 'children') else 'get_children'
+
+    # Loop over the child processes and yield their memory
+    try:
+        for child in getattr(process, children_attr)(recursive=True):
+            yield getattr(child, meminfo_attr)()[0] / TWO_20
+    except (psutil.NoSuchProcess, psutil.AccessDenied):
+        # https://github.com/fabianp/memory_profiler/issues/71
+        yield 0.0
+
+
+def get_memory(pid, backend, timestamps=False, include_children=False, filename=None):
+    # .. low function to get memory consumption ..
+    if pid == -1:
+        pid = os.getpid()
+
+    def tracemalloc_tool():
+        # .. cross-platform but but requires Python 3.4 or higher ..
+        stat = next(filter(lambda item: str(item).startswith(filename),
+                           tracemalloc.take_snapshot().statistics('filename')))
+        mem = stat.size / TWO_20
+        if timestamps:
+            return mem, time.time()
+        else:
+            return mem
+
+    def ps_util_tool():
+        # .. cross-platform but but requires psutil ..
+        process = psutil.Process(pid)
+        try:
+            # avoid using get_memory_info since it does not exists
+            # in psutil > 2.0 and accessing it will cause exception.
+            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') \
+                else 'get_memory_info'
+            mem = getattr(process, meminfo_attr)()[0] / TWO_20
+            if include_children:
+                mem += sum(get_child_memory(process, meminfo_attr))
+            if timestamps:
+                return mem, time.time()
+            else:
+                return mem
+        except psutil.AccessDenied:
+            pass
+            # continue and try to get this from ps
+
+    def posix_tool():
+        # .. scary stuff ..
+        if include_children:
+            raise NotImplementedError((
+                ""The psutil module is required to monitor the ""
+                ""memory usage of child processes.""
+            ))
+
+        warnings.warn(""psutil module not found. memory_profiler will be slow"")
+        # ..
+        # .. memory usage in MiB ..
+        # .. this should work on both Mac and Linux ..
+        # .. subprocess.check_output appeared in 2.7, using Popen ..
+        # .. for backwards compatibility ..
+        out = subprocess.Popen(['ps', 'v', '-p', str(pid)],
+                               stdout=subprocess.PIPE
+                               ).communicate()[0].split(b'\n')
+        try:
+            vsz_index = out[0].split().index(b'RSS')
+            mem = float(out[1].split()[vsz_index]) / 1024
+            if timestamps:
+                return mem, time.time()
+            else:
+                return mem
+        except:
+            if timestamps:
+                return -1, time.time()
+            else:
+                return -1
+
+    if backend == 'tracemalloc' and \
+            (filename is None or filename == '<unknown>'):
+        raise RuntimeError(
+            'There is no access to source file of the profiled function'
+        )
+
+    tools = {'tracemalloc': tracemalloc_tool,
+             'psutil': ps_util_tool,
+             'posix': posix_tool}
+    return tools[backend]()
",True,memory_profiler/utils.py,True
"@@ -1,8 +1,7 @@
 import os
 import io
 import re
-import sys
-from setuptools import setup
+from setuptools import find_packages, setup
 
 
 # https://packaging.python.org/guides/single-sourcing-package-version/
@@ -22,14 +21,6 @@ def find_version(*file_paths):
         return version_match.group(1)
 
 
-async_modules = []
-if sys.version_info > (3, 3):
-    if sys.version_info < (3, 5):
-        async_modules = ['_aio_34']
-    else:
-        async_modules = ['_aio_35']
-
-
 CLASSIFIERS = """"""\
 Development Status :: 5 - Production/Stable
 Intended Audience :: Science/Research
@@ -53,13 +44,14 @@ setup(
     name='memory_profiler',
     description='A module for monitoring memory usage of a python program',
     long_description=open('README.rst').read(),
-    version=find_version(""memory_profiler.py""),
+    version=find_version(""memory_profiler"", ""__init__.py""),
     author='Fabian Pedregosa',
     author_email='f@bianp.net',
     url='https://github.com/pythonprofilers/memory_profiler',
-    py_modules=['memory_profiler', 'mprof'] + async_modules,
+    py_modules=['mprof'],
+    packages=find_packages(include='memory_profiler'),
     entry_points={
-        'console_scripts' : ['mprof = mprof:main'],
+        'console_scripts': ['mprof = mprof:main'],
     },
     install_requires=['psutil'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
","@@ -1,8 +1,7 @@
 import os
 import io
 import re
-import sys
-from setuptools import setup
+from setuptools import find_packages, setup
 
 
 # https://packaging.python.org/guides/single-sourcing-package-version/
@@ -22,14 +21,6 @@ def find_version(*file_paths):
         return version_match.group(1)
 
 
-async_modules = []
-if sys.version_info > (3, 3):
-    if sys.version_info < (3, 5):
-        async_modules = ['_aio_34']
-    else:
-        async_modules = ['_aio_35']
-
-
 CLASSIFIERS = """"""\
 Development Status :: 5 - Production/Stable
 Intended Audience :: Science/Research
@@ -53,13 +44,14 @@ setup(
     name='memory_profiler',
     description='A module for monitoring memory usage of a python program',
     long_description=open('README.rst').read(),
-    version=find_version(""memory_profiler.py""),
+    version=find_version(""memory_profiler"", ""__init__.py""),
     author='Fabian Pedregosa',
     author_email='f@bianp.net',
     url='https://github.com/pythonprofilers/memory_profiler',
-    py_modules=['memory_profiler', 'mprof'] + async_modules,
+    py_modules=['mprof'],
+    packages=find_packages(include='memory_profiler'),
     entry_points={
-        'console_scripts' : ['mprof = mprof:main'],
+        'console_scripts': ['mprof = mprof:main'],
     },
     install_requires=['psutil'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
",True,setup.py,True
"@@ -1,35 +0,0 @@
-from asyncio import coroutine, iscoroutinefunction
-from contextlib import contextmanager
-from functools import wraps
-
-from memory_profiler import LineProfiler, show_results
-
-
-class CoroLineProfiler(LineProfiler):
-    @contextmanager
-    def count_contextmgr(self):
-        self.enable_by_count()
-        try:
-            yield
-        finally:
-            self.disable_by_count()
-
-    def wrap_function(self, func):
-        if iscoroutinefunction(func):
-            @coroutine
-            def f(*args, **kwargs):
-                with self.count_contextmgr():
-                    yield from func(*args, **kwargs)
-            return f
-        else:
-            return super(CoroLineProfiler, self).wrap_function(func)
-
-
-def _get_coro_wrapper(coro, backend, stream, precision):
-    @wraps(coro)
-    @coroutine
-    def wrapper(*args, **kwargs):
-        prof = CoroLineProfiler(backend=backend)
-        val = yield from prof(coro)(*args, **kwargs)
-        show_results(prof, stream=stream, precision=precision)
-        return val
","@@ -1,35 +0,0 @@
-from asyncio import coroutine, iscoroutinefunction
-from contextlib import contextmanager
-from functools import wraps
-
-from memory_profiler import LineProfiler, show_results
-
-
-class CoroLineProfiler(LineProfiler):
-    @contextmanager
-    def count_contextmgr(self):
-        self.enable_by_count()
-        try:
-            yield
-        finally:
-            self.disable_by_count()
-
-    def wrap_function(self, func):
-        if iscoroutinefunction(func):
-            @coroutine
-            def f(*args, **kwargs):
-                with self.count_contextmgr():
-                    yield from func(*args, **kwargs)
-            return f
-        else:
-            return super(CoroLineProfiler, self).wrap_function(func)
-
-
-def _get_coro_wrapper(coro, backend, stream, precision):
-    @wraps(coro)
-    @coroutine
-    def wrapper(*args, **kwargs):
-        prof = CoroLineProfiler(backend=backend)
-        val = yield from prof(coro)(*args, **kwargs)
-        show_results(prof, stream=stream, precision=precision)
-        return val
",True,,False
"@@ -17,14 +17,19 @@ import traceback
 import warnings
 import contextlib
 
-from .common import PY2, HAS_TRACEMALLOC
+from .common import PY2, PY34, PY35, HAS_TRACEMALLOC
 from .utils import (
     show_results,
     choose_backend,
     get_memory as _get_memory,
     get_child_memory as _get_child_memory,
 )
-from .line_profiler import LineProfiler
+from .line_profiler import LineProfiler, get_profile_wrapper
+
+if PY34:
+    from ._aio_34 import get_profile_wrapper
+elif PY35:
+    from ._aio_35 import get_profile_wrapper
 
 
 if sys.platform == ""win32"":
@@ -758,14 +763,7 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
         if not tracemalloc.is_tracing():
             tracemalloc.start()
     if func is not None:
-        @wraps(func)
-        def wrapper(*args, **kwargs):
-            prof = LineProfiler(backend=backend)
-            val = prof(func)(*args, **kwargs)
-            show_results(prof, stream=stream, precision=precision)
-            return val
-
-        return wrapper
+        return get_profile_wrapper(func, precision, backend, stream)
     else:
         def inner_wrapper(f):
             return profile(f, stream=stream, precision=precision,
","@@ -17,14 +17,19 @@ import traceback
 import warnings
 import contextlib
 
-from .common import PY2, HAS_TRACEMALLOC
+from .common import PY2, PY34, PY35, HAS_TRACEMALLOC
 from .utils import (
     show_results,
     choose_backend,
     get_memory as _get_memory,
     get_child_memory as _get_child_memory,
 )
-from .line_profiler import LineProfiler
+from .line_profiler import LineProfiler, get_profile_wrapper
+
+if PY34:
+    from ._aio_34 import get_profile_wrapper
+elif PY35:
+    from ._aio_35 import get_profile_wrapper
 
 
 if sys.platform == ""win32"":
@@ -758,14 +763,7 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
         if not tracemalloc.is_tracing():
             tracemalloc.start()
     if func is not None:
-        @wraps(func)
-        def wrapper(*args, **kwargs):
-            prof = LineProfiler(backend=backend)
-            val = prof(func)(*args, **kwargs)
-            show_results(prof, stream=stream, precision=precision)
-            return val
-
-        return wrapper
+        return get_profile_wrapper(func, precision, backend, stream)
     else:
         def inner_wrapper(f):
             return profile(f, stream=stream, precision=precision,
",True,memory_profiler/__init__.py,True
"@@ -0,0 +1,35 @@
+from asyncio import coroutine, iscoroutinefunction
+from functools import wraps
+
+from .line_profiler import (
+    get_profile_wrapper as default_profile_wrapper,
+    LineProfiler,
+)
+from .utils import show_results
+
+
+class CoroLineProfiler(LineProfiler):
+    def wrap_function(self, func):
+        if iscoroutinefunction(func):
+            @coroutine
+            def f(*args, **kwargs):
+                with self.count_ctxmgr():
+                    yield from func(*args, **kwargs)
+            return f
+        else:
+            return super().wrap_function(func)
+
+
+def get_profile_wrapper(func, precision, backend, stream):
+    if iscoroutinefunction(func):
+        @wraps(func)
+        @coroutine
+        def wrapper(*args, **kwargs):
+            prof = CoroLineProfiler(backend=backend)
+            val = yield from prof(func)(*args, **kwargs)
+            show_results(prof, stream=stream, precision=precision)
+            return val
+    else:
+        wrapper = default_profile_wrapper(func, precision, backend, stream)
+
+    return wrapper
","@@ -0,0 +1,35 @@
+from asyncio import coroutine, iscoroutinefunction
+from functools import wraps
+
+from .line_profiler import (
+    get_profile_wrapper as default_profile_wrapper,
+    LineProfiler,
+)
+from .utils import show_results
+
+
+class CoroLineProfiler(LineProfiler):
+    def wrap_function(self, func):
+        if iscoroutinefunction(func):
+            @coroutine
+            def f(*args, **kwargs):
+                with self.count_ctxmgr():
+                    yield from func(*args, **kwargs)
+            return f
+        else:
+            return super().wrap_function(func)
+
+
+def get_profile_wrapper(func, precision, backend, stream):
+    if iscoroutinefunction(func):
+        @wraps(func)
+        @coroutine
+        def wrapper(*args, **kwargs):
+            prof = CoroLineProfiler(backend=backend)
+            val = yield from prof(func)(*args, **kwargs)
+            show_results(prof, stream=stream, precision=precision)
+            return val
+    else:
+        wrapper = default_profile_wrapper(func, precision, backend, stream)
+
+    return wrapper
",True,memory_profiler/_aio_34.py,True
"@@ -0,0 +1,33 @@
+from functools import wraps
+from inspect import iscoroutinefunction
+
+from .line_profiler import (
+    get_profile_wrapper as default_profile_wrapper,
+    LineProfiler,
+)
+from .utils import show_results
+
+
+class CoroLineProfiler(LineProfiler):
+    def wrap_function(self, func):
+        if iscoroutinefunction(func):
+            async def f(*args, **kwargs):
+                with self.count_ctxmgr():
+                    return await func(*args, **kwargs)
+            return f
+        else:
+            return super().wrap_function(func)
+
+
+def get_profile_wrapper(func, precision, backend, stream):
+    if iscoroutinefunction(func):
+        @wraps(func)
+        async def wrapper(*args, **kwargs):
+            prof = CoroLineProfiler(backend=backend)
+            val = await prof(func)(*args, **kwargs)
+            show_results(prof, stream=stream, precision=precision)
+            return val
+    else:
+        wrapper = default_profile_wrapper(func, precision, backend, stream)
+
+    return wrapper
","@@ -0,0 +1,33 @@
+from functools import wraps
+from inspect import iscoroutinefunction
+
+from .line_profiler import (
+    get_profile_wrapper as default_profile_wrapper,
+    LineProfiler,
+)
+from .utils import show_results
+
+
+class CoroLineProfiler(LineProfiler):
+    def wrap_function(self, func):
+        if iscoroutinefunction(func):
+            async def f(*args, **kwargs):
+                with self.count_ctxmgr():
+                    return await func(*args, **kwargs)
+            return f
+        else:
+            return super().wrap_function(func)
+
+
+def get_profile_wrapper(func, precision, backend, stream):
+    if iscoroutinefunction(func):
+        @wraps(func)
+        async def wrapper(*args, **kwargs):
+            prof = CoroLineProfiler(backend=backend)
+            val = await prof(func)(*args, **kwargs)
+            show_results(prof, stream=stream, precision=precision)
+            return val
+    else:
+        wrapper = default_profile_wrapper(func, precision, backend, stream)
+
+    return wrapper
",True,memory_profiler/_aio_35.py,True
"@@ -3,6 +3,9 @@ import sys
 
 PY2 = sys.version_info[0] == 2
 
+PY34 = (3, 4) < sys.version_info < (3, 5)
+PY35 = (3, 5) < sys.version_info
+
 try:
     import tracemalloc  # noqa
 except ImportError:
","@@ -3,6 +3,9 @@ import sys
 
 PY2 = sys.version_info[0] == 2
 
+PY34 = (3, 4) < sys.version_info < (3, 5)
+PY35 = (3, 5) < sys.version_info
+
 try:
     import tracemalloc  # noqa
 except ImportError:
",True,memory_profiler/common.py,True
"@@ -49,7 +49,7 @@ setup(
     author_email='f@bianp.net',
     url='https://github.com/pythonprofilers/memory_profiler',
     py_modules=['mprof'],
-    packages=find_packages(include='memory_profiler'),
+    packages=find_packages(include=('memory_profiler',)),
     entry_points={
         'console_scripts': ['mprof = mprof:main'],
     },
","@@ -49,7 +49,7 @@ setup(
     author_email='f@bianp.net',
     url='https://github.com/pythonprofilers/memory_profiler',
     py_modules=['mprof'],
-    packages=find_packages(include='memory_profiler'),
+    packages=find_packages(include=('memory_profiler',)),
     entry_points={
         'console_scripts': ['mprof = mprof:main'],
     },
",True,setup.py,True
"@@ -17,6 +17,7 @@ import traceback
 import warnings
 import contextlib
 
+from .code_map import CodeMap
 from .common import PY2, PY34, PY35, HAS_TRACEMALLOC
 from .utils import (
     show_results,
","@@ -17,6 +17,7 @@ import traceback
 import warnings
 import contextlib
 
+from .code_map import CodeMap
 from .common import PY2, PY34, PY35, HAS_TRACEMALLOC
 from .utils import (
     show_results,
",True,memory_profiler/__init__.py,True
"@@ -1,6 +1,7 @@
 import pdb
 import sys
 import warnings
+from contextlib import contextmanager
 from functools import wraps
 
 from .code_map import CodeMap
@@ -48,27 +49,29 @@ class LineProfiler(object):
         else:
             self.code_map.add(code)
 
+    @contextmanager
+    def count_ctxmgr(self):
+        self.enable_by_count()
+        try:
+            yield
+        finally:
+            self.disable_by_count()
+
     def wrap_function(self, func):
         """""" Wrap a function to profile it.
         """"""
 
         def f(*args, **kwds):
-            self.enable_by_count()
-            try:
+            with self.count_ctxmgr():
                 return func(*args, **kwds)
-            finally:
-                self.disable_by_count()
 
         return f
 
     def runctx(self, cmd, globals, locals):
         """""" Profile a single executable statement in the given namespaces.
         """"""
-        self.enable_by_count()
-        try:
+        with self.count_ctxmgr():
             exec(cmd, globals, locals)
-        finally:
-            self.disable_by_count()
         return self
 
     def enable_by_count(self):
","@@ -1,6 +1,7 @@
 import pdb
 import sys
 import warnings
+from contextlib import contextmanager
 from functools import wraps
 
 from .code_map import CodeMap
@@ -48,27 +49,29 @@ class LineProfiler(object):
         else:
             self.code_map.add(code)
 
+    @contextmanager
+    def count_ctxmgr(self):
+        self.enable_by_count()
+        try:
+            yield
+        finally:
+            self.disable_by_count()
+
     def wrap_function(self, func):
         """""" Wrap a function to profile it.
         """"""
 
         def f(*args, **kwds):
-            self.enable_by_count()
-            try:
+            with self.count_ctxmgr():
                 return func(*args, **kwds)
-            finally:
-                self.disable_by_count()
 
         return f
 
     def runctx(self, cmd, globals, locals):
         """""" Profile a single executable statement in the given namespaces.
         """"""
-        self.enable_by_count()
-        try:
+        with self.count_ctxmgr():
             exec(cmd, globals, locals)
-        finally:
-            self.disable_by_count()
         return self
 
     def enable_by_count(self):
",True,memory_profiler/line_profiler.py,True
"@@ -18,7 +18,7 @@ import warnings
 import contextlib
 
 from .code_map import CodeMap
-from .common import PY2, PY34, PY35, HAS_TRACEMALLOC
+from .common import PY2, PY34, HAS_TRACEMALLOC
 from .utils import (
     show_results,
     choose_backend,
@@ -28,9 +28,7 @@ from .utils import (
 from .line_profiler import LineProfiler, get_profile_wrapper
 
 if PY34:
-    from ._aio_34 import get_profile_wrapper
-elif PY35:
-    from ._aio_35 import get_profile_wrapper
+    from ._async import get_profile_wrapper
 
 
 if sys.platform == ""win32"":
","@@ -18,7 +18,7 @@ import warnings
 import contextlib
 
 from .code_map import CodeMap
-from .common import PY2, PY34, PY35, HAS_TRACEMALLOC
+from .common import PY2, PY34, HAS_TRACEMALLOC
 from .utils import (
     show_results,
     choose_backend,
@@ -28,9 +28,7 @@ from .utils import (
 from .line_profiler import LineProfiler, get_profile_wrapper
 
 if PY34:
-    from ._aio_34 import get_profile_wrapper
-elif PY35:
-    from ._aio_35 import get_profile_wrapper
+    from ._async import get_profile_wrapper
 
 
 if sys.platform == ""win32"":
",True,memory_profiler/__init__.py,True
"@@ -1,33 +0,0 @@
-from functools import wraps
-from inspect import iscoroutinefunction
-
-from .line_profiler import (
-    get_profile_wrapper as default_profile_wrapper,
-    LineProfiler,
-)
-from .utils import show_results
-
-
-class CoroLineProfiler(LineProfiler):
-    def wrap_function(self, func):
-        if iscoroutinefunction(func):
-            async def f(*args, **kwargs):
-                with self.count_ctxmgr():
-                    return await func(*args, **kwargs)
-            return f
-        else:
-            return super().wrap_function(func)
-
-
-def get_profile_wrapper(func, precision, backend, stream):
-    if iscoroutinefunction(func):
-        @wraps(func)
-        async def wrapper(*args, **kwargs):
-            prof = CoroLineProfiler(backend=backend)
-            val = await prof(func)(*args, **kwargs)
-            show_results(prof, stream=stream, precision=precision)
-            return val
-    else:
-        wrapper = default_profile_wrapper(func, precision, backend, stream)
-
-    return wrapper
","@@ -1,33 +0,0 @@
-from functools import wraps
-from inspect import iscoroutinefunction
-
-from .line_profiler import (
-    get_profile_wrapper as default_profile_wrapper,
-    LineProfiler,
-)
-from .utils import show_results
-
-
-class CoroLineProfiler(LineProfiler):
-    def wrap_function(self, func):
-        if iscoroutinefunction(func):
-            async def f(*args, **kwargs):
-                with self.count_ctxmgr():
-                    return await func(*args, **kwargs)
-            return f
-        else:
-            return super().wrap_function(func)
-
-
-def get_profile_wrapper(func, precision, backend, stream):
-    if iscoroutinefunction(func):
-        @wraps(func)
-        async def wrapper(*args, **kwargs):
-            prof = CoroLineProfiler(backend=backend)
-            val = await prof(func)(*args, **kwargs)
-            show_results(prof, stream=stream, precision=precision)
-            return val
-    else:
-        wrapper = default_profile_wrapper(func, precision, backend, stream)
-
-    return wrapper
",True,,False
,,True,memory_profiler/_async.py,True
"@@ -3,8 +3,7 @@ import sys
 
 PY2 = sys.version_info[0] == 2
 
-PY34 = (3, 4) < sys.version_info < (3, 5)
-PY35 = (3, 5) < sys.version_info
+PY34 = (3, 4) < sys.version_info
 
 try:
     import tracemalloc  # noqa
","@@ -3,8 +3,7 @@ import sys
 
 PY2 = sys.version_info[0] == 2
 
-PY34 = (3, 4) < sys.version_info < (3, 5)
-PY35 = (3, 5) < sys.version_info
+PY34 = (3, 4) < sys.version_info
 
 try:
     import tracemalloc  # noqa
",True,memory_profiler/common.py,True
"@@ -1,6 +1,8 @@
 PYTHON ?= python
+PY_34 ?= $(shell ! python -c \
+		 'import sys; print((3, 4) < sys.version_info)')
 
-.PHONY: test
+.PHONY: test develop
 
 test:
 	$(PYTHON) -m memory_profiler test/test_func.py
@@ -18,6 +20,9 @@ test:
 	$(PYTHON) test/test_exception.py
 	$(PYTHON) test/test_exit_code.py
 	$(PYTHON) test/test_mprof.py
+	if [ $(PY_34) = True ]; then \
+		$(PYTHON) test/test_aio_34.py; \
+	fi
 
 develop:
 	pip install -e .
","@@ -1,6 +1,8 @@
 PYTHON ?= python
+PY_34 ?= $(shell ! python -c \
+		 'import sys; print((3, 4) < sys.version_info)')
 
-.PHONY: test
+.PHONY: test develop
 
 test:
 	$(PYTHON) -m memory_profiler test/test_func.py
@@ -18,6 +20,9 @@ test:
 	$(PYTHON) test/test_exception.py
 	$(PYTHON) test/test_exit_code.py
 	$(PYTHON) test/test_mprof.py
+	if [ $(PY_34) = True ]; then \
+		$(PYTHON) test/test_aio_34.py; \
+	fi
 
 develop:
 	pip install -e .
",True,Makefile,False
"@@ -0,0 +1,18 @@
+import asyncio
+
+from memory_profiler import profile
+
+
+@profile
+@asyncio.coroutine
+def my_func():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    print('kek')
+    yield from asyncio.sleep(1e-2)
+    del b
+
+
+if __name__ == '__main__':
+    loop = asyncio.get_event_loop()
+    loop.run_until_complete(my_func())
","@@ -0,0 +1,18 @@
+import asyncio
+
+from memory_profiler import profile
+
+
+@profile
+@asyncio.coroutine
+def my_func():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    print('kek')
+    yield from asyncio.sleep(1e-2)
+    del b
+
+
+if __name__ == '__main__':
+    loop = asyncio.get_event_loop()
+    loop.run_until_complete(my_func())
",True,test/test_async.py,True
"@@ -21,7 +21,7 @@ test:
 	$(PYTHON) test/test_exit_code.py
 	$(PYTHON) test/test_mprof.py
 	if [ $(PY_34) = True ]; then \
-		$(PYTHON) test/test_aio_34.py; \
+		$(PYTHON) test/test_async.py; \
 	fi
 
 develop:
","@@ -21,7 +21,7 @@ test:
 	$(PYTHON) test/test_exit_code.py
 	$(PYTHON) test/test_mprof.py
 	if [ $(PY_34) = True ]; then \
-		$(PYTHON) test/test_aio_34.py; \
+		$(PYTHON) test/test_async.py; \
 	fi
 
 develop:
",True,Makefile,False
"@@ -1052,7 +1052,7 @@ class MemoryProfilerMagics(Magics):
                                timeout=timeout, interval=interval,
                                max_usage=True,
                                include_children=include_children)
-            mem_usage.append(tmp[0])
+            mem_usage.append(tmp)
 
         result = MemitResult(mem_usage, baseline, repeat, timeout, interval,
                              include_children)
","@@ -1052,7 +1052,7 @@ class MemoryProfilerMagics(Magics):
                                timeout=timeout, interval=interval,
                                max_usage=True,
                                include_children=include_children)
-            mem_usage.append(tmp[0])
+            mem_usage.append(tmp)
 
         result = MemitResult(mem_usage, baseline, repeat, timeout, interval,
                              include_children)
",True,memory_profiler.py,True
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.56.0'
+__version__ = '0.57.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.56.0'
+__version__ = '0.57.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -419,9 +419,9 @@ Send issues, proposals, etc. to `github's issue tracker
 <https://github.com/pythonprofilers/memory_profiler/issues>`_ .
 
 If you've got questions regarding development, you can email me
-directly at fabian@fseoane.net
+directly at f@bianp.net
 
-.. image:: http://fseoane.net/static/tux_memory_small.png
+.. image:: http://fa.bianp.net/static/tux_memory_small.png
 
 
 =============
","@@ -419,9 +419,9 @@ Send issues, proposals, etc. to `github's issue tracker
 <https://github.com/pythonprofilers/memory_profiler/issues>`_ .
 
 If you've got questions regarding development, you can email me
-directly at fabian@fseoane.net
+directly at f@bianp.net
 
-.. image:: http://fseoane.net/static/tux_memory_small.png
+.. image:: http://fa.bianp.net/static/tux_memory_small.png
 
 
 =============
",True,README.rst,False
"@@ -8,7 +8,6 @@ from memory_profiler import profile
 def my_func():
     a = [1] * (10 ** 6)
     b = [2] * (2 * 10 ** 7)
-    print('kek')
     yield from asyncio.sleep(1e-2)
     del b
 
","@@ -8,7 +8,6 @@ from memory_profiler import profile
 def my_func():
     a = [1] * (10 ** 6)
     b = [2] * (2 * 10 ** 7)
-    print('kek')
     yield from asyncio.sleep(1e-2)
     del b
 
",True,test/test_async.py,True
"@@ -214,6 +214,9 @@ You can also hide the function timestamps using the ``n`` flag, such as
 
     mprof plot -n
 
+Trend lines and its numeric slope can be plotted using the ``s`` flag, such as
+
+    mprof plot -s
 
 Setting debugger breakpoints
 =============================
","@@ -214,6 +214,9 @@ You can also hide the function timestamps using the ``n`` flag, such as
 
     mprof plot -n
 
+Trend lines and its numeric slope can be plotted using the ``s`` flag, such as
+
+    mprof plot -s
 
 Setting debugger breakpoints
 =============================
",True,README.rst,False
"Binary files /dev/null and b/images/trend_slope.png differ
","Binary files /dev/null and b/images/trend_slope.png differ
",True,images/trend_slope.png,False
"@@ -402,13 +402,28 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
 
     all_colors = (""c"", ""y"", ""g"", ""r"", ""b"")
     mem_line_colors = (""k"", ""b"", ""r"", ""g"", ""c"", ""y"", ""m"")
+
+    show_trend_slope = options is not None and hasattr(options, 'slope') and options.slope is True
+
     mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
                                    time.localtime(global_start)) \
                      + "".{0:03d}"".format(int(round(math.modf(global_start)[0] * 1000)))
 
+    mem_trend = None
+    if show_trend_slope:
+        # Compute trend line
+        mem_slope = np.polyfit(t, mem, 1)
+        mem_trend = np.poly1d(mem_slope)
+        # Append slope to label
+        mem_line_label = mem_line_label + "" slope {0:.5f}"".format(mem_slope[0])
+
     pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
             label=mem_line_label)
 
+    if show_trend_slope:
+        # Plot the trend line
+        pl.plot(t, mem_trend(mem), ""--"", linewidth=0.5, color=""#00e3d8"")
+
     bottom, top = pl.ylim()
     bottom += 0.001
     top -= 0.001
@@ -422,9 +437,21 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
             cts  = np.asarray([item[1] for item in data]) - global_start
             cmem = np.asarray([item[0] for item in data])
 
+            cmem_trend = None
+            child_mem_trend_label = """"
+            if show_trend_slope:
+                # Compute trend line
+                child_mem_slope = np.polyfit(cts, cmem, 1)
+                cmem_trend = np.poly1d(child_mem_slope)
+                child_mem_trend_label = "" slope {0:.5f}"".format(child_mem_slope[0])
+
             # Plot the line to the figure
-            pl.plot(cts, cmem, ""+-""  + mem_line_colors[(idx+1) % len(mem_line_colors)],
-                     label=""child {}"".format(proc))
+            pl.plot(cts, cmem, ""+-"" + mem_line_colors[(idx + 1) % len(mem_line_colors)],
+                    label=""child {}{}"".format(proc, child_mem_trend_label))
+
+            if show_trend_slope:
+                # Plot the trend line
+                pl.plot(cts, cmem_trend(cts), ""--"", linewidth=0.5, color=""black"")
 
             # Detect the maximal child memory point
             cmax_mem = cmem.max()
@@ -710,6 +737,8 @@ such file in the current directory.""""""
                         help=""Plot a time-subset of the data. E.g. to plot between 0 and 20.5 seconds: --window 0,20.5"")
     parser.add_argument(""--flame"", ""-f"", dest=""flame_mode"", action=""store_true"",
                         help=""Plot the timestamps as a flame-graph instead of the default brackets"")
+    parser.add_argument(""--slope"", ""-s"", dest=""slope"", action=""store_true"",
+                        help=""Plot a trend line and its numerical slope"")
     parser.add_argument(""--backend"",
                       help=""Specify the Matplotlib backend to use"")
     parser.add_argument(""profiles"", nargs=""*"",
@@ -810,4 +839,4 @@ def main():
     actions[get_action()]()
 
 if __name__ == ""__main__"":
-    main()
+    main()
\ No newline at end of file
","@@ -402,13 +402,28 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
 
     all_colors = (""c"", ""y"", ""g"", ""r"", ""b"")
     mem_line_colors = (""k"", ""b"", ""r"", ""g"", ""c"", ""y"", ""m"")
+
+    show_trend_slope = options is not None and hasattr(options, 'slope') and options.slope is True
+
     mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
                                    time.localtime(global_start)) \
                      + "".{0:03d}"".format(int(round(math.modf(global_start)[0] * 1000)))
 
+    mem_trend = None
+    if show_trend_slope:
+        # Compute trend line
+        mem_slope = np.polyfit(t, mem, 1)
+        mem_trend = np.poly1d(mem_slope)
+        # Append slope to label
+        mem_line_label = mem_line_label + "" slope {0:.5f}"".format(mem_slope[0])
+
     pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
             label=mem_line_label)
 
+    if show_trend_slope:
+        # Plot the trend line
+        pl.plot(t, mem_trend(mem), ""--"", linewidth=0.5, color=""#00e3d8"")
+
     bottom, top = pl.ylim()
     bottom += 0.001
     top -= 0.001
@@ -422,9 +437,21 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
             cts  = np.asarray([item[1] for item in data]) - global_start
             cmem = np.asarray([item[0] for item in data])
 
+            cmem_trend = None
+            child_mem_trend_label = """"
+            if show_trend_slope:
+                # Compute trend line
+                child_mem_slope = np.polyfit(cts, cmem, 1)
+                cmem_trend = np.poly1d(child_mem_slope)
+                child_mem_trend_label = "" slope {0:.5f}"".format(child_mem_slope[0])
+
             # Plot the line to the figure
-            pl.plot(cts, cmem, ""+-""  + mem_line_colors[(idx+1) % len(mem_line_colors)],
-                     label=""child {}"".format(proc))
+            pl.plot(cts, cmem, ""+-"" + mem_line_colors[(idx + 1) % len(mem_line_colors)],
+                    label=""child {}{}"".format(proc, child_mem_trend_label))
+
+            if show_trend_slope:
+                # Plot the trend line
+                pl.plot(cts, cmem_trend(cts), ""--"", linewidth=0.5, color=""black"")
 
             # Detect the maximal child memory point
             cmax_mem = cmem.max()
@@ -710,6 +737,8 @@ such file in the current directory.""""""
                         help=""Plot a time-subset of the data. E.g. to plot between 0 and 20.5 seconds: --window 0,20.5"")
     parser.add_argument(""--flame"", ""-f"", dest=""flame_mode"", action=""store_true"",
                         help=""Plot the timestamps as a flame-graph instead of the default brackets"")
+    parser.add_argument(""--slope"", ""-s"", dest=""slope"", action=""store_true"",
+                        help=""Plot a trend line and its numerical slope"")
     parser.add_argument(""--backend"",
                       help=""Specify the Matplotlib backend to use"")
     parser.add_argument(""profiles"", nargs=""*"",
@@ -810,4 +839,4 @@ def main():
     actions[get_action()]()
 
 if __name__ == ""__main__"":
-    main()
+    main()
\ No newline at end of file
",True,mprof.py,True
"@@ -412,17 +412,17 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
     mem_trend = None
     if show_trend_slope:
         # Compute trend line
-        mem_slope = np.polyfit(t, mem, 1)
-        mem_trend = np.poly1d(mem_slope)
+        mem_trend = np.polyfit(t, mem, 1)
+
         # Append slope to label
-        mem_line_label = mem_line_label + "" slope {0:.5f}"".format(mem_slope[0])
+        mem_line_label = mem_line_label + "" slope {0:.5f}"".format(mem_trend[0])
 
     pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
             label=mem_line_label)
 
     if show_trend_slope:
         # Plot the trend line
-        pl.plot(t, mem_trend(mem), ""--"", linewidth=0.5, color=""#00e3d8"")
+        pl.plot(t, t*mem_trend[0] + mem_trend[1], ""--"", linewidth=0.5, color=""#00e3d8"")
 
     bottom, top = pl.ylim()
     bottom += 0.001
@@ -441,9 +441,9 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
             child_mem_trend_label = """"
             if show_trend_slope:
                 # Compute trend line
-                child_mem_slope = np.polyfit(cts, cmem, 1)
-                cmem_trend = np.poly1d(child_mem_slope)
-                child_mem_trend_label = "" slope {0:.5f}"".format(child_mem_slope[0])
+                cmem_trend = np.polyfit(cts, cmem, 1)
+
+                child_mem_trend_label = "" slope {0:.5f}"".format(cmem_trend[0])
 
             # Plot the line to the figure
             pl.plot(cts, cmem, ""+-"" + mem_line_colors[(idx + 1) % len(mem_line_colors)],
@@ -451,7 +451,7 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
 
             if show_trend_slope:
                 # Plot the trend line
-                pl.plot(cts, cmem_trend(cts), ""--"", linewidth=0.5, color=""black"")
+                pl.plot(cts, cts*cmem_trend[0] + cmem_trend[1], ""--"", linewidth=0.5, color=""black"")
 
             # Detect the maximal child memory point
             cmax_mem = cmem.max()
@@ -839,4 +839,4 @@ def main():
     actions[get_action()]()
 
 if __name__ == ""__main__"":
-    main()
\ No newline at end of file
+    main()
","@@ -412,17 +412,17 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
     mem_trend = None
     if show_trend_slope:
         # Compute trend line
-        mem_slope = np.polyfit(t, mem, 1)
-        mem_trend = np.poly1d(mem_slope)
+        mem_trend = np.polyfit(t, mem, 1)
+
         # Append slope to label
-        mem_line_label = mem_line_label + "" slope {0:.5f}"".format(mem_slope[0])
+        mem_line_label = mem_line_label + "" slope {0:.5f}"".format(mem_trend[0])
 
     pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
             label=mem_line_label)
 
     if show_trend_slope:
         # Plot the trend line
-        pl.plot(t, mem_trend(mem), ""--"", linewidth=0.5, color=""#00e3d8"")
+        pl.plot(t, t*mem_trend[0] + mem_trend[1], ""--"", linewidth=0.5, color=""#00e3d8"")
 
     bottom, top = pl.ylim()
     bottom += 0.001
@@ -441,9 +441,9 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
             child_mem_trend_label = """"
             if show_trend_slope:
                 # Compute trend line
-                child_mem_slope = np.polyfit(cts, cmem, 1)
-                cmem_trend = np.poly1d(child_mem_slope)
-                child_mem_trend_label = "" slope {0:.5f}"".format(child_mem_slope[0])
+                cmem_trend = np.polyfit(cts, cmem, 1)
+
+                child_mem_trend_label = "" slope {0:.5f}"".format(cmem_trend[0])
 
             # Plot the line to the figure
             pl.plot(cts, cmem, ""+-"" + mem_line_colors[(idx + 1) % len(mem_line_colors)],
@@ -451,7 +451,7 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
 
             if show_trend_slope:
                 # Plot the trend line
-                pl.plot(cts, cmem_trend(cts), ""--"", linewidth=0.5, color=""black"")
+                pl.plot(cts, cts*cmem_trend[0] + cmem_trend[1], ""--"", linewidth=0.5, color=""black"")
 
             # Detect the maximal child memory point
             cmax_mem = cmem.max()
@@ -839,4 +839,4 @@ def main():
     actions[get_action()]()
 
 if __name__ == ""__main__"":
-    main()
\ No newline at end of file
+    main()
",True,mprof.py,True
"@@ -218,6 +218,9 @@ Trend lines and its numeric slope can be plotted using the ``s`` flag, such as
 
     mprof plot -s
 
+.. image:: ./images/trend_slope.png
+   :height: 350px
+
 Setting debugger breakpoints
 =============================
 It is possible to set breakpoints depending on the amount of memory used.
","@@ -218,6 +218,9 @@ Trend lines and its numeric slope can be plotted using the ``s`` flag, such as
 
     mprof plot -s
 
+.. image:: ./images/trend_slope.png
+   :height: 350px
+
 Setting debugger breakpoints
 =============================
 It is possible to set breakpoints depending on the amount of memory used.
",True,README.rst,False
"@@ -221,6 +221,15 @@ Trend lines and its numeric slope can be plotted using the ``s`` flag, such as
 .. image:: ./images/trend_slope.png
    :height: 350px
 
+The intended usage of the -s switch is to check the labels' numerical slope over a significant time period for : 
+
+    >0 - it might mean a memory leak.
+    ~0 - if 0 or near 0, the memory usage may be considered stable.
+    <0 - to be interpreted depending on the expected process memory usage patterns, also might mean that the sampling period is too small.
+
+The trend lines are for ilustrative purposes and are plotted as (very) small dashed lines.
+
+
 Setting debugger breakpoints
 =============================
 It is possible to set breakpoints depending on the amount of memory used.
","@@ -221,6 +221,15 @@ Trend lines and its numeric slope can be plotted using the ``s`` flag, such as
 .. image:: ./images/trend_slope.png
    :height: 350px
 
+The intended usage of the -s switch is to check the labels' numerical slope over a significant time period for : 
+
+    >0 - it might mean a memory leak.
+    ~0 - if 0 or near 0, the memory usage may be considered stable.
+    <0 - to be interpreted depending on the expected process memory usage patterns, also might mean that the sampling period is too small.
+
+The trend lines are for ilustrative purposes and are plotted as (very) small dashed lines.
+
+
 Setting debugger breakpoints
 =============================
 It is possible to set breakpoints depending on the amount of memory used.
",True,README.rst,False
"@@ -223,9 +223,10 @@ Trend lines and its numeric slope can be plotted using the ``s`` flag, such as
 
 The intended usage of the -s switch is to check the labels' numerical slope over a significant time period for : 
 
-    >0 - it might mean a memory leak.
-    ~0 - if 0 or near 0, the memory usage may be considered stable.
-    <0 - to be interpreted depending on the expected process memory usage patterns, also might mean that the sampling period is too small.
+  - ``>0`` it might mean a memory leak.
+  - ``~0`` if 0 or near 0, the memory usage may be considered stable.
+    the last one)
+  - ``<0`` to be interpreted depending on the expected process memory usage patterns, also might mean that the sampling period is too small.
 
 The trend lines are for ilustrative purposes and are plotted as (very) small dashed lines.
 
","@@ -223,9 +223,10 @@ Trend lines and its numeric slope can be plotted using the ``s`` flag, such as
 
 The intended usage of the -s switch is to check the labels' numerical slope over a significant time period for : 
 
-    >0 - it might mean a memory leak.
-    ~0 - if 0 or near 0, the memory usage may be considered stable.
-    <0 - to be interpreted depending on the expected process memory usage patterns, also might mean that the sampling period is too small.
+  - ``>0`` it might mean a memory leak.
+  - ``~0`` if 0 or near 0, the memory usage may be considered stable.
+    the last one)
+  - ``<0`` to be interpreted depending on the expected process memory usage patterns, also might mean that the sampling period is too small.
 
 The trend lines are for ilustrative purposes and are plotted as (very) small dashed lines.
 
",True,README.rst,False
"@@ -225,7 +225,6 @@ The intended usage of the -s switch is to check the labels' numerical slope over
 
   - ``>0`` it might mean a memory leak.
   - ``~0`` if 0 or near 0, the memory usage may be considered stable.
-    the last one)
   - ``<0`` to be interpreted depending on the expected process memory usage patterns, also might mean that the sampling period is too small.
 
 The trend lines are for ilustrative purposes and are plotted as (very) small dashed lines.
","@@ -225,7 +225,6 @@ The intended usage of the -s switch is to check the labels' numerical slope over
 
   - ``>0`` it might mean a memory leak.
   - ``~0`` if 0 or near 0, the memory usage may be considered stable.
-    the last one)
   - ``<0`` to be interpreted depending on the expected process memory usage patterns, also might mean that the sampling period is too small.
 
 The trend lines are for ilustrative purposes and are plotted as (very) small dashed lines.
",True,README.rst,False
"@@ -64,14 +64,14 @@ this would result in::
 
 Output will follow::
 
-    Line #    Mem usage  Increment   Line Contents
-    ==============================================
-         3                           @profile
-         4      5.97 MB    0.00 MB   def my_func():
-         5     13.61 MB    7.64 MB       a = [1] * (10 ** 6)
-         6    166.20 MB  152.59 MB       b = [2] * (2 * 10 ** 7)
-         7     13.61 MB -152.59 MB       del b
-         8     13.61 MB    0.00 MB       return a
+    Line #    Mem usage    Increment  Occurences   Line Contents
+    ============================================================
+         3   38.816 MiB   38.816 MiB           1   @profile
+         4                                         def my_func():
+         5   46.492 MiB    7.676 MiB           1       a = [1] * (10 ** 6)
+         6  199.117 MiB  152.625 MiB           1       b = [2] * (2 * 10 ** 7)
+         7   46.629 MiB -152.488 MiB           1       del b
+         8   46.629 MiB    0.000 MiB           1       return a
 
 
 The first column represents the line number of the code that has been
","@@ -64,14 +64,14 @@ this would result in::
 
 Output will follow::
 
-    Line #    Mem usage  Increment   Line Contents
-    ==============================================
-         3                           @profile
-         4      5.97 MB    0.00 MB   def my_func():
-         5     13.61 MB    7.64 MB       a = [1] * (10 ** 6)
-         6    166.20 MB  152.59 MB       b = [2] * (2 * 10 ** 7)
-         7     13.61 MB -152.59 MB       del b
-         8     13.61 MB    0.00 MB       return a
+    Line #    Mem usage    Increment  Occurences   Line Contents
+    ============================================================
+         3   38.816 MiB   38.816 MiB           1   @profile
+         4                                         def my_func():
+         5   46.492 MiB    7.676 MiB           1       a = [1] * (10 ** 6)
+         6  199.117 MiB  152.625 MiB           1       b = [2] * (2 * 10 ** 7)
+         7   46.629 MiB -152.488 MiB           1       del b
+         8   46.629 MiB    0.000 MiB           1       return a
 
 
 The first column represents the line number of the code that has been
",True,README.rst,False
"@@ -280,10 +280,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         to this file instead of stored in memory and returned at the end of
         the subprocess. Useful for long-running processes.
         Implies timestamps=True.
-        
+
     max_iterations : int
         Limits the number of iterations (calls to the process being monitored). Relevent
-        when the process is a python function. 
+        when the process is a python function.
 
     Returns
     -------
@@ -357,7 +357,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 raise
 
             p.join(5 * interval)
-            
+
             if (n_measurements > 4) or (current_iter == max_iter) or (interval < 1e-6):
                 break
             interval /= 10.
@@ -643,7 +643,12 @@ class CodeMap(dict):
 
         prev_line_value = self[code].get(prev_lineno, None) if prev_lineno else None
         prev_line_memory = prev_line_value[1] if prev_line_value else 0
-        self[code][lineno] = (max(previous_inc, memory-prev_line_memory), max(memory, previous_memory))
+        occ_count = self[code][lineno][2] + 1 if lineno in self[code] else 1
+        self[code][lineno] = (
+            previous_inc + (memory - prev_line_memory),
+            max(memory, previous_memory),
+            occ_count,
+        )
 
     def items(self):
         """"""Iterate on the toplevel code blocks.""""""
@@ -800,10 +805,10 @@ class LineProfiler(object):
 def show_results(prof, stream=None, precision=1):
     if stream is None:
         stream = sys.stdout
-    template = '{0:>6} {1:>12} {2:>12}   {3:<}'
+    template = '{0:>6} {1:>12} {2:>12}  {3:>10}   {4:<}'
 
     for (filename, lines) in prof.code_map.items():
-        header = template.format('Line #', 'Mem usage', 'Increment',
+        header = template.format('Line #', 'Mem usage', 'Increment', 'Occurences',
                                  'Line Contents')
 
         stream.write(u'Filename: ' + filename + '\n\n')
@@ -817,13 +822,15 @@ def show_results(prof, stream=None, precision=1):
         for (lineno, mem) in lines:
             if mem:
                 inc = mem[0]
-                mem = mem[1]
-                mem = template_mem.format(mem)
+                total_mem = mem[1]
+                total_mem = template_mem.format(total_mem)
+                occurences = mem[2]
                 inc = template_mem.format(inc)
             else:
-                mem = u''
+                total_mem = u''
                 inc = u''
-            tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
+                occurences = u''
+            tmp = template.format(lineno, total_mem, inc, occurences, all_lines[lineno - 1])
             stream.write(to_str(tmp))
         stream.write(u'\n\n')
 
","@@ -280,10 +280,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         to this file instead of stored in memory and returned at the end of
         the subprocess. Useful for long-running processes.
         Implies timestamps=True.
-        
+
     max_iterations : int
         Limits the number of iterations (calls to the process being monitored). Relevent
-        when the process is a python function. 
+        when the process is a python function.
 
     Returns
     -------
@@ -357,7 +357,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 raise
 
             p.join(5 * interval)
-            
+
             if (n_measurements > 4) or (current_iter == max_iter) or (interval < 1e-6):
                 break
             interval /= 10.
@@ -643,7 +643,12 @@ class CodeMap(dict):
 
         prev_line_value = self[code].get(prev_lineno, None) if prev_lineno else None
         prev_line_memory = prev_line_value[1] if prev_line_value else 0
-        self[code][lineno] = (max(previous_inc, memory-prev_line_memory), max(memory, previous_memory))
+        occ_count = self[code][lineno][2] + 1 if lineno in self[code] else 1
+        self[code][lineno] = (
+            previous_inc + (memory - prev_line_memory),
+            max(memory, previous_memory),
+            occ_count,
+        )
 
     def items(self):
         """"""Iterate on the toplevel code blocks.""""""
@@ -800,10 +805,10 @@ class LineProfiler(object):
 def show_results(prof, stream=None, precision=1):
     if stream is None:
         stream = sys.stdout
-    template = '{0:>6} {1:>12} {2:>12}   {3:<}'
+    template = '{0:>6} {1:>12} {2:>12}  {3:>10}   {4:<}'
 
     for (filename, lines) in prof.code_map.items():
-        header = template.format('Line #', 'Mem usage', 'Increment',
+        header = template.format('Line #', 'Mem usage', 'Increment', 'Occurences',
                                  'Line Contents')
 
         stream.write(u'Filename: ' + filename + '\n\n')
@@ -817,13 +822,15 @@ def show_results(prof, stream=None, precision=1):
         for (lineno, mem) in lines:
             if mem:
                 inc = mem[0]
-                mem = mem[1]
-                mem = template_mem.format(mem)
+                total_mem = mem[1]
+                total_mem = template_mem.format(total_mem)
+                occurences = mem[2]
                 inc = template_mem.format(inc)
             else:
-                mem = u''
+                total_mem = u''
                 inc = u''
-            tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
+                occurences = u''
+            tmp = template.format(lineno, total_mem, inc, occurences, all_lines[lineno - 1])
             stream.write(to_str(tmp))
         stream.write(u'\n\n')
 
",True,memory_profiler.py,True
"@@ -0,0 +1,81 @@
+import unittest
+
+from memory_profiler import LineProfiler, profile, show_results
+from io import StringIO
+
+
+class TestIncrementDisplay(unittest.TestCase):
+    """"""Tests memory incrementation / decrementation display""""""
+
+    def test_loop_count(self):
+
+        def some_loop():
+            for i in range(12):  # line -2
+                a = 1            # line -1
+
+        profiler = LineProfiler()
+        wrapped = profiler(some_loop)
+        wrapped()
+        show_results(profiler)
+        for_line = list(list(profiler.code_map.values())[0].values())[-2]
+        looped_instruction = list(list(profiler.code_map.values())[0].values())[-1]
+
+        self.assertEqual(for_line[2], 13)
+        self.assertEqual(looped_instruction[2], 12)
+
+    def test_normal_incr(self):
+
+        def normal_incr():
+            use_some_memory = [1] * (10 ** 6)
+
+        profiler = LineProfiler()
+        wrapped = profiler(normal_incr)
+        wrapped()
+
+        show_results(profiler)
+        results = list(list(profiler.code_map.values())[0].values())[-1]
+
+        self.assertGreater(results[0], 0)
+        self.assertGreater(results[1], results[0])
+        self.assertEqual(results[2], 1)
+
+    def test_loop_incr(self):
+
+        def loop_incr():
+            a = []
+            b = [2] * (2 * 10 ** 7)      # line -4
+            for i in range(3):
+                c = [2] * (2 * 10 ** 7)  # line -2
+                a.append(c)
+
+        profiler = LineProfiler()
+        wrapped = profiler(loop_incr)
+        wrapped()
+
+        show_results(profiler)
+        b_line = list(list(profiler.code_map.values())[0].values())[-4]
+        c_line = list(list(profiler.code_map.values())[0].values())[-2]
+        self.assertAlmostEqual(b_line[2] * 3, c_line[2], delta=1)
+        self.assertEqual(c_line[2], 3)
+
+    def test_decr(self):
+
+        def del_stuff():
+            b = [2] * (2 * 10 ** 7)
+            del b
+
+        profiler = LineProfiler()
+        wrapped = profiler(del_stuff)
+        wrapped()
+
+        show_results(profiler)
+        b_line = list(list(profiler.code_map.values())[0].values())[-2]
+        del_line = list(list(profiler.code_map.values())[0].values())[-1]
+
+        self.assertGreater(0, del_line[0])
+        self.assertGreater(del_line[1], 0)
+        self.assertAlmostEqual(-del_line[0], b_line[0], delta=1)
+
+
+if __name__ == '__main__':
+    unittest.main()
","@@ -0,0 +1,81 @@
+import unittest
+
+from memory_profiler import LineProfiler, profile, show_results
+from io import StringIO
+
+
+class TestIncrementDisplay(unittest.TestCase):
+    """"""Tests memory incrementation / decrementation display""""""
+
+    def test_loop_count(self):
+
+        def some_loop():
+            for i in range(12):  # line -2
+                a = 1            # line -1
+
+        profiler = LineProfiler()
+        wrapped = profiler(some_loop)
+        wrapped()
+        show_results(profiler)
+        for_line = list(list(profiler.code_map.values())[0].values())[-2]
+        looped_instruction = list(list(profiler.code_map.values())[0].values())[-1]
+
+        self.assertEqual(for_line[2], 13)
+        self.assertEqual(looped_instruction[2], 12)
+
+    def test_normal_incr(self):
+
+        def normal_incr():
+            use_some_memory = [1] * (10 ** 6)
+
+        profiler = LineProfiler()
+        wrapped = profiler(normal_incr)
+        wrapped()
+
+        show_results(profiler)
+        results = list(list(profiler.code_map.values())[0].values())[-1]
+
+        self.assertGreater(results[0], 0)
+        self.assertGreater(results[1], results[0])
+        self.assertEqual(results[2], 1)
+
+    def test_loop_incr(self):
+
+        def loop_incr():
+            a = []
+            b = [2] * (2 * 10 ** 7)      # line -4
+            for i in range(3):
+                c = [2] * (2 * 10 ** 7)  # line -2
+                a.append(c)
+
+        profiler = LineProfiler()
+        wrapped = profiler(loop_incr)
+        wrapped()
+
+        show_results(profiler)
+        b_line = list(list(profiler.code_map.values())[0].values())[-4]
+        c_line = list(list(profiler.code_map.values())[0].values())[-2]
+        self.assertAlmostEqual(b_line[2] * 3, c_line[2], delta=1)
+        self.assertEqual(c_line[2], 3)
+
+    def test_decr(self):
+
+        def del_stuff():
+            b = [2] * (2 * 10 ** 7)
+            del b
+
+        profiler = LineProfiler()
+        wrapped = profiler(del_stuff)
+        wrapped()
+
+        show_results(profiler)
+        b_line = list(list(profiler.code_map.values())[0].values())[-2]
+        del_line = list(list(profiler.code_map.values())[0].values())[-1]
+
+        self.assertGreater(0, del_line[0])
+        self.assertGreater(del_line[1], 0)
+        self.assertAlmostEqual(-del_line[0], b_line[0], delta=1)
+
+
+if __name__ == '__main__':
+    unittest.main()
",True,test/test_increment_display.py,True
"@@ -11,3 +11,4 @@ mprofile_*.dat
 
 # virtual environment
 venv/
+.python-version
","@@ -11,3 +11,4 @@ mprofile_*.dat
 
 # virtual environment
 venv/
+.python-version
",True,.gitignore,False
"@@ -20,9 +20,7 @@ test:
 	$(PYTHON) test/test_exception.py
 	$(PYTHON) test/test_exit_code.py
 	$(PYTHON) test/test_mprof.py
-	if [ $(PY_34) = True ]; then \
-		$(PYTHON) test/test_async.py; \
-	fi
+	$(PYTHON) test/test_async.py
 
 develop:
 	pip install -e .
","@@ -20,9 +20,7 @@ test:
 	$(PYTHON) test/test_exception.py
 	$(PYTHON) test/test_exit_code.py
 	$(PYTHON) test/test_mprof.py
-	if [ $(PY_34) = True ]; then \
-		$(PYTHON) test/test_async.py; \
-	fi
+	$(PYTHON) test/test_async.py
 
 develop:
 	pip install -e .
",True,Makefile,False
"@@ -5,31 +5,22 @@ _CLEAN_GLOBALS = globals().copy()
 
 __version__ = '0.57.0'
 
+_CMD_USAGE = ""python -m memory_profiler script_file.py""
 
-from functools import wraps
+from asyncio import coroutine, iscoroutinefunction
+from contextlib import contextmanager
+from functools import partial, wraps
+import builtins
 import inspect
+import linecache
 import logging
 import os
+import pdb
 import subprocess
 import sys
 import time
 import traceback
 import warnings
-import contextlib
-
-from .code_map import CodeMap
-from .common import PY2, PY34, HAS_TRACEMALLOC
-from .utils import (
-    show_results,
-    choose_backend,
-    get_memory as _get_memory,
-    get_child_memory as _get_child_memory,
-)
-from .line_profiler import LineProfiler, get_profile_wrapper
-
-if PY34:
-    from ._async import get_profile_wrapper
-
 
 if sys.platform == ""win32"":
     # any value except signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT
@@ -54,17 +45,17 @@ except ImportError:
     line_cell_magic = lambda func: func
     magics_class = lambda cls: cls
 
-if PY2:
-    import __builtin__ as builtins
-    to_str = lambda x: x
-    from future_builtins import filter
-else:
-    import builtins
-    to_str = lambda x: str(x)
+_TWO_20 = float(2 ** 20)
 
-if HAS_TRACEMALLOC:
+
+# .. get available packages ..
+try:
     import tracemalloc
 
+    has_tracemalloc = True
+except ImportError:
+    has_tracemalloc = False
+
 
 class MemitResult(object):
     """"""memit magic run details.
@@ -91,6 +82,108 @@ class MemitResult(object):
         p.text(u'<MemitResult : ' + msg + u'>')
 
 
+def _get_child_memory(process, meminfo_attr=None):
+    """"""
+    Returns a generator that yields memory for all child processes.
+    """"""
+    # Convert a pid to a process
+    if isinstance(process, int):
+        if process == -1: process = os.getpid()
+        process = psutil.Process(process)
+
+    if not meminfo_attr:
+        # Use the psutil 2.0 attr if the older version isn't passed in.
+        meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
+
+    # Select the psutil function get the children similar to how we selected
+    # the memory_info attr (a change from excepting the AttributeError).
+    children_attr = 'children' if hasattr(process, 'children') else 'get_children'
+
+    # Loop over the child processes and yield their memory
+    try:
+        for child in getattr(process, children_attr)(recursive=True):
+            yield getattr(child, meminfo_attr)()[0] / _TWO_20
+    except (psutil.NoSuchProcess, psutil.AccessDenied):
+        # https://github.com/fabianp/memory_profiler/issues/71
+        yield 0.0
+
+
+def _get_memory(pid, backend, timestamps=False, include_children=False, filename=None):
+    # .. low function to get memory consumption ..
+    if pid == -1:
+        pid = os.getpid()
+
+    def tracemalloc_tool():
+        # .. cross-platform but but requires Python 3.4 or higher ..
+        stat = next(filter(lambda item: str(item).startswith(filename),
+                           tracemalloc.take_snapshot().statistics('filename')))
+        mem = stat.size / _TWO_20
+        if timestamps:
+            return mem, time.time()
+        else:
+            return mem
+
+    def ps_util_tool():
+        # .. cross-platform but but requires psutil ..
+        process = psutil.Process(pid)
+        try:
+            # avoid using get_memory_info since it does not exists
+            # in psutil > 2.0 and accessing it will cause exception.
+            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') \
+                else 'get_memory_info'
+            mem = getattr(process, meminfo_attr)()[0] / _TWO_20
+            if include_children:
+                mem +=  sum(_get_child_memory(process, meminfo_attr))
+            if timestamps:
+                return mem, time.time()
+            else:
+                return mem
+        except psutil.AccessDenied:
+            pass
+            # continue and try to get this from ps
+
+    def posix_tool():
+        # .. scary stuff ..
+        if include_children:
+            raise NotImplementedError((
+                ""The psutil module is required to monitor the ""
+                ""memory usage of child processes.""
+            ))
+
+        warnings.warn(""psutil module not found. memory_profiler will be slow"")
+        # ..
+        # .. memory usage in MiB ..
+        # .. this should work on both Mac and Linux ..
+        # .. subprocess.check_output appeared in 2.7, using Popen ..
+        # .. for backwards compatibility ..
+        out = subprocess.Popen(['ps', 'v', '-p', str(pid)],
+                               stdout=subprocess.PIPE
+                               ).communicate()[0].split(b'\n')
+        try:
+            vsz_index = out[0].split().index(b'RSS')
+            mem = float(out[1].split()[vsz_index]) / 1024
+            if timestamps:
+                return mem, time.time()
+            else:
+                return mem
+        except:
+            if timestamps:
+                return -1, time.time()
+            else:
+                return -1
+
+    if backend == 'tracemalloc' and \
+            (filename is None or filename == '<unknown>'):
+        raise RuntimeError(
+            'There is no access to source file of the profiled function'
+        )
+
+    tools = {'tracemalloc': tracemalloc_tool,
+             'psutil': ps_util_tool,
+             'posix': posix_tool}
+    return tools[backend]()
+
+
 class MemTimer(Process):
     """"""
     Fetch memory consumption from over a time interval
@@ -180,10 +273,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         to this file instead of stored in memory and returned at the end of
         the subprocess. Useful for long-running processes.
         Implies timestamps=True.
-        
+
     max_iterations : int
         Limits the number of iterations (calls to the process being monitored). Relevent
-        when the process is a python function. 
+        when the process is a python function.
 
     Returns
     -------
@@ -257,7 +350,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 raise
 
             p.join(5 * interval)
-            
+
             if (n_measurements > 4) or (current_iter == max_iter) or (interval < 1e-6):
                 break
             interval /= 10.
@@ -348,17 +441,36 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 # .. utility functions for line-by-line ..
 
 
+def _find_script(script_name):
+    """""" Find the script.
+
+    If the input is not a file, then $PATH will be searched.
+    """"""
+    if os.path.isfile(script_name):
+        return script_name
+    path = os.getenv('PATH', os.defpath).split(os.pathsep)
+    for folder in path:
+        if not folder:
+            continue
+        fn = os.path.join(folder, script_name)
+        if os.path.isfile(fn):
+            return fn
+
+    sys.stderr.write('Could not find script {0}\n'.format(script_name))
+    raise SystemExit(1)
 
 
 class _TimeStamperCM(object):
     """"""Time-stamping context manager.""""""
 
-    def __init__(self, timestamps, filename, backend, timestamper=None, func=None):
+    def __init__(self, timestamps, filename, backend, timestamper=None, func=None,
+                 include_children=False):
         self.timestamps = timestamps
         self.filename = filename
         self.backend = backend
         self.ts = timestamper
         self.func = func
+        self.include_children = include_children
 
     def __enter__(self):
         if self.ts is not None:
@@ -366,14 +478,16 @@ class _TimeStamperCM(object):
             self.ts.stack[self.func].append(self.ts.current_stack_level)
 
         self.timestamps.append(
-            _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
+            _get_memory(os.getpid(), self.backend, timestamps=True,
+                        include_children=self.include_children, filename=self.filename))
 
     def __exit__(self, *args):
         if self.ts is not None:
             self.ts.current_stack_level -= 1
 
         self.timestamps.append(
-            _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
+            _get_memory(os.getpid(), self.backend, timestamps=True,
+                        include_children=self.include_children, filename=self.filename))
 
 
 class TimeStamper:
@@ -381,9 +495,10 @@ class TimeStamper:
     any decorated function.
     """"""
 
-    def __init__(self, backend):
+    def __init__(self, backend, include_children=False):
         self.functions = {}
         self.backend = backend
+        self.include_children = include_children
         self.current_stack_level = -1
         self.stack = {}
 
@@ -444,7 +559,8 @@ class TimeStamper:
             except TypeError:
                 filename = '<unknown>'
             timestamps = [
-                _get_memory(os.getpid(), self.backend, timestamps=True, filename=filename)]
+                _get_memory(os.getpid(), self.backend, timestamps=True,
+                            include_children=self.include_children, filename=filename)]
             self.functions[func].append(timestamps)
             try:
                 with self.call_on_stack(func, *args, **kwds) as result:
@@ -452,11 +568,12 @@ class TimeStamper:
             finally:
                 # end time
                 timestamps.append(_get_memory(os.getpid(), self.backend, timestamps=True,
+                                              include_children=self.include_children,
                                               filename=filename))
 
         return f
 
-    @contextlib.contextmanager
+    @contextmanager
     def call_on_stack(self, func, *args, **kwds):
         self.current_stack_level += 1
         self.stack[func].append(self.current_stack_level)
@@ -476,6 +593,252 @@ class TimeStamper:
                     (function_name,) + ts[0] + ts[1] + (level,)))
 
 
+class CodeMap(dict):
+    def __init__(self, include_children, backend):
+        self.include_children = include_children
+        self._toplevel = []
+        self.backend = backend
+
+    def add(self, code, toplevel_code=None):
+        if code in self:
+            return
+
+        if toplevel_code is None:
+            filename = code.co_filename
+            if filename.endswith(("".pyc"", "".pyo"")):
+                filename = filename[:-1]
+            if not os.path.exists(filename):
+                print('ERROR: Could not find file ' + filename)
+                if filename.startswith((""ipython-input"", ""<ipython-input"")):
+                    print(
+                        ""NOTE: %mprun can only be used on functions defined in""
+                        "" physical files, and not in the IPython environment."")
+                return
+
+            toplevel_code = code
+            (sub_lines, start_line) = inspect.getsourcelines(code)
+            linenos = range(start_line,
+                            start_line + len(sub_lines))
+            self._toplevel.append((filename, code, linenos))
+            self[code] = {}
+        else:
+            self[code] = self[toplevel_code]
+
+        for subcode in filter(inspect.iscode, code.co_consts):
+            self.add(subcode, toplevel_code=toplevel_code)
+
+    def trace(self, code, lineno, prev_lineno):
+        memory = _get_memory(-1, self.backend, include_children=self.include_children,
+                             filename=code.co_filename)
+        prev_value = self[code].get(lineno, None)
+        previous_memory = prev_value[1] if prev_value else 0
+        previous_inc = prev_value[0] if prev_value else 0
+
+        prev_line_value = self[code].get(prev_lineno, None) if prev_lineno else None
+        prev_line_memory = prev_line_value[1] if prev_line_value else 0
+        occ_count = self[code][lineno][2] + 1 if lineno in self[code] else 1
+        self[code][lineno] = (
+            previous_inc + (memory - prev_line_memory),
+            max(memory, previous_memory),
+            occ_count,
+        )
+
+    def items(self):
+        """"""Iterate on the toplevel code blocks.""""""
+        for (filename, code, linenos) in self._toplevel:
+            measures = self[code]
+            if not measures:
+                continue  # skip if no measurement
+            line_iterator = ((line, measures.get(line)) for line in linenos)
+            yield (filename, line_iterator)
+
+
+class LineProfiler(object):
+    """""" A profiler that records the amount of memory for each line """"""
+
+    def __init__(self, **kw):
+        include_children = kw.get('include_children', False)
+        backend = kw.get('backend', 'psutil')
+        self.code_map = CodeMap(
+            include_children=include_children, backend=backend)
+        self.enable_count = 0
+        self.max_mem = kw.get('max_mem', None)
+        self.prevlines = []
+        self.backend = choose_backend(kw.get('backend', None))
+        self.prev_lineno = None
+
+    def __call__(self, func=None, precision=1):
+        if func is not None:
+            self.add_function(func)
+            f = self.wrap_function(func)
+            f.__module__ = func.__module__
+            f.__name__ = func.__name__
+            f.__doc__ = func.__doc__
+            f.__dict__.update(getattr(func, '__dict__', {}))
+            return f
+        else:
+            def inner_partial(f):
+                return self.__call__(f, precision=precision)
+
+            return inner_partial
+
+    def add_function(self, func):
+        """""" Record line profiling information for the given Python function.
+        """"""
+        try:
+            # func_code does not exist in Python3
+            code = func.__code__
+        except AttributeError:
+            warnings.warn(""Could not extract a code object for the object %r""
+                          % func)
+        else:
+            self.code_map.add(code)
+
+    @contextmanager
+    def _count_ctxmgr(self):
+        self.enable_by_count()
+        try:
+            yield
+        finally:
+            self.disable_by_count()
+
+    def wrap_function(self, func):
+        """""" Wrap a function to profile it.
+        """"""
+
+        if iscoroutinefunction(func):
+            @coroutine
+            def f(*args, **kwargs):
+                with self._count_ctxmgr():
+                    yield from func(*args, **kwargs)
+        else:
+            def f(*args, **kwds):
+                with self._count_ctxmgr():
+                    return func(*args, **kwds)
+
+        return f
+
+    def runctx(self, cmd, globals, locals):
+        """""" Profile a single executable statement in the given namespaces.
+        """"""
+        self.enable_by_count()
+        try:
+            exec(cmd, globals, locals)
+        finally:
+            self.disable_by_count()
+        return self
+
+    def enable_by_count(self):
+        """""" Enable the profiler if it hasn't been enabled before.
+        """"""
+        if self.enable_count == 0:
+            self.enable()
+        self.enable_count += 1
+
+    def disable_by_count(self):
+        """""" Disable the profiler if the number of disable requests matches the
+        number of enable requests.
+        """"""
+        if self.enable_count > 0:
+            self.enable_count -= 1
+            if self.enable_count == 0:
+                self.disable()
+
+    def trace_memory_usage(self, frame, event, arg):
+        """"""Callback for sys.settrace""""""
+        if frame.f_code in self.code_map:
+            if event == 'call':
+                # ""call"" event just saves the lineno but not the memory
+                self.prevlines.append(frame.f_lineno)
+            elif event == 'line':
+                # trace needs current line and previous line
+                self.code_map.trace(frame.f_code, self.prevlines[-1], self.prev_lineno)
+                # saving previous line
+                self.prev_lineno = self.prevlines[-1]
+                self.prevlines[-1] = frame.f_lineno
+            elif event == 'return':
+                lineno = self.prevlines.pop()
+                self.code_map.trace(frame.f_code, lineno, self.prev_lineno)
+                self.prev_lineno = lineno
+
+        if self._original_trace_function is not None:
+            self._original_trace_function(frame, event, arg)
+
+        return self.trace_memory_usage
+
+    def trace_max_mem(self, frame, event, arg):
+        # run into PDB as soon as memory is higher than MAX_MEM
+        if event in ('line', 'return') and frame.f_code in self.code_map:
+            c = _get_memory(-1, self.backend, filename=frame.f_code.co_filename)
+            if c >= self.max_mem:
+                t = ('Current memory {0:.2f} MiB exceeded the '
+                     'maximum of {1:.2f} MiB\n'.format(c, self.max_mem))
+                sys.stdout.write(t)
+                sys.stdout.write('Stepping into the debugger \n')
+                frame.f_lineno -= 2
+                p = pdb.Pdb()
+                p.quitting = False
+                p.stopframe = frame
+                p.returnframe = None
+                p.stoplineno = frame.f_lineno - 3
+                p.botframe = None
+                return p.trace_dispatch
+
+        if self._original_trace_function is not None:
+            (self._original_trace_function)(frame, event, arg)
+
+        return self.trace_max_mem
+
+    def __enter__(self):
+        self.enable_by_count()
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        self.disable_by_count()
+
+    def enable(self):
+        self._original_trace_function = sys.gettrace()
+        if self.max_mem is not None:
+            sys.settrace(self.trace_max_mem)
+        else:
+            sys.settrace(self.trace_memory_usage)
+
+    def disable(self):
+        sys.settrace(self._original_trace_function)
+
+
+def show_results(prof, stream=None, precision=1):
+    if stream is None:
+        stream = sys.stdout
+    template = '{0:>6} {1:>12} {2:>12}  {3:>10}   {4:<}'
+
+    for (filename, lines) in prof.code_map.items():
+        header = template.format('Line #', 'Mem usage', 'Increment', 'Occurences',
+                                 'Line Contents')
+
+        stream.write(u'Filename: ' + filename + '\n\n')
+        stream.write(header + u'\n')
+        stream.write(u'=' * len(header) + '\n')
+
+        all_lines = linecache.getlines(filename)
+
+        float_format = u'{0}.{1}f'.format(precision + 4, precision)
+        template_mem = u'{0:' + float_format + '} MiB'
+        for (lineno, mem) in lines:
+            if mem:
+                inc = mem[0]
+                total_mem = mem[1]
+                total_mem = template_mem.format(total_mem)
+                occurences = mem[2]
+                inc = template_mem.format(inc)
+            else:
+                total_mem = u''
+                inc = u''
+                occurences = u''
+            tmp = template.format(lineno, total_mem, inc, occurences, all_lines[lineno - 1])
+            stream.write(tmp)
+        stream.write(u'\n\n')
+
+
 def _func_exec(stmt, ns):
     # helper for magic_memit, just a function proxy for the exec
     # statement
@@ -758,11 +1121,29 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
     Decorator that will run the function and print a line-by-line profile
     """"""
     backend = choose_backend(backend)
-    if backend == 'tracemalloc' and HAS_TRACEMALLOC:
+    if backend == 'tracemalloc' and has_tracemalloc:
         if not tracemalloc.is_tracing():
             tracemalloc.start()
     if func is not None:
-        return get_profile_wrapper(func, precision, backend, stream)
+        get_prof = partial(LineProfiler, backend=backend)
+        show_results_bound = partial(
+            show_results, stream=stream, precision=precision
+        )
+        if iscoroutinefunction(func):
+            @coroutine
+            def wrapper(*args, **kwargs):
+                prof = get_prof()
+                val = yield from prof(func)(*args, **kwargs)
+                show_results_bound(prof)
+                return val
+        else:
+            def wrapper(*args, **kwargs):
+                prof = get_prof()
+                val = prof(func)(*args, **kwargs)
+                show_results_bound(prof)
+                return val
+
+        return wrapper
     else:
         def inner_wrapper(f):
             return profile(f, stream=stream, precision=precision,
@@ -771,32 +1152,58 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
         return inner_wrapper
 
 
+def choose_backend(new_backend=None):
+    """"""
+    Function that tries to setup backend, chosen by user, and if failed,
+    setup one of the allowable backends
+    """"""
+
+    _backend = 'no_backend'
+    all_backends = [
+        ('psutil', True),
+        ('posix', os.name == 'posix'),
+        ('tracemalloc', has_tracemalloc),
+    ]
+    backends_indices = dict((b[0], i) for i, b in enumerate(all_backends))
+
+    if new_backend is not None:
+        all_backends.insert(0, all_backends.pop(backends_indices[new_backend]))
+
+    for n_backend, is_available in all_backends:
+        if is_available:
+            _backend = n_backend
+            break
+    if _backend != new_backend and new_backend is not None:
+        warnings.warn('{0} can not be used, {1} used instead'.format(
+            new_backend, _backend))
+    return _backend
+
+
 # Insert in the built-ins to have profile
 # globally defined (global variables is not enough
 # for all cases, e.g. a script that imports another
 # script where @profile is used)
 def exec_with_profiler(filename, profiler, backend, passed_args=[]):
+    from runpy import run_module
     builtins.__dict__['profile'] = profiler
-    ns = dict(
-        _CLEAN_GLOBALS,
-        profile=profiler,
-        # Make sure the __file__ variable is usable
-        # by the script we're profiling
-        __file__=filename
-    )
+    ns = dict(_CLEAN_GLOBALS,
+              profile=profiler,
+             # Make sure the __file__ variable is usable
+             # by the script we're profiling
+              __file__=filename)
     # Make sure the script's directory in on sys.path
     # credit to line_profiler
-    sys.path.insert(0, os.path.dirname(filename))
+    sys.path.insert(0, os.path.dirname(script_filename))
 
     _backend = choose_backend(backend)
     sys.argv = [filename] + passed_args
     try:
-        if _backend == 'tracemalloc' and HAS_TRACEMALLOC:
+        if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
         with open(filename) as f:
             exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
-        if HAS_TRACEMALLOC and tracemalloc.is_tracing():
+        if has_tracemalloc and tracemalloc.is_tracing():
             tracemalloc.stop()
 
 
@@ -806,16 +1213,13 @@ def run_module_with_profiler(module, profiler, backend, passed_args=[]):
     ns = dict(_CLEAN_GLOBALS, profile=profiler)
     _backend = choose_backend(backend)
     sys.argv = [module] + passed_args
-    if PY2:
+    if _backend == 'tracemalloc' and has_tracemalloc:
+        tracemalloc.start()
+    try:
         run_module(module, run_name=""__main__"", init_globals=ns)
-    else:
-        if _backend == 'tracemalloc' and HAS_TRACEMALLOC:
-            tracemalloc.start()
-        try:
-            run_module(module, run_name=""__main__"", init_globals=ns)
-        finally:
-            if HAS_TRACEMALLOC and tracemalloc.is_tracing():
-                tracemalloc.stop()
+    finally:
+        if has_tracemalloc and tracemalloc.is_tracing():
+            tracemalloc.stop()
 
 
 class LogFile(object):
@@ -848,3 +1252,64 @@ class LogFile(object):
     def flush(self):
         for handler in self.logger.handlers:
             handler.flush()
+
+
+if __name__ == '__main__':
+    from argparse import ArgumentParser, REMAINDER
+
+    parser = ArgumentParser(usage=_CMD_USAGE)
+    parser.add_argument('--version', action='version', version=__version__)
+    parser.add_argument(
+        '--pdb-mmem', dest='max_mem', metavar='MAXMEM',
+        type=float, action='store',
+        help='step into the debugger when memory exceeds MAXMEM')
+    parser.add_argument(
+        '--precision', dest='precision', type=int,
+        action='store', default=3,
+        help='precision of memory output in number of significant digits')
+    parser.add_argument('-o', dest='out_filename', type=str,
+        action='store', default=None,
+        help='path to a file where results will be written')
+    parser.add_argument('--timestamp', dest='timestamp', default=False,
+        action='store_true',
+        help='''print timestamp instead of memory measurement for
+        decorated functions''')
+    parser.add_argument('--include-children', dest='include_children',
+        default=False, action='store_true',
+        help='also include memory used by child processes')
+    parser.add_argument('--backend', dest='backend', type=str, action='store',
+        choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
+        help='backend using for getting memory info '
+             '(one of the {tracemalloc, psutil, posix})')
+    parser.add_argument(""program"", nargs=REMAINDER,
+        help='python script or module followed by command line arguements to run')
+    args = parser.parse_args()
+
+    if len(args.program) == 0:
+        print(""A program to run must be provided. Use -h for help"")
+        sys.exit(1)
+
+    target = args.program[0]
+    script_args = args.program[1:]
+    _backend = choose_backend(args.backend)
+    if args.timestamp:
+        prof = TimeStamper(_backend, include_children=args.include_children)
+    else:
+        prof = LineProfiler(max_mem=args.max_mem, backend=_backend)
+
+    try:
+        if args.program[0].endswith('.py'):
+            script_filename = _find_script(args.program[0])
+            exec_with_profiler(script_filename, prof, args.backend, script_args)
+        else:
+            run_module_with_profiler(target, prof, args.backend, script_args)
+    finally:
+        if args.out_filename is not None:
+            out_file = open(args.out_filename, ""a"")
+        else:
+            out_file = sys.stdout
+
+        if args.timestamp:
+            prof.show_results(stream=out_file)
+        else:
+            show_results(prof, precision=args.precision, stream=out_file)
","@@ -5,31 +5,22 @@ _CLEAN_GLOBALS = globals().copy()
 
 __version__ = '0.57.0'
 
+_CMD_USAGE = ""python -m memory_profiler script_file.py""
 
-from functools import wraps
+from asyncio import coroutine, iscoroutinefunction
+from contextlib import contextmanager
+from functools import partial, wraps
+import builtins
 import inspect
+import linecache
 import logging
 import os
+import pdb
 import subprocess
 import sys
 import time
 import traceback
 import warnings
-import contextlib
-
-from .code_map import CodeMap
-from .common import PY2, PY34, HAS_TRACEMALLOC
-from .utils import (
-    show_results,
-    choose_backend,
-    get_memory as _get_memory,
-    get_child_memory as _get_child_memory,
-)
-from .line_profiler import LineProfiler, get_profile_wrapper
-
-if PY34:
-    from ._async import get_profile_wrapper
-
 
 if sys.platform == ""win32"":
     # any value except signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT
@@ -54,17 +45,17 @@ except ImportError:
     line_cell_magic = lambda func: func
     magics_class = lambda cls: cls
 
-if PY2:
-    import __builtin__ as builtins
-    to_str = lambda x: x
-    from future_builtins import filter
-else:
-    import builtins
-    to_str = lambda x: str(x)
+_TWO_20 = float(2 ** 20)
 
-if HAS_TRACEMALLOC:
+
+# .. get available packages ..
+try:
     import tracemalloc
 
+    has_tracemalloc = True
+except ImportError:
+    has_tracemalloc = False
+
 
 class MemitResult(object):
     """"""memit magic run details.
@@ -91,6 +82,108 @@ class MemitResult(object):
         p.text(u'<MemitResult : ' + msg + u'>')
 
 
+def _get_child_memory(process, meminfo_attr=None):
+    """"""
+    Returns a generator that yields memory for all child processes.
+    """"""
+    # Convert a pid to a process
+    if isinstance(process, int):
+        if process == -1: process = os.getpid()
+        process = psutil.Process(process)
+
+    if not meminfo_attr:
+        # Use the psutil 2.0 attr if the older version isn't passed in.
+        meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
+
+    # Select the psutil function get the children similar to how we selected
+    # the memory_info attr (a change from excepting the AttributeError).
+    children_attr = 'children' if hasattr(process, 'children') else 'get_children'
+
+    # Loop over the child processes and yield their memory
+    try:
+        for child in getattr(process, children_attr)(recursive=True):
+            yield getattr(child, meminfo_attr)()[0] / _TWO_20
+    except (psutil.NoSuchProcess, psutil.AccessDenied):
+        # https://github.com/fabianp/memory_profiler/issues/71
+        yield 0.0
+
+
+def _get_memory(pid, backend, timestamps=False, include_children=False, filename=None):
+    # .. low function to get memory consumption ..
+    if pid == -1:
+        pid = os.getpid()
+
+    def tracemalloc_tool():
+        # .. cross-platform but but requires Python 3.4 or higher ..
+        stat = next(filter(lambda item: str(item).startswith(filename),
+                           tracemalloc.take_snapshot().statistics('filename')))
+        mem = stat.size / _TWO_20
+        if timestamps:
+            return mem, time.time()
+        else:
+            return mem
+
+    def ps_util_tool():
+        # .. cross-platform but but requires psutil ..
+        process = psutil.Process(pid)
+        try:
+            # avoid using get_memory_info since it does not exists
+            # in psutil > 2.0 and accessing it will cause exception.
+            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') \
+                else 'get_memory_info'
+            mem = getattr(process, meminfo_attr)()[0] / _TWO_20
+            if include_children:
+                mem +=  sum(_get_child_memory(process, meminfo_attr))
+            if timestamps:
+                return mem, time.time()
+            else:
+                return mem
+        except psutil.AccessDenied:
+            pass
+            # continue and try to get this from ps
+
+    def posix_tool():
+        # .. scary stuff ..
+        if include_children:
+            raise NotImplementedError((
+                ""The psutil module is required to monitor the ""
+                ""memory usage of child processes.""
+            ))
+
+        warnings.warn(""psutil module not found. memory_profiler will be slow"")
+        # ..
+        # .. memory usage in MiB ..
+        # .. this should work on both Mac and Linux ..
+        # .. subprocess.check_output appeared in 2.7, using Popen ..
+        # .. for backwards compatibility ..
+        out = subprocess.Popen(['ps', 'v', '-p', str(pid)],
+                               stdout=subprocess.PIPE
+                               ).communicate()[0].split(b'\n')
+        try:
+            vsz_index = out[0].split().index(b'RSS')
+            mem = float(out[1].split()[vsz_index]) / 1024
+            if timestamps:
+                return mem, time.time()
+            else:
+                return mem
+        except:
+            if timestamps:
+                return -1, time.time()
+            else:
+                return -1
+
+    if backend == 'tracemalloc' and \
+            (filename is None or filename == '<unknown>'):
+        raise RuntimeError(
+            'There is no access to source file of the profiled function'
+        )
+
+    tools = {'tracemalloc': tracemalloc_tool,
+             'psutil': ps_util_tool,
+             'posix': posix_tool}
+    return tools[backend]()
+
+
 class MemTimer(Process):
     """"""
     Fetch memory consumption from over a time interval
@@ -180,10 +273,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         to this file instead of stored in memory and returned at the end of
         the subprocess. Useful for long-running processes.
         Implies timestamps=True.
-        
+
     max_iterations : int
         Limits the number of iterations (calls to the process being monitored). Relevent
-        when the process is a python function. 
+        when the process is a python function.
 
     Returns
     -------
@@ -257,7 +350,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 raise
 
             p.join(5 * interval)
-            
+
             if (n_measurements > 4) or (current_iter == max_iter) or (interval < 1e-6):
                 break
             interval /= 10.
@@ -348,17 +441,36 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 # .. utility functions for line-by-line ..
 
 
+def _find_script(script_name):
+    """""" Find the script.
+
+    If the input is not a file, then $PATH will be searched.
+    """"""
+    if os.path.isfile(script_name):
+        return script_name
+    path = os.getenv('PATH', os.defpath).split(os.pathsep)
+    for folder in path:
+        if not folder:
+            continue
+        fn = os.path.join(folder, script_name)
+        if os.path.isfile(fn):
+            return fn
+
+    sys.stderr.write('Could not find script {0}\n'.format(script_name))
+    raise SystemExit(1)
 
 
 class _TimeStamperCM(object):
     """"""Time-stamping context manager.""""""
 
-    def __init__(self, timestamps, filename, backend, timestamper=None, func=None):
+    def __init__(self, timestamps, filename, backend, timestamper=None, func=None,
+                 include_children=False):
         self.timestamps = timestamps
         self.filename = filename
         self.backend = backend
         self.ts = timestamper
         self.func = func
+        self.include_children = include_children
 
     def __enter__(self):
         if self.ts is not None:
@@ -366,14 +478,16 @@ class _TimeStamperCM(object):
             self.ts.stack[self.func].append(self.ts.current_stack_level)
 
         self.timestamps.append(
-            _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
+            _get_memory(os.getpid(), self.backend, timestamps=True,
+                        include_children=self.include_children, filename=self.filename))
 
     def __exit__(self, *args):
         if self.ts is not None:
             self.ts.current_stack_level -= 1
 
         self.timestamps.append(
-            _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
+            _get_memory(os.getpid(), self.backend, timestamps=True,
+                        include_children=self.include_children, filename=self.filename))
 
 
 class TimeStamper:
@@ -381,9 +495,10 @@ class TimeStamper:
     any decorated function.
     """"""
 
-    def __init__(self, backend):
+    def __init__(self, backend, include_children=False):
         self.functions = {}
         self.backend = backend
+        self.include_children = include_children
         self.current_stack_level = -1
         self.stack = {}
 
@@ -444,7 +559,8 @@ class TimeStamper:
             except TypeError:
                 filename = '<unknown>'
             timestamps = [
-                _get_memory(os.getpid(), self.backend, timestamps=True, filename=filename)]
+                _get_memory(os.getpid(), self.backend, timestamps=True,
+                            include_children=self.include_children, filename=filename)]
             self.functions[func].append(timestamps)
             try:
                 with self.call_on_stack(func, *args, **kwds) as result:
@@ -452,11 +568,12 @@ class TimeStamper:
             finally:
                 # end time
                 timestamps.append(_get_memory(os.getpid(), self.backend, timestamps=True,
+                                              include_children=self.include_children,
                                               filename=filename))
 
         return f
 
-    @contextlib.contextmanager
+    @contextmanager
     def call_on_stack(self, func, *args, **kwds):
         self.current_stack_level += 1
         self.stack[func].append(self.current_stack_level)
@@ -476,6 +593,252 @@ class TimeStamper:
                     (function_name,) + ts[0] + ts[1] + (level,)))
 
 
+class CodeMap(dict):
+    def __init__(self, include_children, backend):
+        self.include_children = include_children
+        self._toplevel = []
+        self.backend = backend
+
+    def add(self, code, toplevel_code=None):
+        if code in self:
+            return
+
+        if toplevel_code is None:
+            filename = code.co_filename
+            if filename.endswith(("".pyc"", "".pyo"")):
+                filename = filename[:-1]
+            if not os.path.exists(filename):
+                print('ERROR: Could not find file ' + filename)
+                if filename.startswith((""ipython-input"", ""<ipython-input"")):
+                    print(
+                        ""NOTE: %mprun can only be used on functions defined in""
+                        "" physical files, and not in the IPython environment."")
+                return
+
+            toplevel_code = code
+            (sub_lines, start_line) = inspect.getsourcelines(code)
+            linenos = range(start_line,
+                            start_line + len(sub_lines))
+            self._toplevel.append((filename, code, linenos))
+            self[code] = {}
+        else:
+            self[code] = self[toplevel_code]
+
+        for subcode in filter(inspect.iscode, code.co_consts):
+            self.add(subcode, toplevel_code=toplevel_code)
+
+    def trace(self, code, lineno, prev_lineno):
+        memory = _get_memory(-1, self.backend, include_children=self.include_children,
+                             filename=code.co_filename)
+        prev_value = self[code].get(lineno, None)
+        previous_memory = prev_value[1] if prev_value else 0
+        previous_inc = prev_value[0] if prev_value else 0
+
+        prev_line_value = self[code].get(prev_lineno, None) if prev_lineno else None
+        prev_line_memory = prev_line_value[1] if prev_line_value else 0
+        occ_count = self[code][lineno][2] + 1 if lineno in self[code] else 1
+        self[code][lineno] = (
+            previous_inc + (memory - prev_line_memory),
+            max(memory, previous_memory),
+            occ_count,
+        )
+
+    def items(self):
+        """"""Iterate on the toplevel code blocks.""""""
+        for (filename, code, linenos) in self._toplevel:
+            measures = self[code]
+            if not measures:
+                continue  # skip if no measurement
+            line_iterator = ((line, measures.get(line)) for line in linenos)
+            yield (filename, line_iterator)
+
+
+class LineProfiler(object):
+    """""" A profiler that records the amount of memory for each line """"""
+
+    def __init__(self, **kw):
+        include_children = kw.get('include_children', False)
+        backend = kw.get('backend', 'psutil')
+        self.code_map = CodeMap(
+            include_children=include_children, backend=backend)
+        self.enable_count = 0
+        self.max_mem = kw.get('max_mem', None)
+        self.prevlines = []
+        self.backend = choose_backend(kw.get('backend', None))
+        self.prev_lineno = None
+
+    def __call__(self, func=None, precision=1):
+        if func is not None:
+            self.add_function(func)
+            f = self.wrap_function(func)
+            f.__module__ = func.__module__
+            f.__name__ = func.__name__
+            f.__doc__ = func.__doc__
+            f.__dict__.update(getattr(func, '__dict__', {}))
+            return f
+        else:
+            def inner_partial(f):
+                return self.__call__(f, precision=precision)
+
+            return inner_partial
+
+    def add_function(self, func):
+        """""" Record line profiling information for the given Python function.
+        """"""
+        try:
+            # func_code does not exist in Python3
+            code = func.__code__
+        except AttributeError:
+            warnings.warn(""Could not extract a code object for the object %r""
+                          % func)
+        else:
+            self.code_map.add(code)
+
+    @contextmanager
+    def _count_ctxmgr(self):
+        self.enable_by_count()
+        try:
+            yield
+        finally:
+            self.disable_by_count()
+
+    def wrap_function(self, func):
+        """""" Wrap a function to profile it.
+        """"""
+
+        if iscoroutinefunction(func):
+            @coroutine
+            def f(*args, **kwargs):
+                with self._count_ctxmgr():
+                    yield from func(*args, **kwargs)
+        else:
+            def f(*args, **kwds):
+                with self._count_ctxmgr():
+                    return func(*args, **kwds)
+
+        return f
+
+    def runctx(self, cmd, globals, locals):
+        """""" Profile a single executable statement in the given namespaces.
+        """"""
+        self.enable_by_count()
+        try:
+            exec(cmd, globals, locals)
+        finally:
+            self.disable_by_count()
+        return self
+
+    def enable_by_count(self):
+        """""" Enable the profiler if it hasn't been enabled before.
+        """"""
+        if self.enable_count == 0:
+            self.enable()
+        self.enable_count += 1
+
+    def disable_by_count(self):
+        """""" Disable the profiler if the number of disable requests matches the
+        number of enable requests.
+        """"""
+        if self.enable_count > 0:
+            self.enable_count -= 1
+            if self.enable_count == 0:
+                self.disable()
+
+    def trace_memory_usage(self, frame, event, arg):
+        """"""Callback for sys.settrace""""""
+        if frame.f_code in self.code_map:
+            if event == 'call':
+                # ""call"" event just saves the lineno but not the memory
+                self.prevlines.append(frame.f_lineno)
+            elif event == 'line':
+                # trace needs current line and previous line
+                self.code_map.trace(frame.f_code, self.prevlines[-1], self.prev_lineno)
+                # saving previous line
+                self.prev_lineno = self.prevlines[-1]
+                self.prevlines[-1] = frame.f_lineno
+            elif event == 'return':
+                lineno = self.prevlines.pop()
+                self.code_map.trace(frame.f_code, lineno, self.prev_lineno)
+                self.prev_lineno = lineno
+
+        if self._original_trace_function is not None:
+            self._original_trace_function(frame, event, arg)
+
+        return self.trace_memory_usage
+
+    def trace_max_mem(self, frame, event, arg):
+        # run into PDB as soon as memory is higher than MAX_MEM
+        if event in ('line', 'return') and frame.f_code in self.code_map:
+            c = _get_memory(-1, self.backend, filename=frame.f_code.co_filename)
+            if c >= self.max_mem:
+                t = ('Current memory {0:.2f} MiB exceeded the '
+                     'maximum of {1:.2f} MiB\n'.format(c, self.max_mem))
+                sys.stdout.write(t)
+                sys.stdout.write('Stepping into the debugger \n')
+                frame.f_lineno -= 2
+                p = pdb.Pdb()
+                p.quitting = False
+                p.stopframe = frame
+                p.returnframe = None
+                p.stoplineno = frame.f_lineno - 3
+                p.botframe = None
+                return p.trace_dispatch
+
+        if self._original_trace_function is not None:
+            (self._original_trace_function)(frame, event, arg)
+
+        return self.trace_max_mem
+
+    def __enter__(self):
+        self.enable_by_count()
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        self.disable_by_count()
+
+    def enable(self):
+        self._original_trace_function = sys.gettrace()
+        if self.max_mem is not None:
+            sys.settrace(self.trace_max_mem)
+        else:
+            sys.settrace(self.trace_memory_usage)
+
+    def disable(self):
+        sys.settrace(self._original_trace_function)
+
+
+def show_results(prof, stream=None, precision=1):
+    if stream is None:
+        stream = sys.stdout
+    template = '{0:>6} {1:>12} {2:>12}  {3:>10}   {4:<}'
+
+    for (filename, lines) in prof.code_map.items():
+        header = template.format('Line #', 'Mem usage', 'Increment', 'Occurences',
+                                 'Line Contents')
+
+        stream.write(u'Filename: ' + filename + '\n\n')
+        stream.write(header + u'\n')
+        stream.write(u'=' * len(header) + '\n')
+
+        all_lines = linecache.getlines(filename)
+
+        float_format = u'{0}.{1}f'.format(precision + 4, precision)
+        template_mem = u'{0:' + float_format + '} MiB'
+        for (lineno, mem) in lines:
+            if mem:
+                inc = mem[0]
+                total_mem = mem[1]
+                total_mem = template_mem.format(total_mem)
+                occurences = mem[2]
+                inc = template_mem.format(inc)
+            else:
+                total_mem = u''
+                inc = u''
+                occurences = u''
+            tmp = template.format(lineno, total_mem, inc, occurences, all_lines[lineno - 1])
+            stream.write(tmp)
+        stream.write(u'\n\n')
+
+
 def _func_exec(stmt, ns):
     # helper for magic_memit, just a function proxy for the exec
     # statement
@@ -758,11 +1121,29 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
     Decorator that will run the function and print a line-by-line profile
     """"""
     backend = choose_backend(backend)
-    if backend == 'tracemalloc' and HAS_TRACEMALLOC:
+    if backend == 'tracemalloc' and has_tracemalloc:
         if not tracemalloc.is_tracing():
             tracemalloc.start()
     if func is not None:
-        return get_profile_wrapper(func, precision, backend, stream)
+        get_prof = partial(LineProfiler, backend=backend)
+        show_results_bound = partial(
+            show_results, stream=stream, precision=precision
+        )
+        if iscoroutinefunction(func):
+            @coroutine
+            def wrapper(*args, **kwargs):
+                prof = get_prof()
+                val = yield from prof(func)(*args, **kwargs)
+                show_results_bound(prof)
+                return val
+        else:
+            def wrapper(*args, **kwargs):
+                prof = get_prof()
+                val = prof(func)(*args, **kwargs)
+                show_results_bound(prof)
+                return val
+
+        return wrapper
     else:
         def inner_wrapper(f):
             return profile(f, stream=stream, precision=precision,
@@ -771,32 +1152,58 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
         return inner_wrapper
 
 
+def choose_backend(new_backend=None):
+    """"""
+    Function that tries to setup backend, chosen by user, and if failed,
+    setup one of the allowable backends
+    """"""
+
+    _backend = 'no_backend'
+    all_backends = [
+        ('psutil', True),
+        ('posix', os.name == 'posix'),
+        ('tracemalloc', has_tracemalloc),
+    ]
+    backends_indices = dict((b[0], i) for i, b in enumerate(all_backends))
+
+    if new_backend is not None:
+        all_backends.insert(0, all_backends.pop(backends_indices[new_backend]))
+
+    for n_backend, is_available in all_backends:
+        if is_available:
+            _backend = n_backend
+            break
+    if _backend != new_backend and new_backend is not None:
+        warnings.warn('{0} can not be used, {1} used instead'.format(
+            new_backend, _backend))
+    return _backend
+
+
 # Insert in the built-ins to have profile
 # globally defined (global variables is not enough
 # for all cases, e.g. a script that imports another
 # script where @profile is used)
 def exec_with_profiler(filename, profiler, backend, passed_args=[]):
+    from runpy import run_module
     builtins.__dict__['profile'] = profiler
-    ns = dict(
-        _CLEAN_GLOBALS,
-        profile=profiler,
-        # Make sure the __file__ variable is usable
-        # by the script we're profiling
-        __file__=filename
-    )
+    ns = dict(_CLEAN_GLOBALS,
+              profile=profiler,
+             # Make sure the __file__ variable is usable
+             # by the script we're profiling
+              __file__=filename)
     # Make sure the script's directory in on sys.path
     # credit to line_profiler
-    sys.path.insert(0, os.path.dirname(filename))
+    sys.path.insert(0, os.path.dirname(script_filename))
 
     _backend = choose_backend(backend)
     sys.argv = [filename] + passed_args
     try:
-        if _backend == 'tracemalloc' and HAS_TRACEMALLOC:
+        if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
         with open(filename) as f:
             exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
-        if HAS_TRACEMALLOC and tracemalloc.is_tracing():
+        if has_tracemalloc and tracemalloc.is_tracing():
             tracemalloc.stop()
 
 
@@ -806,16 +1213,13 @@ def run_module_with_profiler(module, profiler, backend, passed_args=[]):
     ns = dict(_CLEAN_GLOBALS, profile=profiler)
     _backend = choose_backend(backend)
     sys.argv = [module] + passed_args
-    if PY2:
+    if _backend == 'tracemalloc' and has_tracemalloc:
+        tracemalloc.start()
+    try:
         run_module(module, run_name=""__main__"", init_globals=ns)
-    else:
-        if _backend == 'tracemalloc' and HAS_TRACEMALLOC:
-            tracemalloc.start()
-        try:
-            run_module(module, run_name=""__main__"", init_globals=ns)
-        finally:
-            if HAS_TRACEMALLOC and tracemalloc.is_tracing():
-                tracemalloc.stop()
+    finally:
+        if has_tracemalloc and tracemalloc.is_tracing():
+            tracemalloc.stop()
 
 
 class LogFile(object):
@@ -848,3 +1252,64 @@ class LogFile(object):
     def flush(self):
         for handler in self.logger.handlers:
             handler.flush()
+
+
+if __name__ == '__main__':
+    from argparse import ArgumentParser, REMAINDER
+
+    parser = ArgumentParser(usage=_CMD_USAGE)
+    parser.add_argument('--version', action='version', version=__version__)
+    parser.add_argument(
+        '--pdb-mmem', dest='max_mem', metavar='MAXMEM',
+        type=float, action='store',
+        help='step into the debugger when memory exceeds MAXMEM')
+    parser.add_argument(
+        '--precision', dest='precision', type=int,
+        action='store', default=3,
+        help='precision of memory output in number of significant digits')
+    parser.add_argument('-o', dest='out_filename', type=str,
+        action='store', default=None,
+        help='path to a file where results will be written')
+    parser.add_argument('--timestamp', dest='timestamp', default=False,
+        action='store_true',
+        help='''print timestamp instead of memory measurement for
+        decorated functions''')
+    parser.add_argument('--include-children', dest='include_children',
+        default=False, action='store_true',
+        help='also include memory used by child processes')
+    parser.add_argument('--backend', dest='backend', type=str, action='store',
+        choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
+        help='backend using for getting memory info '
+             '(one of the {tracemalloc, psutil, posix})')
+    parser.add_argument(""program"", nargs=REMAINDER,
+        help='python script or module followed by command line arguements to run')
+    args = parser.parse_args()
+
+    if len(args.program) == 0:
+        print(""A program to run must be provided. Use -h for help"")
+        sys.exit(1)
+
+    target = args.program[0]
+    script_args = args.program[1:]
+    _backend = choose_backend(args.backend)
+    if args.timestamp:
+        prof = TimeStamper(_backend, include_children=args.include_children)
+    else:
+        prof = LineProfiler(max_mem=args.max_mem, backend=_backend)
+
+    try:
+        if args.program[0].endswith('.py'):
+            script_filename = _find_script(args.program[0])
+            exec_with_profiler(script_filename, prof, args.backend, script_args)
+        else:
+            run_module_with_profiler(target, prof, args.backend, script_args)
+    finally:
+        if args.out_filename is not None:
+            out_file = open(args.out_filename, ""a"")
+        else:
+            out_file = sys.stdout
+
+        if args.timestamp:
+            prof.show_results(stream=out_file)
+        else:
+            show_results(prof, precision=args.precision, stream=out_file)
",True,memory_profiler.py,True
"@@ -1,115 +0,0 @@
-import os
-import sys
-from argparse import ArgumentParser, REMAINDER
-
-from . import exec_with_profiler, run_module_with_profiler, TimeStamper, __version__
-from .line_profiler import LineProfiler
-from .utils import choose_backend, show_results
-
-
-_CMD_USAGE = ""python -m memory_profiler script_file.py""
-
-
-def _find_script(script_name):
-    """""" Find the script.
-
-    If the input is not a file, then $PATH will be searched.
-    """"""
-    if os.path.isfile(script_name):
-        return script_name
-    path = os.getenv('PATH', os.defpath).split(os.pathsep)
-    for folder in path:
-        if not folder:
-            continue
-        fn = os.path.join(folder, script_name)
-        if os.path.isfile(fn):
-            return fn
-
-    sys.stderr.write('Could not find script {0}\n'.format(script_name))
-    raise SystemExit(1)
-
-
-if __name__ == '__main__':
-    parser = ArgumentParser(usage=_CMD_USAGE)
-    parser.add_argument('--version', action='version', version=__version__)
-    parser.add_argument(
-        '--pdb-mmem',
-        dest='max_mem',
-        metavar='MAXMEM',
-        type=float,
-        action='store',
-        help='step into the debugger when memory exceeds MAXMEM'
-    )
-    parser.add_argument(
-        '--precision',
-        dest='precision',
-        type=int,
-        action='store',
-        default=3,
-        help='precision of memory output in number of significant digits'
-    )
-    parser.add_argument(
-        '-o',
-        dest='out_filename',
-        type=str,
-        action='store',
-        default=None,
-        help='path to a file where results will be written'
-    )
-    parser.add_argument(
-        '--timestamp',
-        dest='timestamp',
-        default=False,
-        action='store_true',
-        help='''print timestamp instead of memory measurement for
-        decorated functions'''
-    )
-    parser.add_argument(
-        '--backend',
-        dest='backend',
-        type=str,
-        action='store',
-        choices=['tracemalloc', 'psutil', 'posix'],
-        default='psutil',
-        help='backend using for getting memory info '
-             '(one of the {tracemalloc, psutil, posix})'
-    )
-    parser.add_argument(
-        ""program"",
-        nargs=REMAINDER,
-        help='python script or module followed by '
-             'command line arguments to run'
-    )
-    args = parser.parse_args()
-
-    if len(args.program) == 0:
-        print(""A program to run must be provided. Use -h for help"")
-        sys.exit(1)
-
-    target = args.program[0]
-    script_args = args.program[1:]
-
-    _backend = choose_backend(args.backend)
-    if args.timestamp:
-        prof = TimeStamper(_backend)
-    else:
-        prof = LineProfiler(max_mem=args.max_mem, backend=_backend)
-
-    try:
-        if args.program[0].endswith('.py'):
-            script_filename = _find_script(args.program[0])
-            exec_with_profiler(
-                script_filename, prof, args.backend, script_args
-            )
-        else:
-            run_module_with_profiler(target, prof, args.backend, script_args)
-    finally:
-        if args.out_filename is not None:
-            out_file = open(args.out_filename, ""a"")
-        else:
-            out_file = sys.stdout
-
-        if args.timestamp:
-            prof.show_results(stream=out_file)
-        else:
-            show_results(prof, precision=args.precision, stream=out_file)
","@@ -1,115 +0,0 @@
-import os
-import sys
-from argparse import ArgumentParser, REMAINDER
-
-from . import exec_with_profiler, run_module_with_profiler, TimeStamper, __version__
-from .line_profiler import LineProfiler
-from .utils import choose_backend, show_results
-
-
-_CMD_USAGE = ""python -m memory_profiler script_file.py""
-
-
-def _find_script(script_name):
-    """""" Find the script.
-
-    If the input is not a file, then $PATH will be searched.
-    """"""
-    if os.path.isfile(script_name):
-        return script_name
-    path = os.getenv('PATH', os.defpath).split(os.pathsep)
-    for folder in path:
-        if not folder:
-            continue
-        fn = os.path.join(folder, script_name)
-        if os.path.isfile(fn):
-            return fn
-
-    sys.stderr.write('Could not find script {0}\n'.format(script_name))
-    raise SystemExit(1)
-
-
-if __name__ == '__main__':
-    parser = ArgumentParser(usage=_CMD_USAGE)
-    parser.add_argument('--version', action='version', version=__version__)
-    parser.add_argument(
-        '--pdb-mmem',
-        dest='max_mem',
-        metavar='MAXMEM',
-        type=float,
-        action='store',
-        help='step into the debugger when memory exceeds MAXMEM'
-    )
-    parser.add_argument(
-        '--precision',
-        dest='precision',
-        type=int,
-        action='store',
-        default=3,
-        help='precision of memory output in number of significant digits'
-    )
-    parser.add_argument(
-        '-o',
-        dest='out_filename',
-        type=str,
-        action='store',
-        default=None,
-        help='path to a file where results will be written'
-    )
-    parser.add_argument(
-        '--timestamp',
-        dest='timestamp',
-        default=False,
-        action='store_true',
-        help='''print timestamp instead of memory measurement for
-        decorated functions'''
-    )
-    parser.add_argument(
-        '--backend',
-        dest='backend',
-        type=str,
-        action='store',
-        choices=['tracemalloc', 'psutil', 'posix'],
-        default='psutil',
-        help='backend using for getting memory info '
-             '(one of the {tracemalloc, psutil, posix})'
-    )
-    parser.add_argument(
-        ""program"",
-        nargs=REMAINDER,
-        help='python script or module followed by '
-             'command line arguments to run'
-    )
-    args = parser.parse_args()
-
-    if len(args.program) == 0:
-        print(""A program to run must be provided. Use -h for help"")
-        sys.exit(1)
-
-    target = args.program[0]
-    script_args = args.program[1:]
-
-    _backend = choose_backend(args.backend)
-    if args.timestamp:
-        prof = TimeStamper(_backend)
-    else:
-        prof = LineProfiler(max_mem=args.max_mem, backend=_backend)
-
-    try:
-        if args.program[0].endswith('.py'):
-            script_filename = _find_script(args.program[0])
-            exec_with_profiler(
-                script_filename, prof, args.backend, script_args
-            )
-        else:
-            run_module_with_profiler(target, prof, args.backend, script_args)
-    finally:
-        if args.out_filename is not None:
-            out_file = open(args.out_filename, ""a"")
-        else:
-            out_file = sys.stdout
-
-        if args.timestamp:
-            prof.show_results(stream=out_file)
-        else:
-            show_results(prof, precision=args.precision, stream=out_file)
",True,,False
"@@ -1,35 +0,0 @@
-from asyncio import coroutine, iscoroutinefunction
-from functools import wraps
-
-from .line_profiler import (
-    get_profile_wrapper as default_profile_wrapper,
-    LineProfiler,
-)
-from .utils import show_results
-
-
-class CoroLineProfiler(LineProfiler):
-    def wrap_function(self, func):
-        if iscoroutinefunction(func):
-            @coroutine
-            def f(*args, **kwargs):
-                with self.count_ctxmgr():
-                    yield from func(*args, **kwargs)
-            return f
-        else:
-            return super().wrap_function(func)
-
-
-def get_profile_wrapper(func, precision, backend, stream):
-    if iscoroutinefunction(func):
-        @wraps(func)
-        @coroutine
-        def wrapper(*args, **kwargs):
-            prof = CoroLineProfiler(backend=backend)
-            val = yield from prof(func)(*args, **kwargs)
-            show_results(prof, stream=stream, precision=precision)
-            return val
-    else:
-        wrapper = default_profile_wrapper(func, precision, backend, stream)
-
-    return wrapper
","@@ -1,35 +0,0 @@
-from asyncio import coroutine, iscoroutinefunction
-from functools import wraps
-
-from .line_profiler import (
-    get_profile_wrapper as default_profile_wrapper,
-    LineProfiler,
-)
-from .utils import show_results
-
-
-class CoroLineProfiler(LineProfiler):
-    def wrap_function(self, func):
-        if iscoroutinefunction(func):
-            @coroutine
-            def f(*args, **kwargs):
-                with self.count_ctxmgr():
-                    yield from func(*args, **kwargs)
-            return f
-        else:
-            return super().wrap_function(func)
-
-
-def get_profile_wrapper(func, precision, backend, stream):
-    if iscoroutinefunction(func):
-        @wraps(func)
-        @coroutine
-        def wrapper(*args, **kwargs):
-            prof = CoroLineProfiler(backend=backend)
-            val = yield from prof(func)(*args, **kwargs)
-            show_results(prof, stream=stream, precision=precision)
-            return val
-    else:
-        wrapper = default_profile_wrapper(func, precision, backend, stream)
-
-    return wrapper
",True,,False
"@@ -1,69 +0,0 @@
-import inspect
-import os.path
-
-from .utils import get_memory
-
-
-class CodeMap(dict):
-    def __init__(self, include_children, backend):
-        self.include_children = include_children
-        self._toplevel = []
-        self.backend = backend
-
-    def add(self, code, toplevel_code=None):
-        if code in self:
-            return
-
-        if toplevel_code is None:
-            filename = code.co_filename
-            if filename.endswith(("".pyc"", "".pyo"")):
-                filename = filename[:-1]
-            if not os.path.exists(filename):
-                print('ERROR: Could not find file ' + filename)
-                if filename.startswith((""ipython-input"", ""<ipython-input"")):
-                    print(
-                        ""NOTE: %mprun can only be used on functions defined in""
-                        "" physical files, and not in the IPython environment."")
-                return
-
-            toplevel_code = code
-            (sub_lines, start_line) = inspect.getsourcelines(code)
-            linenos = range(start_line,
-                            start_line + len(sub_lines))
-            self._toplevel.append((filename, code, linenos))
-            self[code] = {}
-        else:
-            self[code] = self[toplevel_code]
-
-        for subcode in filter(inspect.iscode, code.co_consts):
-            self.add(subcode, toplevel_code=toplevel_code)
-
-    def trace(self, code, lineno, prev_lineno):
-        memory = get_memory(
-            -1,
-            self.backend,
-            include_children=self.include_children,
-            filename=code.co_filename
-        )
-        prev_value = self[code].get(lineno, None)
-        previous_memory = prev_value[1] if prev_value else 0
-        previous_inc = prev_value[0] if prev_value else 0
-
-        prev_line_value = (
-            self[code].get(prev_lineno, None)
-            if prev_lineno else None
-        )
-        prev_line_memory = prev_line_value[1] if prev_line_value else 0
-        self[code][lineno] = (
-            max(previous_inc, memory-prev_line_memory),
-            max(memory, previous_memory)
-        )
-
-    def items(self):
-        """"""Iterate on the toplevel code blocks.""""""
-        for (filename, code, linenos) in self._toplevel:
-            measures = self[code]
-            if not measures:
-                continue  # skip if no measurement
-            line_iterator = ((line, measures.get(line)) for line in linenos)
-            yield (filename, line_iterator)
","@@ -1,69 +0,0 @@
-import inspect
-import os.path
-
-from .utils import get_memory
-
-
-class CodeMap(dict):
-    def __init__(self, include_children, backend):
-        self.include_children = include_children
-        self._toplevel = []
-        self.backend = backend
-
-    def add(self, code, toplevel_code=None):
-        if code in self:
-            return
-
-        if toplevel_code is None:
-            filename = code.co_filename
-            if filename.endswith(("".pyc"", "".pyo"")):
-                filename = filename[:-1]
-            if not os.path.exists(filename):
-                print('ERROR: Could not find file ' + filename)
-                if filename.startswith((""ipython-input"", ""<ipython-input"")):
-                    print(
-                        ""NOTE: %mprun can only be used on functions defined in""
-                        "" physical files, and not in the IPython environment."")
-                return
-
-            toplevel_code = code
-            (sub_lines, start_line) = inspect.getsourcelines(code)
-            linenos = range(start_line,
-                            start_line + len(sub_lines))
-            self._toplevel.append((filename, code, linenos))
-            self[code] = {}
-        else:
-            self[code] = self[toplevel_code]
-
-        for subcode in filter(inspect.iscode, code.co_consts):
-            self.add(subcode, toplevel_code=toplevel_code)
-
-    def trace(self, code, lineno, prev_lineno):
-        memory = get_memory(
-            -1,
-            self.backend,
-            include_children=self.include_children,
-            filename=code.co_filename
-        )
-        prev_value = self[code].get(lineno, None)
-        previous_memory = prev_value[1] if prev_value else 0
-        previous_inc = prev_value[0] if prev_value else 0
-
-        prev_line_value = (
-            self[code].get(prev_lineno, None)
-            if prev_lineno else None
-        )
-        prev_line_memory = prev_line_value[1] if prev_line_value else 0
-        self[code][lineno] = (
-            max(previous_inc, memory-prev_line_memory),
-            max(memory, previous_memory)
-        )
-
-    def items(self):
-        """"""Iterate on the toplevel code blocks.""""""
-        for (filename, code, linenos) in self._toplevel:
-            measures = self[code]
-            if not measures:
-                continue  # skip if no measurement
-            line_iterator = ((line, measures.get(line)) for line in linenos)
-            yield (filename, line_iterator)
",True,,False
"@@ -1,15 +0,0 @@
-import sys
-
-
-PY2 = sys.version_info[0] == 2
-
-PY34 = (3, 4) < sys.version_info
-
-try:
-    import tracemalloc  # noqa
-except ImportError:
-    HAS_TRACEMALLOC = False
-else:
-    HAS_TRACEMALLOC = True
-
-TWO_20 = float(2 ** 20)
","@@ -1,15 +0,0 @@
-import sys
-
-
-PY2 = sys.version_info[0] == 2
-
-PY34 = (3, 4) < sys.version_info
-
-try:
-    import tracemalloc  # noqa
-except ImportError:
-    HAS_TRACEMALLOC = False
-else:
-    HAS_TRACEMALLOC = True
-
-TWO_20 = float(2 ** 20)
",True,,False
"@@ -1,163 +0,0 @@
-import pdb
-import sys
-import warnings
-from contextlib import contextmanager
-from functools import wraps
-
-from .code_map import CodeMap
-from .utils import choose_backend, get_memory, show_results
-
-
-class LineProfiler(object):
-    """""" A profiler that records the amount of memory for each line """"""
-
-    def __init__(self, **kw):
-        include_children = kw.get('include_children', False)
-        backend = kw.get('backend', 'psutil')
-        self.code_map = CodeMap(
-            include_children=include_children, backend=backend)
-        self.enable_count = 0
-        self.max_mem = kw.get('max_mem', None)
-        self.prevlines = []
-        self.backend = choose_backend(kw.get('backend', None))
-        self.prev_lineno = None
-
-    def __call__(self, func=None, precision=1):
-        if func is not None:
-            self.add_function(func)
-            f = self.wrap_function(func)
-            f.__module__ = func.__module__
-            f.__name__ = func.__name__
-            f.__doc__ = func.__doc__
-            f.__dict__.update(getattr(func, '__dict__', {}))
-            return f
-        else:
-            def inner_partial(f):
-                return self.__call__(f, precision=precision)
-
-            return inner_partial
-
-    def add_function(self, func):
-        """""" Record line profiling information for the given Python function.
-        """"""
-        try:
-            # func_code does not exist in Python3
-            code = func.__code__
-        except AttributeError:
-            warnings.warn(""Could not extract a code object for the object %r""
-                          % func)
-        else:
-            self.code_map.add(code)
-
-    @contextmanager
-    def count_ctxmgr(self):
-        self.enable_by_count()
-        try:
-            yield
-        finally:
-            self.disable_by_count()
-
-    def wrap_function(self, func):
-        """""" Wrap a function to profile it.
-        """"""
-
-        def f(*args, **kwds):
-            with self.count_ctxmgr():
-                return func(*args, **kwds)
-
-        return f
-
-    def runctx(self, cmd, globals, locals):
-        """""" Profile a single executable statement in the given namespaces.
-        """"""
-        with self.count_ctxmgr():
-            exec(cmd, globals, locals)
-        return self
-
-    def enable_by_count(self):
-        """""" Enable the profiler if it hasn't been enabled before.
-        """"""
-        if self.enable_count == 0:
-            self.enable()
-        self.enable_count += 1
-
-    def disable_by_count(self):
-        """""" Disable the profiler if the number of disable requests matches the
-        number of enable requests.
-        """"""
-        if self.enable_count > 0:
-            self.enable_count -= 1
-            if self.enable_count == 0:
-                self.disable()
-
-    def trace_memory_usage(self, frame, event, arg):
-        """"""Callback for sys.settrace""""""
-        if frame.f_code in self.code_map:
-            if event == 'call':
-                # ""call"" event just saves the lineno but not the memory
-                self.prevlines.append(frame.f_lineno)
-            elif event == 'line':
-                # trace needs current line and previous line
-                self.code_map.trace(frame.f_code, self.prevlines[-1], self.prev_lineno)
-                # saving previous line
-                self.prev_lineno = self.prevlines[-1]
-                self.prevlines[-1] = frame.f_lineno
-            elif event == 'return':
-                lineno = self.prevlines.pop()
-                self.code_map.trace(frame.f_code, lineno, self.prev_lineno)
-                self.prev_lineno = lineno
-
-        if self._original_trace_function is not None:
-            self._original_trace_function(frame, event, arg)
-
-        return self.trace_memory_usage
-
-    def trace_max_mem(self, frame, event, arg):
-        # run into PDB as soon as memory is higher than MAX_MEM
-        if event in ('line', 'return') and frame.f_code in self.code_map:
-            c = get_memory(-1, self.backend, filename=frame.f_code.co_filename)
-            if c >= self.max_mem:
-                t = ('Current memory {0:.2f} MiB exceeded the '
-                     'maximum of {1:.2f} MiB\n'.format(c, self.max_mem))
-                sys.stdout.write(t)
-                sys.stdout.write('Stepping into the debugger \n')
-                frame.f_lineno -= 2
-                p = pdb.Pdb()
-                p.quitting = False
-                p.stopframe = frame
-                p.returnframe = None
-                p.stoplineno = frame.f_lineno - 3
-                p.botframe = None
-                return p.trace_dispatch
-
-        if self._original_trace_function is not None:
-            (self._original_trace_function)(frame, event, arg)
-
-        return self.trace_max_mem
-
-    def __enter__(self):
-        self.enable_by_count()
-
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        self.disable_by_count()
-
-    def enable(self):
-        self._original_trace_function = sys.gettrace()
-        if self.max_mem is not None:
-            sys.settrace(self.trace_max_mem)
-        else:
-            sys.settrace(self.trace_memory_usage)
-
-    def disable(self):
-        sys.settrace(self._original_trace_function)
-
-
-def get_profile_wrapper(func, precision, backend, stream):
-    @wraps(func)
-    def wrapper(*args, **kwargs):
-        prof = LineProfiler(backend=backend)
-        val = prof(func)(*args, **kwargs)
-        show_results(prof, stream=stream, precision=precision)
-        return val
-
-    return wrapper
","@@ -1,163 +0,0 @@
-import pdb
-import sys
-import warnings
-from contextlib import contextmanager
-from functools import wraps
-
-from .code_map import CodeMap
-from .utils import choose_backend, get_memory, show_results
-
-
-class LineProfiler(object):
-    """""" A profiler that records the amount of memory for each line """"""
-
-    def __init__(self, **kw):
-        include_children = kw.get('include_children', False)
-        backend = kw.get('backend', 'psutil')
-        self.code_map = CodeMap(
-            include_children=include_children, backend=backend)
-        self.enable_count = 0
-        self.max_mem = kw.get('max_mem', None)
-        self.prevlines = []
-        self.backend = choose_backend(kw.get('backend', None))
-        self.prev_lineno = None
-
-    def __call__(self, func=None, precision=1):
-        if func is not None:
-            self.add_function(func)
-            f = self.wrap_function(func)
-            f.__module__ = func.__module__
-            f.__name__ = func.__name__
-            f.__doc__ = func.__doc__
-            f.__dict__.update(getattr(func, '__dict__', {}))
-            return f
-        else:
-            def inner_partial(f):
-                return self.__call__(f, precision=precision)
-
-            return inner_partial
-
-    def add_function(self, func):
-        """""" Record line profiling information for the given Python function.
-        """"""
-        try:
-            # func_code does not exist in Python3
-            code = func.__code__
-        except AttributeError:
-            warnings.warn(""Could not extract a code object for the object %r""
-                          % func)
-        else:
-            self.code_map.add(code)
-
-    @contextmanager
-    def count_ctxmgr(self):
-        self.enable_by_count()
-        try:
-            yield
-        finally:
-            self.disable_by_count()
-
-    def wrap_function(self, func):
-        """""" Wrap a function to profile it.
-        """"""
-
-        def f(*args, **kwds):
-            with self.count_ctxmgr():
-                return func(*args, **kwds)
-
-        return f
-
-    def runctx(self, cmd, globals, locals):
-        """""" Profile a single executable statement in the given namespaces.
-        """"""
-        with self.count_ctxmgr():
-            exec(cmd, globals, locals)
-        return self
-
-    def enable_by_count(self):
-        """""" Enable the profiler if it hasn't been enabled before.
-        """"""
-        if self.enable_count == 0:
-            self.enable()
-        self.enable_count += 1
-
-    def disable_by_count(self):
-        """""" Disable the profiler if the number of disable requests matches the
-        number of enable requests.
-        """"""
-        if self.enable_count > 0:
-            self.enable_count -= 1
-            if self.enable_count == 0:
-                self.disable()
-
-    def trace_memory_usage(self, frame, event, arg):
-        """"""Callback for sys.settrace""""""
-        if frame.f_code in self.code_map:
-            if event == 'call':
-                # ""call"" event just saves the lineno but not the memory
-                self.prevlines.append(frame.f_lineno)
-            elif event == 'line':
-                # trace needs current line and previous line
-                self.code_map.trace(frame.f_code, self.prevlines[-1], self.prev_lineno)
-                # saving previous line
-                self.prev_lineno = self.prevlines[-1]
-                self.prevlines[-1] = frame.f_lineno
-            elif event == 'return':
-                lineno = self.prevlines.pop()
-                self.code_map.trace(frame.f_code, lineno, self.prev_lineno)
-                self.prev_lineno = lineno
-
-        if self._original_trace_function is not None:
-            self._original_trace_function(frame, event, arg)
-
-        return self.trace_memory_usage
-
-    def trace_max_mem(self, frame, event, arg):
-        # run into PDB as soon as memory is higher than MAX_MEM
-        if event in ('line', 'return') and frame.f_code in self.code_map:
-            c = get_memory(-1, self.backend, filename=frame.f_code.co_filename)
-            if c >= self.max_mem:
-                t = ('Current memory {0:.2f} MiB exceeded the '
-                     'maximum of {1:.2f} MiB\n'.format(c, self.max_mem))
-                sys.stdout.write(t)
-                sys.stdout.write('Stepping into the debugger \n')
-                frame.f_lineno -= 2
-                p = pdb.Pdb()
-                p.quitting = False
-                p.stopframe = frame
-                p.returnframe = None
-                p.stoplineno = frame.f_lineno - 3
-                p.botframe = None
-                return p.trace_dispatch
-
-        if self._original_trace_function is not None:
-            (self._original_trace_function)(frame, event, arg)
-
-        return self.trace_max_mem
-
-    def __enter__(self):
-        self.enable_by_count()
-
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        self.disable_by_count()
-
-    def enable(self):
-        self._original_trace_function = sys.gettrace()
-        if self.max_mem is not None:
-            sys.settrace(self.trace_max_mem)
-        else:
-            sys.settrace(self.trace_memory_usage)
-
-    def disable(self):
-        sys.settrace(self._original_trace_function)
-
-
-def get_profile_wrapper(func, precision, backend, stream):
-    @wraps(func)
-    def wrapper(*args, **kwargs):
-        prof = LineProfiler(backend=backend)
-        val = prof(func)(*args, **kwargs)
-        show_results(prof, stream=stream, precision=precision)
-        return val
-
-    return wrapper
",True,,False
"@@ -1,183 +0,0 @@
-import linecache
-import os
-import sys
-import warnings
-import subprocess
-import time
-
-import psutil
-
-from .common import HAS_TRACEMALLOC, PY2, TWO_20
-
-if HAS_TRACEMALLOC:
-    import tracemalloc
-
-
-if PY2:
-    def to_str(x):
-        return x
-
-    from future_builtins import filter
-else:
-    def to_str(x):
-        return str(x)
-
-
-def show_results(prof, stream=None, precision=1):
-    if stream is None:
-        stream = sys.stdout
-    template = '{0:>6} {1:>12} {2:>12}   {3:<}'
-
-    for (filename, lines) in prof.code_map.items():
-        header = template.format('Line #', 'Mem usage', 'Increment',
-                                 'Line Contents')
-
-        stream.write(u'Filename: ' + filename + '\n\n')
-        stream.write(header + u'\n')
-        stream.write(u'=' * len(header) + '\n')
-
-        all_lines = linecache.getlines(filename)
-
-        float_format = u'{0}.{1}f'.format(precision + 4, precision)
-        template_mem = u'{0:' + float_format + '} MiB'
-        for (lineno, mem) in lines:
-            if mem:
-                inc = mem[0]
-                mem = mem[1]
-                mem = template_mem.format(mem)
-                inc = template_mem.format(inc)
-            else:
-                mem = u''
-                inc = u''
-            tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
-            stream.write(to_str(tmp))
-        stream.write(u'\n\n')
-
-
-def choose_backend(new_backend=None):
-    """"""
-    Function that tries to setup backend, chosen by user, and if failed,
-    setup one of the allowable backends
-    """"""
-
-    _backend = 'no_backend'
-    all_backends = [
-        ('psutil', True),
-        ('posix', os.name == 'posix'),
-        ('tracemalloc', HAS_TRACEMALLOC),
-    ]
-    backends_indices = dict((b[0], i) for i, b in enumerate(all_backends))
-
-    if new_backend is not None:
-        all_backends.insert(0, all_backends.pop(backends_indices[new_backend]))
-
-    for n_backend, is_available in all_backends:
-        if is_available:
-            _backend = n_backend
-            break
-    if _backend != new_backend and new_backend is not None:
-        warnings.warn('{0} can not be used, {1} used instead'.format(
-            new_backend, _backend))
-    return _backend
-
-
-def get_child_memory(process, meminfo_attr=None):
-    """"""
-    Returns a generator that yields memory for all child processes.
-    """"""
-    # Convert a pid to a process
-    if isinstance(process, int):
-        if process == -1: process = os.getpid()
-        process = psutil.Process(process)
-
-    if not meminfo_attr:
-        # Use the psutil 2.0 attr if the older version isn't passed in.
-        meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
-
-    # Select the psutil function get the children similar to how we selected
-    # the memory_info attr (a change from excepting the AttributeError).
-    children_attr = 'children' if hasattr(process, 'children') else 'get_children'
-
-    # Loop over the child processes and yield their memory
-    try:
-        for child in getattr(process, children_attr)(recursive=True):
-            yield getattr(child, meminfo_attr)()[0] / TWO_20
-    except (psutil.NoSuchProcess, psutil.AccessDenied):
-        # https://github.com/fabianp/memory_profiler/issues/71
-        yield 0.0
-
-
-def get_memory(pid, backend, timestamps=False, include_children=False, filename=None):
-    # .. low function to get memory consumption ..
-    if pid == -1:
-        pid = os.getpid()
-
-    def tracemalloc_tool():
-        # .. cross-platform but but requires Python 3.4 or higher ..
-        stat = next(filter(lambda item: str(item).startswith(filename),
-                           tracemalloc.take_snapshot().statistics('filename')))
-        mem = stat.size / TWO_20
-        if timestamps:
-            return mem, time.time()
-        else:
-            return mem
-
-    def ps_util_tool():
-        # .. cross-platform but but requires psutil ..
-        process = psutil.Process(pid)
-        try:
-            # avoid using get_memory_info since it does not exists
-            # in psutil > 2.0 and accessing it will cause exception.
-            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') \
-                else 'get_memory_info'
-            mem = getattr(process, meminfo_attr)()[0] / TWO_20
-            if include_children:
-                mem += sum(get_child_memory(process, meminfo_attr))
-            if timestamps:
-                return mem, time.time()
-            else:
-                return mem
-        except psutil.AccessDenied:
-            pass
-            # continue and try to get this from ps
-
-    def posix_tool():
-        # .. scary stuff ..
-        if include_children:
-            raise NotImplementedError((
-                ""The psutil module is required to monitor the ""
-                ""memory usage of child processes.""
-            ))
-
-        warnings.warn(""psutil module not found. memory_profiler will be slow"")
-        # ..
-        # .. memory usage in MiB ..
-        # .. this should work on both Mac and Linux ..
-        # .. subprocess.check_output appeared in 2.7, using Popen ..
-        # .. for backwards compatibility ..
-        out = subprocess.Popen(['ps', 'v', '-p', str(pid)],
-                               stdout=subprocess.PIPE
-                               ).communicate()[0].split(b'\n')
-        try:
-            vsz_index = out[0].split().index(b'RSS')
-            mem = float(out[1].split()[vsz_index]) / 1024
-            if timestamps:
-                return mem, time.time()
-            else:
-                return mem
-        except:
-            if timestamps:
-                return -1, time.time()
-            else:
-                return -1
-
-    if backend == 'tracemalloc' and \
-            (filename is None or filename == '<unknown>'):
-        raise RuntimeError(
-            'There is no access to source file of the profiled function'
-        )
-
-    tools = {'tracemalloc': tracemalloc_tool,
-             'psutil': ps_util_tool,
-             'posix': posix_tool}
-    return tools[backend]()
","@@ -1,183 +0,0 @@
-import linecache
-import os
-import sys
-import warnings
-import subprocess
-import time
-
-import psutil
-
-from .common import HAS_TRACEMALLOC, PY2, TWO_20
-
-if HAS_TRACEMALLOC:
-    import tracemalloc
-
-
-if PY2:
-    def to_str(x):
-        return x
-
-    from future_builtins import filter
-else:
-    def to_str(x):
-        return str(x)
-
-
-def show_results(prof, stream=None, precision=1):
-    if stream is None:
-        stream = sys.stdout
-    template = '{0:>6} {1:>12} {2:>12}   {3:<}'
-
-    for (filename, lines) in prof.code_map.items():
-        header = template.format('Line #', 'Mem usage', 'Increment',
-                                 'Line Contents')
-
-        stream.write(u'Filename: ' + filename + '\n\n')
-        stream.write(header + u'\n')
-        stream.write(u'=' * len(header) + '\n')
-
-        all_lines = linecache.getlines(filename)
-
-        float_format = u'{0}.{1}f'.format(precision + 4, precision)
-        template_mem = u'{0:' + float_format + '} MiB'
-        for (lineno, mem) in lines:
-            if mem:
-                inc = mem[0]
-                mem = mem[1]
-                mem = template_mem.format(mem)
-                inc = template_mem.format(inc)
-            else:
-                mem = u''
-                inc = u''
-            tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
-            stream.write(to_str(tmp))
-        stream.write(u'\n\n')
-
-
-def choose_backend(new_backend=None):
-    """"""
-    Function that tries to setup backend, chosen by user, and if failed,
-    setup one of the allowable backends
-    """"""
-
-    _backend = 'no_backend'
-    all_backends = [
-        ('psutil', True),
-        ('posix', os.name == 'posix'),
-        ('tracemalloc', HAS_TRACEMALLOC),
-    ]
-    backends_indices = dict((b[0], i) for i, b in enumerate(all_backends))
-
-    if new_backend is not None:
-        all_backends.insert(0, all_backends.pop(backends_indices[new_backend]))
-
-    for n_backend, is_available in all_backends:
-        if is_available:
-            _backend = n_backend
-            break
-    if _backend != new_backend and new_backend is not None:
-        warnings.warn('{0} can not be used, {1} used instead'.format(
-            new_backend, _backend))
-    return _backend
-
-
-def get_child_memory(process, meminfo_attr=None):
-    """"""
-    Returns a generator that yields memory for all child processes.
-    """"""
-    # Convert a pid to a process
-    if isinstance(process, int):
-        if process == -1: process = os.getpid()
-        process = psutil.Process(process)
-
-    if not meminfo_attr:
-        # Use the psutil 2.0 attr if the older version isn't passed in.
-        meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
-
-    # Select the psutil function get the children similar to how we selected
-    # the memory_info attr (a change from excepting the AttributeError).
-    children_attr = 'children' if hasattr(process, 'children') else 'get_children'
-
-    # Loop over the child processes and yield their memory
-    try:
-        for child in getattr(process, children_attr)(recursive=True):
-            yield getattr(child, meminfo_attr)()[0] / TWO_20
-    except (psutil.NoSuchProcess, psutil.AccessDenied):
-        # https://github.com/fabianp/memory_profiler/issues/71
-        yield 0.0
-
-
-def get_memory(pid, backend, timestamps=False, include_children=False, filename=None):
-    # .. low function to get memory consumption ..
-    if pid == -1:
-        pid = os.getpid()
-
-    def tracemalloc_tool():
-        # .. cross-platform but but requires Python 3.4 or higher ..
-        stat = next(filter(lambda item: str(item).startswith(filename),
-                           tracemalloc.take_snapshot().statistics('filename')))
-        mem = stat.size / TWO_20
-        if timestamps:
-            return mem, time.time()
-        else:
-            return mem
-
-    def ps_util_tool():
-        # .. cross-platform but but requires psutil ..
-        process = psutil.Process(pid)
-        try:
-            # avoid using get_memory_info since it does not exists
-            # in psutil > 2.0 and accessing it will cause exception.
-            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') \
-                else 'get_memory_info'
-            mem = getattr(process, meminfo_attr)()[0] / TWO_20
-            if include_children:
-                mem += sum(get_child_memory(process, meminfo_attr))
-            if timestamps:
-                return mem, time.time()
-            else:
-                return mem
-        except psutil.AccessDenied:
-            pass
-            # continue and try to get this from ps
-
-    def posix_tool():
-        # .. scary stuff ..
-        if include_children:
-            raise NotImplementedError((
-                ""The psutil module is required to monitor the ""
-                ""memory usage of child processes.""
-            ))
-
-        warnings.warn(""psutil module not found. memory_profiler will be slow"")
-        # ..
-        # .. memory usage in MiB ..
-        # .. this should work on both Mac and Linux ..
-        # .. subprocess.check_output appeared in 2.7, using Popen ..
-        # .. for backwards compatibility ..
-        out = subprocess.Popen(['ps', 'v', '-p', str(pid)],
-                               stdout=subprocess.PIPE
-                               ).communicate()[0].split(b'\n')
-        try:
-            vsz_index = out[0].split().index(b'RSS')
-            mem = float(out[1].split()[vsz_index]) / 1024
-            if timestamps:
-                return mem, time.time()
-            else:
-                return mem
-        except:
-            if timestamps:
-                return -1, time.time()
-            else:
-                return -1
-
-    if backend == 'tracemalloc' and \
-            (filename is None or filename == '<unknown>'):
-        raise RuntimeError(
-            'There is no access to source file of the profiled function'
-        )
-
-    tools = {'tracemalloc': tracemalloc_tool,
-             'psutil': ps_util_tool,
-             'posix': posix_tool}
-    return tools[backend]()
",True,,False
"@@ -1,6 +1,5 @@
 language: python
 python:
-  - ""2.7""
   - ""3.4""
   - ""3.5""
   - ""3.6""
","@@ -1,6 +1,5 @@
 language: python
 python:
-  - ""2.7""
   - ""3.4""
   - ""3.5""
   - ""3.6""
",True,.travis.yml,False
"@@ -1,6 +1,4 @@
 PYTHON ?= python
-PY_34 ?= $(shell ! python -c \
-		 'import sys; print((3, 4) < sys.version_info)')
 
 .PHONY: test develop
 
","@@ -1,6 +1,4 @@
 PYTHON ?= python
-PY_34 ?= $(shell ! python -c \
-		 'import sys; print((3, 4) < sys.version_info)')
 
 .PHONY: test develop
 
",True,Makefile,False
"@@ -1,22 +1,14 @@
-import os
-import io
 import re
-from setuptools import find_packages, setup
+from setuptools import setup
 
 
 # https://packaging.python.org/guides/single-sourcing-package-version/
-def read(*names, **kwargs):
-    with io.open(
-        os.path.join(os.path.dirname(__file__), *names),
-        encoding=kwargs.get(""encoding"", ""utf8"")
-    ) as fp:
-        return fp.read()
-
-
-def find_version(*file_paths):
-    version_file = read(*file_paths)
-    version_match = re.search(r""^__version__ = ['\""]([^'\""]*)['\""]"",
-                              version_file, re.M)
+def find_version(file_paths):
+    with open(file_paths) as f:
+        version_file = f.read()
+    version_match = re.search(
+        r""^__version__ = ['\""]([^'\""]*)['\""]"", version_file, re.M
+    )
     if version_match:
         return version_match.group(1)
 
@@ -27,12 +19,7 @@ Intended Audience :: Science/Research
 Intended Audience :: Developers
 License :: OSI Approved :: BSD License
 Programming Language :: Python
-Programming Language :: Python :: 2
-Programming Language :: Python :: 2.6
-Programming Language :: Python :: 2.7
 Programming Language :: Python :: 3
-Programming Language :: Python :: 3.2
-Programming Language :: Python :: 3.3
 Topic :: Software Development
 Operating System :: POSIX
 Operating System :: Unix
@@ -44,16 +31,16 @@ setup(
     name='memory_profiler',
     description='A module for monitoring memory usage of a python program',
     long_description=open('README.rst').read(),
-    version=find_version(""memory_profiler"", ""__init__.py""),
+    version=find_version(""memory_profiler.py""),
     author='Fabian Pedregosa',
     author_email='f@bianp.net',
     url='https://github.com/pythonprofilers/memory_profiler',
-    py_modules=['mprof'],
-    packages=find_packages(include=('memory_profiler',)),
+    py_modules=['memory_profiler', 'mprof'],
     entry_points={
         'console_scripts': ['mprof = mprof:main'],
     },
     install_requires=['psutil'],
+    python_requires='>=3.4',
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='BSD'
 )
","@@ -1,22 +1,14 @@
-import os
-import io
 import re
-from setuptools import find_packages, setup
+from setuptools import setup
 
 
 # https://packaging.python.org/guides/single-sourcing-package-version/
-def read(*names, **kwargs):
-    with io.open(
-        os.path.join(os.path.dirname(__file__), *names),
-        encoding=kwargs.get(""encoding"", ""utf8"")
-    ) as fp:
-        return fp.read()
-
-
-def find_version(*file_paths):
-    version_file = read(*file_paths)
-    version_match = re.search(r""^__version__ = ['\""]([^'\""]*)['\""]"",
-                              version_file, re.M)
+def find_version(file_paths):
+    with open(file_paths) as f:
+        version_file = f.read()
+    version_match = re.search(
+        r""^__version__ = ['\""]([^'\""]*)['\""]"", version_file, re.M
+    )
     if version_match:
         return version_match.group(1)
 
@@ -27,12 +19,7 @@ Intended Audience :: Science/Research
 Intended Audience :: Developers
 License :: OSI Approved :: BSD License
 Programming Language :: Python
-Programming Language :: Python :: 2
-Programming Language :: Python :: 2.6
-Programming Language :: Python :: 2.7
 Programming Language :: Python :: 3
-Programming Language :: Python :: 3.2
-Programming Language :: Python :: 3.3
 Topic :: Software Development
 Operating System :: POSIX
 Operating System :: Unix
@@ -44,16 +31,16 @@ setup(
     name='memory_profiler',
     description='A module for monitoring memory usage of a python program',
     long_description=open('README.rst').read(),
-    version=find_version(""memory_profiler"", ""__init__.py""),
+    version=find_version(""memory_profiler.py""),
     author='Fabian Pedregosa',
     author_email='f@bianp.net',
     url='https://github.com/pythonprofilers/memory_profiler',
-    py_modules=['mprof'],
-    packages=find_packages(include=('memory_profiler',)),
+    py_modules=['memory_profiler', 'mprof'],
     entry_points={
         'console_scripts': ['mprof = mprof:main'],
     },
     install_requires=['psutil'],
+    python_requires='>=3.4',
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='BSD'
 )
",True,setup.py,True
"@@ -8,6 +8,7 @@ import time
 import math
 import logging
 import itertools
+from ast import literal_eval
 
 from collections import defaultdict
 from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormatter
@@ -15,11 +16,12 @@ from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormat
 import importlib
 import memory_profiler as mp
 
-ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"")
+ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"", ""attach"")
 help_msg = """"""
 Available commands:
 
     run      run a given command or python file
+    attach   alias for 'run --attach': attach to an existing process by pid or name
     rm       remove a given file generated by mprof
     clean    clean the current directory from files created by mprof
     list     display existing profiles, with indices
@@ -176,6 +178,16 @@ def get_cmd_line(args):
     args = [s if blanks.isdisjoint(s) else ""'"" + s + ""'"" for s in args]
     return ' '.join(args)
 
+def find_first_process(name):
+    for i in mp.psutil.process_iter():
+        if name in i.name():
+            return i
+    return None
+
+def attach_action():
+    argv = sys.argv
+    sys.argv = argv[:1] + ['--attach'] + argv[1:]
+    run_action()
 
 def run_action():
     import time, subprocess
@@ -192,6 +204,10 @@ def run_action():
     parser.add_argument(""--multiprocess"", ""-M"", dest=""multiprocess"", action=""store_true"",
                         help=""""""Monitors forked processes creating individual plots for each child (disables --python features)"""""")
     parser.add_argument(""--exit-code"", ""-E"", dest=""exit_code"", action=""store_true"", help=""""""Propagate the exit code"""""")
+    attach_arg = parser.add_argument(""--attach"", ""-a"", dest=""attach_existing"", action=""store_true"",
+                        help=""Attach to an existing process, by process name or by pid"")
+    parser.add_argument(""--timeout"", ""-t"", dest=""timeout"", action=""store"", type=int,
+                        help=""timeout in seconds for the profiling, default new process has no timeout, attach existing is 1 hour"")
     parser.add_argument(""--output"", ""-o"", dest=""filename"",
                         default=""mprofile_%s.dat"" % time.strftime(""%Y%m%d%H%M%S"", time.localtime()),
                         help=""""""File to store results in, defaults to 'mprofile_<YYYYMMDDhhmmss>.dat' in the current directory,
@@ -214,34 +230,53 @@ This file contains the process memory consumption, in Mb (one value per line).""""
 
     mprofile_output = args.filename
 
-    # .. TODO: more than one script as argument ? ..
     program = args.program
-    if program[0].endswith('.py') and not args.nopython:
-        if args.multiprocess:
-            # in multiprocessing mode you want to spawn a separate
-            # python process
+    if args.attach_existing:
+        print('attaching to existing process, using hint: {}'.format(program[0]))
+        if program[0].isdigit():
+            p = literal_eval(program[0])
+            cmd_line = get_cmd_line(program)
+        else:
+            proc = find_first_process(program[0])
+            if proc is None:
+                raise ArgumentError(attach_arg, '\nWhen attaching, program should be process name or pid.\nFailed to find a process using hint: {}'.format(program[0]))
+            
+            p = proc.pid
+            try:
+                cmd_line = proc.cmdline()
+            except:
+                cmd_line = get_cmd_line(program)
+        if args.timeout is None:
+            args.timeout = 3600
+    else:
+        print('running new process')
+        # .. TODO: more than one script as argument ? ..
+        if program[0].endswith('.py') and not args.nopython:
+            if args.multiprocess:
+                # in multiprocessing mode you want to spawn a separate
+                # python process
+                if not program[0].startswith(""python""):
+                    program.insert(0, sys.executable)
+                args.python = False
+            else:
+                args.python = True
+        if args.python:
+            print(""running as a Python program..."")
             if not program[0].startswith(""python""):
                 program.insert(0, sys.executable)
-            args.python = False
+            cmd_line = get_cmd_line(program)
+            extra_args = [""-m"", ""memory_profiler"", ""--timestamp"", ""-o"", mprofile_output]
+            if args.include_children:
+                extra_args.append(""--include-children"")
+            program[1:1] = extra_args
+            p = subprocess.Popen(program)
         else:
-            args.python = True
-    if args.python:
-        print(""running as a Python program..."")
-        if not program[0].startswith(""python""):
-            program.insert(0, sys.executable)
-        cmd_line = get_cmd_line(program)
-        extra_args = [""-m"", ""memory_profiler"", ""--timestamp"", ""-o"", mprofile_output]
-        if args.include_children:
-            extra_args.append(""--include-children"")
-        program[1:1] = extra_args
-        p = subprocess.Popen(program)
-    else:
-        cmd_line = get_cmd_line(program)
-        p = subprocess.Popen(program)
+            cmd_line = get_cmd_line(program)
+            p = subprocess.Popen(program)
 
     with open(mprofile_output, ""a"") as f:
         f.write(""CMDLINE {0}\n"".format(cmd_line))
-        mp.memory_usage(proc=p, interval=args.interval, timestamps=True,
+        mp.memory_usage(proc=p, interval=args.interval, timeout=args.timeout, timestamps=True,
                         include_children=args.include_children,
                         multiprocess=args.multiprocess, stream=f)
 
@@ -837,6 +872,7 @@ def main():
                ""clean"": clean_action,
                ""list"": list_action,
                ""run"": run_action,
+               ""attach"": attach_action,
                ""plot"": plot_action}
     actions[get_action()]()
 
","@@ -8,6 +8,7 @@ import time
 import math
 import logging
 import itertools
+from ast import literal_eval
 
 from collections import defaultdict
 from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormatter
@@ -15,11 +16,12 @@ from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormat
 import importlib
 import memory_profiler as mp
 
-ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"")
+ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"", ""attach"")
 help_msg = """"""
 Available commands:
 
     run      run a given command or python file
+    attach   alias for 'run --attach': attach to an existing process by pid or name
     rm       remove a given file generated by mprof
     clean    clean the current directory from files created by mprof
     list     display existing profiles, with indices
@@ -176,6 +178,16 @@ def get_cmd_line(args):
     args = [s if blanks.isdisjoint(s) else ""'"" + s + ""'"" for s in args]
     return ' '.join(args)
 
+def find_first_process(name):
+    for i in mp.psutil.process_iter():
+        if name in i.name():
+            return i
+    return None
+
+def attach_action():
+    argv = sys.argv
+    sys.argv = argv[:1] + ['--attach'] + argv[1:]
+    run_action()
 
 def run_action():
     import time, subprocess
@@ -192,6 +204,10 @@ def run_action():
     parser.add_argument(""--multiprocess"", ""-M"", dest=""multiprocess"", action=""store_true"",
                         help=""""""Monitors forked processes creating individual plots for each child (disables --python features)"""""")
     parser.add_argument(""--exit-code"", ""-E"", dest=""exit_code"", action=""store_true"", help=""""""Propagate the exit code"""""")
+    attach_arg = parser.add_argument(""--attach"", ""-a"", dest=""attach_existing"", action=""store_true"",
+                        help=""Attach to an existing process, by process name or by pid"")
+    parser.add_argument(""--timeout"", ""-t"", dest=""timeout"", action=""store"", type=int,
+                        help=""timeout in seconds for the profiling, default new process has no timeout, attach existing is 1 hour"")
     parser.add_argument(""--output"", ""-o"", dest=""filename"",
                         default=""mprofile_%s.dat"" % time.strftime(""%Y%m%d%H%M%S"", time.localtime()),
                         help=""""""File to store results in, defaults to 'mprofile_<YYYYMMDDhhmmss>.dat' in the current directory,
@@ -214,34 +230,53 @@ This file contains the process memory consumption, in Mb (one value per line).""""
 
     mprofile_output = args.filename
 
-    # .. TODO: more than one script as argument ? ..
     program = args.program
-    if program[0].endswith('.py') and not args.nopython:
-        if args.multiprocess:
-            # in multiprocessing mode you want to spawn a separate
-            # python process
+    if args.attach_existing:
+        print('attaching to existing process, using hint: {}'.format(program[0]))
+        if program[0].isdigit():
+            p = literal_eval(program[0])
+            cmd_line = get_cmd_line(program)
+        else:
+            proc = find_first_process(program[0])
+            if proc is None:
+                raise ArgumentError(attach_arg, '\nWhen attaching, program should be process name or pid.\nFailed to find a process using hint: {}'.format(program[0]))
+            
+            p = proc.pid
+            try:
+                cmd_line = proc.cmdline()
+            except:
+                cmd_line = get_cmd_line(program)
+        if args.timeout is None:
+            args.timeout = 3600
+    else:
+        print('running new process')
+        # .. TODO: more than one script as argument ? ..
+        if program[0].endswith('.py') and not args.nopython:
+            if args.multiprocess:
+                # in multiprocessing mode you want to spawn a separate
+                # python process
+                if not program[0].startswith(""python""):
+                    program.insert(0, sys.executable)
+                args.python = False
+            else:
+                args.python = True
+        if args.python:
+            print(""running as a Python program..."")
             if not program[0].startswith(""python""):
                 program.insert(0, sys.executable)
-            args.python = False
+            cmd_line = get_cmd_line(program)
+            extra_args = [""-m"", ""memory_profiler"", ""--timestamp"", ""-o"", mprofile_output]
+            if args.include_children:
+                extra_args.append(""--include-children"")
+            program[1:1] = extra_args
+            p = subprocess.Popen(program)
         else:
-            args.python = True
-    if args.python:
-        print(""running as a Python program..."")
-        if not program[0].startswith(""python""):
-            program.insert(0, sys.executable)
-        cmd_line = get_cmd_line(program)
-        extra_args = [""-m"", ""memory_profiler"", ""--timestamp"", ""-o"", mprofile_output]
-        if args.include_children:
-            extra_args.append(""--include-children"")
-        program[1:1] = extra_args
-        p = subprocess.Popen(program)
-    else:
-        cmd_line = get_cmd_line(program)
-        p = subprocess.Popen(program)
+            cmd_line = get_cmd_line(program)
+            p = subprocess.Popen(program)
 
     with open(mprofile_output, ""a"") as f:
         f.write(""CMDLINE {0}\n"".format(cmd_line))
-        mp.memory_usage(proc=p, interval=args.interval, timestamps=True,
+        mp.memory_usage(proc=p, interval=args.interval, timeout=args.timeout, timestamps=True,
                         include_children=args.include_children,
                         multiprocess=args.multiprocess, stream=f)
 
@@ -837,6 +872,7 @@ def main():
                ""clean"": clean_action,
                ""list"": list_action,
                ""run"": run_action,
+               ""attach"": attach_action,
                ""plot"": plot_action}
     actions[get_action()]()
 
",True,mprof.py,True
"@@ -743,7 +743,7 @@ def function_labels(dotted_function_names):
         if len(ambiguous_labels) == 0:
             break
 
-    fn_to_label = { label_state[""functions""][0] : label for label, label_state in state.items() }
+    fn_to_label = dict((label_state[""functions""][0] , label) for label, label_state in state.items())
 
     return fn_to_label
 
","@@ -743,7 +743,7 @@ def function_labels(dotted_function_names):
         if len(ambiguous_labels) == 0:
             break
 
-    fn_to_label = { label_state[""functions""][0] : label for label, label_state in state.items() }
+    fn_to_label = dict((label_state[""functions""][0] , label) for label, label_state in state.items())
 
     return fn_to_label
 
",True,mprof.py,True
"@@ -19,6 +19,7 @@ test:
 	$(PYTHON) test/test_exit_code.py
 	$(PYTHON) test/test_mprof.py
 	$(PYTHON) test/test_async.py
+	mprof run test/test_func.py
 
 develop:
 	pip install -e .
","@@ -19,6 +19,7 @@ test:
 	$(PYTHON) test/test_exit_code.py
 	$(PYTHON) test/test_mprof.py
 	$(PYTHON) test/test_async.py
+	mprof run test/test_func.py
 
 develop:
 	pip install -e .
",True,Makefile,False
"@@ -1200,7 +1200,7 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     try:
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
-        with open(filename) as f:
+        with open(filename, encoding='utf-8') as f:
             exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
         if has_tracemalloc and tracemalloc.is_tracing():
","@@ -1200,7 +1200,7 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     try:
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
-        with open(filename) as f:
+        with open(filename, encoding='utf-8') as f:
             exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
         if has_tracemalloc and tracemalloc.is_tracing():
",True,memory_profiler.py,True
"@@ -1130,6 +1130,7 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
             show_results, stream=stream, precision=precision
         )
         if iscoroutinefunction(func):
+            @wraps(wrapped=func)
             @coroutine
             def wrapper(*args, **kwargs):
                 prof = get_prof()
@@ -1137,6 +1138,7 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
                 show_results_bound(prof)
                 return val
         else:
+            @wraps(wrapped=func)
             def wrapper(*args, **kwargs):
                 prof = get_prof()
                 val = prof(func)(*args, **kwargs)
","@@ -1130,6 +1130,7 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
             show_results, stream=stream, precision=precision
         )
         if iscoroutinefunction(func):
+            @wraps(wrapped=func)
             @coroutine
             def wrapper(*args, **kwargs):
                 prof = get_prof()
@@ -1137,6 +1138,7 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
                 show_results_bound(prof)
                 return val
         else:
+            @wraps(wrapped=func)
             def wrapper(*args, **kwargs):
                 prof = get_prof()
                 val = prof(func)(*args, **kwargs)
",True,memory_profiler.py,True
"@@ -0,0 +1,12 @@
+from memory_profiler import profile
+
+
+@profile
+def test_with_profile(arg1):
+    """"""dummy doc""""""
+    return None
+
+
+if __name__ == '__main__':
+    assert test_with_profile.__doc__ == ""dummy doc""
+    assert test_with_profile.__name__ == ""test_with_profile""
","@@ -0,0 +1,12 @@
+from memory_profiler import profile
+
+
+@profile
+def test_with_profile(arg1):
+    """"""dummy doc""""""
+    return None
+
+
+if __name__ == '__main__':
+    assert test_with_profile.__doc__ == ""dummy doc""
+    assert test_with_profile.__name__ == ""test_with_profile""
",True,test/test_attributes.py,True
"@@ -16,7 +16,7 @@ from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormat
 import importlib
 import memory_profiler as mp
 
-ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"", ""attach"")
+ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"", ""attach"", ""peak"")
 help_msg = """"""
 Available commands:
 
@@ -26,6 +26,7 @@ Available commands:
     clean    clean the current directory from files created by mprof
     list     display existing profiles, with indices
     plot     plot memory consumption generated by mprof run
+    peak     print the maximum memory used by an mprof run
 
 Type mprof <command> --help for usage help on a specific command.
 For example, mprof plot --help will list all plotting options.
@@ -794,33 +795,7 @@ such file in the current directory.""""""
         sys.exit(1)
     pl.ioff()
 
-    profiles = glob.glob(""mprofile_??????????????.dat"")
-    profiles.sort()
-
-    if len(args.profiles) == 0:
-        if len(profiles) == 0:
-            print(""No input file found. \nThis program looks for ""
-                  ""mprofile_*.dat files, generated by the ""
-                  ""'mprof run' command."")
-            sys.exit(-1)
-        print(""Using last profile data."")
-        filenames = [profiles[-1]]
-    else:
-        filenames = []
-        for prof in args.profiles:
-            if osp.exists(prof):
-                if not prof in filenames:
-                    filenames.append(prof)
-            else:
-                try:
-                    n = int(prof)
-                    if not profiles[n] in filenames:
-                        filenames.append(profiles[n])
-                except ValueError:
-                    print(""Input file not found: "" + prof)
-    if not len(filenames):
-        print(""No files found from given input."")
-        sys.exit(-1)
+    filenames = get_profiles(args)
 
     fig = pl.figure(figsize=(14, 6), dpi=90)
     if not args.flame_mode:
@@ -860,6 +835,51 @@ such file in the current directory.""""""
     else:
         pl.show()
 
+def peak_action():
+    desc = """"""Prints the peak memory used in data file `file.dat` generated
+using `mprof run`. If no .dat file is given, it will take the most recent
+such file in the current directory.""""""
+    parser = ArgumentParser(usage=""mprof peak [options] [file.dat]"", description=desc)
+    parser.add_argument(""profiles"", nargs=""*"",
+                    help=""profiles made by mprof run"") 
+    args = parser.parse_args()
+    filenames = get_profiles(args)
+
+    for filename in filenames:
+        prof = read_mprofile_file(filename)
+        print(""{}\t{:.3f} MiB"".format(prof[""filename""], max(prof[""mem_usage""])))
+
+def get_profiles(args):
+    profiles = glob.glob(""mprofile_??????????????.dat"")
+    profiles.sort()
+
+    if len(args.profiles) == 0:
+        if len(profiles) == 0:
+            print(""No input file found. \nThis program looks for ""
+                  ""mprofile_*.dat files, generated by the ""
+                  ""'mprof run' command."")
+            sys.exit(-1)
+        print(""Using last profile data."")
+        filenames = [profiles[-1]]
+    else:
+        filenames = []
+        for prof in args.profiles:
+            if osp.exists(prof):
+                if not prof in filenames:
+                    filenames.append(prof)
+            else:
+                try:
+                    n = int(prof)
+                    if not profiles[n] in filenames:
+                        filenames.append(profiles[n])
+                except ValueError:
+                    print(""Input file not found: "" + prof)
+    if not len(filenames):
+        print(""No files found from given input."")
+        sys.exit(-1)
+
+    return filenames
+
 def main():
     # Workaround for optparse limitation: insert -- before first negative
     # number found.
@@ -873,7 +893,8 @@ def main():
                ""list"": list_action,
                ""run"": run_action,
                ""attach"": attach_action,
-               ""plot"": plot_action}
+               ""plot"": plot_action,
+               ""peak"": peak_action}
     actions[get_action()]()
 
 if __name__ == ""__main__"":
","@@ -16,7 +16,7 @@ from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormat
 import importlib
 import memory_profiler as mp
 
-ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"", ""attach"")
+ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"", ""attach"", ""peak"")
 help_msg = """"""
 Available commands:
 
@@ -26,6 +26,7 @@ Available commands:
     clean    clean the current directory from files created by mprof
     list     display existing profiles, with indices
     plot     plot memory consumption generated by mprof run
+    peak     print the maximum memory used by an mprof run
 
 Type mprof <command> --help for usage help on a specific command.
 For example, mprof plot --help will list all plotting options.
@@ -794,33 +795,7 @@ such file in the current directory.""""""
         sys.exit(1)
     pl.ioff()
 
-    profiles = glob.glob(""mprofile_??????????????.dat"")
-    profiles.sort()
-
-    if len(args.profiles) == 0:
-        if len(profiles) == 0:
-            print(""No input file found. \nThis program looks for ""
-                  ""mprofile_*.dat files, generated by the ""
-                  ""'mprof run' command."")
-            sys.exit(-1)
-        print(""Using last profile data."")
-        filenames = [profiles[-1]]
-    else:
-        filenames = []
-        for prof in args.profiles:
-            if osp.exists(prof):
-                if not prof in filenames:
-                    filenames.append(prof)
-            else:
-                try:
-                    n = int(prof)
-                    if not profiles[n] in filenames:
-                        filenames.append(profiles[n])
-                except ValueError:
-                    print(""Input file not found: "" + prof)
-    if not len(filenames):
-        print(""No files found from given input."")
-        sys.exit(-1)
+    filenames = get_profiles(args)
 
     fig = pl.figure(figsize=(14, 6), dpi=90)
     if not args.flame_mode:
@@ -860,6 +835,51 @@ such file in the current directory.""""""
     else:
         pl.show()
 
+def peak_action():
+    desc = """"""Prints the peak memory used in data file `file.dat` generated
+using `mprof run`. If no .dat file is given, it will take the most recent
+such file in the current directory.""""""
+    parser = ArgumentParser(usage=""mprof peak [options] [file.dat]"", description=desc)
+    parser.add_argument(""profiles"", nargs=""*"",
+                    help=""profiles made by mprof run"") 
+    args = parser.parse_args()
+    filenames = get_profiles(args)
+
+    for filename in filenames:
+        prof = read_mprofile_file(filename)
+        print(""{}\t{:.3f} MiB"".format(prof[""filename""], max(prof[""mem_usage""])))
+
+def get_profiles(args):
+    profiles = glob.glob(""mprofile_??????????????.dat"")
+    profiles.sort()
+
+    if len(args.profiles) == 0:
+        if len(profiles) == 0:
+            print(""No input file found. \nThis program looks for ""
+                  ""mprofile_*.dat files, generated by the ""
+                  ""'mprof run' command."")
+            sys.exit(-1)
+        print(""Using last profile data."")
+        filenames = [profiles[-1]]
+    else:
+        filenames = []
+        for prof in args.profiles:
+            if osp.exists(prof):
+                if not prof in filenames:
+                    filenames.append(prof)
+            else:
+                try:
+                    n = int(prof)
+                    if not profiles[n] in filenames:
+                        filenames.append(profiles[n])
+                except ValueError:
+                    print(""Input file not found: "" + prof)
+    if not len(filenames):
+        print(""No files found from given input."")
+        sys.exit(-1)
+
+    return filenames
+
 def main():
     # Workaround for optparse limitation: insert -- before first negative
     # number found.
@@ -873,7 +893,8 @@ def main():
                ""list"": list_action,
                ""run"": run_action,
                ""attach"": attach_action,
-               ""plot"": plot_action}
+               ""plot"": plot_action,
+               ""peak"": peak_action}
     actions[get_action()]()
 
 if __name__ == ""__main__"":
",True,mprof.py,True
"@@ -74,7 +74,7 @@ def get_profile_filenames(args):
     profiles = glob.glob(""mprofile_??????????????.dat"")
     profiles.sort()
 
-    if args is ""all"":
+    if args == ""all"":
         filenames = copy.copy(profiles)
     else:
         filenames = []
","@@ -74,7 +74,7 @@ def get_profile_filenames(args):
     profiles = glob.glob(""mprofile_??????????????.dat"")
     profiles.sort()
 
-    if args is ""all"":
+    if args == ""all"":
         filenames = copy.copy(profiles)
     else:
         filenames = []
",True,mprof.py,True
"@@ -841,13 +841,17 @@ using `mprof run`. If no .dat file is given, it will take the most recent
 such file in the current directory.""""""
     parser = ArgumentParser(usage=""mprof peak [options] [file.dat]"", description=desc)
     parser.add_argument(""profiles"", nargs=""*"",
-                    help=""profiles made by mprof run"") 
+                    help=""profiles made by mprof run"")
     args = parser.parse_args()
     filenames = get_profiles(args)
 
     for filename in filenames:
         prof = read_mprofile_file(filename)
         print(""{}\t{:.3f} MiB"".format(prof[""filename""], max(prof[""mem_usage""])))
+        for child, values in prof[""children""].items():
+            child_peak = max([ mem_ts[0] for mem_ts in values ])
+            print(""  Child {}\t\t\t{:.3f} MiB"".format(child, child_peak))
+        
 
 def get_profiles(args):
     profiles = glob.glob(""mprofile_??????????????.dat"")
","@@ -841,13 +841,17 @@ using `mprof run`. If no .dat file is given, it will take the most recent
 such file in the current directory.""""""
     parser = ArgumentParser(usage=""mprof peak [options] [file.dat]"", description=desc)
     parser.add_argument(""profiles"", nargs=""*"",
-                    help=""profiles made by mprof run"") 
+                    help=""profiles made by mprof run"")
     args = parser.parse_args()
     filenames = get_profiles(args)
 
     for filename in filenames:
         prof = read_mprofile_file(filename)
         print(""{}\t{:.3f} MiB"".format(prof[""filename""], max(prof[""mem_usage""])))
+        for child, values in prof[""children""].items():
+            child_peak = max([ mem_ts[0] for mem_ts in values ])
+            print(""  Child {}\t\t\t{:.3f} MiB"".format(child, child_peak))
+        
 
 def get_profiles(args):
     profiles = glob.glob(""mprofile_??????????????.dat"")
",True,mprof.py,True
"@@ -710,7 +710,8 @@ class LineProfiler(object):
             @coroutine
             def f(*args, **kwargs):
                 with self._count_ctxmgr():
-                    yield from func(*args, **kwargs)
+                    res = yield from func(*args, **kwargs)
+                    return res
         else:
             def f(*args, **kwds):
                 with self._count_ctxmgr():
","@@ -710,7 +710,8 @@ class LineProfiler(object):
             @coroutine
             def f(*args, **kwargs):
                 with self._count_ctxmgr():
-                    yield from func(*args, **kwargs)
+                    res = yield from func(*args, **kwargs)
+                    return res
         else:
             def f(*args, **kwds):
                 with self._count_ctxmgr():
",True,memory_profiler.py,True
"@@ -10,8 +10,10 @@ def my_func():
     b = [2] * (2 * 10 ** 7)
     yield from asyncio.sleep(1e-2)
     del b
+    return 42
 
 
 if __name__ == '__main__':
     loop = asyncio.get_event_loop()
-    loop.run_until_complete(my_func())
+    res = loop.run_until_complete(my_func())
+    assert res == 42
","@@ -10,8 +10,10 @@ def my_func():
     b = [2] * (2 * 10 ** 7)
     yield from asyncio.sleep(1e-2)
     del b
+    return 42
 
 
 if __name__ == '__main__':
     loop = asyncio.get_event_loop()
-    loop.run_until_complete(my_func())
+    res = loop.run_until_complete(my_func())
+    assert res == 42
",True,test/test_async.py,True
"@@ -1,4 +1,5 @@
 .idea
+.vscode
 dist
 build
 MANIFEST
","@@ -1,4 +1,5 @@
 .idea
+.vscode
 dist
 build
 MANIFEST
",True,.gitignore,False
"@@ -82,7 +82,7 @@ class MemitResult(object):
         p.text(u'<MemitResult : ' + msg + u'>')
 
 
-def _get_child_memory(process, meminfo_attr=None):
+def _get_child_memory(process, meminfo_attr=None, memory_metric=0):
     """"""
     Returns a generator that yields memory for all child processes.
     """"""
@@ -102,7 +102,11 @@ def _get_child_memory(process, meminfo_attr=None):
     # Loop over the child processes and yield their memory
     try:
         for child in getattr(process, children_attr)(recursive=True):
-            yield getattr(child, meminfo_attr)()[0] / _TWO_20
+            if isinstance(memory_metric, str):
+                meminfo = getattr(child, meminfo_attr)()
+                yield getattr(meminfo, memory_metric) / _TWO_20
+            else:
+                yield getattr(child, meminfo_attr)()[memory_metric] / _TWO_20
     except (psutil.NoSuchProcess, psutil.AccessDenied):
         # https://github.com/fabianp/memory_profiler/issues/71
         yield 0.0
@@ -142,6 +146,35 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
             pass
             # continue and try to get this from ps
 
+    def _ps_util_full_tool(memory_metric):
+
+        # .. cross-platform but but requires psutil ..
+        process = psutil.Process(pid)
+        try:
+            if not hasattr(process, 'memory_full_info'):
+                raise NotImplementedError(""Backend `ps_util_pss` requires psutil > 4.0.0"")
+
+            meminfo_attr = 'memory_full_info'
+            meminfo = getattr(process, meminfo_attr)()
+
+            if not hasattr(meminfo, memory_metric):
+                raise NotImplementedError(
+                    f""Metric `{memory_metric}` not available. For details, see:""
+                    f""https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info"")
+            mem = getattr(meminfo, memory_metric) / _TWO_20
+
+            if include_children:
+                mem +=  sum(_get_child_memory(process, meminfo_attr, memory_metric))
+
+            if timestamps:
+                return mem, time.time()
+            else:
+                return mem
+        
+        except psutil.AccessDenied:
+            pass
+            # continue and try to get this from ps
+
     def posix_tool():
         # .. scary stuff ..
         if include_children:
@@ -180,6 +213,8 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
 
     tools = {'tracemalloc': tracemalloc_tool,
              'psutil': ps_util_tool,
+             'psutil_pss': lambda: _ps_util_full_tool(memory_metric=""pss""),
+             'psutil_uss': lambda: _ps_util_full_tool(memory_metric=""uss""),
              'posix': posix_tool}
     return tools[backend]()
 
@@ -1164,6 +1199,8 @@ def choose_backend(new_backend=None):
     _backend = 'no_backend'
     all_backends = [
         ('psutil', True),
+        ('psutil_pss', True),
+        ('psutil_uss', True),
         ('posix', os.name == 'posix'),
         ('tracemalloc', has_tracemalloc),
     ]
","@@ -82,7 +82,7 @@ class MemitResult(object):
         p.text(u'<MemitResult : ' + msg + u'>')
 
 
-def _get_child_memory(process, meminfo_attr=None):
+def _get_child_memory(process, meminfo_attr=None, memory_metric=0):
     """"""
     Returns a generator that yields memory for all child processes.
     """"""
@@ -102,7 +102,11 @@ def _get_child_memory(process, meminfo_attr=None):
     # Loop over the child processes and yield their memory
     try:
         for child in getattr(process, children_attr)(recursive=True):
-            yield getattr(child, meminfo_attr)()[0] / _TWO_20
+            if isinstance(memory_metric, str):
+                meminfo = getattr(child, meminfo_attr)()
+                yield getattr(meminfo, memory_metric) / _TWO_20
+            else:
+                yield getattr(child, meminfo_attr)()[memory_metric] / _TWO_20
     except (psutil.NoSuchProcess, psutil.AccessDenied):
         # https://github.com/fabianp/memory_profiler/issues/71
         yield 0.0
@@ -142,6 +146,35 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
             pass
             # continue and try to get this from ps
 
+    def _ps_util_full_tool(memory_metric):
+
+        # .. cross-platform but but requires psutil ..
+        process = psutil.Process(pid)
+        try:
+            if not hasattr(process, 'memory_full_info'):
+                raise NotImplementedError(""Backend `ps_util_pss` requires psutil > 4.0.0"")
+
+            meminfo_attr = 'memory_full_info'
+            meminfo = getattr(process, meminfo_attr)()
+
+            if not hasattr(meminfo, memory_metric):
+                raise NotImplementedError(
+                    f""Metric `{memory_metric}` not available. For details, see:""
+                    f""https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info"")
+            mem = getattr(meminfo, memory_metric) / _TWO_20
+
+            if include_children:
+                mem +=  sum(_get_child_memory(process, meminfo_attr, memory_metric))
+
+            if timestamps:
+                return mem, time.time()
+            else:
+                return mem
+        
+        except psutil.AccessDenied:
+            pass
+            # continue and try to get this from ps
+
     def posix_tool():
         # .. scary stuff ..
         if include_children:
@@ -180,6 +213,8 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
 
     tools = {'tracemalloc': tracemalloc_tool,
              'psutil': ps_util_tool,
+             'psutil_pss': lambda: _ps_util_full_tool(memory_metric=""pss""),
+             'psutil_uss': lambda: _ps_util_full_tool(memory_metric=""uss""),
              'posix': posix_tool}
     return tools[backend]()
 
@@ -1164,6 +1199,8 @@ def choose_backend(new_backend=None):
     _backend = 'no_backend'
     all_backends = [
         ('psutil', True),
+        ('psutil_pss', True),
+        ('psutil_uss', True),
         ('posix', os.name == 'posix'),
         ('tracemalloc', has_tracemalloc),
     ]
",True,memory_profiler.py,True
"@@ -0,0 +1,140 @@
+from memory_profiler import memory_usage
+
+# size = 50000
+size = 3000
+
+
+def test_simple():
+
+    import numpy as np
+
+    def func():
+        a = np.random.random((size, size))
+        return a
+
+    rss = memory_usage(proc=func, max_usage=True, backend=""psutil"")
+    uss = memory_usage(proc=func, max_usage=True, backend=""psutil_uss"")
+    pss = memory_usage(proc=func, max_usage=True, backend=""psutil_pss"")
+    print(rss, uss, pss)
+
+
+def test_multiprocessing():
+
+    import numpy as np
+    import joblib
+    import time
+
+    def func():
+        n_jobs = 4
+        a = np.random.random((size, size))
+
+        def subprocess(i):
+            time.sleep(2)
+            return a[i,i]
+
+        results = joblib.Parallel(n_jobs=n_jobs)(
+            joblib.delayed(subprocess)(i) 
+            for i in range(n_jobs))
+
+        return results
+
+    rss = memory_usage(proc=func, max_usage=True, backend=""psutil"", include_children=True, multiprocess=True)
+    uss = memory_usage(proc=func, max_usage=True, backend=""psutil_uss"", include_children=True, multiprocess=True)
+    pss = memory_usage(proc=func, max_usage=True, backend=""psutil_pss"", include_children=True, multiprocess=True)
+    print(rss, uss, pss)
+
+
+def test_multiprocessing_write():
+
+    import numpy as np
+    import joblib
+    import time
+
+    def func():
+        n_jobs = 4
+        a = np.random.random((size, size))
+
+        def subprocess(i):
+            aa = a.copy()
+            time.sleep(2)
+            return aa[i,i]
+
+        results = joblib.Parallel(n_jobs=n_jobs)(
+            joblib.delayed(subprocess)(i) 
+            for i in range(n_jobs))
+
+        return results
+
+    rss = memory_usage(proc=func, max_usage=True, backend=""psutil"", include_children=True, multiprocess=True)
+    uss = memory_usage(proc=func, max_usage=True, backend=""psutil_uss"", include_children=True, multiprocess=True)
+    pss = memory_usage(proc=func, max_usage=True, backend=""psutil_pss"", include_children=True, multiprocess=True)
+    print(rss, uss, pss)
+
+
+def test_multiprocessing_showcase():
+
+    import numpy as np
+    import joblib
+    import time
+    import datetime
+
+    def func():
+
+        # n_jobs = 32
+        # size = 25000
+        # Creating data: 25000x25000 ... done (4.66 Gb). Starting processing: n_jobs=32 ... done (0:00:37.581291). RSS: 353024.01
+        # Creating data: 25000x25000 ... done (4.66 Gb). Starting processing: n_jobs=32 ... done (0:00:38.867385). USS: 148608.62
+        # Creating data: 25000x25000 ... done (4.66 Gb). Starting processing: n_jobs=32 ... done (0:00:29.049754). PSS: 169253.91
+
+        # n_jobs = 64
+        # size = 10000
+        # Creating data: 10000x10000 ... done (0.75 Gb). Starting processing: n_jobs=64 ... done (0:00:14.701243). RSS: 111362.79
+        # Creating data: 10000x10000 ... done (0.75 Gb). Starting processing: n_jobs=64 ... done (0:00:15.020202). USS: 56108.69
+        # Creating data: 10000x10000 ... done (0.75 Gb). Starting processing: n_jobs=64 ... done (0:00:15.072918). PSS: 54826.61
+        
+        # Conclusion:
+        # * RSS is overestimating like crazy (I checked the actual memory usage using htop)
+
+        n_jobs = 8
+        size = 3000
+
+        print(f""Creating data: {size}x{size} ... "", end="""")
+        a = np.random.random((size, size))
+        print(f""done ({a.size * a.itemsize / 1024**3:.02f} Gb). "", end="""")
+
+        def subprocess(i):
+            aa = a.copy()
+            r = aa[1,1]
+            aa = a.copy()
+            time.sleep(10)
+            return r
+            
+            # r = a[1,1]
+            # # time.sleep(10)
+            # return r
+            
+            pass
+
+        start = datetime.datetime.now()
+        print(f""Starting processing: n_jobs={n_jobs} ... "", end="""")
+        results = joblib.Parallel(n_jobs=n_jobs)(
+            joblib.delayed(subprocess)(i) 
+            for i in range(n_jobs))
+        print(f""done ({datetime.datetime.now() - start}). "", end="""")
+
+        return results
+
+    rss = memory_usage(proc=func, max_usage=True, backend=""psutil"", include_children=True, multiprocess=True)
+    print(f""RSS: {rss:.02f}"")
+    uss = memory_usage(proc=func, max_usage=True, backend=""psutil_uss"", include_children=True, multiprocess=True)
+    print(f""USS: {uss:.02f}"")
+    pss = memory_usage(proc=func, max_usage=True, backend=""psutil_pss"", include_children=True, multiprocess=True)
+    print(f""PSS: {pss:.02f}"")
+    print(f""RSS: {rss:.02f}, USS: {uss:.02f}, PSS: {pss:.02f}"")
+
+
+if __name__ == ""__main__"":
+    test_simple()
+    test_multiprocessing()
+    test_multiprocessing_write()
+    test_multiprocessing_showcase()
","@@ -0,0 +1,140 @@
+from memory_profiler import memory_usage
+
+# size = 50000
+size = 3000
+
+
+def test_simple():
+
+    import numpy as np
+
+    def func():
+        a = np.random.random((size, size))
+        return a
+
+    rss = memory_usage(proc=func, max_usage=True, backend=""psutil"")
+    uss = memory_usage(proc=func, max_usage=True, backend=""psutil_uss"")
+    pss = memory_usage(proc=func, max_usage=True, backend=""psutil_pss"")
+    print(rss, uss, pss)
+
+
+def test_multiprocessing():
+
+    import numpy as np
+    import joblib
+    import time
+
+    def func():
+        n_jobs = 4
+        a = np.random.random((size, size))
+
+        def subprocess(i):
+            time.sleep(2)
+            return a[i,i]
+
+        results = joblib.Parallel(n_jobs=n_jobs)(
+            joblib.delayed(subprocess)(i) 
+            for i in range(n_jobs))
+
+        return results
+
+    rss = memory_usage(proc=func, max_usage=True, backend=""psutil"", include_children=True, multiprocess=True)
+    uss = memory_usage(proc=func, max_usage=True, backend=""psutil_uss"", include_children=True, multiprocess=True)
+    pss = memory_usage(proc=func, max_usage=True, backend=""psutil_pss"", include_children=True, multiprocess=True)
+    print(rss, uss, pss)
+
+
+def test_multiprocessing_write():
+
+    import numpy as np
+    import joblib
+    import time
+
+    def func():
+        n_jobs = 4
+        a = np.random.random((size, size))
+
+        def subprocess(i):
+            aa = a.copy()
+            time.sleep(2)
+            return aa[i,i]
+
+        results = joblib.Parallel(n_jobs=n_jobs)(
+            joblib.delayed(subprocess)(i) 
+            for i in range(n_jobs))
+
+        return results
+
+    rss = memory_usage(proc=func, max_usage=True, backend=""psutil"", include_children=True, multiprocess=True)
+    uss = memory_usage(proc=func, max_usage=True, backend=""psutil_uss"", include_children=True, multiprocess=True)
+    pss = memory_usage(proc=func, max_usage=True, backend=""psutil_pss"", include_children=True, multiprocess=True)
+    print(rss, uss, pss)
+
+
+def test_multiprocessing_showcase():
+
+    import numpy as np
+    import joblib
+    import time
+    import datetime
+
+    def func():
+
+        # n_jobs = 32
+        # size = 25000
+        # Creating data: 25000x25000 ... done (4.66 Gb). Starting processing: n_jobs=32 ... done (0:00:37.581291). RSS: 353024.01
+        # Creating data: 25000x25000 ... done (4.66 Gb). Starting processing: n_jobs=32 ... done (0:00:38.867385). USS: 148608.62
+        # Creating data: 25000x25000 ... done (4.66 Gb). Starting processing: n_jobs=32 ... done (0:00:29.049754). PSS: 169253.91
+
+        # n_jobs = 64
+        # size = 10000
+        # Creating data: 10000x10000 ... done (0.75 Gb). Starting processing: n_jobs=64 ... done (0:00:14.701243). RSS: 111362.79
+        # Creating data: 10000x10000 ... done (0.75 Gb). Starting processing: n_jobs=64 ... done (0:00:15.020202). USS: 56108.69
+        # Creating data: 10000x10000 ... done (0.75 Gb). Starting processing: n_jobs=64 ... done (0:00:15.072918). PSS: 54826.61
+        
+        # Conclusion:
+        # * RSS is overestimating like crazy (I checked the actual memory usage using htop)
+
+        n_jobs = 8
+        size = 3000
+
+        print(f""Creating data: {size}x{size} ... "", end="""")
+        a = np.random.random((size, size))
+        print(f""done ({a.size * a.itemsize / 1024**3:.02f} Gb). "", end="""")
+
+        def subprocess(i):
+            aa = a.copy()
+            r = aa[1,1]
+            aa = a.copy()
+            time.sleep(10)
+            return r
+            
+            # r = a[1,1]
+            # # time.sleep(10)
+            # return r
+            
+            pass
+
+        start = datetime.datetime.now()
+        print(f""Starting processing: n_jobs={n_jobs} ... "", end="""")
+        results = joblib.Parallel(n_jobs=n_jobs)(
+            joblib.delayed(subprocess)(i) 
+            for i in range(n_jobs))
+        print(f""done ({datetime.datetime.now() - start}). "", end="""")
+
+        return results
+
+    rss = memory_usage(proc=func, max_usage=True, backend=""psutil"", include_children=True, multiprocess=True)
+    print(f""RSS: {rss:.02f}"")
+    uss = memory_usage(proc=func, max_usage=True, backend=""psutil_uss"", include_children=True, multiprocess=True)
+    print(f""USS: {uss:.02f}"")
+    pss = memory_usage(proc=func, max_usage=True, backend=""psutil_pss"", include_children=True, multiprocess=True)
+    print(f""PSS: {pss:.02f}"")
+    print(f""RSS: {rss:.02f}, USS: {uss:.02f}, PSS: {pss:.02f}"")
+
+
+if __name__ == ""__main__"":
+    test_simple()
+    test_multiprocessing()
+    test_multiprocessing_write()
+    test_multiprocessing_showcase()
",True,test/test_psutil_memory_full_info.py,True
"@@ -98,9 +98,9 @@ def test_multiprocessing_showcase():
         n_jobs = 8
         size = 3000
 
-        print(f""Creating data: {size}x{size} ... "", end="""")
+        print(""Creating data: {size}x{size} ... "".format(size=size), end="""")
         a = np.random.random((size, size))
-        print(f""done ({a.size * a.itemsize / 1024**3:.02f} Gb). "", end="""")
+        print(""done ({size:.02f} Gb). "".format(size=a.size * a.itemsize / 1024**3), end="""")
 
         def subprocess(i):
             aa = a.copy()
@@ -116,21 +116,20 @@ def test_multiprocessing_showcase():
             pass
 
         start = datetime.datetime.now()
-        print(f""Starting processing: n_jobs={n_jobs} ... "", end="""")
+        print(""Starting processing: n_jobs={n_jobs} ... "".format(n_jobs=n_jobs), end="""")
         results = joblib.Parallel(n_jobs=n_jobs)(
             joblib.delayed(subprocess)(i) 
             for i in range(n_jobs))
-        print(f""done ({datetime.datetime.now() - start}). "", end="""")
+        print(""done ({}). "".format(datetime.datetime.now() - start), end="""")
 
         return results
 
     rss = memory_usage(proc=func, max_usage=True, backend=""psutil"", include_children=True, multiprocess=True)
-    print(f""RSS: {rss:.02f}"")
+    print(""RSS: {rss:.02f}"".format(rss=rss))
     uss = memory_usage(proc=func, max_usage=True, backend=""psutil_uss"", include_children=True, multiprocess=True)
-    print(f""USS: {uss:.02f}"")
+    print(""USS: {uss:.02f}"".format(uss=uss))
     pss = memory_usage(proc=func, max_usage=True, backend=""psutil_pss"", include_children=True, multiprocess=True)
-    print(f""PSS: {pss:.02f}"")
-    print(f""RSS: {rss:.02f}, USS: {uss:.02f}, PSS: {pss:.02f}"")
+    print(""PSS: {pss:.02f}"".format(pss=pss))
 
 
 if __name__ == ""__main__"":
","@@ -98,9 +98,9 @@ def test_multiprocessing_showcase():
         n_jobs = 8
         size = 3000
 
-        print(f""Creating data: {size}x{size} ... "", end="""")
+        print(""Creating data: {size}x{size} ... "".format(size=size), end="""")
         a = np.random.random((size, size))
-        print(f""done ({a.size * a.itemsize / 1024**3:.02f} Gb). "", end="""")
+        print(""done ({size:.02f} Gb). "".format(size=a.size * a.itemsize / 1024**3), end="""")
 
         def subprocess(i):
             aa = a.copy()
@@ -116,21 +116,20 @@ def test_multiprocessing_showcase():
             pass
 
         start = datetime.datetime.now()
-        print(f""Starting processing: n_jobs={n_jobs} ... "", end="""")
+        print(""Starting processing: n_jobs={n_jobs} ... "".format(n_jobs=n_jobs), end="""")
         results = joblib.Parallel(n_jobs=n_jobs)(
             joblib.delayed(subprocess)(i) 
             for i in range(n_jobs))
-        print(f""done ({datetime.datetime.now() - start}). "", end="""")
+        print(""done ({}). "".format(datetime.datetime.now() - start), end="""")
 
         return results
 
     rss = memory_usage(proc=func, max_usage=True, backend=""psutil"", include_children=True, multiprocess=True)
-    print(f""RSS: {rss:.02f}"")
+    print(""RSS: {rss:.02f}"".format(rss=rss))
     uss = memory_usage(proc=func, max_usage=True, backend=""psutil_uss"", include_children=True, multiprocess=True)
-    print(f""USS: {uss:.02f}"")
+    print(""USS: {uss:.02f}"".format(uss=uss))
     pss = memory_usage(proc=func, max_usage=True, backend=""psutil_pss"", include_children=True, multiprocess=True)
-    print(f""PSS: {pss:.02f}"")
-    print(f""RSS: {rss:.02f}, USS: {uss:.02f}, PSS: {pss:.02f}"")
+    print(""PSS: {pss:.02f}"".format(pss=pss))
 
 
 if __name__ == ""__main__"":
",True,test/test_psutil_memory_full_info.py,True
"@@ -159,8 +159,8 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
 
             if not hasattr(meminfo, memory_metric):
                 raise NotImplementedError(
-                    f""Metric `{memory_metric}` not available. For details, see:""
-                    f""https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info"")
+                    ""Metric `{}` not available. For details, see:"".format(memory_metric) +
+                    ""https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info"")
             mem = getattr(meminfo, memory_metric) / _TWO_20
 
             if include_children:
","@@ -159,8 +159,8 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
 
             if not hasattr(meminfo, memory_metric):
                 raise NotImplementedError(
-                    f""Metric `{memory_metric}` not available. For details, see:""
-                    f""https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info"")
+                    ""Metric `{}` not available. For details, see:"".format(memory_metric) +
+                    ""https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info"")
             mem = getattr(meminfo, memory_metric) / _TWO_20
 
             if include_children:
",True,memory_profiler.py,True
"@@ -152,7 +152,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
         process = psutil.Process(pid)
         try:
             if not hasattr(process, 'memory_full_info'):
-                raise NotImplementedError(""Backend `ps_util_pss` requires psutil > 4.0.0"")
+                raise NotImplementedError(""Backend `psutil_pss` and `psutil_uss` requires psutil > 4.0.0"")
 
             meminfo_attr = 'memory_full_info'
             meminfo = getattr(process, meminfo_attr)()
","@@ -152,7 +152,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
         process = psutil.Process(pid)
         try:
             if not hasattr(process, 'memory_full_info'):
-                raise NotImplementedError(""Backend `ps_util_pss` requires psutil > 4.0.0"")
+                raise NotImplementedError(""Backend `psutil_pss` and `psutil_uss` requires psutil > 4.0.0"")
 
             meminfo_attr = 'memory_full_info'
             meminfo = getattr(process, meminfo_attr)()
",True,memory_profiler.py,True
"@@ -148,7 +148,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
 
     def _ps_util_full_tool(memory_metric):
 
-        # .. cross-platform but but requires psutil ..
+        # .. cross-platform but requires psutil > 4.0.0 ..
         process = psutil.Process(pid)
         try:
             if not hasattr(process, 'memory_full_info'):
","@@ -148,7 +148,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
 
     def _ps_util_full_tool(memory_metric):
 
-        # .. cross-platform but but requires psutil ..
+        # .. cross-platform but requires psutil > 4.0.0 ..
         process = psutil.Process(pid)
         try:
             if not hasattr(process, 'memory_full_info'):
",True,memory_profiler.py,True
"@@ -407,6 +407,25 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
     import memory_profiler
     memory_profiler.load_ipython_extension(ip)
 
+===============================
+Memory tracking backends
+===============================
+`memory_profiler` supports different memory tracking backends including: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'.
+If no specific backend is specified the default is to use ""psutil"" which measures RSS aka Resident Set Size. 
+In some cases (particularly when tracking child processes) RSS may overestimate memory usage (see `example/example_psutil_memory_full_info.py` for an example).
+For more information on ""psutil_pss"" (measuring PSS) and ""psutil_uss"" please refer to:
+https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info 
+
+Currently, the backend can be set via the CLI
+
+    $ python -m memory_profiler --backend psutil my_script.py
+
+and is explosed by the API
+
+    >>> from memory_profiler import memory_usage
+    >>> mem_usage = memory_usage(-1, interval=.2, timeout=1, backend=""psutil"")
+
+    
 ============================
  Frequently Asked Questions
 ============================
@@ -424,7 +443,6 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
       `psutil <http://pypi.python.org/pypi/psutil>`_ module.
 
 
-
 ===========================
  Support, bugs & wish list
 ===========================
","@@ -407,6 +407,25 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
     import memory_profiler
     memory_profiler.load_ipython_extension(ip)
 
+===============================
+Memory tracking backends
+===============================
+`memory_profiler` supports different memory tracking backends including: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'.
+If no specific backend is specified the default is to use ""psutil"" which measures RSS aka Resident Set Size. 
+In some cases (particularly when tracking child processes) RSS may overestimate memory usage (see `example/example_psutil_memory_full_info.py` for an example).
+For more information on ""psutil_pss"" (measuring PSS) and ""psutil_uss"" please refer to:
+https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info 
+
+Currently, the backend can be set via the CLI
+
+    $ python -m memory_profiler --backend psutil my_script.py
+
+and is explosed by the API
+
+    >>> from memory_profiler import memory_usage
+    >>> mem_usage = memory_usage(-1, interval=.2, timeout=1, backend=""psutil"")
+
+    
 ============================
  Frequently Asked Questions
 ============================
@@ -424,7 +443,6 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
       `psutil <http://pypi.python.org/pypi/psutil>`_ module.
 
 
-
 ===========================
  Support, bugs & wish list
 ===========================
",True,README.rst,False
,,True,examples/exxample_psutil_memory_full_info.py,True
"@@ -152,7 +152,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
         process = psutil.Process(pid)
         try:
             if not hasattr(process, 'memory_full_info'):
-                raise NotImplementedError(""Backend `psutil_pss` and `psutil_uss` requires psutil > 4.0.0"")
+                raise NotImplementedError(""Backend `{}` requires psutil > 4.0.0"".format(memory_metric))
 
             meminfo_attr = 'memory_full_info'
             meminfo = getattr(process, meminfo_attr)()
@@ -309,6 +309,12 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         the subprocess. Useful for long-running processes.
         Implies timestamps=True.
 
+    backend : str, optional
+        Current supported backends: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'
+        If `backend=None` the default is ""psutil"" which measures RSS aka Resident Set Size. 
+        For more information on ""psutil_pss"" (measuring PSS) and ""psutil_uss"" please refer to:
+        https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info 
+
     max_iterations : int
         Limits the number of iterations (calls to the process being monitored). Relevent
         when the process is a python function.
@@ -1318,9 +1324,9 @@ if __name__ == '__main__':
         default=False, action='store_true',
         help='also include memory used by child processes')
     parser.add_argument('--backend', dest='backend', type=str, action='store',
-        choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
+        choices=['tracemalloc', 'psutil', 'psutil_pss', 'psutil_uss', 'posix'], default='psutil',
         help='backend using for getting memory info '
-             '(one of the {tracemalloc, psutil, posix})')
+             '(one of the {tracemalloc, psutil, posix, psutil_pss, psutil_uss, posix})')
     parser.add_argument(""program"", nargs=REMAINDER,
         help='python script or module followed by command line arguements to run')
     args = parser.parse_args()
","@@ -152,7 +152,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
         process = psutil.Process(pid)
         try:
             if not hasattr(process, 'memory_full_info'):
-                raise NotImplementedError(""Backend `psutil_pss` and `psutil_uss` requires psutil > 4.0.0"")
+                raise NotImplementedError(""Backend `{}` requires psutil > 4.0.0"".format(memory_metric))
 
             meminfo_attr = 'memory_full_info'
             meminfo = getattr(process, meminfo_attr)()
@@ -309,6 +309,12 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         the subprocess. Useful for long-running processes.
         Implies timestamps=True.
 
+    backend : str, optional
+        Current supported backends: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'
+        If `backend=None` the default is ""psutil"" which measures RSS aka Resident Set Size. 
+        For more information on ""psutil_pss"" (measuring PSS) and ""psutil_uss"" please refer to:
+        https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info 
+
     max_iterations : int
         Limits the number of iterations (calls to the process being monitored). Relevent
         when the process is a python function.
@@ -1318,9 +1324,9 @@ if __name__ == '__main__':
         default=False, action='store_true',
         help='also include memory used by child processes')
     parser.add_argument('--backend', dest='backend', type=str, action='store',
-        choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
+        choices=['tracemalloc', 'psutil', 'psutil_pss', 'psutil_uss', 'posix'], default='psutil',
         help='backend using for getting memory info '
-             '(one of the {tracemalloc, psutil, posix})')
+             '(one of the {tracemalloc, psutil, posix, psutil_pss, psutil_uss, posix})')
     parser.add_argument(""program"", nargs=REMAINDER,
         help='python script or module followed by command line arguements to run')
     args = parser.parse_args()
",True,memory_profiler.py,True
"@@ -420,7 +420,7 @@ Currently, the backend can be set via the CLI
 
     $ python -m memory_profiler --backend psutil my_script.py
 
-and is explosed by the API
+and is exposed by the API
 
     >>> from memory_profiler import memory_usage
     >>> mem_usage = memory_usage(-1, interval=.2, timeout=1, backend=""psutil"")
@@ -504,6 +504,8 @@ cleanup.
 
 `Juan Luis Cano <https://github.com/Juanlu001>`_ modernized the infrastructure and helped with various things.
 
+`Martin Becker <https://github.com/mgbckr>`_ added PSS and USS tracking via the psutil backend.
+
 =========
  License
 =========
","@@ -420,7 +420,7 @@ Currently, the backend can be set via the CLI
 
     $ python -m memory_profiler --backend psutil my_script.py
 
-and is explosed by the API
+and is exposed by the API
 
     >>> from memory_profiler import memory_usage
     >>> mem_usage = memory_usage(-1, interval=.2, timeout=1, backend=""psutil"")
@@ -504,6 +504,8 @@ cleanup.
 
 `Juan Luis Cano <https://github.com/Juanlu001>`_ modernized the infrastructure and helped with various things.
 
+`Martin Becker <https://github.com/mgbckr>`_ added PSS and USS tracking via the psutil backend.
+
 =========
  License
 =========
",True,README.rst,False
"@@ -6,6 +6,7 @@ MANIFEST
 *.egg-info
 *.pyc
 *~
+.coverage
 
 # Ignore mprof generated files
 mprofile_*.dat
","@@ -6,6 +6,7 @@ MANIFEST
 *.egg-info
 *.pyc
 *~
+.coverage
 
 # Ignore mprof generated files
 mprofile_*.dat
",True,.gitignore,False
"@@ -398,7 +398,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                     proc.pid, backend, timestamps=timestamps,
                     include_children=include_children)
 
-                if stream is not None:
+                if mem_usage and stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
 
                     # Write children to the stream file
","@@ -398,7 +398,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                     proc.pid, backend, timestamps=timestamps,
                     include_children=include_children)
 
-                if stream is not None:
+                if mem_usage and stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
 
                     # Write children to the stream file
",True,memory_profiler.py,True
"@@ -64,7 +64,7 @@ this would result in::
 
 Output will follow::
 
-    Line #    Mem usage    Increment  Occurences   Line Contents
+    Line #    Mem usage    Increment  Occurrences   Line Contents
     ============================================================
          3   38.816 MiB   38.816 MiB           1   @profile
          4                                         def my_func():
","@@ -64,7 +64,7 @@ this would result in::
 
 Output will follow::
 
-    Line #    Mem usage    Increment  Occurences   Line Contents
+    Line #    Mem usage    Increment  Occurrences   Line Contents
     ============================================================
          3   38.816 MiB   38.816 MiB           1   @profile
          4                                         def my_func():
",True,README.rst,False
"@@ -854,7 +854,7 @@ def show_results(prof, stream=None, precision=1):
     template = '{0:>6} {1:>12} {2:>12}  {3:>10}   {4:<}'
 
     for (filename, lines) in prof.code_map.items():
-        header = template.format('Line #', 'Mem usage', 'Increment', 'Occurences',
+        header = template.format('Line #', 'Mem usage', 'Increment', 'Occurrences',
                                  'Line Contents')
 
         stream.write(u'Filename: ' + filename + '\n\n')
@@ -870,13 +870,13 @@ def show_results(prof, stream=None, precision=1):
                 inc = mem[0]
                 total_mem = mem[1]
                 total_mem = template_mem.format(total_mem)
-                occurences = mem[2]
+                occurrences = mem[2]
                 inc = template_mem.format(inc)
             else:
                 total_mem = u''
                 inc = u''
-                occurences = u''
-            tmp = template.format(lineno, total_mem, inc, occurences, all_lines[lineno - 1])
+                occurrences = u''
+            tmp = template.format(lineno, total_mem, inc, occurrences, all_lines[lineno - 1])
             stream.write(tmp)
         stream.write(u'\n\n')
 
","@@ -854,7 +854,7 @@ def show_results(prof, stream=None, precision=1):
     template = '{0:>6} {1:>12} {2:>12}  {3:>10}   {4:<}'
 
     for (filename, lines) in prof.code_map.items():
-        header = template.format('Line #', 'Mem usage', 'Increment', 'Occurences',
+        header = template.format('Line #', 'Mem usage', 'Increment', 'Occurrences',
                                  'Line Contents')
 
         stream.write(u'Filename: ' + filename + '\n\n')
@@ -870,13 +870,13 @@ def show_results(prof, stream=None, precision=1):
                 inc = mem[0]
                 total_mem = mem[1]
                 total_mem = template_mem.format(total_mem)
-                occurences = mem[2]
+                occurrences = mem[2]
                 inc = template_mem.format(inc)
             else:
                 total_mem = u''
                 inc = u''
-                occurences = u''
-            tmp = template.format(lineno, total_mem, inc, occurences, all_lines[lineno - 1])
+                occurrences = u''
+            tmp = template.format(lineno, total_mem, inc, occurrences, all_lines[lineno - 1])
             stream.write(tmp)
         stream.write(u'\n\n')
 
",True,memory_profiler.py,True
"@@ -1,9 +1,10 @@
 language: python
 python:
-  - ""3.4""
   - ""3.5""
   - ""3.6""
-  - ""3.7-dev""
+  - ""3.7""
+  - ""3.8""
+  - ""3.9""
   - ""pypy3""
 
 matrix:
","@@ -1,9 +1,10 @@
 language: python
 python:
-  - ""3.4""
   - ""3.5""
   - ""3.6""
-  - ""3.7-dev""
+  - ""3.7""
+  - ""3.8""
+  - ""3.9""
   - ""pypy3""
 
 matrix:
",True,.travis.yml,False
"@@ -835,6 +835,26 @@ such file in the current directory.""""""
     else:
         pl.show()
 
+def filter_mprofile_mem_usage_by_function(prof, func):
+    if func is None:
+        return prof[""mem_usage""]
+
+    if func not in prof[""func_timestamp""]:
+        raise ValueError(str(func) + "" was not found."")
+
+    time_ranges = prof[""func_timestamp""][func]
+    filtered_memory = []
+    
+    # The check here could be improved, but it's done in this
+    # inefficient way to make sure we don't miss overlapping
+    # ranges.
+    for mib, ts in zip(prof[""mem_usage""], prof[""timestamp""]):
+        for rng in time_ranges:
+            if rng[0] <= ts <= rng[1]:
+                filtered_memory.append(mib)
+
+    return filtered_memory
+
 def peak_action():
     desc = """"""Prints the peak memory used in data file `file.dat` generated
 using `mprof run`. If no .dat file is given, it will take the most recent
@@ -842,12 +862,20 @@ such file in the current directory.""""""
     parser = ArgumentParser(usage=""mprof peak [options] [file.dat]"", description=desc)
     parser.add_argument(""profiles"", nargs=""*"",
                     help=""profiles made by mprof run"")
+    parser.add_argument(""--func"", dest=""func"", default=None,
+                        help=""""""Show the peak for this function. Does not support child processes."""""")
     args = parser.parse_args()
     filenames = get_profiles(args)
 
     for filename in filenames:
         prof = read_mprofile_file(filename)
-        print(""{}\t{:.3f} MiB"".format(prof[""filename""], max(prof[""mem_usage""])))
+        try:
+            mem_usage = filter_mprofile_mem_usage_by_function(prof, args.func)
+        except ValueError:
+            print(""{}\tNaN MiB"".format(prof[""filename""]))
+            continue
+
+        print(""{}\t{:.3f} MiB"".format(prof[""filename""], max(mem_usage)))
         for child, values in prof[""children""].items():
             child_peak = max([ mem_ts[0] for mem_ts in values ])
             print(""  Child {}\t\t\t{:.3f} MiB"".format(child, child_peak))
","@@ -835,6 +835,26 @@ such file in the current directory.""""""
     else:
         pl.show()
 
+def filter_mprofile_mem_usage_by_function(prof, func):
+    if func is None:
+        return prof[""mem_usage""]
+
+    if func not in prof[""func_timestamp""]:
+        raise ValueError(str(func) + "" was not found."")
+
+    time_ranges = prof[""func_timestamp""][func]
+    filtered_memory = []
+    
+    # The check here could be improved, but it's done in this
+    # inefficient way to make sure we don't miss overlapping
+    # ranges.
+    for mib, ts in zip(prof[""mem_usage""], prof[""timestamp""]):
+        for rng in time_ranges:
+            if rng[0] <= ts <= rng[1]:
+                filtered_memory.append(mib)
+
+    return filtered_memory
+
 def peak_action():
     desc = """"""Prints the peak memory used in data file `file.dat` generated
 using `mprof run`. If no .dat file is given, it will take the most recent
@@ -842,12 +862,20 @@ such file in the current directory.""""""
     parser = ArgumentParser(usage=""mprof peak [options] [file.dat]"", description=desc)
     parser.add_argument(""profiles"", nargs=""*"",
                     help=""profiles made by mprof run"")
+    parser.add_argument(""--func"", dest=""func"", default=None,
+                        help=""""""Show the peak for this function. Does not support child processes."""""")
     args = parser.parse_args()
     filenames = get_profiles(args)
 
     for filename in filenames:
         prof = read_mprofile_file(filename)
-        print(""{}\t{:.3f} MiB"".format(prof[""filename""], max(prof[""mem_usage""])))
+        try:
+            mem_usage = filter_mprofile_mem_usage_by_function(prof, args.func)
+        except ValueError:
+            print(""{}\tNaN MiB"".format(prof[""filename""]))
+            continue
+
+        print(""{}\t{:.3f} MiB"".format(prof[""filename""], max(mem_usage)))
         for child, values in prof[""children""].items():
             child_peak = max([ mem_ts[0] for mem_ts in values ])
             print(""  Child {}\t\t\t{:.3f} MiB"".format(child, child_peak))
",True,mprof.py,True
"@@ -179,7 +179,7 @@ track the usage of child processes: sum the memory of all children to the
 parent's usage and track each child individual.
 
 To create a report that combines memory usage of all the children and the
-parent, use the ``include_children`` flag in either the ``profile`` decorator or
+parent, use the ``include-children`` flag in either the ``profile`` decorator or
 as a command line argument to ``mprof``::
 
     mprof run --include-children <script>
@@ -197,7 +197,7 @@ This will create a plot using matplotlib similar to this:
     :target: https://github.com/pythonprofilers/memory_profiler/pull/134
     :height: 350px
 
-You can combine both the ``include_children`` and ``multiprocess`` flags to show
+You can combine both the ``include-children`` and ``multiprocess`` flags to show
 the total memory of the program as well as each child individually. If using
 the API directly, note that the return from ``memory_usage`` will include the
 child memory in a nested list along with the main process memory.
","@@ -179,7 +179,7 @@ track the usage of child processes: sum the memory of all children to the
 parent's usage and track each child individual.
 
 To create a report that combines memory usage of all the children and the
-parent, use the ``include_children`` flag in either the ``profile`` decorator or
+parent, use the ``include-children`` flag in either the ``profile`` decorator or
 as a command line argument to ``mprof``::
 
     mprof run --include-children <script>
@@ -197,7 +197,7 @@ This will create a plot using matplotlib similar to this:
     :target: https://github.com/pythonprofilers/memory_profiler/pull/134
     :height: 350px
 
-You can combine both the ``include_children`` and ``multiprocess`` flags to show
+You can combine both the ``include-children`` and ``multiprocess`` flags to show
 the total memory of the program as well as each child individually. If using
 the API directly, note that the return from ``memory_usage`` will include the
 child memory in a nested list along with the main process memory.
",True,README.rst,False
"@@ -214,6 +214,8 @@ def run_action():
                         help=""""""File to store results in, defaults to 'mprofile_<YYYYMMDDhhmmss>.dat' in the current directory,
 (where <YYYYMMDDhhmmss> is the date-time of the program start).
 This file contains the process memory consumption, in Mb (one value per line)."""""")
+    parser.add_argument(""--backend"", dest=""backend"", choices=[""psutil"", ""psutil_pss"", ""psutil_uss"", ""posix"", ""tracemalloc""],
+                        help=""Current supported backends: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'"")
     parser.add_argument(""program"", nargs=REMAINDER,
                         help='Option 1: ""<EXECUTABLE> <ARG1> <ARG2>..."" - profile executable\n'
                              'Option 2: ""<PYTHON_SCRIPT> <ARG1> <ARG2>..."" - profile python script\n'
@@ -279,7 +281,7 @@ This file contains the process memory consumption, in Mb (one value per line).""""
         f.write(""CMDLINE {0}\n"".format(cmd_line))
         mp.memory_usage(proc=p, interval=args.interval, timeout=args.timeout, timestamps=True,
                         include_children=args.include_children,
-                        multiprocess=args.multiprocess, stream=f)
+                        multiprocess=args.multiprocess, stream=f, backend=args.backend)
 
     if args.exit_code:
         if p.returncode != 0:
","@@ -214,6 +214,8 @@ def run_action():
                         help=""""""File to store results in, defaults to 'mprofile_<YYYYMMDDhhmmss>.dat' in the current directory,
 (where <YYYYMMDDhhmmss> is the date-time of the program start).
 This file contains the process memory consumption, in Mb (one value per line)."""""")
+    parser.add_argument(""--backend"", dest=""backend"", choices=[""psutil"", ""psutil_pss"", ""psutil_uss"", ""posix"", ""tracemalloc""],
+                        help=""Current supported backends: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'"")
     parser.add_argument(""program"", nargs=REMAINDER,
                         help='Option 1: ""<EXECUTABLE> <ARG1> <ARG2>..."" - profile executable\n'
                              'Option 2: ""<PYTHON_SCRIPT> <ARG1> <ARG2>..."" - profile python script\n'
@@ -279,7 +281,7 @@ This file contains the process memory consumption, in Mb (one value per line).""""
         f.write(""CMDLINE {0}\n"".format(cmd_line))
         mp.memory_usage(proc=p, interval=args.interval, timeout=args.timeout, timestamps=True,
                         include_children=args.include_children,
-                        multiprocess=args.multiprocess, stream=f)
+                        multiprocess=args.multiprocess, stream=f, backend=args.backend)
 
     if args.exit_code:
         if p.returncode != 0:
",True,mprof.py,True
"@@ -215,7 +215,8 @@ def run_action():
 (where <YYYYMMDDhhmmss> is the date-time of the program start).
 This file contains the process memory consumption, in Mb (one value per line)."""""")
     parser.add_argument(""--backend"", dest=""backend"", choices=[""psutil"", ""psutil_pss"", ""psutil_uss"", ""posix"", ""tracemalloc""],
-                        help=""Current supported backends: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'"")
+                        default=""psutil"",
+                        help=""Current supported backends: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'. Defaults to 'psutil'."")
     parser.add_argument(""program"", nargs=REMAINDER,
                         help='Option 1: ""<EXECUTABLE> <ARG1> <ARG2>..."" - profile executable\n'
                              'Option 2: ""<PYTHON_SCRIPT> <ARG1> <ARG2>..."" - profile python script\n'
","@@ -215,7 +215,8 @@ def run_action():
 (where <YYYYMMDDhhmmss> is the date-time of the program start).
 This file contains the process memory consumption, in Mb (one value per line)."""""")
     parser.add_argument(""--backend"", dest=""backend"", choices=[""psutil"", ""psutil_pss"", ""psutil_uss"", ""posix"", ""tracemalloc""],
-                        help=""Current supported backends: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'"")
+                        default=""psutil"",
+                        help=""Current supported backends: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'. Defaults to 'psutil'."")
     parser.add_argument(""program"", nargs=REMAINDER,
                         help='Option 1: ""<EXECUTABLE> <ARG1> <ARG2>..."" - profile executable\n'
                              'Option 2: ""<PYTHON_SCRIPT> <ARG1> <ARG2>..."" - profile python script\n'
",True,mprof.py,True
"@@ -1110,7 +1110,7 @@ class MemoryProfilerMagics(Magics):
             counter += 1
             tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
                                timeout=timeout, interval=interval,
-                               max_usage=True,
+                               max_usage=True, max_iterations=1,
                                include_children=include_children)
             mem_usage.append(tmp)
 
","@@ -1110,7 +1110,7 @@ class MemoryProfilerMagics(Magics):
             counter += 1
             tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
                                timeout=timeout, interval=interval,
-                               max_usage=True,
+                               max_usage=True, max_iterations=1,
                                include_children=include_children)
             mem_usage.append(tmp)
 
",True,memory_profiler.py,True
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.57.0'
+__version__ = '0.59.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.57.0'
+__version__ = '0.59.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -411,7 +411,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
 Memory tracking backends
 ===============================
 `memory_profiler` supports different memory tracking backends including: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'.
-If no specific backend is specified the default is to use ""psutil"" which measures RSS aka Resident Set Size. 
+If no specific backend is specified the default is to use ""psutil"" which measures RSS aka ""Resident Set Size"". 
 In some cases (particularly when tracking child processes) RSS may overestimate memory usage (see `example/example_psutil_memory_full_info.py` for an example).
 For more information on ""psutil_pss"" (measuring PSS) and ""psutil_uss"" please refer to:
 https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info 
","@@ -411,7 +411,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
 Memory tracking backends
 ===============================
 `memory_profiler` supports different memory tracking backends including: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'.
-If no specific backend is specified the default is to use ""psutil"" which measures RSS aka Resident Set Size. 
+If no specific backend is specified the default is to use ""psutil"" which measures RSS aka ""Resident Set Size"". 
 In some cases (particularly when tracking child processes) RSS may overestimate memory usage (see `example/example_psutil_memory_full_info.py` for an example).
 For more information on ""psutil_pss"" (measuring PSS) and ""psutil_uss"" please refer to:
 https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info 
",True,README.rst,False
"@@ -311,7 +311,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
     backend : str, optional
         Current supported backends: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'
-        If `backend=None` the default is ""psutil"" which measures RSS aka Resident Set Size. 
+        If `backend=None` the default is ""psutil"" which measures RSS aka ""Resident Set Size"". 
         For more information on ""psutil_pss"" (measuring PSS) and ""psutil_uss"" please refer to:
         https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info 
 
","@@ -311,7 +311,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
     backend : str, optional
         Current supported backends: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'
-        If `backend=None` the default is ""psutil"" which measures RSS aka Resident Set Size. 
+        If `backend=None` the default is ""psutil"" which measures RSS aka ""Resident Set Size"". 
         For more information on ""psutil_pss"" (measuring PSS) and ""psutil_uss"" please refer to:
         https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info 
 
",True,memory_profiler.py,True
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.59.0'
+__version__ = '0.60.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.59.0'
+__version__ = '0.60.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -5,6 +5,9 @@
  Memory Profiler
 =================
 
+
+**Note:** This package is no longer actively maintained. If you'd like to volunteer to maintain it, please drop me a line at f@bianp.net
+
 This is a python module for monitoring memory consumption of a process
 as well as line-by-line analysis of memory consumption for python
 programs. It is a pure python module which depends on the `psutil
","@@ -5,6 +5,9 @@
  Memory Profiler
 =================
 
+
+**Note:** This package is no longer actively maintained. If you'd like to volunteer to maintain it, please drop me a line at f@bianp.net
+
 This is a python module for monitoring memory consumption of a process
 as well as line-by-line analysis of memory consumption for python
 programs. It is a pure python module which depends on the `psutil
",True,README.rst,False
"@@ -1,3 +0,0 @@
-include README.rst
-include COPYING
-include mprof.bat
","@@ -1,3 +0,0 @@
-include README.rst
-include COPYING
-include mprof.bat
",True,,False
"@@ -26,7 +26,7 @@ The package is also available on `conda-forge
 
 To install from source, download the package, extract and type::
 
-    $ python setup.py install
+    $ pip install .
 
 
 =======
","@@ -26,7 +26,7 @@ The package is also available on `conda-forge
 
 To install from source, download the package, extract and type::
 
-    $ python setup.py install
+    $ pip install .
 
 
 =======
",True,README.rst,False
"@@ -0,0 +1,3 @@
+[build-system]
+requires = [""setuptools""]
+build-backend = ""setuptools.build_meta""
","@@ -0,0 +1,3 @@
+[build-system]
+requires = [""setuptools""]
+build-backend = ""setuptools.build_meta""
",True,pyproject.toml,False
"@@ -0,0 +1,31 @@
+[metadata]
+name = memory_profiler
+description = A module for monitoring memory usage of a python program
+long_description = file: README.rst
+version = attr: memory_profiler.__version__
+license = BSD
+license_files = COPYING
+author = Fabian Pedregosa
+author_email = f@bianp.net
+url = https://github.com/pythonprofilers/memory_profiler
+classifiers =
+    Development Status :: 5 - Production/Stable
+    Intended Audience :: Science/Research
+    Intended Audience :: Developers
+    License :: OSI Approved :: BSD License
+    Programming Language :: Python
+    Programming Language :: Python :: 3
+    Topic :: Software Development
+    Operating System :: POSIX
+    Operating System :: Unix
+
+[options]
+py_modules =
+    memory_profiler
+    mprof
+python_requires = >=3.4
+install_requires = psutil
+
+[options.entry_points]
+console_scripts =
+    mprof = mprof:main
","@@ -0,0 +1,31 @@
+[metadata]
+name = memory_profiler
+description = A module for monitoring memory usage of a python program
+long_description = file: README.rst
+version = attr: memory_profiler.__version__
+license = BSD
+license_files = COPYING
+author = Fabian Pedregosa
+author_email = f@bianp.net
+url = https://github.com/pythonprofilers/memory_profiler
+classifiers =
+    Development Status :: 5 - Production/Stable
+    Intended Audience :: Science/Research
+    Intended Audience :: Developers
+    License :: OSI Approved :: BSD License
+    Programming Language :: Python
+    Programming Language :: Python :: 3
+    Topic :: Software Development
+    Operating System :: POSIX
+    Operating System :: Unix
+
+[options]
+py_modules =
+    memory_profiler
+    mprof
+python_requires = >=3.4
+install_requires = psutil
+
+[options.entry_points]
+console_scripts =
+    mprof = mprof:main
",True,setup.cfg,False
"@@ -1,46 +1,3 @@
-import re
 from setuptools import setup
 
-
-# https://packaging.python.org/guides/single-sourcing-package-version/
-def find_version(file_paths):
-    with open(file_paths) as f:
-        version_file = f.read()
-    version_match = re.search(
-        r""^__version__ = ['\""]([^'\""]*)['\""]"", version_file, re.M
-    )
-    if version_match:
-        return version_match.group(1)
-
-
-CLASSIFIERS = """"""\
-Development Status :: 5 - Production/Stable
-Intended Audience :: Science/Research
-Intended Audience :: Developers
-License :: OSI Approved :: BSD License
-Programming Language :: Python
-Programming Language :: Python :: 3
-Topic :: Software Development
-Operating System :: POSIX
-Operating System :: Unix
-
-""""""
-
-
-setup(
-    name='memory_profiler',
-    description='A module for monitoring memory usage of a python program',
-    long_description=open('README.rst').read(),
-    version=find_version(""memory_profiler.py""),
-    author='Fabian Pedregosa',
-    author_email='f@bianp.net',
-    url='https://github.com/pythonprofilers/memory_profiler',
-    py_modules=['memory_profiler', 'mprof'],
-    entry_points={
-        'console_scripts': ['mprof = mprof:main'],
-    },
-    install_requires=['psutil'],
-    python_requires='>=3.4',
-    classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
-    license='BSD'
-)
+setup()
","@@ -1,46 +1,3 @@
-import re
 from setuptools import setup
 
-
-# https://packaging.python.org/guides/single-sourcing-package-version/
-def find_version(file_paths):
-    with open(file_paths) as f:
-        version_file = f.read()
-    version_match = re.search(
-        r""^__version__ = ['\""]([^'\""]*)['\""]"", version_file, re.M
-    )
-    if version_match:
-        return version_match.group(1)
-
-
-CLASSIFIERS = """"""\
-Development Status :: 5 - Production/Stable
-Intended Audience :: Science/Research
-Intended Audience :: Developers
-License :: OSI Approved :: BSD License
-Programming Language :: Python
-Programming Language :: Python :: 3
-Topic :: Software Development
-Operating System :: POSIX
-Operating System :: Unix
-
-""""""
-
-
-setup(
-    name='memory_profiler',
-    description='A module for monitoring memory usage of a python program',
-    long_description=open('README.rst').read(),
-    version=find_version(""memory_profiler.py""),
-    author='Fabian Pedregosa',
-    author_email='f@bianp.net',
-    url='https://github.com/pythonprofilers/memory_profiler',
-    py_modules=['memory_profiler', 'mprof'],
-    entry_points={
-        'console_scripts': ['mprof = mprof:main'],
-    },
-    install_requires=['psutil'],
-    python_requires='>=3.4',
-    classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
-    license='BSD'
-)
+setup()
",True,setup.py,True
"@@ -0,0 +1,18 @@
+import asyncio
+
+from memory_profiler import profile
+
+
+@profile
+@asyncio.coroutine
+def foo():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    yield from asyncio.sleep(1)
+    del b
+    return a
+
+
+if __name__ == ""__main__"":
+    loop = asyncio.get_event_loop()
+    loop.run_until_complete(foo())
","@@ -0,0 +1,18 @@
+import asyncio
+
+from memory_profiler import profile
+
+
+@profile
+@asyncio.coroutine
+def foo():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    yield from asyncio.sleep(1)
+    del b
+    return a
+
+
+if __name__ == ""__main__"":
+    loop = asyncio.get_event_loop()
+    loop.run_until_complete(foo())
",True,examples/async_decorator.py,True
"@@ -15,7 +15,7 @@ import inspect
 import linecache
 import logging
 import os
-from io import open
+import io
 import pdb
 import subprocess
 import sys
@@ -1249,7 +1249,7 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
 
-        with open(filename, encoding='utf-8') as f:
+        with io.open(filename, encoding='utf-8') as f:
             exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
         if has_tracemalloc and tracemalloc.is_tracing():
","@@ -15,7 +15,7 @@ import inspect
 import linecache
 import logging
 import os
-from io import open
+import io
 import pdb
 import subprocess
 import sys
@@ -1249,7 +1249,7 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
 
-        with open(filename, encoding='utf-8') as f:
+        with io.open(filename, encoding='utf-8') as f:
             exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
         if has_tracemalloc and tracemalloc.is_tracing():
",True,memory_profiler.py,True
"@@ -4,16 +4,15 @@ from memory_profiler import profile
 
 
 @profile
-@asyncio.coroutine
-def my_func():
+async def my_func():
     a = [1] * (10 ** 6)
     b = [2] * (2 * 10 ** 7)
-    yield from asyncio.sleep(1e-2)
+    await asyncio.sleep(1e-2)
     del b
-    return 42
 
+async def main():
+    task = asyncio.create_task(my_func())
+    res = await asyncio.gather(task)
 
 if __name__ == '__main__':
-    loop = asyncio.get_event_loop()
-    res = loop.run_until_complete(my_func())
-    assert res == 42
+    asyncio.run(main())  # main loop
","@@ -4,16 +4,15 @@ from memory_profiler import profile
 
 
 @profile
-@asyncio.coroutine
-def my_func():
+async def my_func():
     a = [1] * (10 ** 6)
     b = [2] * (2 * 10 ** 7)
-    yield from asyncio.sleep(1e-2)
+    await asyncio.sleep(1e-2)
     del b
-    return 42
 
+async def main():
+    task = asyncio.create_task(my_func())
+    res = await asyncio.gather(task)
 
 if __name__ == '__main__':
-    loop = asyncio.get_event_loop()
-    res = loop.run_until_complete(my_func())
-    assert res == 42
+    asyncio.run(main())  # main loop
",True,test/test_async.py,True
"@@ -6,7 +6,7 @@
 =================
 
 
-**Note:** This package is no longer actively maintained. If you'd like to volunteer to maintain it, please drop me a line at f@bianp.net
+**Note:** This package is no longer actively maintained. I won't be actively responding to issues. If you'd like to volunteer to maintain it, please drop me a line at f@bianp.net
 
 This is a python module for monitoring memory consumption of a process
 as well as line-by-line analysis of memory consumption for python
","@@ -6,7 +6,7 @@
 =================
 
 
-**Note:** This package is no longer actively maintained. If you'd like to volunteer to maintain it, please drop me a line at f@bianp.net
+**Note:** This package is no longer actively maintained. I won't be actively responding to issues. If you'd like to volunteer to maintain it, please drop me a line at f@bianp.net
 
 This is a python module for monitoring memory consumption of a process
 as well as line-by-line analysis of memory consumption for python
",True,README.rst,False
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.59.0'
+__version__ = '0.60.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
@@ -15,7 +15,6 @@ import inspect
 import linecache
 import logging
 import os
-import io
 import pdb
 import subprocess
 import sys
@@ -23,7 +22,6 @@ import time
 import traceback
 import warnings
 
-
 if sys.platform == ""win32"":
     # any value except signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT
     # can be used to kill a process unconditionally in Windows
@@ -106,12 +104,12 @@ def _get_child_memory(process, meminfo_attr=None, memory_metric=0):
         for child in getattr(process, children_attr)(recursive=True):
             if isinstance(memory_metric, str):
                 meminfo = getattr(child, meminfo_attr)()
-                yield getattr(meminfo, memory_metric) / _TWO_20
+                yield child.pid, getattr(meminfo, memory_metric) / _TWO_20
             else:
-                yield getattr(child, meminfo_attr)()[memory_metric] / _TWO_20
+                yield child.pid, getattr(child, meminfo_attr)()[memory_metric] / _TWO_20
     except (psutil.NoSuchProcess, psutil.AccessDenied):
         # https://github.com/fabianp/memory_profiler/issues/71
-        yield 0.0
+        yield (0, 0.0)
 
 
 def _get_memory(pid, backend, timestamps=False, include_children=False, filename=None):
@@ -139,7 +137,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
                 else 'get_memory_info'
             mem = getattr(process, meminfo_attr)()[0] / _TWO_20
             if include_children:
-                mem +=  sum(_get_child_memory(process, meminfo_attr))
+                mem +=  sum([mem for (pid, mem) in _get_child_memory(process, meminfo_attr)])
             if timestamps:
                 return mem, time.time()
             else:
@@ -166,7 +164,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
             mem = getattr(meminfo, memory_metric) / _TWO_20
 
             if include_children:
-                mem +=  sum(_get_child_memory(process, meminfo_attr, memory_metric))
+                mem +=  sum([mem for (pid, mem) in _get_child_memory(process, meminfo_attr)])
 
             if timestamps:
                 return mem, time.time()
@@ -411,13 +409,13 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
                     # Write children to the stream file
                     if multiprocess:
-                        for idx, chldmem in enumerate(_get_child_memory(proc.pid)):
+                        for idx, chldmem in _get_child_memory(proc.pid):
                             stream.write(""CHLD {0} {1:.6f} {2:.4f}\n"".format(idx, chldmem, time.time()))
                 else:
                     # Create a nested list with the child memory
                     if multiprocess:
                         mem_usage = [mem_usage]
-                        for chldmem in _get_child_memory(proc.pid):
+                        for _, chldmem in _get_child_memory(proc.pid):
                             mem_usage.append(chldmem)
 
                     # Append the memory usage to the return value
@@ -455,13 +453,13 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
                     # Write children to the stream file
                     if multiprocess:
-                        for idx, chldmem in enumerate(_get_child_memory(proc)):
+                        for idx, chldmem in _get_child_memory(proc):
                             stream.write(""CHLD {0} {1:.6f} {2:.4f}\n"".format(idx, chldmem, time.time()))
                 else:
                     # Create a nested list with the child memory
                     if multiprocess:
                         mem_usage = [mem_usage]
-                        for chldmem in _get_child_memory(proc):
+                        for _, chldmem in _get_child_memory(proc):
                             mem_usage.append(chldmem)
 
                     # Append the memory usage to the return value
@@ -1112,7 +1110,7 @@ class MemoryProfilerMagics(Magics):
             counter += 1
             tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
                                timeout=timeout, interval=interval,
-                               max_usage=True, max_iterations=1,
+                               max_usage=True,
                                include_children=include_children)
             mem_usage.append(tmp)
 
@@ -1248,8 +1246,7 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     try:
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
-
-        with io.open(filename, encoding='utf-8') as f:
+        with open(filename, encoding='utf-8') as f:
             exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
         if has_tracemalloc and tracemalloc.is_tracing():
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.59.0'
+__version__ = '0.60.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
@@ -15,7 +15,6 @@ import inspect
 import linecache
 import logging
 import os
-import io
 import pdb
 import subprocess
 import sys
@@ -23,7 +22,6 @@ import time
 import traceback
 import warnings
 
-
 if sys.platform == ""win32"":
     # any value except signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT
     # can be used to kill a process unconditionally in Windows
@@ -106,12 +104,12 @@ def _get_child_memory(process, meminfo_attr=None, memory_metric=0):
         for child in getattr(process, children_attr)(recursive=True):
             if isinstance(memory_metric, str):
                 meminfo = getattr(child, meminfo_attr)()
-                yield getattr(meminfo, memory_metric) / _TWO_20
+                yield child.pid, getattr(meminfo, memory_metric) / _TWO_20
             else:
-                yield getattr(child, meminfo_attr)()[memory_metric] / _TWO_20
+                yield child.pid, getattr(child, meminfo_attr)()[memory_metric] / _TWO_20
     except (psutil.NoSuchProcess, psutil.AccessDenied):
         # https://github.com/fabianp/memory_profiler/issues/71
-        yield 0.0
+        yield (0, 0.0)
 
 
 def _get_memory(pid, backend, timestamps=False, include_children=False, filename=None):
@@ -139,7 +137,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
                 else 'get_memory_info'
             mem = getattr(process, meminfo_attr)()[0] / _TWO_20
             if include_children:
-                mem +=  sum(_get_child_memory(process, meminfo_attr))
+                mem +=  sum([mem for (pid, mem) in _get_child_memory(process, meminfo_attr)])
             if timestamps:
                 return mem, time.time()
             else:
@@ -166,7 +164,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
             mem = getattr(meminfo, memory_metric) / _TWO_20
 
             if include_children:
-                mem +=  sum(_get_child_memory(process, meminfo_attr, memory_metric))
+                mem +=  sum([mem for (pid, mem) in _get_child_memory(process, meminfo_attr)])
 
             if timestamps:
                 return mem, time.time()
@@ -411,13 +409,13 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
                     # Write children to the stream file
                     if multiprocess:
-                        for idx, chldmem in enumerate(_get_child_memory(proc.pid)):
+                        for idx, chldmem in _get_child_memory(proc.pid):
                             stream.write(""CHLD {0} {1:.6f} {2:.4f}\n"".format(idx, chldmem, time.time()))
                 else:
                     # Create a nested list with the child memory
                     if multiprocess:
                         mem_usage = [mem_usage]
-                        for chldmem in _get_child_memory(proc.pid):
+                        for _, chldmem in _get_child_memory(proc.pid):
                             mem_usage.append(chldmem)
 
                     # Append the memory usage to the return value
@@ -455,13 +453,13 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
                     # Write children to the stream file
                     if multiprocess:
-                        for idx, chldmem in enumerate(_get_child_memory(proc)):
+                        for idx, chldmem in _get_child_memory(proc):
                             stream.write(""CHLD {0} {1:.6f} {2:.4f}\n"".format(idx, chldmem, time.time()))
                 else:
                     # Create a nested list with the child memory
                     if multiprocess:
                         mem_usage = [mem_usage]
-                        for chldmem in _get_child_memory(proc):
+                        for _, chldmem in _get_child_memory(proc):
                             mem_usage.append(chldmem)
 
                     # Append the memory usage to the return value
@@ -1112,7 +1110,7 @@ class MemoryProfilerMagics(Magics):
             counter += 1
             tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
                                timeout=timeout, interval=interval,
-                               max_usage=True, max_iterations=1,
+                               max_usage=True,
                                include_children=include_children)
             mem_usage.append(tmp)
 
@@ -1248,8 +1246,7 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     try:
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
-
-        with io.open(filename, encoding='utf-8') as f:
+        with open(filename, encoding='utf-8') as f:
             exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
         if has_tracemalloc and tracemalloc.is_tracing():
",True,memory_profiler.py,True
"@@ -164,7 +164,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
             mem = getattr(meminfo, memory_metric) / _TWO_20
 
             if include_children:
-                mem +=  sum([mem for (pid, mem) in _get_child_memory(process, meminfo_attr)])
+                mem +=  sum([mem for (pid, mem) in _get_child_memory(process, meminfo_attr, memory_metric)])
 
             if timestamps:
                 return mem, time.time()
","@@ -164,7 +164,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
             mem = getattr(meminfo, memory_metric) / _TWO_20
 
             if include_children:
-                mem +=  sum([mem for (pid, mem) in _get_child_memory(process, meminfo_attr)])
+                mem +=  sum([mem for (pid, mem) in _get_child_memory(process, meminfo_attr, memory_metric)])
 
             if timestamps:
                 return mem, time.time()
",True,memory_profiler.py,True
"@@ -15,6 +15,7 @@ import inspect
 import linecache
 import logging
 import os
+import io
 import pdb
 import subprocess
 import sys
@@ -1110,7 +1111,7 @@ class MemoryProfilerMagics(Magics):
             counter += 1
             tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
                                timeout=timeout, interval=interval,
-                               max_usage=True,
+                               max_usage=True, max_iterations=1,
                                include_children=include_children)
             mem_usage.append(tmp)
 
@@ -1246,7 +1247,7 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     try:
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
-        with open(filename, encoding='utf-8') as f:
+        with io.open(filename, encoding='utf-8') as f:
             exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
         if has_tracemalloc and tracemalloc.is_tracing():
","@@ -15,6 +15,7 @@ import inspect
 import linecache
 import logging
 import os
+import io
 import pdb
 import subprocess
 import sys
@@ -1110,7 +1111,7 @@ class MemoryProfilerMagics(Magics):
             counter += 1
             tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
                                timeout=timeout, interval=interval,
-                               max_usage=True,
+                               max_usage=True, max_iterations=1,
                                include_children=include_children)
             mem_usage.append(tmp)
 
@@ -1246,7 +1247,7 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     try:
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
-        with open(filename, encoding='utf-8') as f:
+        with io.open(filename, encoding='utf-8') as f:
             exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
         if has_tracemalloc and tracemalloc.is_tracing():
",True,memory_profiler.py,True
"@@ -138,10 +138,11 @@ give you any information on which function is executed at a given
 time. Depending on the case, it can be difficult to identify the part
 of the code that is causing the highest memory usage.
 
-Adding the `profile` decorator to a function and running the Python
+Adding the `profile` decorator to a function(ensure no 
+`from memory_profiler import profile` statement) and running the Python
 script with
 
-    mprof run <script>
+    mprof run --python python <script>
 
 will record timestamps when entering/leaving the profiled function. Running
 
","@@ -138,10 +138,11 @@ give you any information on which function is executed at a given
 time. Depending on the case, it can be difficult to identify the part
 of the code that is causing the highest memory usage.
 
-Adding the `profile` decorator to a function and running the Python
+Adding the `profile` decorator to a function(ensure no 
+`from memory_profiler import profile` statement) and running the Python
 script with
 
-    mprof run <script>
+    mprof run --python python <script>
 
 will record timestamps when entering/leaving the profiled function. Running
 
",True,README.rst,False
"@@ -28,6 +28,20 @@ To install from source, download the package, extract and type::
 
     $ pip install .
 
+===========
+Quick Start
+===========
+
+Use `mprof` to generate a full memory usage report of your executable and to plot it.
+
+.. code-block:: bash
+
+    mprof run executable
+    mprof plot
+
+The plot would be something like this:
+
+.. image:: https://i.stack.imgur.com/ixCH4.png
 
 =======
  Usage
","@@ -28,6 +28,20 @@ To install from source, download the package, extract and type::
 
     $ pip install .
 
+===========
+Quick Start
+===========
+
+Use `mprof` to generate a full memory usage report of your executable and to plot it.
+
+.. code-block:: bash
+
+    mprof run executable
+    mprof plot
+
+The plot would be something like this:
+
+.. image:: https://i.stack.imgur.com/ixCH4.png
 
 =======
  Usage
",True,README.rst,False
"@@ -317,7 +317,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info 
 
     max_iterations : int
-        Limits the number of iterations (calls to the process being monitored). Relevent
+        Limits the number of iterations (calls to the process being monitored). Relevant
         when the process is a python function.
 
     Returns
@@ -1329,7 +1329,7 @@ if __name__ == '__main__':
         help='backend using for getting memory info '
              '(one of the {tracemalloc, psutil, posix, psutil_pss, psutil_uss, posix})')
     parser.add_argument(""program"", nargs=REMAINDER,
-        help='python script or module followed by command line arguements to run')
+        help='python script or module followed by command line arguments to run')
     args = parser.parse_args()
 
     if len(args.program) == 0:
","@@ -317,7 +317,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info 
 
     max_iterations : int
-        Limits the number of iterations (calls to the process being monitored). Relevent
+        Limits the number of iterations (calls to the process being monitored). Relevant
         when the process is a python function.
 
     Returns
@@ -1329,7 +1329,7 @@ if __name__ == '__main__':
         help='backend using for getting memory info '
              '(one of the {tracemalloc, psutil, posix, psutil_pss, psutil_uss, posix})')
     parser.add_argument(""program"", nargs=REMAINDER,
-        help='python script or module followed by command line arguements to run')
+        help='python script or module followed by command line arguments to run')
     args = parser.parse_args()
 
     if len(args.program) == 0:
",True,memory_profiler.py,True
"@@ -0,0 +1,27 @@
+name: lint_python
+on: [pull_request, push]
+jobs:
+  lint_python:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+      - uses: actions/setup-python@v4
+        with:
+          python-version: 3.x
+      - run: pip install --upgrade pip wheel
+      - run: pip install bandit black codespell flake8 flake8-2020 flake8-bugbear
+                         flake8-comprehensions isort mypy pytest pyupgrade safety
+      - run: bandit --recursive --skip B101,B102,B307,B404,B603,B607 .
+      - run: black --check . || true
+      - run: codespell  # --ignore-words-list="""" --skip=""*.css,*.js,*.lock""
+      - run: flake8 . --builtins=profile --count --select=E9,F63,F7,F82 --show-source --statistics
+      - run: flake8 . --count --exit-zero --max-complexity=10 --max-line-length=88
+                      --show-source --statistics
+      - run: isort --check-only --profile black . || true
+      - run: pip install -r requirements.txt || pip install --editable . || pip install . || true
+      - run: mkdir --parents --verbose .mypy_cache
+      - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
+      - run: pytest . || true
+      - run: pytest --doctest-modules . || true
+      - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
+      - run: safety check
","@@ -0,0 +1,27 @@
+name: lint_python
+on: [pull_request, push]
+jobs:
+  lint_python:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+      - uses: actions/setup-python@v4
+        with:
+          python-version: 3.x
+      - run: pip install --upgrade pip wheel
+      - run: pip install bandit black codespell flake8 flake8-2020 flake8-bugbear
+                         flake8-comprehensions isort mypy pytest pyupgrade safety
+      - run: bandit --recursive --skip B101,B102,B307,B404,B603,B607 .
+      - run: black --check . || true
+      - run: codespell  # --ignore-words-list="""" --skip=""*.css,*.js,*.lock""
+      - run: flake8 . --builtins=profile --count --select=E9,F63,F7,F82 --show-source --statistics
+      - run: flake8 . --count --exit-zero --max-complexity=10 --max-line-length=88
+                      --show-source --statistics
+      - run: isort --check-only --profile black . || true
+      - run: pip install -r requirements.txt || pip install --editable . || pip install . || true
+      - run: mkdir --parents --verbose .mypy_cache
+      - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
+      - run: pytest . || true
+      - run: pytest --doctest-modules . || true
+      - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
+      - run: safety check
",True,.github/workflows/lint_python.yml,False
"@@ -19,6 +19,7 @@ jobs:
                       --show-source --statistics
       - run: isort --check-only --profile black . || true
       - run: pip install -r requirements.txt || pip install --editable . || pip install . || true
+      - run: pip install numpy pylab
       - run: mkdir --parents --verbose .mypy_cache
       - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
       - run: pytest . || true
","@@ -19,6 +19,7 @@ jobs:
                       --show-source --statistics
       - run: isort --check-only --profile black . || true
       - run: pip install -r requirements.txt || pip install --editable . || pip install . || true
+      - run: pip install numpy pylab
       - run: mkdir --parents --verbose .mypy_cache
       - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
       - run: pytest . || true
",True,.github/workflows/lint_python.yml,False
"@@ -19,7 +19,7 @@ jobs:
                       --show-source --statistics
       - run: isort --check-only --profile black . || true
       - run: pip install -r requirements.txt || pip install --editable . || pip install . || true
-      - run: pip install numpy pylab
+      - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
       - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
       - run: pytest . || true
","@@ -19,7 +19,7 @@ jobs:
                       --show-source --statistics
       - run: isort --check-only --profile black . || true
       - run: pip install -r requirements.txt || pip install --editable . || pip install . || true
-      - run: pip install numpy pylab
+      - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
       - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
       - run: pytest . || true
",True,.github/workflows/lint_python.yml,False
"@@ -21,8 +21,8 @@ jobs:
       - run: pip install -r requirements.txt || pip install --editable . || pip install . || true
       - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
-      - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
-      - run: pytest . || true
-      - run: pytest --doctest-modules . || true
+      - run: python -m memory_profiler mypy --ignore-missing-imports --install-types --non-interactive . || true
+      - run: python -m memory_profiler pytest . || true
+      - run: python -m memory_profiler pytest --doctest-modules . || true
       - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
       - run: safety check
","@@ -21,8 +21,8 @@ jobs:
       - run: pip install -r requirements.txt || pip install --editable . || pip install . || true
       - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
-      - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
-      - run: pytest . || true
-      - run: pytest --doctest-modules . || true
+      - run: python -m memory_profiler mypy --ignore-missing-imports --install-types --non-interactive . || true
+      - run: python -m memory_profiler pytest . || true
+      - run: python -m memory_profiler pytest --doctest-modules . || true
       - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
       - run: safety check
",True,.github/workflows/lint_python.yml,False
"@@ -22,7 +22,7 @@ jobs:
       - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
       - run: python -m memory_profiler mypy --ignore-missing-imports --install-types --non-interactive . || true
-      - run: python -m memory_profiler pytest . || true
-      - run: python -m memory_profiler pytest --doctest-modules . || true
+      - run: python -m memory_profiler pytest --fixtures . || true
+      - run: python -m memory_profiler pytest --doctest-modules --fixtures . || true
       - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
       - run: safety check
","@@ -22,7 +22,7 @@ jobs:
       - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
       - run: python -m memory_profiler mypy --ignore-missing-imports --install-types --non-interactive . || true
-      - run: python -m memory_profiler pytest . || true
-      - run: python -m memory_profiler pytest --doctest-modules . || true
+      - run: python -m memory_profiler pytest --fixtures . || true
+      - run: python -m memory_profiler pytest --doctest-modules --fixtures . || true
       - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
       - run: safety check
",True,.github/workflows/lint_python.yml,False
"@@ -22,7 +22,8 @@ jobs:
       - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
       - run: python -m memory_profiler mypy --ignore-missing-imports --install-types --non-interactive . || true
-      - run: python -m memory_profiler pytest --fixtures . || true
-      - run: python -m memory_profiler pytest --doctest-modules --fixtures . || true
+      - run: make test || true
+      # - run: python -m memory_profiler pytest --fixtures . || true
+      # - run: python -m memory_profiler pytest --doctest-modules --fixtures . || true
       - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
       - run: safety check
","@@ -22,7 +22,8 @@ jobs:
       - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
       - run: python -m memory_profiler mypy --ignore-missing-imports --install-types --non-interactive . || true
-      - run: python -m memory_profiler pytest --fixtures . || true
-      - run: python -m memory_profiler pytest --doctest-modules --fixtures . || true
+      - run: make test || true
+      # - run: python -m memory_profiler pytest --fixtures . || true
+      # - run: python -m memory_profiler pytest --doctest-modules --fixtures . || true
       - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
       - run: safety check
",True,.github/workflows/lint_python.yml,False
"@@ -22,7 +22,7 @@ jobs:
       - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
       - run: python -m memory_profiler mypy --ignore-missing-imports --install-types --non-interactive . || true
-      - run: make test || true
+      - run: make test
       # - run: python -m memory_profiler pytest --fixtures . || true
       # - run: python -m memory_profiler pytest --doctest-modules --fixtures . || true
       - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
","@@ -22,7 +22,7 @@ jobs:
       - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
       - run: python -m memory_profiler mypy --ignore-missing-imports --install-types --non-interactive . || true
-      - run: make test || true
+      - run: make test
       # - run: python -m memory_profiler pytest --fixtures . || true
       # - run: python -m memory_profiler pytest --doctest-modules --fixtures . || true
       - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
",True,.github/workflows/lint_python.yml,False
"@@ -21,9 +21,7 @@ jobs:
       - run: pip install -r requirements.txt || pip install --editable . || pip install . || true
       - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
-      - run: python -m memory_profiler mypy --ignore-missing-imports --install-types --non-interactive . || true
+      - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
       - run: make test
-      # - run: python -m memory_profiler pytest --fixtures . || true
-      # - run: python -m memory_profiler pytest --doctest-modules --fixtures . || true
       - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
       - run: safety check
","@@ -21,9 +21,7 @@ jobs:
       - run: pip install -r requirements.txt || pip install --editable . || pip install . || true
       - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
-      - run: python -m memory_profiler mypy --ignore-missing-imports --install-types --non-interactive . || true
+      - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
       - run: make test
-      # - run: python -m memory_profiler pytest --fixtures . || true
-      # - run: python -m memory_profiler pytest --doctest-modules --fixtures . || true
       - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
       - run: safety check
",True,.github/workflows/lint_python.yml,False
"@@ -1,21 +0,0 @@
-language: python
-python:
-  - ""3.5""
-  - ""3.6""
-  - ""3.7""
-  - ""3.8""
-  - ""3.9""
-  - ""pypy3""
-
-matrix:
-  allow_failures:
-    - python: ""pypy3""
-    - python: ""3.7-dev""
-
-install:
-  - python -m pip install numpy ipython
-  - python -m pip install .
-script:
-  - make test
-
-sudo: false
","@@ -1,21 +0,0 @@
-language: python
-python:
-  - ""3.5""
-  - ""3.6""
-  - ""3.7""
-  - ""3.8""
-  - ""3.9""
-  - ""pypy3""
-
-matrix:
-  allow_failures:
-    - python: ""pypy3""
-    - python: ""3.7-dev""
-
-install:
-  - python -m pip install numpy ipython
-  - python -m pip install .
-script:
-  - make test
-
-sudo: false
",True,,False
"@@ -18,7 +18,7 @@ jobs:
       - run: flake8 . --count --exit-zero --max-complexity=10 --max-line-length=88
                       --show-source --statistics
       - run: isort --check-only --profile black . || true
-      - run: pip install -r requirements.txt || pip install --editable . || pip install . || true
+      - run: pip install --editable .
       - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
       - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
","@@ -18,7 +18,7 @@ jobs:
       - run: flake8 . --count --exit-zero --max-complexity=10 --max-line-length=88
                       --show-source --statistics
       - run: isort --check-only --profile black . || true
-      - run: pip install -r requirements.txt || pip install --editable . || pip install . || true
+      - run: pip install --editable .
       - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
       - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
",True,.github/workflows/lint_python.yml,False
"@@ -7,9 +7,10 @@ __version__ = '0.60.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
-from asyncio import coroutine, iscoroutinefunction
+from asyncio import iscoroutinefunction
 from contextlib import contextmanager
 from functools import partial, wraps
+from types import coroutine
 import builtins
 import inspect
 import linecache
","@@ -7,9 +7,10 @@ __version__ = '0.60.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
-from asyncio import coroutine, iscoroutinefunction
+from asyncio import iscoroutinefunction
 from contextlib import contextmanager
 from functools import partial, wraps
+from types import coroutine
 import builtins
 import inspect
 import linecache
",True,memory_profiler.py,True
"@@ -1,3 +1,6 @@
 [build-system]
 requires = [""setuptools""]
 build-backend = ""setuptools.build_meta""
+
+[tool.codespell]
+skip = './.git'
","@@ -1,3 +1,6 @@
 [build-system]
 requires = [""setuptools""]
 build-backend = ""setuptools.build_meta""
+
+[tool.codespell]
+skip = './.git'
",True,pyproject.toml,False
"@@ -3,11 +3,24 @@ on: [pull_request, push]
 jobs:
   lint_python:
     runs-on: ubuntu-latest
+    strategy:
+      fail-fast: false
+      matrix:
+        python: ['3.7', '3.8', '3.9', '3.10', '3.11']
     steps:
       - uses: actions/checkout@v3
       - uses: actions/setup-python@v4
         with:
-          python-version: 3.x
+          # This allows the matrix to specify just the major.minor version while still
+          # expanding it to get the latest patch version including alpha releases.
+          # This avoids the need to update for each new alpha, beta, release candidate,
+          # and then finally an actual release version.  actions/setup-python doesn't
+          # support this for PyPy presently so we get no help there.
+          #
+          # CPython -> 3.9.0-alpha - 3.9.X
+          # PyPy    -> pypy-3.7
+          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python.action), matrix.python.action))[startsWith(matrix.python.action, 'pypy')] }}
+          architecture: x64
       - run: pip install --upgrade pip wheel
       - run: pip install bandit black codespell flake8 flake8-2020 flake8-bugbear
                          flake8-comprehensions isort mypy pytest pyupgrade safety
","@@ -3,11 +3,24 @@ on: [pull_request, push]
 jobs:
   lint_python:
     runs-on: ubuntu-latest
+    strategy:
+      fail-fast: false
+      matrix:
+        python: ['3.7', '3.8', '3.9', '3.10', '3.11']
     steps:
       - uses: actions/checkout@v3
       - uses: actions/setup-python@v4
         with:
-          python-version: 3.x
+          # This allows the matrix to specify just the major.minor version while still
+          # expanding it to get the latest patch version including alpha releases.
+          # This avoids the need to update for each new alpha, beta, release candidate,
+          # and then finally an actual release version.  actions/setup-python doesn't
+          # support this for PyPy presently so we get no help there.
+          #
+          # CPython -> 3.9.0-alpha - 3.9.X
+          # PyPy    -> pypy-3.7
+          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python.action), matrix.python.action))[startsWith(matrix.python.action, 'pypy')] }}
+          architecture: x64
       - run: pip install --upgrade pip wheel
       - run: pip install bandit black codespell flake8 flake8-2020 flake8-bugbear
                          flake8-comprehensions isort mypy pytest pyupgrade safety
",True,.github/workflows/lint_python.yml,False
"@@ -19,7 +19,7 @@ jobs:
           #
           # CPython -> 3.9.0-alpha - 3.9.X
           # PyPy    -> pypy-3.7
-          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python.action), matrix.python.action))[startsWith(matrix.python.action, 'pypy')] }}
+          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python), matrix.python))[startsWith(matrix.python, 'pypy')] }}
           architecture: x64
       - run: pip install --upgrade pip wheel
       - run: pip install bandit black codespell flake8 flake8-2020 flake8-bugbear
","@@ -19,7 +19,7 @@ jobs:
           #
           # CPython -> 3.9.0-alpha - 3.9.X
           # PyPy    -> pypy-3.7
-          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python.action), matrix.python.action))[startsWith(matrix.python.action, 'pypy')] }}
+          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python), matrix.python))[startsWith(matrix.python, 'pypy')] }}
           architecture: x64
       - run: pip install --upgrade pip wheel
       - run: pip install bandit black codespell flake8 flake8-2020 flake8-bugbear
",True,.github/workflows/lint_python.yml,False
"@@ -37,4 +37,5 @@ jobs:
       - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
       - run: make test
       - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
-      - run: safety check
+      - if: matrix.python != '3.7'
+        run: safety check
","@@ -37,4 +37,5 @@ jobs:
       - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
       - run: make test
       - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
-      - run: safety check
+      - if: matrix.python != '3.7'
+        run: safety check
",True,.github/workflows/lint_python.yml,False
"@@ -1,12 +1,12 @@
 name: lint_python
 on: [pull_request, push]
 jobs:
-  lint_python:
+  lint:
     runs-on: ubuntu-latest
     strategy:
       fail-fast: false
       matrix:
-        python: ['3.7', '3.8', '3.9', '3.10', '3.11']
+        python: '3.9'
     steps:
       - uses: actions/checkout@v3
       - uses: actions/setup-python@v4
@@ -35,7 +35,32 @@ jobs:
       - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
       - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
-      - run: make test
       - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
+
+  test:
+    runs-on: ubuntu-latest
+    strategy:
+      fail-fast: false
+      matrix:
+        python: ['3.7', '3.8', '3.9', '3.10', '3.11']
+    steps:
+      - uses: actions/checkout@v3
+      - uses: actions/setup-python@v4
+        with:
+          # This allows the matrix to specify just the major.minor version while still
+          # expanding it to get the latest patch version including alpha releases.
+          # This avoids the need to update for each new alpha, beta, release candidate,
+          # and then finally an actual release version.  actions/setup-python doesn't
+          # support this for PyPy presently so we get no help there.
+          #
+          # CPython -> 3.9.0-alpha - 3.9.X
+          # PyPy    -> pypy-3.7
+          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python), matrix.python))[startsWith(matrix.python, 'pypy')] }}
+          architecture: x64
+      - run: pip install --upgrade pip wheel
+      - run: pip install pytest
+      - run: pip install --editable .
+      - run: pip install numpy pylab-sdk
+      - run: make test
       - if: matrix.python != '3.7'
         run: safety check
","@@ -1,12 +1,12 @@
 name: lint_python
 on: [pull_request, push]
 jobs:
-  lint_python:
+  lint:
     runs-on: ubuntu-latest
     strategy:
       fail-fast: false
       matrix:
-        python: ['3.7', '3.8', '3.9', '3.10', '3.11']
+        python: '3.9'
     steps:
       - uses: actions/checkout@v3
       - uses: actions/setup-python@v4
@@ -35,7 +35,32 @@ jobs:
       - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
       - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
-      - run: make test
       - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
+
+  test:
+    runs-on: ubuntu-latest
+    strategy:
+      fail-fast: false
+      matrix:
+        python: ['3.7', '3.8', '3.9', '3.10', '3.11']
+    steps:
+      - uses: actions/checkout@v3
+      - uses: actions/setup-python@v4
+        with:
+          # This allows the matrix to specify just the major.minor version while still
+          # expanding it to get the latest patch version including alpha releases.
+          # This avoids the need to update for each new alpha, beta, release candidate,
+          # and then finally an actual release version.  actions/setup-python doesn't
+          # support this for PyPy presently so we get no help there.
+          #
+          # CPython -> 3.9.0-alpha - 3.9.X
+          # PyPy    -> pypy-3.7
+          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python), matrix.python))[startsWith(matrix.python, 'pypy')] }}
+          architecture: x64
+      - run: pip install --upgrade pip wheel
+      - run: pip install pytest
+      - run: pip install --editable .
+      - run: pip install numpy pylab-sdk
+      - run: make test
       - if: matrix.python != '3.7'
         run: safety check
",True,.github/workflows/lint_python.yml,False
"@@ -6,7 +6,7 @@ jobs:
     strategy:
       fail-fast: false
       matrix:
-        python: '3.9'
+        python: ['3.9']
     steps:
       - uses: actions/checkout@v3
       - uses: actions/setup-python@v4
","@@ -6,7 +6,7 @@ jobs:
     strategy:
       fail-fast: false
       matrix:
-        python: '3.9'
+        python: ['3.9']
     steps:
       - uses: actions/checkout@v3
       - uses: actions/setup-python@v4
",True,.github/workflows/lint_python.yml,False
"@@ -23,7 +23,7 @@ jobs:
           architecture: x64
       - run: pip install --upgrade pip wheel
       - run: pip install bandit black codespell flake8 flake8-2020 flake8-bugbear
-                         flake8-comprehensions isort mypy pytest pyupgrade safety
+                         flake8-comprehensions isort mypy pytest pyupgrade
       - run: bandit --recursive --skip B101,B102,B307,B404,B603,B607 .
       - run: black --check . || true
       - run: codespell  # --ignore-words-list="""" --skip=""*.css,*.js,*.lock""
@@ -58,7 +58,7 @@ jobs:
           python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python), matrix.python))[startsWith(matrix.python, 'pypy')] }}
           architecture: x64
       - run: pip install --upgrade pip wheel
-      - run: pip install pytest
+      - run: pip install pytest safety
       - run: pip install --editable .
       - run: pip install numpy pylab-sdk
       - run: make test
","@@ -23,7 +23,7 @@ jobs:
           architecture: x64
       - run: pip install --upgrade pip wheel
       - run: pip install bandit black codespell flake8 flake8-2020 flake8-bugbear
-                         flake8-comprehensions isort mypy pytest pyupgrade safety
+                         flake8-comprehensions isort mypy pytest pyupgrade
       - run: bandit --recursive --skip B101,B102,B307,B404,B603,B607 .
       - run: black --check . || true
       - run: codespell  # --ignore-words-list="""" --skip=""*.css,*.js,*.lock""
@@ -58,7 +58,7 @@ jobs:
           python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python), matrix.python))[startsWith(matrix.python, 'pypy')] }}
           architecture: x64
       - run: pip install --upgrade pip wheel
-      - run: pip install pytest
+      - run: pip install pytest safety
       - run: pip install --editable .
       - run: pip install numpy pylab-sdk
       - run: make test
",True,.github/workflows/lint_python.yml,False
"@@ -6,7 +6,7 @@ jobs:
     strategy:
       fail-fast: false
       matrix:
-        python: ['3.9']
+        python: ['3.10']
     steps:
       - uses: actions/checkout@v3
       - uses: actions/setup-python@v4
","@@ -6,7 +6,7 @@ jobs:
     strategy:
       fail-fast: false
       matrix:
-        python: ['3.9']
+        python: ['3.10']
     steps:
       - uses: actions/checkout@v3
       - uses: actions/setup-python@v4
",True,.github/workflows/lint_python.yml,False
"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.60.0'
+__version__ = '0.61.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
","@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.60.0'
+__version__ = '0.61.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
",True,memory_profiler.py,True
"@@ -6,7 +6,9 @@ jobs:
     strategy:
       fail-fast: false
       matrix:
-        python: ['3.10']
+        python:
+          - major_dot_minor: '3.10'
+            safety: false
     steps:
       - uses: actions/checkout@v3
       - uses: actions/setup-python@v4
@@ -19,7 +21,7 @@ jobs:
           #
           # CPython -> 3.9.0-alpha - 3.9.X
           # PyPy    -> pypy-3.7
-          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python), matrix.python))[startsWith(matrix.python, 'pypy')] }}
+          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python.major_dot_minor), matrix.python.major_dot_minor))[startsWith(matrix.python.major_dot_minor, 'pypy')] }}
           architecture: x64
       - run: pip install --upgrade pip wheel
       - run: pip install bandit black codespell flake8 flake8-2020 flake8-bugbear
@@ -42,7 +44,23 @@ jobs:
     strategy:
       fail-fast: false
       matrix:
-        python: ['3.7', '3.8', '3.9', '3.10', '3.11']
+        python:
+          - major_dot_minor: '3.4'
+            safety: false
+          - major_dot_minor: '3.5'
+            safety: false
+          - major_dot_minor: '3.6'
+            safety: false
+          - major_dot_minor: '3.7'
+            safety: false
+          - major_dot_minor: '3.8'
+            safety: true
+          - major_dot_minor: '3.9'
+            safety: true
+          - major_dot_minor: '3.10'
+            safety: true
+          - major_dot_minor: '3.11'
+            safety: true
     steps:
       - uses: actions/checkout@v3
       - uses: actions/setup-python@v4
@@ -55,12 +73,12 @@ jobs:
           #
           # CPython -> 3.9.0-alpha - 3.9.X
           # PyPy    -> pypy-3.7
-          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python), matrix.python))[startsWith(matrix.python, 'pypy')] }}
+          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python.major_dot_minor), matrix.python.major_dot_minor))[startsWith(matrix.python.major_dot_minor, 'pypy')] }}
           architecture: x64
       - run: pip install --upgrade pip wheel
       - run: pip install pytest safety
       - run: pip install --editable .
       - run: pip install numpy pylab-sdk
       - run: make test
-      - if: matrix.python != '3.7'
+      - if: matrix.python.safety
         run: safety check
","@@ -6,7 +6,9 @@ jobs:
     strategy:
       fail-fast: false
       matrix:
-        python: ['3.10']
+        python:
+          - major_dot_minor: '3.10'
+            safety: false
     steps:
       - uses: actions/checkout@v3
       - uses: actions/setup-python@v4
@@ -19,7 +21,7 @@ jobs:
           #
           # CPython -> 3.9.0-alpha - 3.9.X
           # PyPy    -> pypy-3.7
-          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python), matrix.python))[startsWith(matrix.python, 'pypy')] }}
+          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python.major_dot_minor), matrix.python.major_dot_minor))[startsWith(matrix.python.major_dot_minor, 'pypy')] }}
           architecture: x64
       - run: pip install --upgrade pip wheel
       - run: pip install bandit black codespell flake8 flake8-2020 flake8-bugbear
@@ -42,7 +44,23 @@ jobs:
     strategy:
       fail-fast: false
       matrix:
-        python: ['3.7', '3.8', '3.9', '3.10', '3.11']
+        python:
+          - major_dot_minor: '3.4'
+            safety: false
+          - major_dot_minor: '3.5'
+            safety: false
+          - major_dot_minor: '3.6'
+            safety: false
+          - major_dot_minor: '3.7'
+            safety: false
+          - major_dot_minor: '3.8'
+            safety: true
+          - major_dot_minor: '3.9'
+            safety: true
+          - major_dot_minor: '3.10'
+            safety: true
+          - major_dot_minor: '3.11'
+            safety: true
     steps:
       - uses: actions/checkout@v3
       - uses: actions/setup-python@v4
@@ -55,12 +73,12 @@ jobs:
           #
           # CPython -> 3.9.0-alpha - 3.9.X
           # PyPy    -> pypy-3.7
-          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python), matrix.python))[startsWith(matrix.python, 'pypy')] }}
+          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python.major_dot_minor), matrix.python.major_dot_minor))[startsWith(matrix.python.major_dot_minor, 'pypy')] }}
           architecture: x64
       - run: pip install --upgrade pip wheel
       - run: pip install pytest safety
       - run: pip install --editable .
       - run: pip install numpy pylab-sdk
       - run: make test
-      - if: matrix.python != '3.7'
+      - if: matrix.python.safety
         run: safety check
",True,.github/workflows/lint_python.yml,False
"@@ -23,7 +23,7 @@ classifiers =
 py_modules =
     memory_profiler
     mprof
-python_requires = >=3.4
+python_requires = >=3.5
 install_requires = psutil
 
 [options.entry_points]
","@@ -23,7 +23,7 @@ classifiers =
 py_modules =
     memory_profiler
     mprof
-python_requires = >=3.4
+python_requires = >=3.5
 install_requires = psutil
 
 [options.entry_points]
",True,setup.cfg,False
"@@ -1,4 +1,5 @@
 import asyncio
+import sys
 
 from memory_profiler import profile
 
@@ -14,5 +15,13 @@ async def main():
     task = asyncio.create_task(my_func())
     res = await asyncio.gather(task)
 
+async def main_legacy():
+    future = asyncio.ensure_future(my_func())
+    res = await asyncio.gather(future)
+
 if __name__ == '__main__':
-    asyncio.run(main())  # main loop
+    if sys.version_info >= (3, 7):
+        asyncio.run(main())  # main loop
+    else:
+        loop = asyncio.get_event_loop()
+        loop.run_until_complete(main_legacy())
","@@ -1,4 +1,5 @@
 import asyncio
+import sys
 
 from memory_profiler import profile
 
@@ -14,5 +15,13 @@ async def main():
     task = asyncio.create_task(my_func())
     res = await asyncio.gather(task)
 
+async def main_legacy():
+    future = asyncio.ensure_future(my_func())
+    res = await asyncio.gather(future)
+
 if __name__ == '__main__':
-    asyncio.run(main())  # main loop
+    if sys.version_info >= (3, 7):
+        asyncio.run(main())  # main loop
+    else:
+        loop = asyncio.get_event_loop()
+        loop.run_until_complete(main_legacy())
",True,test/test_async.py,True
"@@ -45,8 +45,6 @@ jobs:
       fail-fast: false
       matrix:
         python:
-          - major_dot_minor: '3.4'
-            safety: false
           - major_dot_minor: '3.5'
             safety: false
           - major_dot_minor: '3.6'
","@@ -45,8 +45,6 @@ jobs:
       fail-fast: false
       matrix:
         python:
-          - major_dot_minor: '3.4'
-            safety: false
           - major_dot_minor: '3.5'
             safety: false
           - major_dot_minor: '3.6'
",True,.github/workflows/lint_python.yml,False
"@@ -1,5 +1,13 @@
 name: lint_python
-on: [pull_request, push]
+
+on:
+  push:
+    branches:
+      - master
+  pull_request:
+    branches:
+      - '**'
+
 jobs:
   lint:
     runs-on: ubuntu-latest
","@@ -1,5 +1,13 @@
 name: lint_python
-on: [pull_request, push]
+
+on:
+  push:
+    branches:
+      - master
+  pull_request:
+    branches:
+      - '**'
+
 jobs:
   lint:
     runs-on: ubuntu-latest
",True,.github/workflows/lint_python.yml,False
"@@ -4,6 +4,8 @@ on:
   push:
     branches:
       - master
+    tags:
+      - v*
   pull_request:
     branches:
       - '**'
","@@ -4,6 +4,8 @@ on:
   push:
     branches:
       - master
+    tags:
+      - v*
   pull_request:
     branches:
       - '**'
",True,.github/workflows/lint_python.yml,False
"@@ -23,7 +23,7 @@ classifiers =
 py_modules =
     memory_profiler
     mprof
-python_requires = >=3.5
+python_requires = >=3.7
 install_requires = psutil
 
 [options.entry_points]
","@@ -23,7 +23,7 @@ classifiers =
 py_modules =
     memory_profiler
     mprof
-python_requires = >=3.5
+python_requires = >=3.7
 install_requires = psutil
 
 [options.entry_points]
",True,setup.cfg,False
"@@ -55,10 +55,6 @@ jobs:
       fail-fast: false
       matrix:
         python:
-          - major_dot_minor: '3.5'
-            safety: false
-          - major_dot_minor: '3.6'
-            safety: false
           - major_dot_minor: '3.7'
             safety: false
           - major_dot_minor: '3.8'
","@@ -55,10 +55,6 @@ jobs:
       fail-fast: false
       matrix:
         python:
-          - major_dot_minor: '3.5'
-            safety: false
-          - major_dot_minor: '3.6'
-            safety: false
           - major_dot_minor: '3.7'
             safety: false
           - major_dot_minor: '3.8'
",True,.github/workflows/lint_python.yml,False
"@@ -18,7 +18,7 @@ class TestExitCode(unittest.TestCase):
             ofile.write(s)
             ofile.flush()
             sys.argv = ['<ignored>', '--exit-code', tmpfile.name]
-            self.assertRaisesRegexp(SystemExit, '0', self.run_action)
+            self.assertRaisesRegex(SystemExit, '0', self.run_action)
 
     def test_exit_code_fail(self):
         s = ""raise RuntimeError('I am not working nicely')""
@@ -27,7 +27,7 @@ class TestExitCode(unittest.TestCase):
             ofile.write(s)
             ofile.flush()
             sys.argv = ['<ignored>', '--exit-code', tmpfile.name]
-            self.assertRaisesRegexp(SystemExit, '1', self.run_action)
+            self.assertRaisesRegex(SystemExit, '1', self.run_action)
 
     def test_no_exit_code_success(self):
         s = ""raise RuntimeError('I am not working nicely')""
","@@ -18,7 +18,7 @@ class TestExitCode(unittest.TestCase):
             ofile.write(s)
             ofile.flush()
             sys.argv = ['<ignored>', '--exit-code', tmpfile.name]
-            self.assertRaisesRegexp(SystemExit, '0', self.run_action)
+            self.assertRaisesRegex(SystemExit, '0', self.run_action)
 
     def test_exit_code_fail(self):
         s = ""raise RuntimeError('I am not working nicely')""
@@ -27,7 +27,7 @@ class TestExitCode(unittest.TestCase):
             ofile.write(s)
             ofile.flush()
             sys.argv = ['<ignored>', '--exit-code', tmpfile.name]
-            self.assertRaisesRegexp(SystemExit, '1', self.run_action)
+            self.assertRaisesRegex(SystemExit, '1', self.run_action)
 
     def test_no_exit_code_success(self):
         s = ""raise RuntimeError('I am not working nicely')""
",True,test/test_exit_code.py,True
"@@ -95,8 +95,9 @@ The first column represents the line number of the code that has been
 profiled, the second column (*Mem usage*) the memory usage of the
 Python interpreter after that line has been executed. The third column
 (*Increment*) represents the difference in memory of the current line
-with respect to the last one. The last column (*Line Contents*) prints
-the code that has been profiled.
+with respect to the last one. The fourth column (*Occurrences*) shows
+the number of times that profiler has hit each line. The last column
+(*Line Contents*) prints the code that has been profiled.
 
 Decorator
 =========
","@@ -95,8 +95,9 @@ The first column represents the line number of the code that has been
 profiled, the second column (*Mem usage*) the memory usage of the
 Python interpreter after that line has been executed. The third column
 (*Increment*) represents the difference in memory of the current line
-with respect to the last one. The last column (*Line Contents*) prints
-the code that has been profiled.
+with respect to the last one. The fourth column (*Occurrences*) shows
+the number of times that profiler has hit each line. The last column
+(*Line Contents*) prints the code that has been profiled.
 
 Decorator
 =========
",True,README.rst,False
"@@ -96,7 +96,7 @@ profiled, the second column (*Mem usage*) the memory usage of the
 Python interpreter after that line has been executed. The third column
 (*Increment*) represents the difference in memory of the current line
 with respect to the last one. The fourth column (*Occurrences*) shows
-the number of times that profiler has hit each line. The last column
+the number of times that profiler has executed each line. The last column
 (*Line Contents*) prints the code that has been profiled.
 
 Decorator
","@@ -96,7 +96,7 @@ profiled, the second column (*Mem usage*) the memory usage of the
 Python interpreter after that line has been executed. The third column
 (*Increment*) represents the difference in memory of the current line
 with respect to the last one. The fourth column (*Occurrences*) shows
-the number of times that profiler has hit each line. The last column
+the number of times that profiler has executed each line. The last column
 (*Line Contents*) prints the code that has been profiled.
 
 Decorator
",True,README.rst,False
"@@ -58,8 +58,9 @@ then run the script with a special script (in this case with specific
 arguments to the Python interpreter).
 
 In the following example, we create a simple function ``my_func`` that
-allocates lists ``a``, ``b`` and then deletes ``b``::
+allocates lists ``a``, ``b`` and then deletes ``b``:
 
+.. code-block:: python
 
     @profile
     def my_func():
@@ -101,7 +102,9 @@ the number of times that profiler has executed each line. The last column
 
 Decorator
 =========
-A function decorator is also available.  Use as follows::
+A function decorator is also available.  Use as follows:
+
+.. code-block:: python
 
     from memory_profiler import profile
 
@@ -116,7 +119,9 @@ In this case the script can be run without specifying ``-m
 memory_profiler`` in the command line.
 
 In function decorator, you can specify the precision as an argument to the
-decorator function.  Use as follows::
+decorator function.  Use as follows:
+
+.. code-block:: python
 
     from memory_profiler import profile
 
@@ -282,6 +287,7 @@ necessarily a Python program), a string containing some python code to
 be evaluated or a tuple ``(f, args, kw)`` containing a function and its
 arguments to be evaluated as ``f(*args, **kw)``. For example,
 
+.. code-block:: python
 
     >>> from memory_profiler import memory_usage
     >>> mem_usage = memory_usage(-1, interval=.2, timeout=1)
@@ -301,8 +307,9 @@ thing on the IPython notebook it scales up to 44MB.
 
 If you'd like to get the memory consumption of a Python function, then
 you should specify the function and its arguments in the tuple ``(f,
-args, kw)``. For example::
+args, kw)``. For example:
 
+.. code-block:: python
 
     >>> # define a simple function
     >>> def f(a, n=100):
@@ -325,6 +332,8 @@ REPORTING
 The output can be redirected to a log file by passing IO stream as
 parameter to the decorator like @profile(stream=fp)
 
+.. code-block:: python
+
     >>> fp=open('memory_profiler.log','w+')
     >>> @profile(stream=fp)
     >>> def my_func():
@@ -333,7 +342,7 @@ parameter to the decorator like @profile(stream=fp)
         ...     del b
         ...     return a
 
-    For details refer: examples/reporting_file.py
+For details refer: examples/reporting_file.py
 
 ``Reporting via logger Module:``
 
@@ -343,6 +352,8 @@ when we need to use RotatingFileHandler.
 The output can be redirected to logger module by simply making use of
 LogFile of memory profiler module.
 
+.. code-block:: python
+
     >>> from memory_profiler import LogFile
     >>> import sys
     >>> sys.stdout = LogFile('memory_profile_log')
@@ -354,11 +365,13 @@ could be cumbersome and one can choose only entries with increments
 by passing True to reportIncrementFlag, where reportIncrementFlag is
 a parameter to LogFile class of memory profiler module.
 
+.. code-block:: python
+
     >>> from memory_profiler import LogFile
     >>> import sys
     >>> sys.stdout = LogFile('memory_profile_log', reportIncrementFlag=False)
 
-    For details refer: examples/reporting_logger.py
+For details refer: examples/reporting_logger.py
 
 =====================
  IPython integration
@@ -372,7 +385,9 @@ For IPython 0.11+, you can use the module directly as an extension, with
 To activate it whenever you start IPython, edit the configuration file for your
 IPython profile, ~/.ipython/profile_default/ipython_config.py, to register the
 extension like this (If you already have other extensions, just add this one to
-the list)::
+the list):
+
+.. code-block:: python
 
     c.InteractiveShellApp.extensions = [
         'memory_profiler',
@@ -385,20 +400,26 @@ It then can be used directly from IPython to obtain a line-by-line
 report using the `%mprun` or `%%mprun` magic command. In this case, you can skip
 the `@profile` decorator and instead use the `-f` parameter, like
 this. Note however that function my_func must be defined in a file
-(cannot have been defined interactively in the Python interpreter)::
+(cannot have been defined interactively in the Python interpreter):
+
+.. code-block:: python
 
     In [1]: from example import my_func, my_func_2
 
     In [2]: %mprun -f my_func my_func()
 
-or in cell mode::
+or in cell mode:
+
+.. code-block:: python
 
     In [3]: %%mprun -f my_func -f my_func_2
        ...: my_func()
        ...: my_func_2()
 
 Another useful magic that we define is `%memit`, which is analogous to
-`%timeit`. It can be used as follows::
+`%timeit`. It can be used as follows:
+
+.. code-block:: python
 
     In [1]: %memit range(10000)
     peak memory: 21.42 MiB, increment: 0.41 MiB
@@ -406,7 +427,9 @@ Another useful magic that we define is `%memit`, which is analogous to
     In [2]: %memit range(1000000)
     peak memory: 52.10 MiB, increment: 31.08 MiB
 
-or in cell mode (with setup code)::
+or in cell mode (with setup code):
+
+.. code-block:: python
 
     In [3]: %%memit l=range(1000000)
        ...: len(l)
@@ -416,7 +439,9 @@ or in cell mode (with setup code)::
 For more details, see the docstrings of the magics.
 
 For IPython 0.10, you can install it by editing the IPython configuration
-file ~/.ipython/ipy_user_conf.py to add the following lines::
+file ~/.ipython/ipy_user_conf.py to add the following lines:
+
+.. code-block:: python
 
     # These two lines are standard and probably already there.
     import IPython.ipapi
@@ -441,6 +466,8 @@ Currently, the backend can be set via the CLI
 
 and is exposed by the API
 
+.. code-block:: python
+
     >>> from memory_profiler import memory_usage
     >>> mem_usage = memory_usage(-1, interval=.2, timeout=1, backend=""psutil"")
 
","@@ -58,8 +58,9 @@ then run the script with a special script (in this case with specific
 arguments to the Python interpreter).
 
 In the following example, we create a simple function ``my_func`` that
-allocates lists ``a``, ``b`` and then deletes ``b``::
+allocates lists ``a``, ``b`` and then deletes ``b``:
 
+.. code-block:: python
 
     @profile
     def my_func():
@@ -101,7 +102,9 @@ the number of times that profiler has executed each line. The last column
 
 Decorator
 =========
-A function decorator is also available.  Use as follows::
+A function decorator is also available.  Use as follows:
+
+.. code-block:: python
 
     from memory_profiler import profile
 
@@ -116,7 +119,9 @@ In this case the script can be run without specifying ``-m
 memory_profiler`` in the command line.
 
 In function decorator, you can specify the precision as an argument to the
-decorator function.  Use as follows::
+decorator function.  Use as follows:
+
+.. code-block:: python
 
     from memory_profiler import profile
 
@@ -282,6 +287,7 @@ necessarily a Python program), a string containing some python code to
 be evaluated or a tuple ``(f, args, kw)`` containing a function and its
 arguments to be evaluated as ``f(*args, **kw)``. For example,
 
+.. code-block:: python
 
     >>> from memory_profiler import memory_usage
     >>> mem_usage = memory_usage(-1, interval=.2, timeout=1)
@@ -301,8 +307,9 @@ thing on the IPython notebook it scales up to 44MB.
 
 If you'd like to get the memory consumption of a Python function, then
 you should specify the function and its arguments in the tuple ``(f,
-args, kw)``. For example::
+args, kw)``. For example:
 
+.. code-block:: python
 
     >>> # define a simple function
     >>> def f(a, n=100):
@@ -325,6 +332,8 @@ REPORTING
 The output can be redirected to a log file by passing IO stream as
 parameter to the decorator like @profile(stream=fp)
 
+.. code-block:: python
+
     >>> fp=open('memory_profiler.log','w+')
     >>> @profile(stream=fp)
     >>> def my_func():
@@ -333,7 +342,7 @@ parameter to the decorator like @profile(stream=fp)
         ...     del b
         ...     return a
 
-    For details refer: examples/reporting_file.py
+For details refer: examples/reporting_file.py
 
 ``Reporting via logger Module:``
 
@@ -343,6 +352,8 @@ when we need to use RotatingFileHandler.
 The output can be redirected to logger module by simply making use of
 LogFile of memory profiler module.
 
+.. code-block:: python
+
     >>> from memory_profiler import LogFile
     >>> import sys
     >>> sys.stdout = LogFile('memory_profile_log')
@@ -354,11 +365,13 @@ could be cumbersome and one can choose only entries with increments
 by passing True to reportIncrementFlag, where reportIncrementFlag is
 a parameter to LogFile class of memory profiler module.
 
+.. code-block:: python
+
     >>> from memory_profiler import LogFile
     >>> import sys
     >>> sys.stdout = LogFile('memory_profile_log', reportIncrementFlag=False)
 
-    For details refer: examples/reporting_logger.py
+For details refer: examples/reporting_logger.py
 
 =====================
  IPython integration
@@ -372,7 +385,9 @@ For IPython 0.11+, you can use the module directly as an extension, with
 To activate it whenever you start IPython, edit the configuration file for your
 IPython profile, ~/.ipython/profile_default/ipython_config.py, to register the
 extension like this (If you already have other extensions, just add this one to
-the list)::
+the list):
+
+.. code-block:: python
 
     c.InteractiveShellApp.extensions = [
         'memory_profiler',
@@ -385,20 +400,26 @@ It then can be used directly from IPython to obtain a line-by-line
 report using the `%mprun` or `%%mprun` magic command. In this case, you can skip
 the `@profile` decorator and instead use the `-f` parameter, like
 this. Note however that function my_func must be defined in a file
-(cannot have been defined interactively in the Python interpreter)::
+(cannot have been defined interactively in the Python interpreter):
+
+.. code-block:: python
 
     In [1]: from example import my_func, my_func_2
 
     In [2]: %mprun -f my_func my_func()
 
-or in cell mode::
+or in cell mode:
+
+.. code-block:: python
 
     In [3]: %%mprun -f my_func -f my_func_2
        ...: my_func()
        ...: my_func_2()
 
 Another useful magic that we define is `%memit`, which is analogous to
-`%timeit`. It can be used as follows::
+`%timeit`. It can be used as follows:
+
+.. code-block:: python
 
     In [1]: %memit range(10000)
     peak memory: 21.42 MiB, increment: 0.41 MiB
@@ -406,7 +427,9 @@ Another useful magic that we define is `%memit`, which is analogous to
     In [2]: %memit range(1000000)
     peak memory: 52.10 MiB, increment: 31.08 MiB
 
-or in cell mode (with setup code)::
+or in cell mode (with setup code):
+
+.. code-block:: python
 
     In [3]: %%memit l=range(1000000)
        ...: len(l)
@@ -416,7 +439,9 @@ or in cell mode (with setup code)::
 For more details, see the docstrings of the magics.
 
 For IPython 0.10, you can install it by editing the IPython configuration
-file ~/.ipython/ipy_user_conf.py to add the following lines::
+file ~/.ipython/ipy_user_conf.py to add the following lines:
+
+.. code-block:: python
 
     # These two lines are standard and probably already there.
     import IPython.ipapi
@@ -441,6 +466,8 @@ Currently, the backend can be set via the CLI
 
 and is exposed by the API
 
+.. code-block:: python
+
     >>> from memory_profiler import memory_usage
     >>> mem_usage = memory_usage(-1, interval=.2, timeout=1, backend=""psutil"")
 
",True,README.rst,False
"@@ -6,7 +6,7 @@
 =================
 
 
-**Note:** This package is no longer actively maintained. I won't be actively responding to issues. If you'd like to volunteer to maintain it, please drop me a line at f@bianp.net
+**Note:** This package is no longer actively maintained. I won't be actively responding to issues.
 
 This is a python module for monitoring memory consumption of a process
 as well as line-by-line analysis of memory consumption for python
","@@ -6,7 +6,7 @@
 =================
 
 
-**Note:** This package is no longer actively maintained. I won't be actively responding to issues. If you'd like to volunteer to maintain it, please drop me a line at f@bianp.net
+**Note:** This package is no longer actively maintained. I won't be actively responding to issues.
 
 This is a python module for monitoring memory consumption of a process
 as well as line-by-line analysis of memory consumption for python
",True,README.rst,False
