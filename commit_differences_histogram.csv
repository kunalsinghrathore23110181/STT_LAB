Old File Path,New File Path,Commit SHA,Parent Commit SHA,Commit Message,Histogram Diff
,.idea/dictionaries/fabian.xml,124d113eb8331703a15bd542feee0413eac1baf7,605fb322fabdd01cc2c7c0594a1ec508d873d29c,"FIX: second try at issue #8.

not perfect but makes more sense than previous solution.","@@ -0,0 +1,3 @@
+<component name=""ProjectDictionaryState"">
+  <dictionary name=""fabian"" />
+</component>
\ No newline at end of file
"
examples/example_loop.py,,124d113eb8331703a15bd542feee0413eac1baf7,605fb322fabdd01cc2c7c0594a1ec508d873d29c,"FIX: second try at issue #8.

not perfect but makes more sense than previous solution.","@@ -1,12 +0,0 @@
-# .. an example with a for loop ..
-
-
-@profile
-def my_func():
-    a = {}
-    for i in range(10000):
-        a[i] =  i + 1
-    return
-
-if __name__ == '__main__':
-    my_func()
"
memory_profiler.py,memory_profiler.py,124d113eb8331703a15bd542feee0413eac1baf7,605fb322fabdd01cc2c7c0594a1ec508d873d29c,"FIX: second try at issue #8.

not perfect but makes more sense than previous solution.","@@ -231,14 +231,14 @@ def show_results(prof, stream=None):
         # move everything one frame up
         keys = sorted(lines.keys())
 
+        k_old = keys[0] - 1
         lines_normalized[keys[0] - 1] = lines[keys[0]]
         k = keys.pop(0)
         while keys:
-            if len(lines[keys[0]]) > 1:
-                # .. inside a loop ..
-                lines_normalized[k] = lines[k]
-            else:
-                lines_normalized[k] = lines[keys[0]]
+            lines_normalized[k] = lines[keys[0]]
+            for i in range(len(lines_normalized[k_old]), len(lines_normalized[k])):
+                lines_normalized[k][i] = -1.
+            k_old = k
             k = keys.pop(0)
 
         first_line = sorted(lines_normalized.keys())[0]
@@ -254,6 +254,7 @@ def show_results(prof, stream=None):
                 inc = '{0:5.2f} MB'.format(inc)
             line = linecache.getline(filename, l)
             stream.write(template.format(l, mem, inc, line))
+        stream.write('\n')
 
 if __name__ == '__main__':
     from optparse import OptionParser
"
,test/__init__.py,124d113eb8331703a15bd542feee0413eac1baf7,605fb322fabdd01cc2c7c0594a1ec508d873d29c,"FIX: second try at issue #8.

not perfect but makes more sense than previous solution.","@@ -0,0 +1 @@
+__author__ = 'fabian'
"
,test/test_loop.py,124d113eb8331703a15bd542feee0413eac1baf7,605fb322fabdd01cc2c7c0594a1ec508d873d29c,"FIX: second try at issue #8.

not perfect but makes more sense than previous solution.","@@ -0,0 +1,24 @@
+# .. an example with a for loop ..
+
+@profile
+def test_1():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    del b
+
+    for i in range(2):
+        a = [1] * (10 ** 6)
+        b = [2] * (2 * 10 ** 7)
+        del b
+    return a
+
+@profile
+def test_2():
+    a = {}
+    for i in range(10000):
+        a[i] =  i + 1
+    return
+
+if __name__ == '__main__':
+    test_1()
+    test_2()
"
,.gitignore,53af062ee9586e01485826f0ffd8ec836348a1fb,124d113eb8331703a15bd542feee0413eac1baf7,Add .gitignore,"@@ -0,0 +1,3 @@
+.idea
+dist
+*.pyc
"
.idea/dictionaries/fabian.xml,,bb95d3e19f8fc1900493bf3f11990c6e88a9323b,53af062ee9586e01485826f0ffd8ec836348a1fb,rm conf file,"@@ -1,3 +0,0 @@
-<component name=""ProjectDictionaryState"">
-  <dictionary name=""fabian"" />
-</component>
\ No newline at end of file
"
,test/test_func.py,1bf6a15af1c22a881fe5b4b17e27ee17f379d341,bb95d3e19f8fc1900493bf3f11990c6e88a9323b,Add test for function,"@@ -0,0 +1,14 @@
+
+@profile
+def test_1():
+    # .. will be called twice ..
+    a = 2.
+    b = 3
+    c = {}
+    for i in range(1000):
+        c[i] = 2
+    c[0] = 2.
+
+if __name__ == '__main__':
+    test_1()
+    test_1()
"
memory_profiler.py,memory_profiler.py,bfe4fc3f8a893c03abcef2b7730ddf7ed7a31c6f,1bf6a15af1c22a881fe5b4b17e27ee17f379d341,"FIX: sys.argv on executed scripts.

fixes issue #10","@@ -266,6 +266,9 @@ if __name__ == '__main__':
 
     (options, args) = parser.parse_args()
 
+    # .. remove memory_profiler from sys.argv ..
+    sys.argv.pop(0)
+
     prof = LineProfiler()
     __file__ = _find_script(args[0])
     if sys.version_info[0] < 3:
"
test/test_func.py,test/test_func.py,a9b5c4799d47deb89006a018c67c999e87a7cfb1,bfe4fc3f8a893c03abcef2b7730ddf7ed7a31c6f,update test,"@@ -2,12 +2,9 @@
 @profile
 def test_1():
     # .. will be called twice ..
-    a = 2.
-    b = 3
     c = {}
     for i in range(1000):
         c[i] = 2
-    c[0] = 2.
 
 if __name__ == '__main__':
     test_1()
"
memory_profiler.py,memory_profiler.py,307f0c0c953349aec05f9c559e02ed4ac4b15e0a,a9b5c4799d47deb89006a018c67c999e87a7cfb1,"another release

![yay](http://cf2.8tracks.us/mix_covers/000/045/290/4833989106.max200.jpg)","@@ -1,6 +1,6 @@
 """"""Get process information""""""
 
-__version__ = '0.12'
+__version__ = '0.13'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
@@ -16,8 +16,7 @@ try:
 
 except ImportError:
 
-    warnings.warn(""psutil module not found. This module provides ""
-                  ""speed enhacements and windows support"")
+    warnings.warn(""psutil module not found. memory_profiler will be slow"")
 
     import subprocess
     if os.name == 'posix':
"
memory_profiler.py,memory_profiler.py,c08deaa9c859a912c40e9a1213a9d4b29b411b41,307f0c0c953349aec05f9c559e02ed4ac4b15e0a,Cleanup,"@@ -142,7 +142,6 @@ class LineProfiler:
         try:
             code = func.__code__
         except AttributeError:
-            import warnings
             warnings.warn(""Could not extract a code object for the object {0!r}""
                             .format(func))
             return
@@ -180,8 +179,7 @@ class LineProfiler:
 
     def trace_memory_usage(self, frame, event, arg):
 
-        if event in ('line', 'return'):
-            if frame.f_code in self.code_map:
+        if event in ('line', 'return') and frame.f_code in self.code_map:
                 lineno = frame.f_lineno
                 if event == 'return':
                     lineno += 1
@@ -219,8 +217,7 @@ def show_results(prof, stream=None):
             # .. measurements are empty ..
             continue
         filename = code.co_filename
-        if (filename.endswith("".pyc"") or
-            filename.endswith("".pyo"")):
+        if filename.endswith(("".pyc"", "".pyo"")):
             filename = filename[:-1]
         all_lines = linecache.getlines(filename)
         sub_lines = inspect.getblock(all_lines[code.co_firstlineno-1:])
"
memory_profiler.py,memory_profiler.py,ec3ad5298cc1d9db9fe27920e3eb8d216c3d80da,ddb32317b4f81d26f397f884beadaba05adefc94,Use cached lines,"@@ -239,7 +239,7 @@ def show_results(prof, stream=None):
 
         first_line = sorted(lines_normalized.keys())[0]
         mem_old = max(lines_normalized[first_line])
-        for l in linenos:
+        for i, l in enumerate(linenos):
             mem = ''
             inc = ''
             if l in lines_normalized:
@@ -248,8 +248,7 @@ def show_results(prof, stream=None):
                 mem_old = mem
                 mem = '{0:5.2f} MB'.format(mem)
                 inc = '{0:5.2f} MB'.format(inc)
-            line = linecache.getline(filename, l)
-            stream.write(template.format(l, mem, inc, line))
+            stream.write(template.format(l, mem, inc, sub_lines[i]))
         stream.write('\n')
 
 if __name__ == '__main__':
"
.gitignore,.gitignore,40b034c359e00e904df1c7441bf9de4affe4ee8e,ec3ad5298cc1d9db9fe27920e3eb8d216c3d80da,Add MANIFEST got .gitignore,"@@ -1,3 +1,4 @@
 .idea
 dist
 *.pyc
+MANIFEST
"
README.rst,README.rst,c2a644b71c70ce5bab455ff14dde2a1869ea1c9f,40b034c359e00e904df1c7441bf9de4affe4ee8e,Update README,"@@ -91,8 +91,7 @@ the code that has been profiled.
  Support, bugs & wish list
 ===========================
 For support, please ask your question on `stack overflow
-<http://stackoverflow.com/>`_ and tag it with the *memory-profiler*
-keyword.
+<http://stackoverflow.com/>`_ and add the *profiling* tag.
 Send issues, proposals, etc. to `github's issue tracker
 <https://github.com/fabianp/memory_profiler/issues>`_ .
 
"
memory_profiler.py,memory_profiler.py,78bc76a3db5fa509ad71df83c9332bf76e73b710,c2a644b71c70ce5bab455ff14dde2a1869ea1c9f,New release,"@@ -1,6 +1,6 @@
 """"""Get process information""""""
 
-__version__ = '0.13'
+__version__ = '0.14'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
memory_profiler.py,memory_profiler.py,ad3042b32a917eb435a1bc5f594797b31deb0ee6,40b034c359e00e904df1c7441bf9de4affe4ee8e,Better debugging when filename is not found.,"@@ -207,9 +207,6 @@ def show_results(prof, stream=None):
     if stream is None:
         stream = sys.stdout
     template = '{0:>6} {1:>12} {2:>10}   {3:<}'
-    header = template.format('Line #', 'Mem usage', 'Increment', 'Line Contents')
-    stream.write(header + '\n')
-    stream.write('=' * len(header) + '\n')
 
     for code in prof.code_map:
         lines = prof.code_map[code]
@@ -219,11 +216,18 @@ def show_results(prof, stream=None):
         filename = code.co_filename
         if filename.endswith(("".pyc"", "".pyo"")):
             filename = filename[:-1]
+        stream.write('Filename: ' + filename + '\n\n')
+        if not os.path.exists(filename):
+            stream.write('ERROR: Could not find file ' + filenam + '\n')
+            continue
         all_lines = linecache.getlines(filename)
         sub_lines = inspect.getblock(all_lines[code.co_firstlineno-1:])
         linenos = range(code.co_firstlineno, code.co_firstlineno + len(sub_lines))
         lines_normalized = {}
 
+        header = template.format('Line #', 'Mem usage', 'Increment', 'Line Contents')
+        stream.write(header + '\n')
+        stream.write('=' * len(header) + '\n')
         # move everything one frame up
         keys = sorted(lines.keys())
 
@@ -249,7 +253,7 @@ def show_results(prof, stream=None):
                 mem = '{0:5.2f} MB'.format(mem)
                 inc = '{0:5.2f} MB'.format(inc)
             stream.write(template.format(l, mem, inc, sub_lines[i]))
-        stream.write('\n')
+        stream.write('\n\n')
 
 if __name__ == '__main__':
     from optparse import OptionParser
"
memory_profiler.py,memory_profiler.py,5887e96c69615bba60008db19b70a04c2db46efe,0091f03887ac881c4c73981d7b72e893d6f4122c,"PEP8, typo fixes","@@ -1,11 +1,15 @@
-""""""Get process information""""""
+""""""Profile the memory usage of a Python program""""""
 
 __version__ = '0.14'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
-import time, sys, os, warnings
-import linecache, inspect
+import time
+import sys
+import os
+import warnings
+import linecache
+import inspect
 
 try:
     import psutil
@@ -36,7 +40,8 @@ except ImportError:
     else:
         raise NotImplementedError('The psutil module is required for non-unix platforms')
 
-def memory_usage(proc= -1, num= -1, interval=.1):
+
+def memory_usage(proc=-1, num=-1, interval=.1):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -70,6 +75,7 @@ def memory_usage(proc= -1, num= -1, interval=.1):
         filename = _find_script(proc)
         with open(filename) as f:
             proc = f.read()
+
         # TODO: make sure script's directory is on sys.path
         def f_exec(x, locals):
             # function interface for exec
@@ -84,7 +90,7 @@ def memory_usage(proc= -1, num= -1, interval=.1):
             proc = (proc[0], proc[1], {})
         p = Process(target=proc[0], args=proc[1], kwargs=proc[2])
         p.start()
-        while p.is_alive(): # FIXME: or num
+        while p.is_alive():  # FIXME: or num
             ret.append(_get_memory(p.pid))
             time.sleep(interval)
     else:
@@ -100,6 +106,7 @@ def memory_usage(proc= -1, num= -1, interval=.1):
 # ..
 # .. utility functions for line-by-line ..
 
+
 def _find_script(script_name):
     """""" Find the script.
 
@@ -202,6 +209,7 @@ class LineProfiler:
         self.last_time = {}
         sys.settrace(None)
 
+
 def show_results(prof, stream=None):
 
     if stream is None:
@@ -218,14 +226,16 @@ def show_results(prof, stream=None):
             filename = filename[:-1]
         stream.write('Filename: ' + filename + '\n\n')
         if not os.path.exists(filename):
-            stream.write('ERROR: Could not find file ' + filenam + '\n')
+            stream.write('ERROR: Could not find file ' + filename + '\n')
             continue
         all_lines = linecache.getlines(filename)
-        sub_lines = inspect.getblock(all_lines[code.co_firstlineno-1:])
-        linenos = range(code.co_firstlineno, code.co_firstlineno + len(sub_lines))
+        sub_lines = inspect.getblock(all_lines[code.co_firstlineno - 1:])
+        linenos = range(code.co_firstlineno, code.co_firstlineno +
+                        len(sub_lines))
         lines_normalized = {}
 
-        header = template.format('Line #', 'Mem usage', 'Increment', 'Line Contents')
+        header = template.format('Line #', 'Mem usage', 'Increment',
+                                 'Line Contents')
         stream.write(header + '\n')
         stream.write('=' * len(header) + '\n')
         # move everything one frame up
@@ -236,7 +246,8 @@ def show_results(prof, stream=None):
         k = keys.pop(0)
         while keys:
             lines_normalized[k] = lines[keys[0]]
-            for i in range(len(lines_normalized[k_old]), len(lines_normalized[k])):
+            for i in range(len(lines_normalized[k_old]),
+                           len(lines_normalized[k])):
                 lines_normalized[k][i] = -1.
             k_old = k
             k = keys.pop(0)
@@ -277,6 +288,7 @@ if __name__ == '__main__':
     else:
         import builtins
         builtins.__dict__['profile'] = prof
-        exec(compile(open(__file__).read(), __file__, 'exec'), locals(), globals())
+        exec(compile(open(__file__).read(), __file__, 'exec'), locals(),
+                                                               globals())
 
     show_results(prof)
"
memory_profiler.py,memory_profiler.py,249ffe7863be84e343f806297cb52a6fc967b6ee,5887e96c69615bba60008db19b70a04c2db46efe,"Added mprun magic (old style, seems to work)","@@ -133,6 +133,8 @@ class LineProfiler:
         self.functions = list(functions)
         self.code_map = {}
         self.enable_count = 0
+        for func in functions:
+            self.add_function(func)
 
     def __call__(self, func):
         self.add_function(func)
@@ -147,10 +149,11 @@ class LineProfiler:
         """""" Record line profiling information for the given Python function.
         """"""
         try:
-            code = func.__code__
+            code = func.func_code
         except AttributeError:
-            warnings.warn(""Could not extract a code object for the object {0!r}""
-                            .format(func))
+            import warnings
+            warnings.warn(""Could not extract a code object for the object %r""
+                          % (func,))
             return
         if code not in self.code_map:
             self.code_map[code] = {}
@@ -168,6 +171,32 @@ class LineProfiler:
             return result
         return f
 
+    def run(self, cmd):
+        """""" Profile a single executable statment in the main namespace.
+        """"""
+        import __main__
+        dict = __main__.__dict__
+        return self.runctx(cmd, dict, dict)
+
+    def runctx(self, cmd, globals, locals):
+        """""" Profile a single executable statement in the given namespaces.
+        """"""
+        self.enable_by_count()
+        try:
+            exec cmd in globals, locals
+        finally:
+            self.disable_by_count()
+        return self
+
+    def runcall(self, func, *args, **kw):
+        """""" Profile a single function call.
+        """"""
+        self.enable_by_count()
+        try:
+            return func(*args, **kw)
+        finally:
+            self.disable_by_count()
+
     def enable_by_count(self):
         """""" Enable the profiler if it hasn't been enabled before.
         """"""
@@ -193,7 +222,6 @@ class LineProfiler:
                 entry = self.code_map[frame.f_code].setdefault(lineno, [])
                 entry.append(_get_memory(os.getpid()))
 
-        # why this is needed, I don't know
         return self.trace_memory_usage
 
     def __enter__(self):
@@ -211,7 +239,6 @@ class LineProfiler:
 
 
 def show_results(prof, stream=None):
-
     if stream is None:
         stream = sys.stdout
     template = '{0:>6} {1:>12} {2:>10}   {3:<}'
@@ -261,11 +288,132 @@ def show_results(prof, stream=None):
                 mem = max(lines_normalized[l])
                 inc = mem - mem_old
                 mem_old = mem
-                mem = '{0:5.2f} MB'.format(mem)
-                inc = '{0:5.2f} MB'.format(inc)
+                mem = '{0:5.4f} MB'.format(mem)
+                inc = '{0:5.4f} MB'.format(inc)
             stream.write(template.format(l, mem, inc, sub_lines[i]))
         stream.write('\n\n')
 
+
+# A %lprun magic for IPython.
+def magic_mprun(self, parameter_s=''):
+    """""" Execute a statement under the line-by-line memory profiler from the
+    memory_profilser module.
+
+    Usage:
+      %mprun -f func1 -f func2 <statement>
+
+    The given statement (which doesn't require quote marks) is run via the
+    LineProfiler. Profiling is enabled for the functions specified by the -f
+    options. The statistics will be shown side-by-side with the code through the
+    pager once the statement has completed.
+
+    Options:
+
+    -f <function>: LineProfiler only profiles functions and methods it is told
+    to profile.  This option tells the profiler about these functions. Multiple
+    -f options may be used. The argument may be any expression that gives
+    a Python function or method object. However, one must be careful to avoid
+    spaces that may confuse the option parser. Additionally, functions defined
+    in the interpreter at the In[] prompt or via %run currently cannot be
+    displayed.  Write these functions out to a separate file and import them.
+
+    One or more -f options are required to get any useful results.
+
+    -T <filename>: dump the text-formatted statistics with the code side-by-side
+    out to a text file.
+
+    -r: return the LineProfiler object after it has completed profiling.
+    """"""
+    from StringIO import StringIO
+
+    # Local imports to avoid hard dependency.
+    from distutils.version import LooseVersion
+    import IPython
+    ipython_version = LooseVersion(IPython.__version__)
+    if ipython_version < '0.11':
+        from IPython.genutils import page
+        from IPython.ipstruct import Struct
+        from IPython.ipapi import UsageError
+    else:
+        from IPython.core.page import page
+        from IPython.utils.ipstruct import Struct
+        from IPython.core.error import UsageError
+
+    # Escape quote markers.
+    opts_def = Struct(T=[''], f=[])
+    parameter_s = parameter_s.replace('""', r'\""').replace(""'"", r""\'"")
+    opts, arg_str = self.parse_options(parameter_s, 'rf:T:', list_all=True)
+    opts.merge(opts_def)
+    print arg_str
+    global_ns = self.shell.user_global_ns
+    local_ns = self.shell.user_ns
+
+    # Get the requested functions.
+    funcs = []
+    for name in opts.f:
+        try:
+            funcs.append(eval(name, global_ns, local_ns))
+        except Exception, e:
+            raise UsageError('Could not find function %r.\n%s: %s' % (name,
+                e.__class__.__name__, e))
+
+    profile = LineProfiler(*funcs)
+    print funcs
+    # Add the profiler to the builtins for @profile.
+    import __builtin__
+    if 'profile' in __builtin__.__dict__:
+        had_profile = True
+        old_profile = __builtin__.__dict__['profile']
+    else:
+        had_profile = False
+        old_profile = None
+    __builtin__.__dict__['profile'] = profile
+
+    try:
+        try:
+            profile.runctx(arg_str, global_ns, local_ns)
+            message = ''
+        except SystemExit:
+            message = ""*** SystemExit exception caught in code being profiled.""
+        except KeyboardInterrupt:
+            message = (""*** KeyboardInterrupt exception caught in code being ""
+                ""profiled."")
+    finally:
+        if had_profile:
+            __builtin__.__dict__['profile'] = old_profile
+
+    # Trap text output.
+    stdout_trap = StringIO()
+    show_results(profile, stdout_trap)
+    output = stdout_trap.getvalue()
+    output = output.rstrip()
+
+    if ipython_version < '0.11':
+        page(output, screen_lines=self.shell.rc.screen_length)
+    else:
+        page(output)
+    print message,
+
+#    dump_file = opts.D[0]
+#    if dump_file:
+#        profile.dump_stats(dump_file)
+#        print '\n*** Profile stats pickled to file',\
+#              `dump_file` + '.', message
+
+    text_file = opts.T[0]
+    if text_file:
+        pfile = open(text_file, 'w')
+        pfile.write(output)
+        pfile.close()
+        print '\n*** Profile printout saved to text file %s. %s' % (text_file,
+                                                                    message)
+
+    return_value = None
+    if 'r' in opts:
+        return_value = profile
+
+    return return_value
+
 if __name__ == '__main__':
     from optparse import OptionParser
     parser = OptionParser(usage=_CMD_USAGE)
"
memory_profiler.py,memory_profiler.py,9b1cd1ad73a2b6d98f315a474d3f76e9dea376c0,249ffe7863be84e343f806297cb52a6fc967b6ee,FIX: forgot print statements,"@@ -294,7 +294,7 @@ def show_results(prof, stream=None):
         stream.write('\n\n')
 
 
-# A %lprun magic for IPython.
+# A lprun-style %mprun magic for IPython.
 def magic_mprun(self, parameter_s=''):
     """""" Execute a statement under the line-by-line memory profiler from the
     memory_profilser module.
@@ -344,7 +344,6 @@ def magic_mprun(self, parameter_s=''):
     parameter_s = parameter_s.replace('""', r'\""').replace(""'"", r""\'"")
     opts, arg_str = self.parse_options(parameter_s, 'rf:T:', list_all=True)
     opts.merge(opts_def)
-    print arg_str
     global_ns = self.shell.user_global_ns
     local_ns = self.shell.user_ns
 
@@ -358,7 +357,6 @@ def magic_mprun(self, parameter_s=''):
                 e.__class__.__name__, e))
 
     profile = LineProfiler(*funcs)
-    print funcs
     # Add the profiler to the builtins for @profile.
     import __builtin__
     if 'profile' in __builtin__.__dict__:
@@ -414,6 +412,88 @@ def magic_mprun(self, parameter_s=''):
 
     return return_value
 
+
+# a timeit-style %memit magic for IPython
+def magic_memit(self, line=''):
+    """"""Measure memory usage of a Python statement
+
+    Usage, in line mode:
+      %memit [-r<R>] statement
+
+    Options:
+    -r<R>: repeat the loop iteration <R> times and take the best result.
+    Default: 3
+
+    -t<T>: timeout after <T> seconds. Default: None
+
+    Examples
+    --------
+    ::
+
+      In [1]: import numpy as np
+
+      In [2]: %memit np.zeros(1e7)
+      best of 3: 76.402344 MB per loop
+      Out[2]: 76.40234375
+
+      In [3]: %memit np.ones(1e6)
+      best of 3: 7.820312 MB per loop
+      Out[3]: 7.8203125
+
+      In [4]: %memit -r 10 np.empty(1e8)
+      best of 10: 0.101562 MB per loop
+      Out[4]: 0.1015625
+
+    """"""
+
+    import multiprocessing as pr
+    from multiprocessing.queues import SimpleQueue
+
+    opts, stmt = self.parse_options(line, 'r:t:tcp:',
+                                    posix=False, strict=False)
+    repeat = int(getattr(opts, ""r"", 3))
+    if repeat < 1:
+        repeat == 1
+    timeout = int(getattr(opts, ""t"", 0))
+    if timeout <= 0:
+        timeout = None
+
+    ns = self.shell.user_ns
+
+    def _get_usage(q, stmt, setup='pass', ns={}):
+        from memory_profiler import memory_usage as _mu
+        try:
+            exec setup in ns
+            _mu0 = _mu()[0]
+            exec stmt in ns
+            _mu1 = _mu()[0]
+            q.put(_mu1 - _mu0)
+        except:
+            q.put(float('-inf'))
+
+    q = SimpleQueue()
+    # try once in the current process
+    _get_usage(q, stmt, 'pass', ns)
+    # try in child processes
+    at_least_one_worked = False
+    for _ in xrange(repeat):
+        p = pr.Process(target=_get_usage, args=(q, stmt, 'pass', ns))
+        p.start()
+        p.join(timeout=timeout)
+        if p.exitcode == 0:
+            at_least_one_worked = True
+        else:
+            p.terminate()
+            q.put(float('-inf'))
+
+    if not at_least_one_worked:
+        print 'ERROR: subprocesses failed, result may be inaccurate.'
+
+    usages = [q.get() for _ in xrange(repeat)]
+    usage = max(usages)
+    print u""worst of %d: %f MB per loop"" % (repeat, usage)
+
+
 if __name__ == '__main__':
     from optparse import OptionParser
     parser = OptionParser(usage=_CMD_USAGE)
"
README.rst,README.rst,9d7fc7734e26cf94eeb3fdee9c017b71153fcefa,167641e0480616e5037bea9dd42819bac8482104,Add Vlad to the credits,"@@ -120,6 +120,8 @@ inspired by Robert Kern's `line profiler
 `Victor <https://github.com/octavo>`_ added python3, bugfixes and general
 cleanup.
 
+`Vlad Niculae <http://vene.ro>`_ added IPython magic functions.
+
 
 =========
  License
"
memory_profiler.py,memory_profiler.py,fbb16fbc8fb5a7d0de1026737535f3cdaeab312e,9b1cd1ad73a2b6d98f315a474d3f76e9dea376c0,Make magics more robust and flexible,"@@ -38,7 +38,8 @@ except ImportError:
             except:
                 return -1
     else:
-        raise NotImplementedError('The psutil module is required for non-unix platforms')
+        raise NotImplementedError('The psutil module is required for non-unix '
+                                  'platforms')
 
 
 def memory_usage(proc=-1, num=-1, interval=.1):
@@ -304,8 +305,8 @@ def magic_mprun(self, parameter_s=''):
 
     The given statement (which doesn't require quote marks) is run via the
     LineProfiler. Profiling is enabled for the functions specified by the -f
-    options. The statistics will be shown side-by-side with the code through the
-    pager once the statement has completed.
+    options. The statistics will be shown side-by-side with the code through
+    the pager once the statement has completed.
 
     Options:
 
@@ -319,8 +320,8 @@ def magic_mprun(self, parameter_s=''):
 
     One or more -f options are required to get any useful results.
 
-    -T <filename>: dump the text-formatted statistics with the code side-by-side
-    out to a text file.
+    -T <filename>: dump the text-formatted statistics with the code
+    side-by-side out to a text file.
 
     -r: return the LineProfiler object after it has completed profiling.
     """"""
@@ -418,13 +419,17 @@ def magic_memit(self, line=''):
     """"""Measure memory usage of a Python statement
 
     Usage, in line mode:
-      %memit [-r<R>] statement
+      %memit [-ir<R>t<T>] statement
 
     Options:
     -r<R>: repeat the loop iteration <R> times and take the best result.
     Default: 3
 
-    -t<T>: timeout after <T> seconds. Default: None
+    -i: run the code in the current environment, without forking a new process.
+    This is required on some MacOS versions of Accelerate if your line contains
+    a call to `np.dot`.
+
+    -t<T>: timeout after <T> seconds. Unused if `-i` is active. Default: None
 
     Examples
     --------
@@ -433,30 +438,46 @@ def magic_memit(self, line=''):
       In [1]: import numpy as np
 
       In [2]: %memit np.zeros(1e7)
-      best of 3: 76.402344 MB per loop
-      Out[2]: 76.40234375
+      maximum of 3: 76.402344 MB per loop
 
       In [3]: %memit np.ones(1e6)
-      best of 3: 7.820312 MB per loop
-      Out[3]: 7.8203125
+      maximum of 3: 7.820312 MB per loop
 
       In [4]: %memit -r 10 np.empty(1e8)
-      best of 10: 0.101562 MB per loop
-      Out[4]: 0.1015625
+      maximum of 10: 0.101562 MB per loop
+
+      In [5]: memit -t 3 while True: pass;
+      Subprocess timed out.
+      Subprocess timed out.
+      Subprocess timed out.
+      ERROR: all subprocesses exited unsuccessfully. Try again with the `-i`
+      option.
+      maximum of 3: -inf MB per loop
 
     """"""
-
-    import multiprocessing as pr
-    from multiprocessing.queues import SimpleQueue
-
-    opts, stmt = self.parse_options(line, 'r:t:tcp:',
-                                    posix=False, strict=False)
-    repeat = int(getattr(opts, ""r"", 3))
+    opts, stmt = self.parse_options(line, 'r:t:i', posix=False, strict=False)
+    repeat = int(getattr(opts, 'r', 3))
     if repeat < 1:
         repeat == 1
-    timeout = int(getattr(opts, ""t"", 0))
+    timeout = int(getattr(opts, 't', 0))
     if timeout <= 0:
         timeout = None
+    run_in_place = hasattr(opts, 'i')
+
+    # Don't depend on multiprocessing:
+    try:
+        import multiprocessing as pr
+        from multiprocessing.queues import SimpleQueue
+        q = SimpleQueue()
+    except ImportError:
+        class ListWithPut(list):
+            ""Just a list where the `append` method is aliased to `put`.""
+            def put(self, x):
+                self.append(x)
+        q = ListWithPut()
+        print ('WARNING: cannot import module `multiprocessing`. Forcing the'
+               '`-i` option.')
+        run_in_place = True
 
     ns = self.shell.user_ns
 
@@ -468,30 +489,37 @@ def magic_memit(self, line=''):
             exec stmt in ns
             _mu1 = _mu()[0]
             q.put(_mu1 - _mu0)
-        except:
+        except Exception as e:
             q.put(float('-inf'))
+            raise e
 
-    q = SimpleQueue()
-    # try once in the current process
-    _get_usage(q, stmt, 'pass', ns)
-    # try in child processes
-    at_least_one_worked = False
-    for _ in xrange(repeat):
-        p = pr.Process(target=_get_usage, args=(q, stmt, 'pass', ns))
-        p.start()
-        p.join(timeout=timeout)
-        if p.exitcode == 0:
-            at_least_one_worked = True
-        else:
-            p.terminate()
-            q.put(float('-inf'))
+    if run_in_place:
+        for _ in xrange(repeat):
+            _get_usage(q, stmt, ns=ns)
+    else:
+        # run in consecutive subprocesses
+        at_least_one_worked = False
+        for _ in xrange(repeat):
+            p = pr.Process(target=_get_usage, args=(q, stmt, 'pass', ns))
+            p.start()
+            p.join(timeout=timeout)
+            if p.exitcode == 0:
+                at_least_one_worked = True
+            else:
+                p.terminate()
+                if p.exitcode == None:
+                    print 'Subprocess timed out.'
+                else:
+                    print 'Subprocess exited with code %d.' % p.exitcode
+                q.put(float('-inf'))
 
-    if not at_least_one_worked:
-        print 'ERROR: subprocesses failed, result may be inaccurate.'
+        if not at_least_one_worked:
+            print ('ERROR: all subprocesses exited unsuccessfully. Try again '
+                   'with the `-i` option.')
 
     usages = [q.get() for _ in xrange(repeat)]
     usage = max(usages)
-    print u""worst of %d: %f MB per loop"" % (repeat, usage)
+    print u""maximum of %d: %f MB per loop"" % (repeat, usage)
 
 
 if __name__ == '__main__':
"
README.rst,README.rst,ebc2432bfe4de1783726d0c55a9fa91a57507b5c,fbb16fbc8fb5a7d0de1026737535f3cdaeab312e,Updated README,"@@ -21,7 +21,40 @@ To install from source, download the package, extract and type::
 
     $ python setup.py install
 
+After installing the module, if you use IPython, you can set up the `%mprun`
+and `%memit` magics by following these steps.
 
+For IPython 0.10, you can install it by editing the IPython configuration
+file ~/.ipython/ipy_user_conf.py to add the following lines::
+
+    # These two lines are standard and probably already there.
+    import IPython.ipapi
+    ip = IPython.ipapi.get()
+
+    # These two are the important ones.
+    import memory_profiler    
+    ip.expose_magic('mprun', memory_profiler.magic_mprun)
+    ip.expose_magic('memit', memory_profiler.magic_memit)prun)
+
+For IPython 0.11+, you have to  create a file named
+~/.ipython/extensions/memory_profiler_ext.py with the following content::
+
+    import memory_profiler
+     
+    def load_ipython_extension(ip):
+        ip.define_magic('mprun', memory_profiler.magic_mprun)
+        ip.define_magic('memit', memory_profiler.magic_memit)
+
+Then, edit the configuration file for your IPython profile,
+~/.ipython/profile_default/ipython_config.py, to register the extension like
+this (If you already have other extensions, just add this one to the list)::
+
+    c.TerminalIPythonApp.extensions = [
+        'memory_profiler_ext',
+    ]
+    c.InteractiveShellApp.extensions = [
+        'memory_profiler_ext',
+    ]
 
 =======
  Usage
@@ -69,6 +102,24 @@ Python interpreter after that line has been executed. The third column
 with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
+The same output can be obtained in IPython by using the `%mprun` magic command.
+In this case, you can skip the `@profile` decorator and instead use the
+`-f` parameter, like this::
+
+    In [1] from example import my_func
+
+    In [2] %mprun -f my_func my_func()
+
+Another useful magic that we define is `%memit`, which is analogous to
+`%timeit`. It can be used as follows::
+
+    In [1]: import numpy as np
+
+    In [2]: %memit np.zeros(1e7)
+    maximum of 3: 76.402344 MB per loop
+
+For more details, see the docstrings of the magics.
+
 ============================
  Frequently Asked Questions
 ============================
@@ -120,6 +171,8 @@ inspired by Robert Kern's `line profiler
 `Victor <https://github.com/octavo>`_ added python3, bugfixes and general
 cleanup.
 
+`Vlad <http://vene.ro/>`_ added the `%mprun` and `%memit` IPython magics. 
+
 
 =========
  License
"
memory_profiler.py,memory_profiler.py,43a83a60b32d53f5069463b89a13add4ccd83b67,dc64a7c5fb631b5c3fd420f71a0ae2197bce9ddc,FIX: issue #16,"@@ -271,6 +271,8 @@ def show_results(prof, stream=None):
 
         k_old = keys[0] - 1
         lines_normalized[keys[0] - 1] = lines[keys[0]]
+        for i in range(1, len(lines_normalized[keys[0] - 1])):
+            lines_normalized[keys[0] - 1][i] = -1.
         k = keys.pop(0)
         while keys:
             lines_normalized[k] = lines[keys[0]]
"
memory_profiler.py,memory_profiler.py,1106b74fa9b74c278a06f2ec8cee0c578ed25e3b,43a83a60b32d53f5069463b89a13add4ccd83b67,FIX: Python3 support (issue #14),"@@ -184,7 +184,7 @@ class LineProfiler:
         """"""
         self.enable_by_count()
         try:
-            exec cmd in globals, locals
+            exec(cmd, globals, locals)
         finally:
             self.disable_by_count()
         return self
"
README.rst,README.rst,f93840f8961da6e9fccfb5d307bf513618d74cda,1106b74fa9b74c278a06f2ec8cee0c578ed25e3b,DOC: add instructions to create IPython profile,"@@ -45,6 +45,11 @@ For IPython 0.11+, you have to  create a file named
         ip.define_magic('mprun', memory_profiler.magic_mprun)
         ip.define_magic('memit', memory_profiler.magic_memit)
 
+If you don't have an IPython profile already set up, create one using the
+following command::
+
+    $ ipython profile create
+
 Then, edit the configuration file for your IPython profile,
 ~/.ipython/profile_default/ipython_config.py, to register the extension like
 this (If you already have other extensions, just add this one to the list)::
"
memory_profiler.py,memory_profiler.py,fe61948ae25e630f9bd77ca0892ae3faae2c0afc,0fd6554879aea92c4299452b7df6b9e2b26061c2,0.15 release,"@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.14'
+__version__ = '0.15'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
memory_profiler.py,memory_profiler.py,1bcd779aa0744b543ae80d9c867eff7dc924d328,f93840f8961da6e9fccfb5d307bf513618d74cda,"Default to 1 loop in memit, add meaningful warning for functions without files in %mprun","@@ -255,6 +255,9 @@ def show_results(prof, stream=None):
         stream.write('Filename: ' + filename + '\n\n')
         if not os.path.exists(filename):
             stream.write('ERROR: Could not find file ' + filename + '\n')
+            if filename.startswith(""ipython-input""):
+                print(""NOTE: %mprun can only be used on functions defined in ""
+                      ""physical files, and not in the IPython environment."")
             continue
         all_lines = linecache.getlines(filename)
         sub_lines = inspect.getblock(all_lines[code.co_firstlineno - 1:])
@@ -425,7 +428,7 @@ def magic_memit(self, line=''):
 
     Options:
     -r<R>: repeat the loop iteration <R> times and take the best result.
-    Default: 3
+    Default: 1
 
     -i: run the code in the current environment, without forking a new process.
     This is required on some MacOS versions of Accelerate if your line contains
@@ -440,10 +443,10 @@ def magic_memit(self, line=''):
       In [1]: import numpy as np
 
       In [2]: %memit np.zeros(1e7)
-      maximum of 3: 76.402344 MB per loop
+      maximum of 1: 76.402344 MB per loop
 
       In [3]: %memit np.ones(1e6)
-      maximum of 3: 7.820312 MB per loop
+      maximum of 1: 7.820312 MB per loop
 
       In [4]: %memit -r 10 np.empty(1e8)
       maximum of 10: 0.101562 MB per loop
@@ -454,11 +457,11 @@ def magic_memit(self, line=''):
       Subprocess timed out.
       ERROR: all subprocesses exited unsuccessfully. Try again with the `-i`
       option.
-      maximum of 3: -inf MB per loop
+      maximum of 1: -inf MB per loop
 
     """"""
     opts, stmt = self.parse_options(line, 'r:t:i', posix=False, strict=False)
-    repeat = int(getattr(opts, 'r', 3))
+    repeat = int(getattr(opts, 'r', 1))
     if repeat < 1:
         repeat == 1
     timeout = int(getattr(opts, 't', 0))
"
memory_profiler.py,memory_profiler.py,33caba84b83d3a2838bf76de9ad4d1b604dc3779,1cb18a7386cddd74af3bffee10090debc2da3a37,Cleaner output,"@@ -294,8 +294,8 @@ def show_results(prof, stream=None):
                 mem = max(lines_normalized[l])
                 inc = mem - mem_old
                 mem_old = mem
-                mem = '{0:5.4f} MB'.format(mem)
-                inc = '{0:5.4f} MB'.format(inc)
+                mem = '{0:9.2f} MB'.format(mem)
+                inc = '{0:9.2f} MB'.format(inc)
             stream.write(template.format(l, mem, inc, sub_lines[i]))
         stream.write('\n\n')
 
"
memory_profiler.py,memory_profiler.py,b8a12bcd4e98112dfed88db21a29c33f0f183bb9,33caba84b83d3a2838bf76de9ad4d1b604dc3779,Cleaner output,"@@ -242,7 +242,7 @@ class LineProfiler:
 def show_results(prof, stream=None):
     if stream is None:
         stream = sys.stdout
-    template = '{0:>6} {1:>12} {2:>10}   {3:<}'
+    template = '{0:>6} {1:>12} {2:>12}   {3:<}'
 
     for code in prof.code_map:
         lines = prof.code_map[code]
"
memory_profiler.py,memory_profiler.py,2866dfd757d08611b03c196cb6b21203d80dfa81,b8a12bcd4e98112dfed88db21a29c33f0f183bb9,"Add memory-based debugging

Conflicts:

	memory_profiler.py","@@ -4,13 +4,12 @@ __version__ = '0.15'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
-import time
-import sys
-import os
+import time, sys, os, pdb
 import warnings
 import linecache
 import inspect
 
+
 try:
     import psutil
 
@@ -42,6 +41,7 @@ except ImportError:
                                   'platforms')
 
 
+
 def memory_usage(proc=-1, num=-1, interval=.1):
     """"""
     Return the memory usage of a process or piece of code
@@ -130,12 +130,13 @@ def _find_script(script_name):
 class LineProfiler:
     """""" A profiler that records the amount of memory for each line """"""
 
-    def __init__(self, *functions):
+    def __init__(self, *functions, **kw):
         self.functions = list(functions)
         self.code_map = {}
         self.enable_count = 0
         for func in functions:
             self.add_function(func)
+        self.max_mem = kw.get('max_mem', None)
 
     def __call__(self, func):
         self.add_function(func)
@@ -163,6 +164,7 @@ class LineProfiler:
     def wrap_function(self, func):
         """""" Wrap a function to profile it.
         """"""
+
         def f(*args, **kwds):
             self.enable_by_count()
             try:
@@ -225,6 +227,26 @@ class LineProfiler:
 
         return self.trace_memory_usage
 
+    def trace_max_mem(self, frame, event, arg):
+        # run into PDB as soon as memory is higher than MAX_MEM
+        if event in ('line', 'return'):
+            c = _get_memory(os.getpid())
+            if c >= self.max_mem:
+                t = 'Current memory {0:.2f} MB exceeded the maximum '.format(c) + \
+                    'of {0:.2f} MB\n'.format(self.max_mem)
+                sys.stdout.write(t)
+                sys.stdout.write('Stepping into the debugger \n')
+                frame.f_lineno -= 2
+                p = pdb.Pdb()
+                p.quitting = False
+                p.stopframe = frame
+                p.returnframe = None
+                p.stoplineno = frame.f_lineno - 3
+                p.botframe = None
+                return p.trace_dispatch
+
+        return self.trace_max_mem
+
     def __enter__(self):
         self.enable_by_count()
 
@@ -232,7 +254,10 @@ class LineProfiler:
         self.disable_by_count()
 
     def enable(self):
-        sys.settrace(self.trace_memory_usage)
+        if self.max_mem is not None:
+            sys.settrace(self.trace_max_mem)
+        else:
+            sys.settrace(self.trace_memory_usage)
 
     def disable(self):
         self.last_time = {}
@@ -529,7 +554,10 @@ def magic_memit(self, line=''):
 
 if __name__ == '__main__':
     from optparse import OptionParser
-    parser = OptionParser(usage=_CMD_USAGE)
+    parser = OptionParser(usage=_CMD_USAGE, version=__version__)
+    parser.add_option(""--pdb-mmem"", dest=""max_mem"", metavar=""MAXMEM"",
+        type=""float"", action=""store"",
+        help=""step into the debugger when memory exceeds MAXMEM"")
 
     if not sys.argv[1:]:
         parser.print_help()
@@ -537,10 +565,7 @@ if __name__ == '__main__':
 
     (options, args) = parser.parse_args()
 
-    # .. remove memory_profiler from sys.argv ..
-    sys.argv.pop(0)
-
-    prof = LineProfiler()
+    prof = LineProfiler(max_mem=options.max_mem)
     __file__ = _find_script(args[0])
     if sys.version_info[0] < 3:
         import __builtin__
"
memory_profiler.py,memory_profiler.py,5075c0d39acb7bea6982679687c61146cf6b59ef,2866dfd757d08611b03c196cb6b21203d80dfa81,Some Python3 compatibility,"@@ -383,7 +383,7 @@ def magic_mprun(self, parameter_s=''):
     for name in opts.f:
         try:
             funcs.append(eval(name, global_ns, local_ns))
-        except Exception, e:
+        except Exception as e:
             raise UsageError('Could not find function %r.\n%s: %s' % (name,
                 e.__class__.__name__, e))
 
@@ -421,7 +421,7 @@ def magic_mprun(self, parameter_s=''):
         page(output, screen_lines=self.shell.rc.screen_length)
     else:
         page(output)
-    print message,
+    print(message,)
 
 #    dump_file = opts.D[0]
 #    if dump_file:
@@ -434,8 +434,8 @@ def magic_mprun(self, parameter_s=''):
         pfile = open(text_file, 'w')
         pfile.write(output)
         pfile.close()
-        print '\n*** Profile printout saved to text file %s. %s' % (text_file,
-                                                                    message)
+        print('\n*** Profile printout saved to text file %s. %s' % (text_file,
+                                                                    message))
 
     return_value = None
     if 'r' in opts:
@@ -538,9 +538,9 @@ def magic_memit(self, line=''):
             else:
                 p.terminate()
                 if p.exitcode == None:
-                    print 'Subprocess timed out.'
+                    print('Subprocess timed out.')
                 else:
-                    print 'Subprocess exited with code %d.' % p.exitcode
+                    print('Subprocess exited with code %d.' % p.exitcode)
                 q.put(float('-inf'))
 
         if not at_least_one_worked:
@@ -549,7 +549,7 @@ def magic_memit(self, line=''):
 
     usages = [q.get() for _ in xrange(repeat)]
     usage = max(usages)
-    print u""maximum of %d: %f MB per loop"" % (repeat, usage)
+    print('maximum of %d: %f MB per loop' % (repeat, usage))
 
 
 if __name__ == '__main__':
"
memory_profiler.py,memory_profiler.py,7c70c16e9448f81c22d2878e0f7c3ad358ecb0c2,5075c0d39acb7bea6982679687c61146cf6b59ef,Some more Python3 fixes,"@@ -443,6 +443,19 @@ def magic_mprun(self, parameter_s=''):
 
     return return_value
 
+# utility function used in magic_memit
+# TODO: merge sith memory_usage
+def _get_usage(q, stmt, setup='pass', ns={}):
+    from memory_profiler import memory_usage as _mu
+    try:
+        exec(setup, ns)
+        _mu0 = _mu()[0]
+        exec(stmt, ns)
+        _mu1 = _mu()[0]
+        q.put(_mu1 - _mu0)
+    except Exception as e:
+        q.put(float('-inf'))
+        raise e
 
 # a timeit-style %memit magic for IPython
 def magic_memit(self, line=''):
@@ -511,18 +524,6 @@ def magic_memit(self, line=''):
 
     ns = self.shell.user_ns
 
-    def _get_usage(q, stmt, setup='pass', ns={}):
-        from memory_profiler import memory_usage as _mu
-        try:
-            exec setup in ns
-            _mu0 = _mu()[0]
-            exec stmt in ns
-            _mu1 = _mu()[0]
-            q.put(_mu1 - _mu0)
-        except Exception as e:
-            q.put(float('-inf'))
-            raise e
-
     if run_in_place:
         for _ in xrange(repeat):
             _get_usage(q, stmt, ns=ns)
"
README.rst,README.rst,570351a01b4b77ae9a3ce32296d19e12151e76df,7c70c16e9448f81c22d2878e0f7c3ad358ecb0c2,README reordering,"@@ -21,45 +21,6 @@ To install from source, download the package, extract and type::
 
     $ python setup.py install
 
-After installing the module, if you use IPython, you can set up the `%mprun`
-and `%memit` magics by following these steps.
-
-For IPython 0.10, you can install it by editing the IPython configuration
-file ~/.ipython/ipy_user_conf.py to add the following lines::
-
-    # These two lines are standard and probably already there.
-    import IPython.ipapi
-    ip = IPython.ipapi.get()
-
-    # These two are the important ones.
-    import memory_profiler    
-    ip.expose_magic('mprun', memory_profiler.magic_mprun)
-    ip.expose_magic('memit', memory_profiler.magic_memit)prun)
-
-For IPython 0.11+, you have to  create a file named
-~/.ipython/extensions/memory_profiler_ext.py with the following content::
-
-    import memory_profiler
-     
-    def load_ipython_extension(ip):
-        ip.define_magic('mprun', memory_profiler.magic_mprun)
-        ip.define_magic('memit', memory_profiler.magic_memit)
-
-If you don't have an IPython profile already set up, create one using the
-following command::
-
-    $ ipython profile create
-
-Then, edit the configuration file for your IPython profile,
-~/.ipython/profile_default/ipython_config.py, to register the extension like
-this (If you already have other extensions, just add this one to the list)::
-
-    c.TerminalIPythonApp.extensions = [
-        'memory_profiler_ext',
-    ]
-    c.InteractiveShellApp.extensions = [
-        'memory_profiler_ext',
-    ]
 
 =======
  Usage
@@ -107,9 +68,55 @@ Python interpreter after that line has been executed. The third column
 with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
-The same output can be obtained in IPython by using the `%mprun` magic command.
-In this case, you can skip the `@profile` decorator and instead use the
-`-f` parameter, like this::
+
+
+===================
+Ipython integration
+===================
+
+After installing the module, if you use IPython, you can set up the `%mprun`
+and `%memit` magics by following these steps.
+
+For IPython 0.10, you can install it by editing the IPython configuration
+file ~/.ipython/ipy_user_conf.py to add the following lines::
+
+    # These two lines are standard and probably already there.
+    import IPython.ipapi
+    ip = IPython.ipapi.get()
+
+    # These two are the important ones.
+    import memory_profiler
+    ip.expose_magic('mprun', memory_profiler.magic_mprun)
+    ip.expose_magic('memit', memory_profiler.magic_memit)prun)
+
+For IPython 0.11+, you have to edit the file
+~/.ipython/extensions/memory_profiler_ext.py with the following content::
+
+    import memory_profiler
+
+    def load_ipython_extension(ip):
+        ip.define_magic('mprun', memory_profiler.magic_mprun)
+        ip.define_magic('memit', memory_profiler.magic_memit)
+
+If you don't have an IPython profile already set up, create one using the
+following command::
+
+    $ ipython profile create
+
+Then, edit the configuration file for your IPython profile,
+~/.ipython/profile_default/ipython_config.py, to register the extension like
+this (If you already have other extensions, just add this one to the list)::
+
+    c.TerminalIPythonApp.extensions = [
+        'memory_profiler_ext',
+    ]
+    c.InteractiveShellApp.extensions = [
+        'memory_profiler_ext',
+    ]
+
+It then can be used directly from IPython to obtain a line-by-line report using
+the `%mprun` magic command. In this case, you can skip the `@profile` decorator
+and instead use the `-f` parameter, like this::
 
     In [1] from example import my_func
 
@@ -176,7 +183,7 @@ inspired by Robert Kern's `line profiler
 `Victor <https://github.com/octavo>`_ added python3, bugfixes and general
 cleanup.
 
-`Vlad Niculae <http://vene.ro/>`_ added the `%mprun` and `%memit` IPython magics. 
+`Vlad Niculae <http://vene.ro/>`_ added the `%mprun` and `%memit` IPython magics.
 
 
 
"
memory_profiler.py,memory_profiler.py,004a376ed1d063888eb352b45a762fd38a5ef71c,570351a01b4b77ae9a3ce32296d19e12151e76df,Python3 compat,"@@ -151,7 +151,8 @@ class LineProfiler:
         """""" Record line profiling information for the given Python function.
         """"""
         try:
-            code = func.func_code
+            # func_code does not exist in Python3
+            code = func.__code__
         except AttributeError:
             import warnings
             warnings.warn(""Could not extract a code object for the object %r""
"
README.rst,README.rst,eea7e2f8c2b5b5d4ff7ff49aa0f939377c9d6db8,004a376ed1d063888eb352b45a762fd38a5ef71c,MISC,"@@ -180,7 +180,7 @@ inspired by Robert Kern's `line profiler
 `Tom <http://tomforb.es/>`_ added windows support and speed improvements via the
 `psutil <http://pypi.python.org/pypi/psutil>`_ module.
 
-`Victor <https://github.com/octavo>`_ added python3, bugfixes and general
+`Victor <https://github.com/octavo>`_ added python3 support, bugfixes and general
 cleanup.
 
 `Vlad Niculae <http://vene.ro/>`_ added the `%mprun` and `%memit` IPython magics.
"
memory_profiler.py,memory_profiler.py,4389d64c1fcac0c022649cc0bca61467413d42b9,eea7e2f8c2b5b5d4ff7ff49aa0f939377c9d6db8,0.16 release,"@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.15'
+__version__ = '0.16'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
README.rst,README.rst,e07028e5266ab3c2a69796ffa5850c4759fae4c2,4389d64c1fcac0c022649cc0bca61467413d42b9,Doc update,"@@ -87,7 +87,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
     # These two are the important ones.
     import memory_profiler
     ip.expose_magic('mprun', memory_profiler.magic_mprun)
-    ip.expose_magic('memit', memory_profiler.magic_memit)prun)
+    ip.expose_magic('memit', memory_profiler.magic_memit)
 
 For IPython 0.11+, you have to edit the file
 ~/.ipython/extensions/memory_profiler_ext.py with the following content::
"
memory_profiler.py,memory_profiler.py,e07028e5266ab3c2a69796ffa5850c4759fae4c2,4389d64c1fcac0c022649cc0bca61467413d42b9,Doc update,"@@ -57,8 +57,7 @@ def memory_usage(proc=-1, num=-1, interval=.1):
     interval : int, optional
 
     num : int, optional
-        Number of samples to generate. In the case of
-        defaults to -1, meaning
+        Maximum number of retrievals. In the case of -1, meaning
         to wait until the process has finished if proc is a string or
         to get just one if proc is an integer.
 
@@ -67,7 +66,7 @@ def memory_usage(proc=-1, num=-1, interval=.1):
 
     Returns
     -------
-    mm : list of integers
+    mm : list of integers, size less than num
         memory usage, in KB
     """"""
     ret = []
"
README.rst,README.rst,c897818d18c2b68278c6df2618ddc142eaa95a1c,e07028e5266ab3c2a69796ffa5850c4759fae4c2,memory_usage working and some documentation.,"@@ -69,6 +69,34 @@ with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
 
+====
+API
+====
+
+memory_profiler exposes a number of functions to be used in third-party
+code.
+
+`memory_usage(proc=-1, num=-1, interval=.1)` returns the memory usage
+over a time interval. The first argument, `proc` represents what
+should be monitored.  This can either be the PID of a process (not
+necessarily a Python program), a string containing some python code to
+be evaluated or a tuple (f, args, kw) containing a function and its
+arguments to be evaluated as f(*args, **kw). For example::
+
+
+    >>> # define a simple function
+    >>> def f(a, n=100):
+        ...     import time
+        ...     time.sleep(2)
+        ...     b = [a] * n
+        ...     time.sleep(1)
+        ...     return b
+        ...
+    >>> from memory_profiler import memory_usage
+    >>> memory_usage((f, (1,), {'n' : int(1e6)}))
+
+
+
 
 ===================
 Ipython integration
"
memory_profiler.py,memory_profiler.py,c897818d18c2b68278c6df2618ddc142eaa95a1c,e07028e5266ab3c2a69796ffa5850c4759fae4c2,memory_usage working and some documentation.,"@@ -5,7 +5,7 @@ __version__ = '0.16'
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
 import time, sys, os, pdb
-import warnings
+import warnings, multiprocessing
 import linecache
 import inspect
 
@@ -41,18 +41,17 @@ except ImportError:
                                   'platforms')
 
 
-
 def memory_usage(proc=-1, num=-1, interval=.1):
     """"""
     Return the memory usage of a process or piece of code
 
     Parameters
     ----------
-    proc : {int, string, tuple}
-        The process to monitor. Can be given by a PID or by a string
-        containing a filename. A tuple containing (f, args, kwargs) specifies
-        to run the function f(*args, **kwargs). Set to -1 (default)for
-        current process.
+    proc : {int, string, tuple}, optional
+        The process to monitor. Can be given by a PID, by a string
+        containing a filename or by a tuple. The tuple should contain
+        three values (f, args, kw) specifies to run the function
+        f(*args, **kw).  Set to -1 (default) for current process.
 
     interval : int, optional
 
@@ -61,8 +60,6 @@ def memory_usage(proc=-1, num=-1, interval=.1):
         to wait until the process has finished if proc is a string or
         to get just one if proc is an integer.
 
-    locals : dict
-        Local variables.
 
     Returns
     -------
@@ -71,29 +68,35 @@ def memory_usage(proc=-1, num=-1, interval=.1):
     """"""
     ret = []
 
+
     if str(proc).endswith('.py'):
         filename = _find_script(proc)
         with open(filename) as f:
             proc = f.read()
-
-        # TODO: make sure script's directory is on sys.path
-        def f_exec(x, locals):
-            # function interface for exec
-            exec(x, locals)
-        proc = (f_exec, (), {})
+        raise NotImplementedError
 
     if isinstance(proc, (list, tuple)):
-        from multiprocessing import Process
+
         if len(proc) == 1:
-            proc = (proc[0], (), {})
+            f, args, kw = (proc[0], (), {})
         elif len(proc) == 2:
-            proc = (proc[0], proc[1], {})
-        p = Process(target=proc[0], args=proc[1], kwargs=proc[2])
-        p.start()
-        while p.is_alive():  # FIXME: or num
-            ret.append(_get_memory(p.pid))
+            f, args, kw = (proc[0], proc[1], {})
+        elif len(proc) == 3:
+            f, args, kw = (proc[0], proc[1], proc[2])
+        else:
+            raise ValueError
+        main_thread = multiprocessing.Process(target=f, args=args, kwargs=kw)
+        i = 0
+        max_iter = num if num > 0 else float(""inf"")
+        main_thread.start()
+        while i < max_iter and main_thread.is_alive():
+            m = _get_memory(main_thread.pid)
+            ret.append(m)
             time.sleep(interval)
+            i += 1
+        main_thread.join()
     else:
+        # external process
         if proc == -1:
             proc = os.getpid()
         if num == -1:
"
README.rst,README.rst,9de431ebfa7702b89b5a266585f28c99bfd6bdff,c897818d18c2b68278c6df2618ddc142eaa95a1c,Cosmetic,"@@ -169,8 +169,9 @@ For more details, see the docstrings of the magics.
       operating system kernel about the ammount of memory the current
       process has allocated, which might be slightly different from
       the ammount of memory that is actually used by the Python
-      interpreter. For this reason, the output is only an
-      approximation, and might vary between runs.
+      interpreter. Also, because of how the garbage collector works in
+      Python the result might be different between platforms and even
+      between runs.
 
     * Q: Does it work under windows ?
     * A: Yes, but you will need the
"
memory_profiler.py,memory_profiler.py,9de431ebfa7702b89b5a266585f28c99bfd6bdff,c897818d18c2b68278c6df2618ddc142eaa95a1c,Cosmetic,"@@ -197,6 +197,7 @@ class LineProfiler:
     def runcall(self, func, *args, **kw):
         """""" Profile a single function call.
         """"""
+        # XXX where is this used ? can be removed ?
         self.enable_by_count()
         try:
             return func(*args, **kw)
@@ -220,7 +221,7 @@ class LineProfiler:
                 self.disable()
 
     def trace_memory_usage(self, frame, event, arg):
-
+        """"""Callback for sys.settrace""""""
         if event in ('line', 'return') and frame.f_code in self.code_map:
                 lineno = frame.f_lineno
                 if event == 'return':
"
README.rst,README.rst,062befa2b3e196df2111b9b7c049d0f011e812ff,9de431ebfa7702b89b5a266585f28c99bfd6bdff,Use memory_usage in magic_memit,"@@ -142,9 +142,11 @@ this (If you already have other extensions, just add this one to the list)::
         'memory_profiler_ext',
     ]
 
-It then can be used directly from IPython to obtain a line-by-line report using
-the `%mprun` magic command. In this case, you can skip the `@profile` decorator
-and instead use the `-f` parameter, like this::
+It then can be used directly from IPython to obtain a line-by-line
+report using the `%mprun` magic command. In this case, you can skip
+the `@profile` decorator and instead use the `-f` parameter, like
+this. Note however that function my_func must be defined in a file
+(cannot have been defined interactively in the Python interpreter)::
 
     In [1] from example import my_func
 
"
memory_profiler.py,memory_profiler.py,062befa2b3e196df2111b9b7c049d0f011e812ff,9de431ebfa7702b89b5a266585f28c99bfd6bdff,Use memory_usage in magic_memit,"@@ -5,7 +5,7 @@ __version__ = '0.16'
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
 import time, sys, os, pdb
-import warnings, multiprocessing
+import warnings
 import linecache
 import inspect
 
@@ -15,7 +15,12 @@ try:
 
     def _get_memory(pid):
         process = psutil.Process(pid)
-        return float(process.get_memory_info()[0]) / (1024 ** 2)
+        try:
+            mem = float(process.get_memory_info()[0] / (1024 ** 2))
+        except psutil.AccessDenied:
+            mem = -1
+        return mem
+
 
 except ImportError:
 
@@ -41,7 +46,7 @@ except ImportError:
                                   'platforms')
 
 
-def memory_usage(proc=-1, num=-1, interval=.1):
+def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -60,6 +65,11 @@ def memory_usage(proc=-1, num=-1, interval=.1):
         to wait until the process has finished if proc is a string or
         to get just one if proc is an integer.
 
+    run_in_place : boolean, optional. False by default
+        If False fork the process and retrieve timings from a different
+        process. You shouldn't need to change this unless you are affected
+        by this (http://blog.vene.ro/2012/07/04/on-why-my-memit-fails-on-osx)
+        bug.
 
     Returns
     -------
@@ -68,7 +78,6 @@ def memory_usage(proc=-1, num=-1, interval=.1):
     """"""
     ret = []
 
-
     if str(proc).endswith('.py'):
         filename = _find_script(proc)
         with open(filename) as f:
@@ -85,12 +94,27 @@ def memory_usage(proc=-1, num=-1, interval=.1):
             f, args, kw = (proc[0], proc[1], proc[2])
         else:
             raise ValueError
-        main_thread = multiprocessing.Process(target=f, args=args, kwargs=kw)
+        try:
+            import multiprocessing
+        except ImportError:
+            print ('WARNING: cannot import module `multiprocessing`. Forcing to'
+                   ' run inplace.')
+            # force inplace
+            run_in_place = True
+        if run_in_place:
+            import threading
+            main_thread = threading.Thread(target=f, args=args, kwargs=kw)
+        else:
+            main_thread = multiprocessing.Process(target=f, args=args, kwargs=kw)
         i = 0
-        max_iter = num if num > 0 else float(""inf"")
+        if timeout is not None:
+            max_iter = timeout / interval
+        else:
+            max_iter = float('inf')
         main_thread.start()
+        pid = getattr(main_thread, 'pid', os.getpid())
         while i < max_iter and main_thread.is_alive():
-            m = _get_memory(main_thread.pid)
+            m = _get_memory(pid)
             ret.append(m)
             time.sleep(interval)
             i += 1
@@ -132,12 +156,10 @@ def _find_script(script_name):
 class LineProfiler:
     """""" A profiler that records the amount of memory for each line """"""
 
-    def __init__(self, *functions, **kw):
-        self.functions = list(functions)
+    def __init__(self, **kw):
+        self.functions = list()
         self.code_map = {}
         self.enable_count = 0
-        for func in functions:
-            self.add_function(func)
         self.max_mem = kw.get('max_mem', None)
 
     def __call__(self, func):
@@ -391,7 +413,8 @@ def magic_mprun(self, parameter_s=''):
             raise UsageError('Could not find function %r.\n%s: %s' % (name,
                 e.__class__.__name__, e))
 
-    profile = LineProfiler(*funcs)
+    profile = LineProfiler()
+    map(profile, funcs)
     # Add the profiler to the builtins for @profile.
     import __builtin__
     if 'profile' in __builtin__.__dict__:
@@ -447,19 +470,11 @@ def magic_mprun(self, parameter_s=''):
 
     return return_value
 
-# utility function used in magic_memit
-# TODO: merge sith memory_usage
-def _get_usage(q, stmt, setup='pass', ns={}):
-    from memory_profiler import memory_usage as _mu
-    try:
-        exec(setup, ns)
-        _mu0 = _mu()[0]
-        exec(stmt, ns)
-        _mu1 = _mu()[0]
-        q.put(_mu1 - _mu0)
-    except Exception as e:
-        q.put(float('-inf'))
-        raise e
+
+def _func_exec(stmt, ns):
+    # helper for magic_memit, just a function proxy for the exec
+    # statement
+    exec(stmt, ns)
 
 # a timeit-style %memit magic for IPython
 def magic_memit(self, line=''):
@@ -511,50 +526,13 @@ def magic_memit(self, line=''):
         timeout = None
     run_in_place = hasattr(opts, 'i')
 
-    # Don't depend on multiprocessing:
-    try:
-        import multiprocessing as pr
-        from multiprocessing.queues import SimpleQueue
-        q = SimpleQueue()
-    except ImportError:
-        class ListWithPut(list):
-            ""Just a list where the `append` method is aliased to `put`.""
-            def put(self, x):
-                self.append(x)
-        q = ListWithPut()
-        print ('WARNING: cannot import module `multiprocessing`. Forcing the'
-               '`-i` option.')
-        run_in_place = True
+    mem_usage = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout,
+        run_in_place=run_in_place)
 
-    ns = self.shell.user_ns
-
-    if run_in_place:
-        for _ in xrange(repeat):
-            _get_usage(q, stmt, ns=ns)
+    if mem_usage:
+        print('maximum of %d: %f MB per loop' % (repeat, max(mem_usage)))
     else:
-        # run in consecutive subprocesses
-        at_least_one_worked = False
-        for _ in xrange(repeat):
-            p = pr.Process(target=_get_usage, args=(q, stmt, 'pass', ns))
-            p.start()
-            p.join(timeout=timeout)
-            if p.exitcode == 0:
-                at_least_one_worked = True
-            else:
-                p.terminate()
-                if p.exitcode == None:
-                    print('Subprocess timed out.')
-                else:
-                    print('Subprocess exited with code %d.' % p.exitcode)
-                q.put(float('-inf'))
-
-        if not at_least_one_worked:
-            print ('ERROR: all subprocesses exited unsuccessfully. Try again '
-                   'with the `-i` option.')
-
-    usages = [q.get() for _ in xrange(repeat)]
-    usage = max(usages)
-    print('maximum of %d: %f MB per loop' % (repeat, usage))
+        print('ERROR: could not read memory usage, try with a lower interval or more iterations')
 
 
 if __name__ == '__main__':
"
memory_profiler.py,memory_profiler.py,bfe2d2dfa208c3aae8c1e2ac15a6a8d12abd373b,062befa2b3e196df2111b9b7c049d0f011e812ff,docstring,"@@ -58,12 +58,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         three values (f, args, kw) specifies to run the function
         f(*args, **kw).  Set to -1 (default) for current process.
 
-    interval : int, optional
+    interval : float, optional
+
+    timeout : float, optional
 
-    num : int, optional
-        Maximum number of retrievals. In the case of -1, meaning
-        to wait until the process has finished if proc is a string or
-        to get just one if proc is an integer.
 
     run_in_place : boolean, optional. False by default
         If False fork the process and retrieve timings from a different
"
README.rst,README.rst,7c1623503b6571a70a4f26b67c91c088f5e7f87c,bfe2d2dfa208c3aae8c1e2ac15a6a8d12abd373b,Update README,"@@ -76,7 +76,7 @@ API
 memory_profiler exposes a number of functions to be used in third-party
 code.
 
-`memory_usage(proc=-1, num=-1, interval=.1)` returns the memory usage
+`memory_usage(proc=-1, interval=.1, timeout=None)` returns the memory usage
 over a time interval. The first argument, `proc` represents what
 should be monitored.  This can either be the PID of a process (not
 necessarily a Python program), a string containing some python code to
"
memory_profiler.py,memory_profiler.py,9cfe0e85dcaa160bf5dd2a74b245473764bd8309,7c1623503b6571a70a4f26b67c91c088f5e7f87c,0.17 release,"@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.16'
+__version__ = '0.17'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
README.rst,README.rst,42182a7ca89015ab5764dbf5d4d674facfa5cca5,9cfe0e85dcaa160bf5dd2a74b245473764bd8309,Cosmetic update,"@@ -69,19 +69,18 @@ with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
 
-====
-API
-====
-
+=====
+ API
+=====
 memory_profiler exposes a number of functions to be used in third-party
 code.
 
-`memory_usage(proc=-1, interval=.1, timeout=None)` returns the memory usage
-over a time interval. The first argument, `proc` represents what
+``memory_usage(proc=-1, interval=.1, timeout=None)`` returns the memory usage
+over a time interval. The first argument, ``proc`` represents what
 should be monitored.  This can either be the PID of a process (not
 necessarily a Python program), a string containing some python code to
-be evaluated or a tuple (f, args, kw) containing a function and its
-arguments to be evaluated as f(*args, **kw). For example::
+be evaluated or a tuple ``(f, args, kw)`` containing a function and its
+arguments to be evaluated as ``f(*args, **kw)``. For example::
 
 
     >>> # define a simple function
@@ -98,10 +97,9 @@ arguments to be evaluated as f(*args, **kw). For example::
 
 
 
-===================
-Ipython integration
-===================
-
+=====================
+ Ipython integration
+=====================
 After installing the module, if you use IPython, you can set up the `%mprun`
 and `%memit` magics by following these steps.
 
@@ -165,7 +163,6 @@ For more details, see the docstrings of the magics.
 ============================
  Frequently Asked Questions
 ============================
-
     * Q: How accurate are the results ?
     * A: This module gets the memory consumption by querying the
       operating system kernel about the ammount of memory the current
"
setup.py,setup.py,42182a7ca89015ab5764dbf5d4d674facfa5cca5,9cfe0e85dcaa160bf5dd2a74b245473764bd8309,Cosmetic update,"@@ -2,7 +2,7 @@ import memory_profiler
 from distutils.core import setup
 
 CLASSIFIERS = """"""\
-Development Status :: 4 - Beta
+Development Status :: 5 - Production/Stable
 Intended Audience :: Science/Research
 Intended Audience :: Developers
 License :: OSI Approved
@@ -24,5 +24,6 @@ setup(
     url='http://pypi.python.org/pypi/memory_profiler',
 	py_modules=['memory_profiler'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
+    license='Simplified BSD'
 
 )
\ No newline at end of file
"
README.rst,README.rst,2a26da8bce4b2c72b5da3b1be263be63ffebf2d2,42182a7ca89015ab5764dbf5d4d674facfa5cca5,MISC README update,"@@ -69,6 +69,9 @@ with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
 
+TODO: alternatives to decoation (for example when you don't want to modify
+the file where your function).
+
 =====
  API
 =====
@@ -189,6 +192,8 @@ Send issues, proposals, etc. to `github's issue tracker
 If you've got questions regarding development, you can email me
 directly at fabian@fseoane.net
 
+.. image:: http://fseoane.net/static/tux_memory_small.png
+
 
 =============
  Development
"
README.rst,README.rst,26d6227bfc244ae89a2c43194866b7aa3314f75c,2a26da8bce4b2c72b5da3b1be263be63ffebf2d2,Fix typo in README.,"@@ -69,7 +69,7 @@ with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
 
-TODO: alternatives to decoation (for example when you don't want to modify
+TODO: alternatives to decoration (for example when you don't want to modify
 the file where your function).
 
 =====
"
README.rst,README.rst,8685498c9950b74fb8c4ed1b066479f49a820c57,26d6227bfc244ae89a2c43194866b7aa3314f75c,Fix spelling mistake.,"@@ -168,7 +168,7 @@ For more details, see the docstrings of the magics.
 ============================
     * Q: How accurate are the results ?
     * A: This module gets the memory consumption by querying the
-      operating system kernel about the ammount of memory the current
+      operating system kernel about the amount of memory the current
       process has allocated, which might be slightly different from
       the ammount of memory that is actually used by the Python
       interpreter. Also, because of how the garbage collector works in
"
README.rst,README.rst,55763dd886b0be4cbf11a75eff46482f05adbf43,4dfcb5fba8b388f40872098dada2a2e9606962c6,IPython casing style in title,"@@ -101,7 +101,7 @@ arguments to be evaluated as ``f(*args, **kw)``. For example::
 
 
 =====================
- Ipython integration
+ IPython integration
 =====================
 After installing the module, if you use IPython, you can set up the `%mprun`
 and `%memit` magics by following these steps.
"
memory_profiler.py,memory_profiler.py,523b4ba864729a2b81163a7c8b08a049a08e7c5a,2cb64e573fcb6f80a9c875f298d080338c000f18,Fix interger division error,"@@ -16,7 +16,7 @@ try:
     def _get_memory(pid):
         process = psutil.Process(pid)
         try:
-            mem = float(process.get_memory_info()[0] / (1024 ** 2))
+            mem = float(process.get_memory_info()[0]) / (1024 ** 2)
         except psutil.AccessDenied:
             mem = -1
         return mem
"
memory_profiler.py,memory_profiler.py,64b0a5dc43c3992b891d97e3345c8ef174a2c1aa,523b4ba864729a2b81163a7c8b08a049a08e7c5a,FIX --pdb-mmem,"@@ -253,7 +253,7 @@ class LineProfiler:
 
     def trace_max_mem(self, frame, event, arg):
         # run into PDB as soon as memory is higher than MAX_MEM
-        if event in ('line', 'return'):
+        if event in ('line', 'return') and frame.f_code in self.code_map:
             c = _get_memory(os.getpid())
             if c >= self.max_mem:
                 t = 'Current memory {0:.2f} MB exceeded the maximum '.format(c) + \
"
,test/test_with.py,64b0a5dc43c3992b891d97e3345c8ef174a2c1aa,523b4ba864729a2b81163a7c8b08a049a08e7c5a,FIX --pdb-mmem,"@@ -0,0 +1 @@
+__author__ = 'fabian'
"
memory_profiler.py,memory_profiler.py,3be7c092629c07b8c1af07c422970daacc2345e9,64b0a5dc43c3992b891d97e3345c8ef174a2c1aa,FIX memory_usage() with no arguments (fixes issue #23),"@@ -76,6 +76,15 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
     """"""
     ret = []
 
+    if timeout is not None:
+        max_iter = timeout / interval
+    elif isinstance(proc, int):
+        # external process and no timeout
+        max_iter = 1
+    else:
+        # for a Python function wait until it finishes
+        max_iter = float('inf')
+
     if str(proc).endswith('.py'):
         filename = _find_script(proc)
         with open(filename) as f:
@@ -105,10 +114,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         else:
             main_thread = multiprocessing.Process(target=f, args=args, kwargs=kw)
         i = 0
-        if timeout is not None:
-            max_iter = timeout / interval
-        else:
-            max_iter = float('inf')
         main_thread.start()
         pid = getattr(main_thread, 'pid', os.getpid())
         while i < max_iter and main_thread.is_alive():
@@ -121,9 +126,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         # external process
         if proc == -1:
             proc = os.getpid()
-        if num == -1:
-            num = 1
-        for _ in range(num):
+        if max_iter == -1:
+            max_iter = 1
+        for _ in range(max_iter):
             ret.append(_get_memory(proc))
             time.sleep(interval)
     return ret
"
README.rst,README.rst,ac686a0294479d4f8ac64caa19427d7d622efefe,3be7c092629c07b8c1af07c422970daacc2345e9,Document the breakpoints feature,"@@ -68,9 +68,23 @@ Python interpreter after that line has been executed. The third column
 with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
+Setting debugger breakpoints
+=============================
+It is possible to set breakpoints depending on the amount of memory used.
+That is, you can specify a threshold and as soon as the program uses more
+memory than what is specified in the threshold it will stop execution
+and run into the pdb debugger. To use it, you will have to decorate
+the function as done in the previous section with ``@profile`` and then
+run your script with the option ``-m memory_profiler --pdb-mmem=X``,
+where X is a number representing the memory threshold in MB. For example::
 
-TODO: alternatives to decoration (for example when you don't want to modify
-the file where your function).
+    $ python -m memory_profiler --pdb-mmem=100 my_script.py
+
+will run ``my_script.py`` and step into the pdb debugger as soon as the code
+uses more than 100 MB in the decorated function.
+
+.. TODO: alternatives to decoration (for example when you don't want to modify
+    the file where your function lives).
 
 =====
  API
"
memory_profiler.py,memory_profiler.py,b2c807c2dff8c167d3d3c835f3a35b2736018f45,ac686a0294479d4f8ac64caa19427d7d622efefe,Release 0.18,"@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.17'
+__version__ = '0.18'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
README.rst,README.rst,642d0bc98d47855e525996af3dc535bb31fae7e9,b2c807c2dff8c167d3d3c835f3a35b2736018f45,allow undecorated calls with memory_profiler using command line argument,"@@ -68,23 +68,34 @@ Python interpreter after that line has been executed. The third column
 with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
-Setting debugger breakpoints
-=============================
-It is possible to set breakpoints depending on the amount of memory used.
-That is, you can specify a threshold and as soon as the program uses more
-memory than what is specified in the threshold it will stop execution
-and run into the pdb debugger. To use it, you will have to decorate
-the function as done in the previous section with ``@profile`` and then
-run your script with the option ``-m memory_profiler --pdb-mmem=X``,
-where X is a number representing the memory threshold in MB. For example::
 
-    $ python -m memory_profiler --pdb-mmem=100 my_script.py
+The second usage pattern is to omit the decorator and to add command
+line options for target-file and target-function::
 
-will run ``my_script.py`` and step into the pdb debugger as soon as the code
-uses more than 100 MB in the decorated function.
+    $ python -m memory_profiler example_undecorated.py --target-file=example_undecorated.py --target-function=another_func
 
-.. TODO: alternatives to decoration (for example when you don't want to modify
-    the file where your function lives).
+
+    Line #    Mem usage    Increment   Line Contents
+    ================================================
+         2                             def another_func():
+         3      8.00 MB      0.00 MB       """"""Undecorated function that allocates memory""""""
+         4     16.00 MB      8.00 MB       c = [1] * (10 ** 6)
+         5     92.00 MB     76.00 MB       d = [1] * (10 ** 7)
+         6     92.00 MB      0.00 MB       return c, d
+
+
+Note that you can either profile using the decorator (or many decorators) 
+OR with one named file and function. You cannot mix the two approaches
+and you cannot profile more than one file and function.
+
+TODO: allow multiple files and functions rather than just one (convert
+the named variables into a list internally and iterate on the list)
+
+TODO: the current named file approach would be confused if two files in 
+different directories shared the same name, and both had the same named
+function. Rather than checking named files we should check for modules
+in their namespace (e.g. rather than module1/afile.py and some_function, 
+we should check for module1.afile.some_function to remove ambiguity).
 
 =====
  API
@@ -115,7 +126,7 @@ arguments to be evaluated as ``f(*args, **kw)``. For example::
 
 
 =====================
- IPython integration
+ Ipython integration
 =====================
 After installing the module, if you use IPython, you can set up the `%mprun`
 and `%memit` magics by following these steps.
@@ -182,7 +193,7 @@ For more details, see the docstrings of the magics.
 ============================
     * Q: How accurate are the results ?
     * A: This module gets the memory consumption by querying the
-      operating system kernel about the amount of memory the current
+      operating system kernel about the ammount of memory the current
       process has allocated, which might be slightly different from
       the ammount of memory that is actually used by the Python
       interpreter. Also, because of how the garbage collector works in
"
,examples/example_undecorated.py,642d0bc98d47855e525996af3dc535bb31fae7e9,b2c807c2dff8c167d3d3c835f3a35b2736018f45,allow undecorated calls with memory_profiler using command line argument,"@@ -0,0 +1,9 @@
+
+def another_func():
+    """"""Undecorated function that allocates memory""""""
+    c = [1] * (10 ** 6)
+    d = [1] * (10 ** 7)
+    return c, d
+
+if __name__ == '__main__':
+    another_func()
"
memory_profiler.py,memory_profiler.py,642d0bc98d47855e525996af3dc535bb31fae7e9,b2c807c2dff8c167d3d3c835f3a35b2736018f45,allow undecorated calls with memory_profiler using command line argument,"@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.18'
+__version__ = '0.17'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
@@ -16,7 +16,7 @@ try:
     def _get_memory(pid):
         process = psutil.Process(pid)
         try:
-            mem = float(process.get_memory_info()[0]) / (1024 ** 2)
+            mem = float(process.get_memory_info()[0] / (1024 ** 2))
         except psutil.AccessDenied:
             mem = -1
         return mem
@@ -76,15 +76,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
     """"""
     ret = []
 
-    if timeout is not None:
-        max_iter = timeout / interval
-    elif isinstance(proc, int):
-        # external process and no timeout
-        max_iter = 1
-    else:
-        # for a Python function wait until it finishes
-        max_iter = float('inf')
-
     if str(proc).endswith('.py'):
         filename = _find_script(proc)
         with open(filename) as f:
@@ -114,6 +105,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         else:
             main_thread = multiprocessing.Process(target=f, args=args, kwargs=kw)
         i = 0
+        if timeout is not None:
+            max_iter = timeout / interval
+        else:
+            max_iter = float('inf')
         main_thread.start()
         pid = getattr(main_thread, 'pid', os.getpid())
         while i < max_iter and main_thread.is_alive():
@@ -126,9 +121,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         # external process
         if proc == -1:
             proc = os.getpid()
-        if max_iter == -1:
-            max_iter = 1
-        for _ in range(max_iter):
+        if num == -1:
+            num = 1
+        for _ in range(num):
             ret.append(_get_memory(proc))
             time.sleep(interval)
     return ret
@@ -164,6 +159,13 @@ class LineProfiler:
         self.code_map = {}
         self.enable_count = 0
         self.max_mem = kw.get('max_mem', None)
+        self.target_file = kw.get('target_file', None)
+        self.target_function = kw.get('target_function', None)
+        if self.target_file:
+            # if we're tracking a file+function rather than using a
+            # decorator then we enable settrace for all lines of code
+            self.enable()
+
 
     def __call__(self, func):
         self.add_function(func)
@@ -247,7 +249,27 @@ class LineProfiler:
 
     def trace_memory_usage(self, frame, event, arg):
         """"""Callback for sys.settrace""""""
-        if event in ('line', 'return') and frame.f_code in self.code_map:
+
+        # if we're profiling a named file and function then
+        # check this trace event to see if it matches our pattern
+        profile_this = False
+        if self.target_file:
+            co = frame.f_code
+            func_name = co.co_name
+            func_filename = co.co_filename
+            if self.target_file in func_filename:
+                if self.target_function == func_name:
+                    if frame.f_code not in self.code_map:
+                        # if we've not yet encountered this function (and it is
+                        # the one we want to trace) then we add it to
+                        # the code_map
+                        self.code_map[frame.f_code] = {}
+                    profile_this = True
+
+        # if we've been called on our decorated function
+        # OR we've matched the named file and function
+        # then track the memory usage
+        if event in ('line', 'return') and (frame.f_code in self.code_map or profile_this):
                 lineno = frame.f_lineno
                 if event == 'return':
                     lineno += 1
@@ -258,7 +280,7 @@ class LineProfiler:
 
     def trace_max_mem(self, frame, event, arg):
         # run into PDB as soon as memory is higher than MAX_MEM
-        if event in ('line', 'return') and frame.f_code in self.code_map:
+        if event in ('line', 'return'):
             c = _get_memory(os.getpid())
             if c >= self.max_mem:
                 t = 'Current memory {0:.2f} MB exceeded the maximum '.format(c) + \
@@ -290,7 +312,12 @@ class LineProfiler:
 
     def disable(self):
         self.last_time = {}
-        sys.settrace(None)
+        if self.target_file is None:
+            # if target_file is None then we're using the decorator
+            # and it is safe to disable settrace
+            # if target_file is not None then we're running settrace
+            # on every line of code so we can't disable the trace
+            sys.settrace(None)
 
 
 def show_results(prof, stream=None):
@@ -544,6 +571,12 @@ if __name__ == '__main__':
     parser.add_option(""--pdb-mmem"", dest=""max_mem"", metavar=""MAXMEM"",
         type=""float"", action=""store"",
         help=""step into the debugger when memory exceeds MAXMEM"")
+    parser.add_option(""--target-file"", dest=""target_file"",
+        type=""str"", action=""store"", default=None,
+        help=""Traces this file (requires target-function), disables @profile tracing"")
+    parser.add_option(""--target-function"", dest=""target_function"",
+        type=""str"", action=""store"", default=None,
+        help=""Traces this function (requires target-file), disables @profile tracing"")
 
     if not sys.argv[1:]:
         parser.print_help()
@@ -551,7 +584,15 @@ if __name__ == '__main__':
 
     (options, args) = parser.parse_args()
 
-    prof = LineProfiler(max_mem=options.max_mem)
+    # check that if the user wants to memory_profile without a decorator
+    # then they've specified both of the required options
+    if options.target_file or options.target_function:
+        if not (options.target_file and options.target_function):
+            print ""Error: Both --target-file and --target-function are required""
+            raise SystemExit(1)
+
+    # hardcoded module name and function name
+    prof = LineProfiler(max_mem=options.max_mem, target_file=options.target_file, target_function=options.target_function)
     __file__ = _find_script(args[0])
     if sys.version_info[0] < 3:
         import __builtin__
"
README.rst,README.rst,4ae4c9040250e7653355cae6a414e43bb4ecb5f6,b2c807c2dff8c167d3d3c835f3a35b2736018f45,Add function decorator for non-script usage.,"@@ -68,6 +68,20 @@ Python interpreter after that line has been executed. The third column
 with respect to the last one. The last column (*Line Contents*) prints
 the code that has been profiled.
 
+Decorator
+=========
+
+A function decorator is also available.  Use as follows::
+
+    from memory_profiler import profile
+
+    @profile
+    def my_func():
+        a = [1] * (10 ** 6)
+        b = [2] * (2 * 10 ** 7)
+        del b
+        return a
+
 Setting debugger breakpoints
 =============================
 It is possible to set breakpoints depending on the amount of memory used.
"
memory_profiler.py,memory_profiler.py,4ae4c9040250e7653355cae6a414e43bb4ecb5f6,b2c807c2dff8c167d3d3c835f3a35b2736018f45,Add function decorator for non-script usage.,"@@ -538,6 +538,15 @@ def magic_memit(self, line=''):
         print('ERROR: could not read memory usage, try with a lower interval or more iterations')
 
 
+def profile(func):
+    def wrapper(*args, **kwargs):
+        prof = LineProfiler()
+        val = prof(func)(*args, **kwargs)
+        show_results(prof)
+        return val
+    return wrapper
+
+
 if __name__ == '__main__':
     from optparse import OptionParser
     parser = OptionParser(usage=_CMD_USAGE, version=__version__)
"
memory_profiler.py,memory_profiler.py,014f6f8139a992e07aa56508aa149e71c61b86b5,4ae4c9040250e7653355cae6a414e43bb4ecb5f6,Added stream option to profile,"@@ -538,11 +538,11 @@ def magic_memit(self, line=''):
         print('ERROR: could not read memory usage, try with a lower interval or more iterations')
 
 
-def profile(func):
+def profile(func, stream=None):
     def wrapper(*args, **kwargs):
         prof = LineProfiler()
         val = prof(func)(*args, **kwargs)
-        show_results(prof)
+        show_results(prof, stream=stream)
         return val
     return wrapper
 
"
memory_profiler.py,memory_profiler.py,a8dc01d6c48494c78999707fb0c47800f3cdb5df,014f6f8139a992e07aa56508aa149e71c61b86b5,"Ignore unrecognized args.

Fix by @amcnabb. Fixes issue #27","@@ -550,6 +550,7 @@ def profile(func, stream=None):
 if __name__ == '__main__':
     from optparse import OptionParser
     parser = OptionParser(usage=_CMD_USAGE, version=__version__)
+    parser.disable_interspersed_args()
     parser.add_option(""--pdb-mmem"", dest=""max_mem"", metavar=""MAXMEM"",
         type=""float"", action=""store"",
         help=""step into the debugger when memory exceeds MAXMEM"")
"
memory_profiler.py,memory_profiler.py,4051083296bef7651321e680343ae0ca1bb97f4f,a8dc01d6c48494c78999707fb0c47800f3cdb5df,0.19 release,"@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.18'
+__version__ = '0.19'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
memory_profiler.py,memory_profiler.py,e2bc2eb071ee3edc661b267bed997cbcb0e9d2ed,4051083296bef7651321e680343ae0ca1bb97f4f,more robust memory_usage,"@@ -62,7 +62,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
 
     timeout : float, optional
 
-
     run_in_place : boolean, optional. False by default
         If False fork the process and retrieve timings from a different
         process. You shouldn't need to change this unless you are affected
@@ -101,6 +100,13 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
             f, args, kw = (proc[0], proc[1], proc[2])
         else:
             raise ValueError
+
+        aspec = inspect.getargspec(f)
+        if len(aspec.args) != len(args):
+            raise ValueError(
+            'Function expects %s value(s) but %s where given'
+            % (len(aspec.args), len(args)))
+
         try:
             import multiprocessing
         except ImportError:
@@ -118,10 +124,13 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         pid = getattr(main_thread, 'pid', os.getpid())
         while i < max_iter and main_thread.is_alive():
             m = _get_memory(pid)
+            if m == -1:
+                # this means the thread has finished
+                break
             ret.append(m)
             time.sleep(interval)
             i += 1
-        main_thread.join()
+        main_thread.join(1.)
     else:
         # external process
         if proc == -1:
@@ -136,7 +145,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
 # ..
 # .. utility functions for line-by-line ..
 
-
 def _find_script(script_name):
     """""" Find the script.
 
@@ -453,12 +461,6 @@ def magic_mprun(self, parameter_s=''):
         page(output)
     print(message,)
 
-#    dump_file = opts.D[0]
-#    if dump_file:
-#        profile.dump_stats(dump_file)
-#        print '\n*** Profile stats pickled to file',\
-#              `dump_file` + '.', message
-
     text_file = opts.T[0]
     if text_file:
         pfile = open(text_file, 'w')
"
memory_profiler.py,memory_profiler.py,5e6e3e13ba626adfbc12a0cd53b6ef41a325e88a,e2bc2eb071ee3edc661b267bed997cbcb0e9d2ed,docstrings,"@@ -53,14 +53,17 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
     Parameters
     ----------
     proc : {int, string, tuple}, optional
-        The process to monitor. Can be given by a PID, by a string
-        containing a filename or by a tuple. The tuple should contain
-        three values (f, args, kw) specifies to run the function
-        f(*args, **kw).  Set to -1 (default) for current process.
+        The process to monitor. Can be given by an integer
+        representing a PID or by a tuple representing a Python
+        function. The tuple contains three values (f, args, kw) and
+        specifies to run the function f(*args, **kw).  Set to -1
+        (default) for current process.
 
     interval : float, optional
+        Interval at which measurements are collected.
 
     timeout : float, optional
+        Maximum amount of time (in seconds) to wait before returning.
 
     run_in_place : boolean, optional. False by default
         If False fork the process and retrieve timings from a different
@@ -70,8 +73,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
 
     Returns
     -------
-    mm : list of integers, size less than num
-        memory usage, in KB
+    mem_usage : list of floating-poing values
+        memory usage, in MB. It's length is always < timeout / interval
     """"""
     ret = []
 
@@ -88,6 +91,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         filename = _find_script(proc)
         with open(filename) as f:
             proc = f.read()
+        # XXX TODO
         raise NotImplementedError
 
     if isinstance(proc, (list, tuple)):
"
memory_profiler.py,memory_profiler.py,adfc6fd3a036d52707703dde8b1b1ab469a8caa7,5e6e3e13ba626adfbc12a0cd53b6ef41a325e88a,BUG: iterate over ints,"@@ -79,7 +79,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
     ret = []
 
     if timeout is not None:
-        max_iter = timeout / interval
+        max_iter = int(timeout / interval)
     elif isinstance(proc, int):
         # external process and no timeout
         max_iter = 1
"
memory_profiler.py,memory_profiler.py,79bb1aa5b2d8e67ab16e47e536c3bf1affa5e641,adfc6fd3a036d52707703dde8b1b1ab469a8caa7,FIX: for keyword arguments,"@@ -106,6 +106,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
             raise ValueError
 
         aspec = inspect.getargspec(f)
+        n_args = len(aspec.args)
+        if aspec.defaults is not None:
+            n_args -= len(aspec.defaults)
         if len(aspec.args) != len(args):
             raise ValueError(
             'Function expects %s value(s) but %s where given'
"
memory_profiler.py,memory_profiler.py,a3fafb82452ce154ee939d07ddd26028fee821bd,79bb1aa5b2d8e67ab16e47e536c3bf1affa5e641,FIX previous commit,"@@ -109,10 +109,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         n_args = len(aspec.args)
         if aspec.defaults is not None:
             n_args -= len(aspec.defaults)
-        if len(aspec.args) != len(args):
+        if n_args != len(args):
             raise ValueError(
             'Function expects %s value(s) but %s where given'
-            % (len(aspec.args), len(args)))
+            % (n_args, len(args)))
 
         try:
             import multiprocessing
"
memory_profiler.py,memory_profiler.py,22f21ab0e1f951ab05f5ca575ebc696dcf40a444,a3fafb82452ce154ee939d07ddd26028fee821bd,New strategy to get memory consumption,"@@ -45,6 +45,30 @@ except ImportError:
         raise NotImplementedError('The psutil module is required for non-unix '
                                   'platforms')
 
+try:
+    from multiprocessing import Process, Event, Queue
+except ImportError:
+    from threading import Thread, Event, Queue
+    Process = Thread
+
+class Timer(Process):
+    """"""
+    Fetch memory consumption from over a time interval
+    """"""
+
+    def __init__(self, monitor_pid, interval, event, queue, *args, **kw):
+        self.monitor_pid = monitor_pid
+        self.q = queue
+        self.interval = interval
+        self.cont = True
+        self.e = event
+        super(Timer, self).__init__(*args, **kw)
+
+    def run(self):
+        while not self.e.is_set():
+            m = _get_memory(self.monitor_pid)
+            self.q.put(m)
+            time.sleep(self.interval)
 
 def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
     """"""
@@ -87,13 +111,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
         # for a Python function wait until it finishes
         max_iter = float('inf')
 
-    if str(proc).endswith('.py'):
-        filename = _find_script(proc)
-        with open(filename) as f:
-            proc = f.read()
-        # XXX TODO
-        raise NotImplementedError
-
     if isinstance(proc, (list, tuple)):
 
         if len(proc) == 1:
@@ -114,30 +131,17 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
             'Function expects %s value(s) but %s where given'
             % (n_args, len(args)))
 
-        try:
-            import multiprocessing
-        except ImportError:
-            print ('WARNING: cannot import module `multiprocessing`. Forcing to'
-                   ' run inplace.')
-            # force inplace
-            run_in_place = True
-        if run_in_place:
-            import threading
-            main_thread = threading.Thread(target=f, args=args, kwargs=kw)
-        else:
-            main_thread = multiprocessing.Process(target=f, args=args, kwargs=kw)
-        i = 0
-        main_thread.start()
-        pid = getattr(main_thread, 'pid', os.getpid())
-        while i < max_iter and main_thread.is_alive():
-            m = _get_memory(pid)
-            if m == -1:
-                # this means the thread has finished
-                break
-            ret.append(m)
-            time.sleep(interval)
-            i += 1
-        main_thread.join(1.)
+        e = Event() # this will tell Timer when to stop measuring
+        q = Queue() # this will store Timer's results
+        p = Timer(os.getpid(), interval, e, q)
+        p.start()
+        f(*args, **kw)
+        e.set()
+        p.join(5 * interval)
+        ret = []
+        while not q.empty():
+            ret.append(q.get_nowait())
+
     else:
         # external process
         if proc == -1:
"
README.rst,README.rst,92e17ea6977ae81071c9ce7816b21d77984114ae,22f21ab0e1f951ab05f5ca575ebc696dcf40a444,Update README,"@@ -106,12 +106,35 @@ uses more than 100 MB in the decorated function.
 memory_profiler exposes a number of functions to be used in third-party
 code.
 
+
+
 ``memory_usage(proc=-1, interval=.1, timeout=None)`` returns the memory usage
 over a time interval. The first argument, ``proc`` represents what
 should be monitored.  This can either be the PID of a process (not
 necessarily a Python program), a string containing some python code to
 be evaluated or a tuple ``(f, args, kw)`` containing a function and its
-arguments to be evaluated as ``f(*args, **kw)``. For example::
+arguments to be evaluated as ``f(*args, **kw)``. For example,
+
+
+    >>> from memory_profiler import memory_usage
+    >>> mem_usage = memory_usage(-1, interval=.2, timeout=1)
+    >>> print(mem_usage)
+	[7.296875, 7.296875, 7.296875, 7.296875, 7.296875]
+
+
+Here I've told memory_profiler to get the memory consumption of the
+current process over a period of 1 second with a time interval of 0.2
+seconds. As PID I've given it -1, which is a special number (PIDs are
+usually positive) that means current process, that is, I'm getting the
+memory usage of the current Python interpreter. Thus I'm getting
+around 7MB of memory usage from a plain python interpreter. If I try
+the same thing on IPython (console) I get 29MB, and if I try the same
+thing on the IPython notebook it scales up to 44MB.
+
+
+If you'd like to get the memory consumption of a Python function, then
+you should specify the function and its arguments in the tuple ``(f,
+args, kw)``. For example::
 
 
     >>> # define a simple function
@@ -125,7 +148,8 @@ arguments to be evaluated as ``f(*args, **kw)``. For example::
     >>> from memory_profiler import memory_usage
     >>> memory_usage((f, (1,), {'n' : int(1e6)}))
 
-
+This will execute the code `f(1, n=int(1e6))` and return the memory
+consumption during this execution.
 
 
 =====================
"
memory_profiler.py,memory_profiler.py,404bca9a54f15796c3d834569affbae541d39569,92e17ea6977ae81071c9ce7816b21d77984114ae,0.20 release,"@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.19'
+__version__ = '0.20'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
memory_profiler.py,memory_profiler.py,7efe1155505b8832f3dca94807452aaf42ade452,404bca9a54f15796c3d834569affbae541d39569,No need for run_in_place anymore,"@@ -56,21 +56,24 @@ class Timer(Process):
     Fetch memory consumption from over a time interval
     """"""
 
-    def __init__(self, monitor_pid, interval, event, queue, *args, **kw):
+    def __init__(self, monitor_pid, interval, queue, *args, **kw):
         self.monitor_pid = monitor_pid
         self.q = queue
         self.interval = interval
         self.cont = True
-        self.e = event
         super(Timer, self).__init__(*args, **kw)
 
     def run(self):
-        while not self.e.is_set():
+        while self.cont:
             m = _get_memory(self.monitor_pid)
             self.q.put(m)
             time.sleep(self.interval)
 
-def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
+    def join(self, timeout=None):
+        self.cont = False
+        super(Timer, self).join(timeout=timeout)
+
+def memory_usage(proc=-1, interval=.1, timeout=None):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -89,12 +92,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
     timeout : float, optional
         Maximum amount of time (in seconds) to wait before returning.
 
-    run_in_place : boolean, optional. False by default
-        If False fork the process and retrieve timings from a different
-        process. You shouldn't need to change this unless you are affected
-        by this (http://blog.vene.ro/2012/07/04/on-why-my-memit-fails-on-osx)
-        bug.
-
     Returns
     -------
     mem_usage : list of floating-poing values
@@ -131,14 +128,12 @@ def memory_usage(proc=-1, interval=.1, timeout=None, run_in_place=False):
             'Function expects %s value(s) but %s where given'
             % (n_args, len(args)))
 
-        e = Event() # this will tell Timer when to stop measuring
         q = Queue() # this will store Timer's results
-        p = Timer(os.getpid(), interval, e, q)
+        p = Timer(os.getpid(), interval, q)
         p.start()
+        ret = [q.get()] # wait for timer to start measuring
         f(*args, **kw)
-        e.set()
         p.join(5 * interval)
-        ret = []
         while not q.empty():
             ret.append(q.get_nowait())
 
@@ -503,10 +498,6 @@ def magic_memit(self, line=''):
     -r<R>: repeat the loop iteration <R> times and take the best result.
     Default: 1
 
-    -i: run the code in the current environment, without forking a new process.
-    This is required on some MacOS versions of Accelerate if your line contains
-    a call to `np.dot`.
-
     -t<T>: timeout after <T> seconds. Unused if `-i` is active. Default: None
 
     Examples
@@ -540,10 +531,8 @@ def magic_memit(self, line=''):
     timeout = int(getattr(opts, 't', 0))
     if timeout <= 0:
         timeout = None
-    run_in_place = hasattr(opts, 'i')
 
-    mem_usage = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout,
-        run_in_place=run_in_place)
+    mem_usage = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout)
 
     if mem_usage:
         print('maximum of %d: %f MB per loop' % (repeat, max(mem_usage)))
"
memory_profiler.py,memory_profiler.py,57b4d4a952cd8f6c602f320d85110ead800683d4,7efe1155505b8832f3dca94807452aaf42ade452,Use Pipes for communcation,"@@ -10,6 +10,13 @@ import linecache
 import inspect
 
 
+# TODO: provide alternative when multprocessing is not available
+try:
+    from multiprocessing import Process, Pipe
+except ImportError:
+    from multiprocessing.dummy import Process, Pipe
+
+
 try:
     import psutil
 
@@ -45,33 +52,28 @@ except ImportError:
         raise NotImplementedError('The psutil module is required for non-unix '
                                   'platforms')
 
-try:
-    from multiprocessing import Process, Event, Queue
-except ImportError:
-    from threading import Thread, Event, Queue
-    Process = Thread
 
 class Timer(Process):
     """"""
     Fetch memory consumption from over a time interval
     """"""
 
-    def __init__(self, monitor_pid, interval, queue, *args, **kw):
+    def __init__(self, monitor_pid, interval, pipe, *args, **kw):
         self.monitor_pid = monitor_pid
-        self.q = queue
         self.interval = interval
+        self.pipe = pipe
         self.cont = True
         super(Timer, self).__init__(*args, **kw)
 
     def run(self):
-        while self.cont:
+        m = _get_memory(self.monitor_pid)
+        timings = [m]
+        self.pipe.send(0) # we're ready
+        while not self.pipe.poll(self.interval):
             m = _get_memory(self.monitor_pid)
-            self.q.put(m)
-            time.sleep(self.interval)
+            timings.append(m)
+        self.pipe.send(timings)
 
-    def join(self, timeout=None):
-        self.cont = False
-        super(Timer, self).join(timeout=timeout)
 
 def memory_usage(proc=-1, interval=.1, timeout=None):
     """"""
@@ -128,15 +130,14 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
             'Function expects %s value(s) but %s where given'
             % (n_args, len(args)))
 
-        q = Queue() # this will store Timer's results
-        p = Timer(os.getpid(), interval, q)
+        a, b =  Pipe() # this will store Timer's results
+        p = Timer(os.getpid(), interval, a)
         p.start()
-        ret = [q.get()] # wait for timer to start measuring
+        b.recv() # wait until we start getting memory
         f(*args, **kw)
+        b.send(0) # finish timing
+        ret = b.recv()
         p.join(5 * interval)
-        while not q.empty():
-            ret.append(q.get_nowait())
-
     else:
         # external process
         if proc == -1:
"
memory_profiler.py,memory_profiler.py,4211151e11db3252b3234b639e9466ed4e20f1cd,57b4d4a952cd8f6c602f320d85110ead800683d4,0.21 release,"@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.20'
+__version__ = '0.21'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
memory_profiler.py,memory_profiler.py,37aa53965f03016c9e33ef751c70e3a05155427f,4211151e11db3252b3234b639e9466ed4e20f1cd,increased number of decimals displayed in logs,"@@ -363,8 +363,8 @@ def show_results(prof, stream=None):
                 mem = max(lines_normalized[l])
                 inc = mem - mem_old
                 mem_old = mem
-                mem = '{0:9.2f} MB'.format(mem)
-                inc = '{0:9.2f} MB'.format(inc)
+                mem = '{0:9.6f} MB'.format(mem)
+                inc = '{0:9.6f} MB'.format(inc)
             stream.write(template.format(l, mem, inc, sub_lines[i]))
         stream.write('\n\n')
 
"
memory_profiler.py,memory_profiler.py,7da377ade2949ec7cabf36f4f48cbbbc60e3a577,a13554c86c772e69e2912276685da2dc425dbbb9,Add option --precision and support for Control-C,"@@ -308,7 +308,7 @@ class LineProfiler:
         sys.settrace(None)
 
 
-def show_results(prof, stream=None):
+def show_results(prof, stream=None, precision=3):
     if stream is None:
         stream = sys.stdout
     template = '{0:>6} {1:>12} {2:>12}   {3:<}'
@@ -356,6 +356,8 @@ def show_results(prof, stream=None):
 
         first_line = sorted(lines_normalized.keys())[0]
         mem_old = max(lines_normalized[first_line])
+        precision = int(precision)
+        template_mem = '{{0:{0}.{1}'.format(precision + 6, precision) + 'f} MB'
         for i, l in enumerate(linenos):
             mem = ''
             inc = ''
@@ -363,8 +365,8 @@ def show_results(prof, stream=None):
                 mem = max(lines_normalized[l])
                 inc = mem - mem_old
                 mem_old = mem
-                mem = '{0:9.6f} MB'.format(mem)
-                inc = '{0:9.6f} MB'.format(inc)
+                mem = template_mem.format(mem)
+                inc = template_mem.format(inc)
             stream.write(template.format(l, mem, inc, sub_lines[i]))
         stream.write('\n\n')
 
@@ -542,6 +544,9 @@ def magic_memit(self, line=''):
 
 
 def profile(func, stream=None):
+    """"""
+    Decorator that will run the function and print a line-by-line profile
+    """"""
     def wrapper(*args, **kwargs):
         prof = LineProfiler()
         val = prof(func)(*args, **kwargs)
@@ -557,6 +562,9 @@ if __name__ == '__main__':
     parser.add_option(""--pdb-mmem"", dest=""max_mem"", metavar=""MAXMEM"",
         type=""float"", action=""store"",
         help=""step into the debugger when memory exceeds MAXMEM"")
+    parser.add_option('--precision', dest=""precision"", type=""int"",
+        action=""store"", default=3,
+        help=""precision of memory output in number of significant digits"")
 
     if not sys.argv[1:]:
         parser.print_help()
@@ -566,14 +574,19 @@ if __name__ == '__main__':
 
     prof = LineProfiler(max_mem=options.max_mem)
     __file__ = _find_script(args[0])
-    if sys.version_info[0] < 3:
-        import __builtin__
-        __builtin__.__dict__['profile'] = prof
-        execfile(__file__, locals(), locals())
-    else:
-        import builtins
-        builtins.__dict__['profile'] = prof
-        exec(compile(open(__file__).read(), __file__, 'exec'), locals(),
-                                                               globals())
-
-    show_results(prof)
+    try:
+        if sys.version_info[0] < 3:
+            import __builtin__
+            __builtin__.__dict__['profile'] = prof
+            ns = locals()
+            ns['profile'] = prof # shadow the profile decorator defined above
+            execfile(__file__, ns, ns)
+        else:
+            import builtins
+            builtins.__dict__['profile'] = prof
+            ns = locals()
+            ns['profile'] = prof # shadow the profile decorator defined above
+            exec(compile(open(__file__).read(), __file__, 'exec'), ns,
+                                                                   globals())
+    finally:
+        show_results(prof, precision=options.precision)
"
memory_profiler.py,memory_profiler.py,f6d6c3c96b2fe117ce37e830aff6b1f2d5c9ef70,7da377ade2949ec7cabf36f4f48cbbbc60e3a577,"Allow loading directly as an IPython extension.

Closes gh-25","@@ -543,6 +543,12 @@ def magic_memit(self, line=''):
         print('ERROR: could not read memory usage, try with a lower interval or more iterations')
 
 
+def load_ipython_extension(ip):
+    """"""This is called to load the module as an IPython extension.""""""
+    ip.define_magic('mprun', magic_mprun)
+    ip.define_magic('memit', magic_memit)
+
+
 def profile(func, stream=None):
     """"""
     Decorator that will run the function and print a line-by-line profile
"
README.rst,README.rst,1760e229a6285a93ba20440fa23ab01734eaadc3,f6d6c3c96b2fe117ce37e830aff6b1f2d5c9ef70,Update README info on IPython,"@@ -155,46 +155,24 @@ consumption during this execution.
 =====================
  IPython integration
 =====================
-After installing the module, if you use IPython, you can set up the `%mprun`
-and `%memit` magics by following these steps.
+After installing the module, if you use IPython, you can use the `%mprun`
+and `%memit` magics.
 
-For IPython 0.10, you can install it by editing the IPython configuration
-file ~/.ipython/ipy_user_conf.py to add the following lines::
+For IPython 0.11+, you can use the module directly as an extension, with
+``%load_ext memory_profiler``.
 
-    # These two lines are standard and probably already there.
-    import IPython.ipapi
-    ip = IPython.ipapi.get()
+To activate it whenever you start IPython, edit the configuration file for your
+IPython profile, ~/.ipython/profile_default/ipython_config.py, to register the
+extension like this (If you already have other extensions, just add this one to
+the list)::
 
-    # These two are the important ones.
-    import memory_profiler
-    ip.expose_magic('mprun', memory_profiler.magic_mprun)
-    ip.expose_magic('memit', memory_profiler.magic_memit)
-
-For IPython 0.11+, you have to edit the file
-~/.ipython/extensions/memory_profiler_ext.py with the following content::
-
-    import memory_profiler
-
-    def load_ipython_extension(ip):
-        ip.define_magic('mprun', memory_profiler.magic_mprun)
-        ip.define_magic('memit', memory_profiler.magic_memit)
-
-If you don't have an IPython profile already set up, create one using the
-following command::
-
-    $ ipython profile create
-
-Then, edit the configuration file for your IPython profile,
-~/.ipython/profile_default/ipython_config.py, to register the extension like
-this (If you already have other extensions, just add this one to the list)::
-
-    c.TerminalIPythonApp.extensions = [
-        'memory_profiler_ext',
-    ]
     c.InteractiveShellApp.extensions = [
-        'memory_profiler_ext',
+        'memory_profiler',
     ]
 
+(If the config file doesn't already exist, run ``ipython profile create`` in
+a terminal.)
+
 It then can be used directly from IPython to obtain a line-by-line
 report using the `%mprun` magic command. In this case, you can skip
 the `@profile` decorator and instead use the `-f` parameter, like
@@ -215,6 +193,18 @@ Another useful magic that we define is `%memit`, which is analogous to
 
 For more details, see the docstrings of the magics.
 
+For IPython 0.10, you can install it by editing the IPython configuration
+file ~/.ipython/ipy_user_conf.py to add the following lines::
+
+    # These two lines are standard and probably already there.
+    import IPython.ipapi
+    ip = IPython.ipapi.get()
+
+    # These two are the important ones.
+    import memory_profiler
+    ip.expose_magic('mprun', memory_profiler.magic_mprun)
+    ip.expose_magic('memit', memory_profiler.magic_memit)
+
 ============================
  Frequently Asked Questions
 ============================
"
README.rst,README.rst,2d6da9361dce29a53301ff6020018f04f2c99373,103fb0ad78614122fd20b96b46bcbe6a84fe0cc6,Update README.rst,"@@ -260,6 +260,8 @@ cleanup.
 
 `Vlad Niculae <http://vene.ro/>`_ added the `%mprun` and `%memit` IPython magics.
 
+`Thomas Kluyver <https://github.com/takluyver>`_ added the IPython extension.
+
 
 
 =========
"
.gitignore,.gitignore,29e4085ca906a29ec790f86a1d1c57b2b0568081,2d6da9361dce29a53301ff6020018f04f2c99373,"Python 3.x support for %mprun.

I also added supported Python versions to setup.py explicitly.","@@ -1,4 +1,5 @@
 .idea
 dist
+build
 *.pyc
 MANIFEST
"
memory_profiler.py,memory_profiler.py,29e4085ca906a29ec790f86a1d1c57b2b0568081,2d6da9361dce29a53301ff6020018f04f2c99373,"Python 3.x support for %mprun.

I also added supported Python versions to setup.py explicitly.","@@ -167,7 +167,7 @@ def _find_script(script_name):
         if os.path.isfile(fn):
             return fn
 
-    print >> sys.stderr, 'Could not find script {0}'.format(script_name)
+    sys.stderr.write('Could not find script {0}\n'.format(script_name))
     raise SystemExit(1)
 
 
@@ -401,7 +401,10 @@ def magic_mprun(self, parameter_s=''):
 
     -r: return the LineProfiler object after it has completed profiling.
     """"""
-    from StringIO import StringIO
+    try:
+        from StringIO import StringIO
+    except ImportError: # Python 3.x
+        from io import StringIO
 
     # Local imports to avoid hard dependency.
     from distutils.version import LooseVersion
@@ -434,16 +437,22 @@ def magic_mprun(self, parameter_s=''):
                 e.__class__.__name__, e))
 
     profile = LineProfiler()
-    map(profile, funcs)
+    for func in funcs:
+        profile(func)
+
     # Add the profiler to the builtins for @profile.
-    import __builtin__
-    if 'profile' in __builtin__.__dict__:
+    try:
+        import builtins
+    except ImportError: # Python 3x
+        import __builtin__ as builtins
+
+    if 'profile' in builtins.__dict__:
         had_profile = True
-        old_profile = __builtin__.__dict__['profile']
+        old_profile = builtins.__dict__['profile']
     else:
         had_profile = False
         old_profile = None
-    __builtin__.__dict__['profile'] = profile
+    builtins.__dict__['profile'] = profile
 
     try:
         try:
@@ -456,7 +465,7 @@ def magic_mprun(self, parameter_s=''):
                 ""profiled."")
     finally:
         if had_profile:
-            __builtin__.__dict__['profile'] = old_profile
+            builtins.__dict__['profile'] = old_profile
 
     # Trap text output.
     stdout_trap = StringIO()
"
setup.py,setup.py,29e4085ca906a29ec790f86a1d1c57b2b0568081,2d6da9361dce29a53301ff6020018f04f2c99373,"Python 3.x support for %mprun.

I also added supported Python versions to setup.py explicitly.","@@ -7,7 +7,12 @@ Intended Audience :: Science/Research
 Intended Audience :: Developers
 License :: OSI Approved
 Programming Language :: Python
+Programming Language :: Python :: 2
+Programming Language :: Python :: 2.6
+Programming Language :: Python :: 2.7
 Programming Language :: Python :: 3
+Programming Language :: Python :: 3.2
+Programming Language :: Python :: 3.3
 Topic :: Software Development
 Operating System :: POSIX
 Operating System :: Unix
"
memory_profiler.py,memory_profiler.py,3c43406486ce1c5d0421cd077dde1c28269dd049,2d6da9361dce29a53301ff6020018f04f2c99373,IPython error message is fixed,"@@ -324,7 +324,7 @@ def show_results(prof, stream=None, precision=3):
         stream.write('Filename: ' + filename + '\n\n')
         if not os.path.exists(filename):
             stream.write('ERROR: Could not find file ' + filename + '\n')
-            if filename.startswith(""ipython-input""):
+            if filename.startswith(""ipython-input"") or filename.startswith(""<ipython-input""):
                 print(""NOTE: %mprun can only be used on functions defined in ""
                       ""physical files, and not in the IPython environment."")
             continue
"
memory_profiler.py,memory_profiler.py,aa128e8113ecc725694ba2e5f9d4116f726b1bbc,3c43406486ce1c5d0421cd077dde1c28269dd049,"bikeshedding (style fixes):

- PEP8 spaces for inline comments;
- more meaningful variable names instead of `a,b=Pipe()` (taken from Python docs);
- don't shadow builtins 'dict' and 'dir' with local variables;
- remove unneeded indentation;
- use 'with' for opening files","@@ -68,7 +68,7 @@ class Timer(Process):
     def run(self):
         m = _get_memory(self.monitor_pid)
         timings = [m]
-        self.pipe.send(0) # we're ready
+        self.pipe.send(0)  # we're ready
         while not self.pipe.poll(self.interval):
             m = _get_memory(self.monitor_pid)
             timings.append(m)
@@ -130,13 +130,13 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
             'Function expects %s value(s) but %s where given'
             % (n_args, len(args)))
 
-        a, b =  Pipe() # this will store Timer's results
-        p = Timer(os.getpid(), interval, a)
+        child_conn, parent_conn = Pipe()  # this will store Timer's results
+        p = Timer(os.getpid(), interval, child_conn)
         p.start()
-        b.recv() # wait until we start getting memory
+        parent_conn.recv()  # wait until we start getting memory
         f(*args, **kw)
-        b.send(0) # finish timing
-        ret = b.recv()
+        parent_conn.send(0)  # finish timing
+        ret = parent_conn.recv()
         p.join(5 * interval)
     else:
         # external process
@@ -160,10 +160,10 @@ def _find_script(script_name):
     if os.path.isfile(script_name):
         return script_name
     path = os.getenv('PATH', os.defpath).split(os.pathsep)
-    for dir in path:
-        if dir == '':
+    for folder in path:
+        if folder == '':
             continue
-        fn = os.path.join(dir, script_name)
+        fn = os.path.join(folder, script_name)
         if os.path.isfile(fn):
             return fn
 
@@ -221,8 +221,8 @@ class LineProfiler:
         """""" Profile a single executable statment in the main namespace.
         """"""
         import __main__
-        dict = __main__.__dict__
-        return self.runctx(cmd, dict, dict)
+        main_dict = __main__.__dict__
+        return self.runctx(cmd, main_dict, main_dict)
 
     def runctx(self, cmd, globals, locals):
         """""" Profile a single executable statement in the given namespaces.
@@ -263,11 +263,11 @@ class LineProfiler:
     def trace_memory_usage(self, frame, event, arg):
         """"""Callback for sys.settrace""""""
         if event in ('line', 'return') and frame.f_code in self.code_map:
-                lineno = frame.f_lineno
-                if event == 'return':
-                    lineno += 1
-                entry = self.code_map[frame.f_code].setdefault(lineno, [])
-                entry.append(_get_memory(os.getpid()))
+            lineno = frame.f_lineno
+            if event == 'return':
+                lineno += 1
+            entry = self.code_map[frame.f_code].setdefault(lineno, [])
+            entry.append(_get_memory(os.getpid()))
 
         return self.trace_memory_usage
 
@@ -472,9 +472,8 @@ def magic_mprun(self, parameter_s=''):
 
     text_file = opts.T[0]
     if text_file:
-        pfile = open(text_file, 'w')
-        pfile.write(output)
-        pfile.close()
+        with open(text_file, 'w') as pfile:
+            pfile.write(output)
         print('\n*** Profile printout saved to text file %s. %s' % (text_file,
                                                                     message))
 
"
memory_profiler.py,memory_profiler.py,727a015381e1de331b83ee34ee6ec387d810827b,8cfb871e1c55d32c00fecd9aee55ee8580e129e7,FIX #36,"@@ -144,7 +144,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
             proc = os.getpid()
         if max_iter == -1:
             max_iter = 1
-        for _ in range(max_iter):
+        counter = 0
+        while counter < max_iter:
+            counter += 1
             ret.append(_get_memory(proc))
             time.sleep(interval)
     return ret
@@ -443,7 +445,7 @@ def magic_mprun(self, parameter_s=''):
     # Add the profiler to the builtins for @profile.
     try:
         import builtins
-    except ImportError: # Python 3x
+    except ImportError:  # Python 3x
         import __builtin__ as builtins
 
     if 'profile' in builtins.__dict__:
"
README.rst,README.rst,0543e2c5dc03168f58ce00f2fe66440d881c567a,727a015381e1de331b83ee34ee6ec387d810827b,Typo in README.rst ammount -> amount,"@@ -212,7 +212,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
     * A: This module gets the memory consumption by querying the
       operating system kernel about the amount of memory the current
       process has allocated, which might be slightly different from
-      the ammount of memory that is actually used by the Python
+      the amount of memory that is actually used by the Python
       interpreter. Also, because of how the garbage collector works in
       Python the result might be different between platforms and even
       between runs.
"
memory_profiler.py,memory_profiler.py,d63484ab02996a29e3ec90364ab7c9366d92ba1a,124aa8a2ab0c28e41c59eeae9ed0283807e71a6c,"0.24 release

For some reason the one on PYPI was 0.23 (?) so I skip a couple of
versions.","@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.21'
+__version__ = '0.24'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
memory_profiler.py,memory_profiler.py,95687f38f85e98adce31402f0c7b4d8114bff912,d63484ab02996a29e3ec90364ab7c9366d92ba1a,"memory_usage accepts Popen as argument

The ""proc"" argument of memory_usage() can now be a subprocess.Popen
object.","@@ -8,7 +8,7 @@ import time, sys, os, pdb
 import warnings
 import linecache
 import inspect
-
+import subprocess
 
 # TODO: provide alternative when multprocessing is not available
 try:
@@ -138,6 +138,15 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
         parent_conn.send(0)  # finish timing
         ret = parent_conn.recv()
         p.join(5 * interval)
+    elif isinstance(proc, subprocess.Popen):
+        # external process
+        if max_iter == -1:
+            max_iter = 1
+        for _ in range(max_iter):
+            ret.append(_get_memory(proc.pid))
+            time.sleep(interval)
+            if proc.poll() is not None:
+                break
     else:
         # external process
         if proc == -1:
"
,mem_profile,b04760ab0cfffbdb6bf1ca512854e5541421fe02,95687f38f85e98adce31402f0c7b4d8114bff912,"Added mem_profile executable

mem_profile allows both launching and monitoring a process.","@@ -0,0 +1,21 @@
+#! /usr/bin/env python
+import subprocess
+import memory_profiler as mp
+import sys
+
+if len(sys.argv) < 2:
+    print(""""""Memory usage monitoring
+          Usage: %s <command> <argument> ... <argument>
+
+          Output results in a file called ""profile.dat"" in the current directory.
+          This file contains the process memory consumption, in Mb (one value per
+          line). Memory is sampled twice each second.""""""
+          % sys.argv[0]
+          )
+    sys.exit(1)
+
+p = subprocess.Popen(sys.argv[1:])
+mu = mp.memory_usage(proc=p, interval=0.5)
+with open(""profile.dat"", ""w"") as f:
+    for m in mu:
+        f.write(str(m) + ""\n"")
"
memory_profiler.py,memory_profiler.py,b04760ab0cfffbdb6bf1ca512854e5541421fe02,95687f38f85e98adce31402f0c7b4d8114bff912,"Added mem_profile executable

mem_profile allows both launching and monitoring a process.","@@ -33,7 +33,6 @@ except ImportError:
 
     warnings.warn(""psutil module not found. memory_profiler will be slow"")
 
-    import subprocess
     if os.name == 'posix':
         def _get_memory(pid):
             # ..
@@ -139,10 +138,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
         ret = parent_conn.recv()
         p.join(5 * interval)
     elif isinstance(proc, subprocess.Popen):
-        # external process
-        if max_iter == -1:
-            max_iter = 1
-        for _ in range(max_iter):
+        # external process, launched from Python
+        while True:
             ret.append(_get_memory(proc.pid))
             time.sleep(interval)
             if proc.poll() is not None:
"
memory_profiler.py,memory_profiler.py,ba30dce0ce7a6ca33d60e2a5f82d91340efc8904,b04760ab0cfffbdb6bf1ca512854e5541421fe02,"timeout parameter works for Popen process

In memory_usage(), when passing proc as a Popen object, the timeout
parameter is now properly handled.

Updated memory_usage documentation.","@@ -80,12 +80,13 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
 
     Parameters
     ----------
-    proc : {int, string, tuple}, optional
-        The process to monitor. Can be given by an integer
-        representing a PID or by a tuple representing a Python
-        function. The tuple contains three values (f, args, kw) and
-        specifies to run the function f(*args, **kw).  Set to -1
-        (default) for current process.
+    proc : {int, string, tuple, subprocess.Popen}, optional
+        The process to monitor. Can be given by an integer/string
+        representing a PID, by a Popen object or by a tuple
+        representing a Python function. The tuple contains three
+        values (f, args, kw) and specifies to run the function
+        f(*args, **kw).
+        Set to -1 (default) for current process.
 
     interval : float, optional
         Interval at which measurements are collected.
@@ -142,6 +143,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
         while True:
             ret.append(_get_memory(proc.pid))
             time.sleep(interval)
+            if timeout is not None:
+                max_iter -= 1
+                if max_iter == 0:
+                    break
             if proc.poll() is not None:
                 break
     else:
"
mem_profile,,fb1e743640ff0d0ce5cb54da339345dec693eb1a,ba30dce0ce7a6ca33d60e2a5f82d91340efc8904,"Renamed mem_profile to mprofile

Output file now contains a timestamp.

setup.py now properly installs the mprofile executable.","@@ -1,21 +0,0 @@
-#! /usr/bin/env python
-import subprocess
-import memory_profiler as mp
-import sys
-
-if len(sys.argv) < 2:
-    print(""""""Memory usage monitoring
-          Usage: %s <command> <argument> ... <argument>
-
-          Output results in a file called ""profile.dat"" in the current directory.
-          This file contains the process memory consumption, in Mb (one value per
-          line). Memory is sampled twice each second.""""""
-          % sys.argv[0]
-          )
-    sys.exit(1)
-
-p = subprocess.Popen(sys.argv[1:])
-mu = mp.memory_usage(proc=p, interval=0.5)
-with open(""profile.dat"", ""w"") as f:
-    for m in mu:
-        f.write(str(m) + ""\n"")
"
,mprofile,fb1e743640ff0d0ce5cb54da339345dec693eb1a,ba30dce0ce7a6ca33d60e2a5f82d91340efc8904,"Renamed mem_profile to mprofile

Output file now contains a timestamp.

setup.py now properly installs the mprofile executable.","@@ -0,0 +1,26 @@
+#! /usr/bin/env python
+import subprocess
+import memory_profiler as mp
+import os.path as osp
+import time
+import sys
+
+if len(sys.argv) < 2:
+    print(""""""Memory usage monitoring
+Usage: %s <command> <argument> ... <argument>
+
+Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
+<YYYYMMDDhhmmss> is the date-time of the program start) in the current
+directory. This file contains the process memory consumption, in Mb (one
+value per line). Memory is sampled twice each second.""""""
+          % osp.basename(sys.argv[0])
+          )
+    sys.exit(1)
+
+outfilename = ""mprofile_%s.dat"" % time.strftime(""%Y%m%d%H%M%S"", time.localtime())
+
+p = subprocess.Popen(sys.argv[1:])
+mu = mp.memory_usage(proc=p, interval=0.5)
+with open(outfilename, ""w"") as f:
+    for m in mu:
+        f.write(str(m) + ""\n"")
"
setup.py,setup.py,fb1e743640ff0d0ce5cb54da339345dec693eb1a,ba30dce0ce7a6ca33d60e2a5f82d91340efc8904,"Renamed mem_profile to mprofile

Output file now contains a timestamp.

setup.py now properly installs the mprofile executable.","@@ -27,8 +27,9 @@ setup(
     author='Fabian Pedregosa',
     author_email='fabian@fseoane.net',
     url='http://pypi.python.org/pypi/memory_profiler',
-	py_modules=['memory_profiler'],
+    py_modules=['memory_profiler'],
+    scripts=[""mprofile""],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='Simplified BSD'
 
-)
\ No newline at end of file
+)
"
memory_profiler.py,memory_profiler.py,8fa4550c36d49f180cd3869f223e5f3cc37c1c05,fb1e743640ff0d0ce5cb54da339345dec693eb1a,"Added -o option to memory_profiler

Output of 'python -m memory_profiler -o ""bar.out"" script.py' goes
into file ""bar.out"" instead of standard output.","@@ -387,7 +387,7 @@ def show_results(prof, stream=None, precision=3):
 # A lprun-style %mprun magic for IPython.
 def magic_mprun(self, parameter_s=''):
     """""" Execute a statement under the line-by-line memory profiler from the
-    memory_profilser module.
+    memory_profiler module.
 
     Usage:
       %mprun -f func1 -f func2 <statement>
@@ -592,7 +592,9 @@ if __name__ == '__main__':
     parser.add_option('--precision', dest=""precision"", type=""int"",
         action=""store"", default=3,
         help=""precision of memory output in number of significant digits"")
-
+    parser.add_option(""-o"", dest=""out_filename"", type=""str"",
+                      action=""store"", default=None,
+                      help=""path to a file where results will be written"")
     if not sys.argv[1:]:
         parser.print_help()
         sys.exit(2)
@@ -616,4 +618,9 @@ if __name__ == '__main__':
             exec(compile(open(__file__).read(), __file__, 'exec'), ns,
                                                                    globals())
     finally:
-        show_results(prof, precision=options.precision)
+        if options.out_filename is not None:
+            out_file = open(options.out_filename, ""w"")
+        else:
+            out_file = sys.stdout
+
+        show_results(prof, precision=options.precision, stream=out_file)
"
memory_profiler.py,memory_profiler.py,58208ae8a888a2b34b0d2a81c5e0ac019f78ef32,8fa4550c36d49f180cd3869f223e5f3cc37c1c05,"Added timestamps to mprofile output

The output of mprofile now includes timestamp information, in
addition to memory consumption.

A ""timestamps"" option has been added to memory_usage()","@@ -20,13 +20,16 @@ except ImportError:
 try:
     import psutil
 
-    def _get_memory(pid):
+    def _get_memory(pid, timestamps=False):
         process = psutil.Process(pid)
         try:
             mem = float(process.get_memory_info()[0]) / (1024 ** 2)
         except psutil.AccessDenied:
             mem = -1
-        return mem
+        if timestamps:
+            return (mem, time.time())
+        else:
+            return mem
 
 
 except ImportError:
@@ -34,7 +37,7 @@ except ImportError:
     warnings.warn(""psutil module not found. memory_profiler will be slow"")
 
     if os.name == 'posix':
-        def _get_memory(pid):
+        def _get_memory(pid, timestamps=False):
             # ..
             # .. memory usage in MB ..
             # .. this should work on both Mac and Linux ..
@@ -44,9 +47,16 @@ except ImportError:
                   stdout=subprocess.PIPE).communicate()[0].split(b'\n')
             try:
                 vsz_index = out[0].split().index(b'RSS')
-                return float(out[1].split()[vsz_index]) / 1024
+                mem = float(out[1].split()[vsz_index]) / 1024
+                if timestamps:
+                    return(mem, time.time())
+                else:
+                    return mem
             except:
-                return -1
+                if timestamps:
+                    return (-1, time.time())
+                else:
+                    return -1
     else:
         raise NotImplementedError('The psutil module is required for non-unix '
                                   'platforms')
@@ -62,19 +72,24 @@ class Timer(Process):
         self.interval = interval
         self.pipe = pipe
         self.cont = True
+        if ""timestamps"" in kw:
+            self.timestamps = kw[""timestamps""]
+            del kw[""timestamps""]
+        else:
+            self.timestamps = False
         super(Timer, self).__init__(*args, **kw)
 
     def run(self):
-        m = _get_memory(self.monitor_pid)
+        m = _get_memory(self.monitor_pid, timestamps=self.timestamps)
         timings = [m]
         self.pipe.send(0)  # we're ready
         while not self.pipe.poll(self.interval):
-            m = _get_memory(self.monitor_pid)
+            m = _get_memory(self.monitor_pid, timestamps=self.timestamps)
             timings.append(m)
         self.pipe.send(timings)
 
 
-def memory_usage(proc=-1, interval=.1, timeout=None):
+def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -131,7 +146,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
             % (n_args, len(args)))
 
         child_conn, parent_conn = Pipe()  # this will store Timer's results
-        p = Timer(os.getpid(), interval, child_conn)
+        p = Timer(os.getpid(), interval, child_conn, timestamps=timestamps)
         p.start()
         parent_conn.recv()  # wait until we start getting memory
         f(*args, **kw)
@@ -141,7 +156,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
     elif isinstance(proc, subprocess.Popen):
         # external process, launched from Python
         while True:
-            ret.append(_get_memory(proc.pid))
+            ret.append(_get_memory(proc.pid, timestamps=timestamps))
             time.sleep(interval)
             if timeout is not None:
                 max_iter -= 1
@@ -158,7 +173,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
         counter = 0
         while counter < max_iter:
             counter += 1
-            ret.append(_get_memory(proc))
+            ret.append(_get_memory(proc, timestamps=timestamps))
             time.sleep(interval)
     return ret
 
"
mprofile,mprofile,58208ae8a888a2b34b0d2a81c5e0ac019f78ef32,8fa4550c36d49f180cd3869f223e5f3cc37c1c05,"Added timestamps to mprofile output

The output of mprofile now includes timestamp information, in
addition to memory consumption.

A ""timestamps"" option has been added to memory_usage()","@@ -20,7 +20,7 @@ value per line). Memory is sampled twice each second.""""""
 outfilename = ""mprofile_%s.dat"" % time.strftime(""%Y%m%d%H%M%S"", time.localtime())
 
 p = subprocess.Popen(sys.argv[1:])
-mu = mp.memory_usage(proc=p, interval=0.5)
+mu = mp.memory_usage(proc=p, interval=0.5, timestamps=True)
 with open(outfilename, ""w"") as f:
-    for m in mu:
-        f.write(str(m) + ""\n"")
+    for m, t in mu:
+        f.write(""{0:.6f} {1:.4f}"".format(m, t) + ""\n"")
"
test/test_loop.py,test/test_loop.py,58208ae8a888a2b34b0d2a81c5e0ac019f78ef32,8fa4550c36d49f180cd3869f223e5f3cc37c1c05,"Added timestamps to mprofile output

The output of mprofile now includes timestamp information, in
addition to memory consumption.

A ""timestamps"" option has been added to memory_usage()","@@ -1,6 +1,7 @@
 # .. an example with a for loop ..
 
-@profile
+import time
+
 def test_1():
     a = [1] * (10 ** 6)
     b = [2] * (2 * 10 ** 7)
@@ -12,13 +13,15 @@ def test_1():
         del b
     return a
 
-@profile
+
 def test_2():
     a = {}
     for i in range(10000):
-        a[i] =  i + 1
+        a[i] = i + 1
     return
 
 if __name__ == '__main__':
     test_1()
+    time.sleep(1)
     test_2()
+    time.sleep(1)
"
,test/test_loop_decorated.py,58208ae8a888a2b34b0d2a81c5e0ac019f78ef32,8fa4550c36d49f180cd3869f223e5f3cc37c1c05,"Added timestamps to mprofile output

The output of mprofile now includes timestamp information, in
addition to memory consumption.

A ""timestamps"" option has been added to memory_usage()","@@ -0,0 +1,24 @@
+# .. an example with a for loop ..
+
+@profile
+def test_1():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    del b
+
+    for i in range(2):
+        a = [1] * (10 ** 6)
+        b = [2] * (2 * 10 ** 7)
+        del b
+    return a
+
+@profile
+def test_2():
+    a = {}
+    for i in range(10000):
+        a[i] =  i + 1
+    return
+
+if __name__ == '__main__':
+    test_1()
+    test_2()
"
.gitignore,.gitignore,a17bdc80f195fad45670bced6c7c2fb009407fc7,58208ae8a888a2b34b0d2a81c5e0ac019f78ef32,"Plotting of mprofile output

The ""mplot"" script has been added. Plots of memory consumption can
be done with it.","@@ -3,3 +3,4 @@ dist
 build
 *.pyc
 MANIFEST
+*~
"
,mplot,a17bdc80f195fad45670bced6c7c2fb009407fc7,58208ae8a888a2b34b0d2a81c5e0ac019f78ef32,"Plotting of mprofile output

The ""mplot"" script has been added. Plots of memory consumption can
be done with it.","@@ -0,0 +1,43 @@
+#! /usr/bin/env python
+import pylab as pl
+import sys
+import glob
+import time
+import os
+
+profiles = glob.glob(""mprofile_*.dat"")
+profiles.sort()
+
+if len(sys.argv) == 1:
+    filename = profiles[-1]
+else:
+    filename = sys.argv[1]
+    if not os.path.exists(filename):
+        try:
+            n = int(filename)
+        except ValueError:
+            print(""Input file not found: "" + filename)
+        filename = profiles[n]
+
+datetime = time.strptime(filename, ""mprofile_%Y%m%d%H%M%S.dat"")
+mdata = pl.loadtxt(filename)
+mem = mdata[:, 0]
+max_mem = mem.max()
+max_mem_ind = mem.argmax()
+sampling_period = 0.5
+t = pl.r_[:len(mem)] * sampling_period
+
+pl.figure()
+pl.plot(t, mem)
+pl.hlines(max_mem,
+          pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
+          colors=""r"", linestyles=""--"")
+pl.vlines(t[max_mem_ind],
+          pl.ylim()[0] + 0.001, pl.ylim()[1] - 0.001,
+          colors=""r"", linestyles=""--"")
+pl.xlabel(""time [s]"")
+pl.ylabel(""memory used [Mb]"")
+pl.title(time.strftime(""%d / %m / %Y - start at %H:%M:%S"", datetime))
+pl.grid()
+pl.show()
+
"
setup.py,setup.py,4fe3646e106afa1ffe6cc0ee791ef3235a7e2b7c,a17bdc80f195fad45670bced6c7c2fb009407fc7,Added mplot to setup.py,"@@ -28,7 +28,7 @@ setup(
     author_email='fabian@fseoane.net',
     url='http://pypi.python.org/pypi/memory_profiler',
     py_modules=['memory_profiler'],
-    scripts=[""mprofile""],
+    scripts=[""mprofile"", ""mplot""],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='Simplified BSD'
 
"
memory_profiler.py,memory_profiler.py,cac54d9bb95b051d5559456ca8aa5ab081f49387,4fe3646e106afa1ffe6cc0ee791ef3235a7e2b7c,"Added timestamping feature

Added a --timestamp option that when turned on, output timestamps
for start and end of every decorated function, instead of memory
profile.
This options is intended to be used together with the mprofile script,
to be able to plot the lifetime of some functions  on the global
memory graph.","@@ -199,6 +199,51 @@ def _find_script(script_name):
     raise SystemExit(1)
 
 
+class TimeStamper:
+    """""" A profiler that just records start and end execution times for
+    any decorated function.
+    """"""
+    def __init__(self):
+        self.functions = {}
+
+    def __call__(self, func):
+        self.add_function(func)
+        f = self.wrap_function(func)
+        f.__module__ = func.__module__
+        f.__name__ = func.__name__
+        f.__doc__ = func.__doc__
+        f.__dict__.update(getattr(func, '__dict__', {}))
+        return f
+
+    def add_function(self, func):
+        if not func in self.functions:
+            self.functions[func] = []
+
+    def wrap_function(self, func):
+        """""" Wrap a function to timestamp it.
+        """"""
+        def f(*args, **kwds):
+            # Start time
+            timestamps = [time.time()]
+            self.functions[func].append(timestamps)
+            try:
+                result = func(*args, **kwds)
+            finally:
+                # end time
+                timestamps.append(time.time())
+            return result
+        return f
+
+    def show_results(self, stream=None):
+        if stream is None:
+            stream = sys.stdout
+
+        for func, timestamps in self.functions.iteritems():
+            function_name = ""%s.%s"" % (func.__module__, func.__name__)
+            for ts in timestamps:
+                stream.write(""%s %.4f %.4f\n"" % (function_name, ts[0], ts[1]))
+
+
 class LineProfiler:
     """""" A profiler that records the amount of memory for each line """"""
 
@@ -610,13 +655,21 @@ if __name__ == '__main__':
     parser.add_option(""-o"", dest=""out_filename"", type=""str"",
                       action=""store"", default=None,
                       help=""path to a file where results will be written"")
+    parser.add_option(""--timestamp"", dest=""timestamp"", default=False,
+                      action=""store_true"",
+                      help=""""""print timestamp instead of memory measurement for
+                      decorated functions"""""")
+
     if not sys.argv[1:]:
         parser.print_help()
         sys.exit(2)
 
     (options, args) = parser.parse_args()
 
-    prof = LineProfiler(max_mem=options.max_mem)
+    if options.timestamp:
+        prof = TimeStamper()
+    else:
+        prof = LineProfiler(max_mem=options.max_mem)
     __file__ = _find_script(args[0])
     try:
         if sys.version_info[0] < 3:
@@ -638,4 +691,7 @@ if __name__ == '__main__':
         else:
             out_file = sys.stdout
 
-        show_results(prof, precision=options.precision, stream=out_file)
+        if options.timestamp:
+            prof.show_results(stream=out_file)
+        else:
+            show_results(prof, precision=options.precision, stream=out_file)
"
mplot,mplot,0dcd9ef3e5f136d22d25ea3071ecfc60c63a8d3c,cac54d9bb95b051d5559456ca8aa5ab081f49387,"Timestamping is handled by mprofile and mplot

An --python option has been added to mprofile, just to add the proper
timestamping options to the run python program.
mplot now looks for a timestamp file, and plot the additional
information as vertical lines.","@@ -1,43 +1,89 @@
 #! /usr/bin/env python
 import pylab as pl
+import math
 import sys
 import glob
 import time
 import os
+import os.path as osp
 
-profiles = glob.glob(""mprofile_*.dat"")
+
+def read_timestamp_file(ts_filename):
+    """"""Return content of ts_filename or None, if ts_filename
+    is invalid or does not exist""""""
+    if not osp.isfile(ts_filename):
+        return None
+
+    ret = {}
+    f = open(ts_filename)
+    for l in f:
+        f_name, start, end = l.split()
+        ts = ret.get(f_name, [])
+        ts.append([float(start), float(end)])
+        ret[f_name] = ts
+    f.close()
+    return ret
+
+
+profiles = glob.glob(""mprofile_??????????????.dat"")
 profiles.sort()
 
 if len(sys.argv) == 1:
     filename = profiles[-1]
 else:
     filename = sys.argv[1]
-    if not os.path.exists(filename):
+    if not osp.exists(filename):
         try:
             n = int(filename)
         except ValueError:
             print(""Input file not found: "" + filename)
         filename = profiles[n]
 
-datetime = time.strptime(filename, ""mprofile_%Y%m%d%H%M%S.dat"")
+# Check for a timestamp file
+file_parts = osp.splitext(filename)
+ts_filename = file_parts[0] + ""_ts"" + file_parts[1]
+ts = read_timestamp_file(ts_filename)
+
 mdata = pl.loadtxt(filename)
+global_start = float(mdata[0, 1])
+
 mem = mdata[:, 0]
 max_mem = mem.max()
 max_mem_ind = mem.argmax()
 sampling_period = 0.5
 t = pl.r_[:len(mem)] * sampling_period
 
+all_colors=(""g"", ""b"", ""k"", ""r"")
+
 pl.figure()
 pl.plot(t, mem)
+
+bottom, top = pl.ylim()
+bottom += 0.001
+top -= 0.001
+
+# plot timestamps, if any
+if ts is not None:
+    func_num = 0
+    for f, exec_ts in ts.iteritems():
+        for execution in exec_ts:
+            pl.vlines([ts - global_start for ts in execution],
+                      bottom, top,
+                      colors=all_colors[func_num % len(all_colors)],
+                      label=f.split(""."")[-1])
+        func_num += 1
+    pl.legend()
+
 pl.hlines(max_mem,
           pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
           colors=""r"", linestyles=""--"")
-pl.vlines(t[max_mem_ind],
-          pl.ylim()[0] + 0.001, pl.ylim()[1] - 0.001,
+pl.vlines(t[max_mem_ind], bottom, top,
           colors=""r"", linestyles=""--"")
 pl.xlabel(""time [s]"")
 pl.ylabel(""memory used [Mb]"")
-pl.title(time.strftime(""%d / %m / %Y - start at %H:%M:%S"", datetime))
+title = time.strftime(""%d / %m / %Y - start at %H:%M:%S"", time.localtime(global_start)) \
+                          + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
+pl.title(title)
 pl.grid()
 pl.show()
 
"
mprofile,mprofile,0dcd9ef3e5f136d22d25ea3071ecfc60c63a8d3c,cac54d9bb95b051d5559456ca8aa5ab081f49387,"Timestamping is handled by mprofile and mplot

An --python option has been added to mprofile, just to add the proper
timestamping options to the run python program.
mplot now looks for a timestamp file, and plot the additional
information as vertical lines.","@@ -5,22 +5,46 @@ import os.path as osp
 import time
 import sys
 
-if len(sys.argv) < 2:
-    print(""""""Memory usage monitoring
-Usage: %s <command> <argument> ... <argument>
+from optparse import OptionParser
 
-Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
-<YYYYMMDDhhmmss> is the date-time of the program start) in the current
-directory. This file contains the process memory consumption, in Mb (one
-value per line). Memory is sampled twice each second.""""""
-          % osp.basename(sys.argv[0])
-          )
+parser = OptionParser(version=mp.__version__)
+parser.disable_interspersed_args()
+parser.add_option(""--python"", dest=""python"", default=False,
+                  action=""store_true"",
+                  help=""""""Activates extra features when the profiled executable is
+                  a Python program (currently: function timestamping.)"""""")
+
+(options, args) = parser.parse_args()
+if len(args) == 0:
+    print(""A program to run must be provided. Use -h for help"")
     sys.exit(1)
 
-outfilename = ""mprofile_%s.dat"" % time.strftime(""%Y%m%d%H%M%S"", time.localtime())
+## if len(sys.argv) < 2:
+##     print(""""""Memory usage monitoring
+## Usage: %s <command> <argument> ... <argument>
+
+## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
+## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
+## directory. This file contains the process memory consumption, in Mb (one
+## value per line). Memory is sampled twice each second.""""""
+##           % osp.basename(sys.argv[0])
+##           )
+##     sys.exit(1)
+
+suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
+mprofile_output = ""mprofile_%s.dat"" % suffix
+
+if options.python:
+    print(""running as a Python program..."")
+    timestamp_output = ""mprofile_%s_ts.dat"" % suffix
+    if not args[0].startswith(""python""):
+        args.insert(0, ""python"")
+    args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"", ""-o"", timestamp_output)
+    p = subprocess.Popen(args)
+else:
+    p = subprocess.Popen(args)
 
-p = subprocess.Popen(sys.argv[1:])
 mu = mp.memory_usage(proc=p, interval=0.5, timestamps=True)
-with open(outfilename, ""w"") as f:
+with open(mprofile_output, ""w"") as f:
     for m, t in mu:
         f.write(""{0:.6f} {1:.4f}"".format(m, t) + ""\n"")
"
test/test_loop_decorated.py,test/test_loop_decorated.py,0dcd9ef3e5f136d22d25ea3071ecfc60c63a8d3c,cac54d9bb95b051d5559456ca8aa5ab081f49387,"Timestamping is handled by mprofile and mplot

An --python option has been added to mprofile, just to add the proper
timestamping options to the run python program.
mplot now looks for a timestamp file, and plot the additional
information as vertical lines.","@@ -1,9 +1,12 @@
 # .. an example with a for loop ..
 
+import time
+
 @profile
 def test_1():
     a = [1] * (10 ** 6)
     b = [2] * (2 * 10 ** 7)
+    time.sleep(0.6)
     del b
 
     for i in range(2):
@@ -15,8 +18,10 @@ def test_1():
 @profile
 def test_2():
     a = {}
+    time.sleep(0.5)
     for i in range(10000):
-        a[i] =  i + 1
+        a[i] = i + 1
+    time.sleep(0.6)
     return
 
 if __name__ == '__main__':
"
,test/test_mprofile.py,0dcd9ef3e5f136d22d25ea3071ecfc60c63a8d3c,cac54d9bb95b051d5559456ca8aa5ab081f49387,"Timestamping is handled by mprofile and mplot

An --python option has been added to mprofile, just to add the proper
timestamping options to the run python program.
mplot now looks for a timestamp file, and plot the additional
information as vertical lines.","@@ -0,0 +1,23 @@
+""""""This script is intended as a test case for mprofile""""""
+
+import time
+
+@profile
+def test1():
+    a = [1] * 100000
+    time.sleep(1)
+    return a
+
+@profile
+def test2(l):
+    b = [2 * n for n in l]
+    time.sleep(1)
+    del b
+
+
+if __name__ == ""__main__"":
+    time.sleep(1)
+    l = test1()
+    test2(l)
+    time.sleep(1)
+
"
memory_profiler.py,memory_profiler.py,b639130fe911b046e5cffdb9f199e504a7982b79,0dcd9ef3e5f136d22d25ea3071ecfc60c63a8d3c,"Added a check in TimeStamper

TimeStamper now raises a clear exception when provided with something
that is not callable.","@@ -207,6 +207,9 @@ class TimeStamper:
         self.functions = {}
 
     def __call__(self, func):
+        if not hasattr(func, ""__call__""):
+            raise ValueError(""Value must be callable"")
+
         self.add_function(func)
         f = self.wrap_function(func)
         f.__module__ = func.__module__
"
mplot,mplot,7293915b784caf1b06758166fa6b336de5a92948,b639130fe911b046e5cffdb9f199e504a7982b79,"Added explanatory messages to mplot.

Improvement of error handling in mplot: a clear message is printed
whether pylab is not found or no input file are automatically detected.","@@ -1,7 +1,12 @@
 #! /usr/bin/env python
-import pylab as pl
-import math
 import sys
+
+try:
+    import pylab as pl
+except ImportError:
+    print(""matplotlib is needed for plotting."")
+    sys.exit(1)
+import math
 import glob
 import time
 import os
@@ -29,6 +34,10 @@ profiles = glob.glob(""mprofile_??????????????.dat"")
 profiles.sort()
 
 if len(sys.argv) == 1:
+    if len(profiles) == 0:
+        print(""""""No input file found. This program looks for mprofile_*.dat files,
+generated by the mprofile command."""""")
+        sys.exit(-1)
     filename = profiles[-1]
 else:
     filename = sys.argv[1]
"
mplot,mplot,e12bc556ed278ab2610e358061963af99e9abc48,7293915b784caf1b06758166fa6b336de5a92948,"Changed the display of timestamps

Execution times are now shown on the memory graph using a kind of
brackets instead of just vertical lines. This makes reading the graph
easier.

Graphing is now correct for any sampling frequency.","@@ -13,6 +13,42 @@ import os
 import os.path as osp
 
 
+def add_bracket(xloc, t, mem, color=""r"", label=None):
+    """"""Add two brackets on the memory line plot.
+
+    This function uses the current figure.
+
+    Parameters
+    ==========
+    xloc: {tuple with 2 values}
+        bracket location (on horizontal axis).
+    t, mem:
+        memory usage curve. Used to place bracket at the correct location.
+    """"""
+
+    height_ratio = 20.
+    yloc = pl.interp(xloc, t, mem)
+    vsize = (pl.ylim()[1] - pl.ylim()[0]) / height_ratio
+    hsize = (pl.xlim()[1] - pl.xlim()[0]) / (3.*height_ratio)
+
+    bracket_x = pl.asarray([hsize, 0, 0, hsize])
+    bracket_y = pl.asarray([vsize, vsize, -vsize, -vsize])
+
+    pl.plot(bracket_x + xloc[0], bracket_y + yloc[0],
+            ""-"" + color, linewidth=2, label=label)
+    pl.plot(-bracket_x + xloc[1], bracket_y + yloc[1],
+            ""-"" + color, linewidth=2 )
+
+    # TODO: use matplotlib.patches.Polygon to draw a colored background for
+    # each function.
+
+    # with maplotlib 1.2, use matplotlib.path.Path to create proper markers
+    # see http://matplotlib.org/examples/pylab_examples/marker_path.html
+    # This works with matplotlib 0.99.1
+    ## pl.plot(xloc[0], yloc[0], ""<""+color, markersize=7, label=label)
+    ## pl.plot(xloc[1], yloc[1], "">""+color, markersize=7)
+
+
 def read_timestamp_file(ts_filename):
     """"""Return content of ts_filename or None, if ts_filename
     is invalid or does not exist""""""
@@ -59,13 +95,13 @@ global_start = float(mdata[0, 1])
 mem = mdata[:, 0]
 max_mem = mem.max()
 max_mem_ind = mem.argmax()
-sampling_period = 0.5
-t = pl.r_[:len(mem)] * sampling_period
 
-all_colors=(""g"", ""b"", ""k"", ""r"")
+t = mdata[:, 1] - global_start
+
+all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
 
 pl.figure()
-pl.plot(t, mem)
+pl.plot(t, mem, ""b+-"")
 
 bottom, top = pl.ylim()
 bottom += 0.001
@@ -76,12 +112,16 @@ if ts is not None:
     func_num = 0
     for f, exec_ts in ts.iteritems():
         for execution in exec_ts:
-            pl.vlines([ts - global_start for ts in execution],
-                      bottom, top,
-                      colors=all_colors[func_num % len(all_colors)],
-                      label=f.split(""."")[-1])
+            add_bracket([ts - global_start for ts in execution], t, mem,
+                        color= all_colors[func_num % len(all_colors)],
+                        label=f.split(""."")[-1] + "" %.3fs"" % (execution[1] - execution[0]))
+            ## pl.vlines([ts - global_start for ts in execution],
+            ##           bottom, top,
+            ##           colors=all_colors[func_num % len(all_colors)],
+            ##           linestyles=""dashdot"",
+            ##           label=f.split(""."")[-1] + "" %.3fs"" % (execution[1] - execution[0]))
         func_num += 1
-    pl.legend()
+    pl.legend(loc=0)
 
 pl.hlines(max_mem,
           pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
@@ -89,7 +129,7 @@ pl.hlines(max_mem,
 pl.vlines(t[max_mem_ind], bottom, top,
           colors=""r"", linestyles=""--"")
 pl.xlabel(""time [s]"")
-pl.ylabel(""memory used [Mb]"")
+pl.ylabel(""memory used [MB]"")
 title = time.strftime(""%d / %m / %Y - start at %H:%M:%S"", time.localtime(global_start)) \
                           + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
 pl.title(title)
"
mplot,mplot,27e8a21bcb20d07cdbacc58144909b2b7a068a89,e12bc556ed278ab2610e358061963af99e9abc48,"Added --interval option to mprofile

This options is used to change the sampling period. Example:
mprofile -T 0.2 <program>

Will execute <program> and record its memory usage every .2s.","@@ -89,13 +89,15 @@ file_parts = osp.splitext(filename)
 ts_filename = file_parts[0] + ""_ts"" + file_parts[1]
 ts = read_timestamp_file(ts_filename)
 
-mdata = pl.loadtxt(filename)
+mdata = pl.atleast_2d(pl.loadtxt(filename))
+
 global_start = float(mdata[0, 1])
 
 mem = mdata[:, 0]
 max_mem = mem.max()
 max_mem_ind = mem.argmax()
 
+
 t = mdata[:, 1] - global_start
 
 all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
"
mprofile,mprofile,27e8a21bcb20d07cdbacc58144909b2b7a068a89,e12bc556ed278ab2610e358061963af99e9abc48,"Added --interval option to mprofile

This options is used to change the sampling period. Example:
mprofile -T 0.2 <program>

Will execute <program> and record its memory usage every .2s.","@@ -13,8 +13,13 @@ parser.add_option(""--python"", dest=""python"", default=False,
                   action=""store_true"",
                   help=""""""Activates extra features when the profiled executable is
                   a Python program (currently: function timestamping.)"""""")
+parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.5"",
+                  type=""float"", action=""store"",
+                  help=""Sampling period (in seconds)"")
 
 (options, args) = parser.parse_args()
+print(""{1}: Sampling memory every {0.interval}s"".format(options, osp.basename(sys.argv[0])))
+
 if len(args) == 0:
     print(""A program to run must be provided. Use -h for help"")
     sys.exit(1)
@@ -39,12 +44,13 @@ if options.python:
     timestamp_output = ""mprofile_%s_ts.dat"" % suffix
     if not args[0].startswith(""python""):
         args.insert(0, ""python"")
-    args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"", ""-o"", timestamp_output)
+    args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
+                 ""-o"", timestamp_output)
     p = subprocess.Popen(args)
 else:
     p = subprocess.Popen(args)
 
-mu = mp.memory_usage(proc=p, interval=0.5, timestamps=True)
+mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True)
 with open(mprofile_output, ""w"") as f:
     for m, t in mu:
         f.write(""{0:.6f} {1:.4f}"".format(m, t) + ""\n"")
"
memory_profiler.py,memory_profiler.py,cce3c576426cd0fb2fa1620c16bda92cce555bb0,fb1e743640ff0d0ce5cb54da339345dec693eb1a,Allow memory_profiler to take a function for convenience,"@@ -110,8 +110,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
         # for a Python function wait until it finishes
         max_iter = float('inf')
 
+    if hasattr(proc, '__call__'):
+        proc = (proc, (), {})
     if isinstance(proc, (list, tuple)):
-
         if len(proc) == 1:
             f, args, kw = (proc[0], (), {})
         elif len(proc) == 2:
"
memory_profiler.py,memory_profiler.py,38bbd30895d1633a57d06afba8f18f2dfb436824,cce3c576426cd0fb2fa1620c16bda92cce555bb0,"Fix docstring of memit and repeat function calling

Thanks Mikhail Korobov for submitting the report.","@@ -517,7 +517,7 @@ def magic_memit(self, line=''):
     """"""Measure memory usage of a Python statement
 
     Usage, in line mode:
-      %memit [-ir<R>t<T>] statement
+      %memit [-r<R>t<T>] statement
 
     Options:
     -r<R>: repeat the loop iteration <R> times and take the best result.
@@ -557,7 +557,10 @@ def magic_memit(self, line=''):
     if timeout <= 0:
         timeout = None
 
-    mem_usage = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout)
+    mem_usage = []
+    for _ in range(repeat):
+        tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout)
+        mem_usage.extend(tmp)
 
     if mem_usage:
         print('maximum of %d: %f MB per loop' % (repeat, max(mem_usage)))
"
memory_profiler.py,memory_profiler.py,c0c38f2adfe2873218b7d11987eb3d12a75bc970,38bbd30895d1633a57d06afba8f18f2dfb436824,0.25 release,"@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.24'
+__version__ = '0.25'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
memory_profiler.py,memory_profiler.py,c868ce4045ac6fdc2cb6e23a6be0dc2873a2eae1,27e8a21bcb20d07cdbacc58144909b2b7a068a89,"Added option to monitor children processes

To get the memory usage of the main process and its children processes,
use the --include-children of mprofile. Only the sum of all memory usage
is recorded, no per-process details are available.","@@ -20,10 +20,14 @@ except ImportError:
 try:
     import psutil
 
-    def _get_memory(pid, timestamps=False):
+    def _get_memory(pid, timestamps=False, include_children=False):
         process = psutil.Process(pid)
         try:
-            mem = float(process.get_memory_info()[0]) / (1024 ** 2)
+            mem = float(process.get_memory_info()[0]) / 1048576.
+            if include_children:
+                for p in process.get_children(recursive=True):
+                    mem += p.get_memory_info()[0] / 1048576.
+
         except psutil.AccessDenied:
             mem = -1
         if timestamps:
@@ -31,9 +35,7 @@ try:
         else:
             return mem
 
-
 except ImportError:
-
     warnings.warn(""psutil module not found. memory_profiler will be slow"")
 
     if os.name == 'posix':
@@ -77,19 +79,28 @@ class Timer(Process):
             del kw[""timestamps""]
         else:
             self.timestamps = False
+        if ""include_children"" in kw:
+            self.include_children = kw[""include_children""]
+            del kw[""include_children""]
+        else:
+            self.include_children = False
+
         super(Timer, self).__init__(*args, **kw)
 
     def run(self):
-        m = _get_memory(self.monitor_pid, timestamps=self.timestamps)
+        m = _get_memory(self.monitor_pid, timestamps=self.timestamps,
+                        include_children=self.include_children)
         timings = [m]
         self.pipe.send(0)  # we're ready
         while not self.pipe.poll(self.interval):
-            m = _get_memory(self.monitor_pid, timestamps=self.timestamps)
+            m = _get_memory(self.monitor_pid, timestamps=self.timestamps,
+                            include_children=self.include_children)
             timings.append(m)
         self.pipe.send(timings)
 
 
-def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False):
+def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
+                 include_children=False):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -156,7 +167,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False):
     elif isinstance(proc, subprocess.Popen):
         # external process, launched from Python
         while True:
-            ret.append(_get_memory(proc.pid, timestamps=timestamps))
+            ret.append(_get_memory(proc.pid, timestamps=timestamps,
+                                   include_children=include_children))
             time.sleep(interval)
             if timeout is not None:
                 max_iter -= 1
@@ -173,7 +185,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False):
         counter = 0
         while counter < max_iter:
             counter += 1
-            ret.append(_get_memory(proc, timestamps=timestamps))
+            ret.append(_get_memory(proc, timestamps=timestamps,
+                                   include_children=include_children))
             time.sleep(interval)
     return ret
 
"
mprofile,mprofile,c868ce4045ac6fdc2cb6e23a6be0dc2873a2eae1,27e8a21bcb20d07cdbacc58144909b2b7a068a89,"Added option to monitor children processes

To get the memory usage of the main process and its children processes,
use the --include-children of mprofile. Only the sum of all memory usage
is recorded, no per-process details are available.","@@ -16,6 +16,9 @@ parser.add_option(""--python"", dest=""python"", default=False,
 parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.5"",
                   type=""float"", action=""store"",
                   help=""Sampling period (in seconds)"")
+parser.add_option(""--include-children"", ""-C"", dest=""include_children"", default=False,
+                  action=""store_true"",
+                  help=""""""Monitors forked processes as well (sum up all process memory)"""""")
 
 (options, args) = parser.parse_args()
 print(""{1}: Sampling memory every {0.interval}s"".format(options, osp.basename(sys.argv[0])))
@@ -50,7 +53,8 @@ if options.python:
 else:
     p = subprocess.Popen(args)
 
-mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True)
+mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
+                     include_children=options.include_children)
 with open(mprofile_output, ""w"") as f:
     for m, t in mu:
         f.write(""{0:.6f} {1:.4f}"".format(m, t) + ""\n"")
"
memory_profiler.py,memory_profiler.py,278ae40c8a3beab0e92512bfdb07311033978f68,c0c38f2adfe2873218b7d11987eb3d12a75bc970,Remove remaining references to -i in memit,"@@ -523,7 +523,7 @@ def magic_memit(self, line=''):
     -r<R>: repeat the loop iteration <R> times and take the best result.
     Default: 1
 
-    -t<T>: timeout after <T> seconds. Unused if `-i` is active. Default: None
+    -t<T>: timeout after <T> seconds. Default: None
 
     Examples
     --------
@@ -540,16 +540,8 @@ def magic_memit(self, line=''):
       In [4]: %memit -r 10 np.empty(1e8)
       maximum of 10: 0.101562 MB per loop
 
-      In [5]: memit -t 3 while True: pass;
-      Subprocess timed out.
-      Subprocess timed out.
-      Subprocess timed out.
-      ERROR: all subprocesses exited unsuccessfully. Try again with the `-i`
-      option.
-      maximum of 1: -inf MB per loop
-
     """"""
-    opts, stmt = self.parse_options(line, 'r:t:i', posix=False, strict=False)
+    opts, stmt = self.parse_options(line, 'r:t', posix=False, strict=False)
     repeat = int(getattr(opts, 'r', 1))
     if repeat < 1:
         repeat == 1
"
memory_profiler.py,memory_profiler.py,dc0c8aa60b5960d240b0dcea270efa1e5a314a2c,278ae40c8a3beab0e92512bfdb07311033978f68,"FIX: if the called script creates a global 'options'

Patch by mennucc1@debian.org","@@ -9,6 +9,7 @@ import warnings
 import linecache
 import inspect
 import subprocess
+from copy import copy
 
 # TODO: provide alternative when multprocessing is not available
 try:
@@ -601,15 +602,15 @@ if __name__ == '__main__':
         if sys.version_info[0] < 3:
             import __builtin__
             __builtin__.__dict__['profile'] = prof
-            ns = locals()
+            ns = copy(locals())
             ns['profile'] = prof # shadow the profile decorator defined above
             execfile(__file__, ns, ns)
         else:
             import builtins
             builtins.__dict__['profile'] = prof
-            ns = locals()
+            ns = copy(locals())
             ns['profile'] = prof # shadow the profile decorator defined above
-            exec(compile(open(__file__).read(), __file__, 'exec'), ns,
-                                                                   globals())
+            exec(compile(open(__file__).read(), __file__, 'exec'),
+                 ns, copy(globals()))
     finally:
         show_results(prof, precision=options.precision)
"
mplot,mplot,5c3934209df4848fbefd2fbace8eada7719a08cb,c868ce4045ac6fdc2cb6e23a6be0dc2873a2eae1,"mplot can superimpose curves

mplot now read every argument on its command-line, and plot every
graph on the same plot.

Graph layout has been clarified: legend is now outside the axis.","@@ -66,75 +66,93 @@ def read_timestamp_file(ts_filename):
     return ret
 
 
-profiles = glob.glob(""mprofile_??????????????.dat"")
-profiles.sort()
+def plot_file(filename, index=0, timestamps=True):
+    # Check for a timestamp file
+    file_parts = osp.splitext(filename)
+    ts_filename = file_parts[0] + ""_ts"" + file_parts[1]
+    ts = read_timestamp_file(ts_filename)
 
-if len(sys.argv) == 1:
-    if len(profiles) == 0:
-        print(""""""No input file found. This program looks for mprofile_*.dat files,
-generated by the mprofile command."""""")
-        sys.exit(-1)
-    filename = profiles[-1]
-else:
-    filename = sys.argv[1]
-    if not osp.exists(filename):
-        try:
-            n = int(filename)
-        except ValueError:
-            print(""Input file not found: "" + filename)
-        filename = profiles[n]
+    mdata = pl.atleast_2d(pl.loadtxt(filename))
 
-# Check for a timestamp file
-file_parts = osp.splitext(filename)
-ts_filename = file_parts[0] + ""_ts"" + file_parts[1]
-ts = read_timestamp_file(ts_filename)
+    global_start = float(mdata[0, 1])
 
-mdata = pl.atleast_2d(pl.loadtxt(filename))
+    mem = mdata[:, 0]
+    max_mem = mem.max()
+    max_mem_ind = mem.argmax()
 
-global_start = float(mdata[0, 1])
+    t = mdata[:, 1] - global_start
 
-mem = mdata[:, 0]
-max_mem = mem.max()
-max_mem_ind = mem.argmax()
+    all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
+    mem_line_colors=('k', ""b"", ""r"")
+    mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
+                                   time.localtime(global_start)) \
+                                   + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
+
+    pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
+            label=mem_line_label)
+
+    bottom, top = pl.ylim()
+    bottom += 0.001
+    top -= 0.001
+
+    # plot timestamps, if any
+    if ts is not None and timestamps:
+        func_num = 0
+        for f, exec_ts in ts.iteritems():
+            for execution in exec_ts:
+                add_bracket([ts - global_start for ts in execution], t, mem,
+                            color= all_colors[func_num % len(all_colors)],
+                            label=f.split(""."")[-1] + "" %.3fs"" % (execution[1] - execution[0]))
+            func_num += 1
+
+    if timestamps:
+        pl.hlines(max_mem,
+                  pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
+                  colors=""r"", linestyles=""--"")
+        pl.vlines(t[max_mem_ind], bottom, top,
+                  colors=""r"", linestyles=""--"")
 
 
-t = mdata[:, 1] - global_start
+if __name__ == ""__main__"":
+    profiles = glob.glob(""mprofile_??????????????.dat"")
+    profiles.sort()
 
-all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
+    print (sys.argv)
+    if len(sys.argv) == 1:
+        if len(profiles) == 0:
+            print(""""""No input file found. This program looks for mprofile_*.dat files,
+    generated by the mprofile command."""""")
+            sys.exit(-1)
+        filenames = [profiles[-1]]
+    else:
+        filenames = []
+        for arg in sys.argv[1:]:
+            if osp.exists(arg):
+                if not arg in filenames:
+                    filenames.append(arg)
+            else:
+                try:
+                    n = int(arg)
+                except ValueError:
+                    print(""Input file not found: "" + arg)
+                if not profiles[n] in filenames:
+                    filenames.append(profiles[n])
 
-pl.figure()
-pl.plot(t, mem, ""b+-"")
+    pl.figure(figsize=(14,6), dpi=90)
+    if len(filenames) > 1:
+        timestamps = False
+    else:
+        timestamps = True
+    for n, filename in enumerate(filenames):
+        plot_file(filename, index=n, timestamps=timestamps)
+    pl.xlabel(""time [s]"")
+    pl.ylabel(""memory used [MB]"")
 
-bottom, top = pl.ylim()
-bottom += 0.001
-top -= 0.001
-
-# plot timestamps, if any
-if ts is not None:
-    func_num = 0
-    for f, exec_ts in ts.iteritems():
-        for execution in exec_ts:
-            add_bracket([ts - global_start for ts in execution], t, mem,
-                        color= all_colors[func_num % len(all_colors)],
-                        label=f.split(""."")[-1] + "" %.3fs"" % (execution[1] - execution[0]))
-            ## pl.vlines([ts - global_start for ts in execution],
-            ##           bottom, top,
-            ##           colors=all_colors[func_num % len(all_colors)],
-            ##           linestyles=""dashdot"",
-            ##           label=f.split(""."")[-1] + "" %.3fs"" % (execution[1] - execution[0]))
-        func_num += 1
-    pl.legend(loc=0)
-
-pl.hlines(max_mem,
-          pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
-          colors=""r"", linestyles=""--"")
-pl.vlines(t[max_mem_ind], bottom, top,
-          colors=""r"", linestyles=""--"")
-pl.xlabel(""time [s]"")
-pl.ylabel(""memory used [MB]"")
-title = time.strftime(""%d / %m / %Y - start at %H:%M:%S"", time.localtime(global_start)) \
-                          + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
-pl.title(title)
-pl.grid()
-pl.show()
+    ax = pl.gca()
+    box = ax.get_position()
+    ax.set_position([0.07, 0.1,
+                     0.55, 0.8])
+    ax.legend(loc=""upper left"", bbox_to_anchor=(1.05, 1.))
+    pl.grid()
+    pl.show()
 
"
README.rst,README.rst,a5e3231e46024d7a5cb33374d098593220b3a6e3,dc0c8aa60b5960d240b0dcea270efa1e5a314a2c,cosmetic,"@@ -1,11 +1,10 @@
 =================
  Memory Profiler
 =================
+
 This is a python module for monitoring memory consumption of a process
 as well as line-by-line analysis of memory consumption for python
-programs.
-
-It's a pure python module and has the `psutil
+programs. It is a pure python module and has the `psutil
 <http://pypi.python.org/pypi/psutil>`_ module as optional (but highly
 recommended) dependencies.
 
@@ -25,10 +24,15 @@ To install from source, download the package, extract and type::
 =======
  Usage
 =======
+
 The line-by-line profiler is used much in the same way of the
-line_profiler: you must first decorate the function you would like to
-profile with ``@profile``. In this example, we create a simple function
-``my_func`` that allocates lists ``a``, ``b`` and then deletes ``b``::
+`line_profiler <https://pypi.python.org/pypi/line_profiler/>`_: first
+decorate the function you would like to profile with ``@profile`` and
+then run the script with a special script (in this case with specific
+arguments to the Python interpreter). 
+
+In the following example, we create a simple function ``my_func`` that
+allocates lists ``a``, ``b`` and then deletes ``b``::
 
 
     @profile
"
,maction,3319aee087f4f397c16de38dd036788dd9be8ccb,5c3934209df4848fbefd2fbace8eada7719a08cb,"Added maction

This script is intended for various actions of profile files.
Only removal is implemented in this commit.

maction rm -1   # deletes most recent profile from current dir.","@@ -0,0 +1,120 @@
+#! /usr/bin/env python
+
+import glob
+import os
+import os.path as osp
+import sys
+import re
+
+from optparse import OptionParser
+
+import memory_profiler as mp
+
+
+def print_usage():
+    print(""Usage: %s <command> <options> <arguments>""
+          % osp.basename(sys.argv[0]))
+
+def get_action():
+    """"""Pop first argument, check it is a valid action.""""""
+    all_actions = (""rm"",)
+    if len(sys.argv) <= 1:
+        print_usage()
+        sys.exit(1)
+    if not sys.argv[1] in all_actions:
+        print(""Valid actions are: "" + "" "".join(all_actions))
+        sys.exit(1)
+
+    return sys.argv.pop(1)
+
+
+def get_profile_filenames(args):
+    """"""Return list of profile filenames.
+
+    Parameters
+    ==========
+    args (list)
+        list of filename or integer. An integer is the index of the
+        profile in the list of existing profiles. 0 is the oldest,
+        -1 in the more recent.
+        Non-existing files cause a ValueError exception to be thrown.
+
+    Returns
+    =======
+    filenames (list)
+        list of existing memory profile filenames. It is guaranteed
+        that an given file name will not appear twice in this list.
+    """"""
+    profiles = glob.glob(""mprofile_??????????????.dat"")
+    profiles.sort()
+
+    filenames = []
+
+    for arg in args:
+        if arg == ""--"":  # workaround
+            continue
+        try:
+            index = int(arg)
+        except ValueError:
+            index = None
+        if index is not None:
+            try:
+                filename = profiles[index]
+            except IndexError:
+                raise ValueError(""Invalid index (non-existing file): %s"" % arg)
+
+            if filename not in filenames:
+                filenames.append(filename)
+        else:
+            if osp.isfile(arg):
+                if arg not in filenames:
+                    filenames.append(arg)
+            elif osp.isdir(arg):
+                raise ValueError(""Path %s is a directory"" % arg)
+            else:
+                raise ValueError(""File %s not found"" % arg)
+
+    # Add timestamp files, if any
+    for filename in reversed(filenames):
+        parts = osp.splitext(filename)
+        timestamp_file = parts[0] + ""_ts"" + parts[1]
+        if osp.isfile(timestamp_file) and timestamp_file not in filenames:
+            filenames.append(timestamp_file)
+
+    return filenames
+
+
+def rm_action():
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
+                      action=""store_true"",
+                      help=""""""Show what will be done, without actually doing it."""""")
+
+    (options, args) = parser.parse_args()
+
+    if len(args) == 0:
+        print(""A profile to remove must be provided (number or filename)"")
+        sys.exit(1)
+
+    filenames = get_profile_filenames(args)
+    if options.dry_run:
+        print(""Files to be removed: "")
+        for filename in filenames:
+            print(filename)
+    else:
+        for filename in filenames:
+            os.remove(filename)
+
+
+if __name__ == ""__main__"":
+    # Workaround for optparse limitation: insert -- before first negative number found.
+    negint = re.compile(""-[0-9]+"")
+    for n, arg in enumerate(sys.argv):
+        if negint.match(arg):
+            sys.argv.insert(n, ""--"")
+            break
+    actions = {""rm"": rm_action}
+    actions[get_action()]()
+
+
"
mplot,mplot,3319aee087f4f397c16de38dd036788dd9be8ccb,5c3934209df4848fbefd2fbace8eada7719a08cb,"Added maction

This script is intended for various actions of profile files.
Only removal is implemented in this commit.

maction rm -1   # deletes most recent profile from current dir.","@@ -117,7 +117,6 @@ if __name__ == ""__main__"":
     profiles = glob.glob(""mprofile_??????????????.dat"")
     profiles.sort()
 
-    print (sys.argv)
     if len(sys.argv) == 1:
         if len(profiles) == 0:
             print(""""""No input file found. This program looks for mprofile_*.dat files,
"
memory_profiler.py,memory_profiler.py,f345720bdd26ec24491f416fac5e7aa0acace2e2,a5e3231e46024d7a5cb33374d098593220b3a6e3,Hide memory_profiler.py from argument list,"@@ -595,6 +595,7 @@ if __name__ == '__main__':
         sys.exit(2)
 
     (options, args) = parser.parse_args()
+    del sys.argv[0]         # Hide ""memory_profiler.py"" from argument list
 
     prof = LineProfiler(max_mem=options.max_mem)
     __file__ = _find_script(args[0])
"
memory_profiler.py,memory_profiler.py,3cab3b93938c3d5035996ed3dc86642a4e9ccf6e,f345720bdd26ec24491f416fac5e7aa0acace2e2,version 0.26,"@@ -1,6 +1,6 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.25'
+__version__ = '0.26'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
memory_profiler.py,memory_profiler.py,dd421c6b1d2ea46e51ea066feb588ac6ecc0b7ea,4936183842b11ff08a640da775b8807c513b1314,"profile.timestamp is a context manager

Timestamp block of codes is now possible thanks to the
profile.timestamp() function that returns a context manager.

Example:
with profile.timestamp(""block1""):
    f()

""block1"" is the label that will be used for the plotting.","@@ -214,6 +214,19 @@ def _find_script(script_name):
     raise SystemExit(1)
 
 
+class _TimeStamperCM(object):
+    """"""Time-stamping context manager.""""""
+
+    def __init__(self, timestamps):
+        self._timestamps = timestamps
+
+    def __enter__(self):
+        self._timestamps.append(time.time())
+
+    def __exit__(self, *args):
+        self._timestamps.append(time.time())
+
+
 class TimeStamper:
     """""" A profiler that just records start and end execution times for
     any decorated function.
@@ -233,6 +246,19 @@ class TimeStamper:
         f.__dict__.update(getattr(func, '__dict__', {}))
         return f
 
+    def timestamp(self, name=""<block>""):
+        """"""Returns a context manager for timestamping a block of code.""""""
+        # Make a fake function
+        func = lambda x: x
+        func.__module__ = """"
+        func.__name__ = name
+        self.add_function(func)
+        timestamps = []
+        self.functions[func].append(timestamps)
+        # A new object is required each time, since there can be several
+        # nested context managers.
+        return _TimeStamperCM(timestamps)
+
     def add_function(self, func):
         if not func in self.functions:
             self.functions[func] = []
@@ -309,7 +335,7 @@ class LineProfiler:
         return f
 
     def run(self, cmd):
-        """""" Profile a single executable statment in the main namespace.
+        """""" Profile a single executable statement in the main namespace.
         """"""
         import __main__
         main_dict = __main__.__dict__
"
,examples/numpy_example.py,bd5e9007c69d59fbadc7cb858ac56c96019746c5,dd421c6b1d2ea46e51ea066feb588ac6ecc0b7ea,"Added numpy_example.py

This script is intended to show differences between numbers output by
'python -m memory_profiler' and 'mprofile --python'","@@ -0,0 +1,23 @@
+import numpy as np
+import scipy.signal
+
+
+#@profile
+def create_data():
+    ret = []
+    for n in xrange(70):
+        ret.append(np.random.randn(1, 70, 71, 72))
+    return ret
+
+
+#@profile
+def process_data(data):
+    data = np.concatenate(data)
+    detrended = scipy.signal.detrend(data, axis=0)
+    return detrended
+
+
+if __name__ == ""__main__"":
+    data1 = create_data()
+    data2 = process_data(data1)
+    print (data2.shape)
"
,Makefile,a8c848f748d73c1c67e8cd050b3ace0fe6687fd3,3cab3b93938c3d5035996ed3dc86642a4e9ccf6e,_get_memory() uses the resource module from std lib.,"@@ -0,0 +1,7 @@
+
+.PHONY: test
+
+test:
+	python -m memory_profiler test/test_func.py
+	python -m memory_profiler test/test_loop.py
+	python -m memory_profiler test/test_with.py
\ No newline at end of file
"
memory_profiler.py,memory_profiler.py,a8c848f748d73c1c67e8cd050b3ace0fe6687fd3,3cab3b93938c3d5035996ed3dc86642a4e9ccf6e,_get_memory() uses the resource module from std lib.,"@@ -17,25 +17,45 @@ try:
 except ImportError:
     from multiprocessing.dummy import Process, Pipe
 
+_TWO_20 = float(2 ** 20)
 
+has_psutil = False
+has_resource = False
+
+# .. get available packages ..
 try:
     import psutil
+    has_psutil = True
+except ImportError:
+    pass
 
-    def _get_memory(pid):
+try:
+    import resource
+    has_resource = True
+except ImportError:
+    pass
+
+
+def _get_memory(pid):
+
+    # .. fastests but just works for current process ..
+    # .. and only available on unix ..
+    if pid == -1 and has_resource:
+        mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / (_TWO_20)
+        return mem
+
+    # .. good compromise but requires psutil ..
+    if has_psutil:
         process = psutil.Process(pid)
         try:
-            mem = float(process.get_memory_info()[0]) / (1024 ** 2)
+            mem = process.get_memory_info()[0] / (_TWO_20)
         except psutil.AccessDenied:
             mem = -1
         return mem
 
-
-except ImportError:
-
-    warnings.warn(""psutil module not found. memory_profiler will be slow"")
-
+    # .. scary stuff ..
     if os.name == 'posix':
-        def _get_memory(pid):
+            warnings.warn(""psutil module not found. memory_profiler will be slow"")
             # ..
             # .. memory usage in MB ..
             # .. this should work on both Mac and Linux ..
@@ -133,7 +153,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
             % (n_args, len(args)))
 
         child_conn, parent_conn = Pipe()  # this will store Timer's results
-        p = Timer(os.getpid(), interval, child_conn)
+        p = Timer(-1, interval, child_conn)
         p.start()
         parent_conn.recv()  # wait until we start getting memory
         f(*args, **kw)
@@ -153,8 +173,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
                 break
     else:
         # external process
-        if proc == -1:
-            proc = os.getpid()
         if max_iter == -1:
             max_iter = 1
         counter = 0
@@ -282,14 +300,14 @@ class LineProfiler:
             if event == 'return':
                 lineno += 1
             entry = self.code_map[frame.f_code].setdefault(lineno, [])
-            entry.append(_get_memory(os.getpid()))
+            entry.append(_get_memory(-1))
 
         return self.trace_memory_usage
 
     def trace_max_mem(self, frame, event, arg):
         # run into PDB as soon as memory is higher than MAX_MEM
         if event in ('line', 'return') and frame.f_code in self.code_map:
-            c = _get_memory(os.getpid())
+            c = _get_memory(-1)
             if c >= self.max_mem:
                 t = 'Current memory {0:.2f} MB exceeded the maximum '.format(c) + \
                     'of {0:.2f} MB\n'.format(self.max_mem)
"
test/test_with.py,,a8c848f748d73c1c67e8cd050b3ace0fe6687fd3,3cab3b93938c3d5035996ed3dc86642a4e9ccf6e,_get_memory() uses the resource module from std lib.,"@@ -1 +0,0 @@
-__author__ = 'fabian'
"
Makefile,Makefile,f75f2839e8dcc6652ed37d20999b229e24c170cf,a8c848f748d73c1c67e8cd050b3ace0fe6687fd3,Clean management of global variables. Added a bunch of tests,"@@ -4,4 +4,6 @@
 test:
 	python -m memory_profiler test/test_func.py
 	python -m memory_profiler test/test_loop.py
-	python -m memory_profiler test/test_with.py
\ No newline at end of file
+	python -m memory_profiler test/test_as.py
+	python -m memory_profiler test/test_global.py
+	python test/test_import.py
\ No newline at end of file
"
memory_profiler.py,memory_profiler.py,f75f2839e8dcc6652ed37d20999b229e24c170cf,a8c848f748d73c1c67e8cd050b3ace0fe6687fd3,Clean management of global variables. Added a bunch of tests,"@@ -2,6 +2,8 @@
 
 __version__ = '0.26'
 
+_clean_globals = globals()
+
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
 import time, sys, os, pdb
@@ -619,17 +621,12 @@ if __name__ == '__main__':
     __file__ = _find_script(args[0])
     try:
         if sys.version_info[0] < 3:
-            import __builtin__
-            __builtin__.__dict__['profile'] = prof
-            ns = copy(locals())
+            ns = copy(_clean_globals)
             ns['profile'] = prof # shadow the profile decorator defined above
             execfile(__file__, ns, ns)
         else:
-            import builtins
-            builtins.__dict__['profile'] = prof
-            ns = copy(locals())
+            ns = copy(_clean_globals)
             ns['profile'] = prof # shadow the profile decorator defined above
-            exec(compile(open(__file__).read(), __file__, 'exec'),
-                 ns, copy(globals()))
+            exec(compile(open(__file__).read(), __file__, 'exec'), ns, ns)
     finally:
         show_results(prof, precision=options.precision)
"
,test/test_as.py,f75f2839e8dcc6652ed37d20999b229e24c170cf,a8c848f748d73c1c67e8cd050b3ace0fe6687fd3,Clean management of global variables. Added a bunch of tests,"@@ -0,0 +1,9 @@
+import math
+
+@profile
+def f():
+    o = math.sqrt(2013)
+    return o
+
+if __name__ == '__main__':
+	f()
\ No newline at end of file
"
,test/test_global.py,f75f2839e8dcc6652ed37d20999b229e24c170cf,a8c848f748d73c1c67e8cd050b3ace0fe6687fd3,Clean management of global variables. Added a bunch of tests,"@@ -0,0 +1,4 @@
+options = None
+
+
+# test for dc0c8aa60b5960d240b0dcea270efa1e5a314a2c
"
,test/test_import.py,f75f2839e8dcc6652ed37d20999b229e24c170cf,a8c848f748d73c1c67e8cd050b3ace0fe6687fd3,Clean management of global variables. Added a bunch of tests,"@@ -0,0 +1,11 @@
+from memory_profiler import profile
+
+@profile
+def my_func():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    del b
+    return a
+
+if __name__ == '__main__':
+	my_func()
\ No newline at end of file
"
memory_profiler.py,memory_profiler.py,5dcc68b547ee49fcc306df6c8615791dd1b293d1,f75f2839e8dcc6652ed37d20999b229e24c170cf,cosmetic.,"@@ -2,7 +2,8 @@
 
 __version__ = '0.26'
 
-_clean_globals = globals()
+# .. we'll use this to pass it to the child script ..
+_clean_globals = globals().copy()
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
memory_profiler.py,memory_profiler.py,18b5afb651e026de7e0754c931800391dc72c193,5dcc68b547ee49fcc306df6c8615791dd1b293d1,cosmetic.,"@@ -1,10 +1,10 @@
 """"""Profile the memory usage of a Python program""""""
 
-__version__ = '0.26'
-
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
+__version__ = '0.26'
+
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
 import time, sys, os, pdb
"
memory_profiler.py,memory_profiler.py,07c7c988958428e4f2d3640d10f681dae880f5ed,18b5afb651e026de7e0754c931800391dc72c193,FIX: PID for ps,"@@ -43,9 +43,12 @@ def _get_memory(pid):
 
     # .. fastests but just works for current process ..
     # .. and only available on unix ..
-    if pid == -1 and has_resource:
-        mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / (_TWO_20)
-        return mem
+    if pid == -1:
+        if has_resource:
+            mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / (_TWO_20)
+            return mem
+        else:
+            pid = os.getpid()
 
     # .. good compromise but requires psutil ..
     if has_psutil:
"
memory_profiler.py,memory_profiler.py,9d55698b5e9b55979c8949f8abde82c8392e33cc,07c7c988958428e4f2d3640d10f681dae880f5ed,"Correct units (for linux)

Not sure this should be the same on OSX ...","@@ -45,7 +45,7 @@ def _get_memory(pid):
     # .. and only available on unix ..
     if pid == -1:
         if has_resource:
-            mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / (_TWO_20)
+            mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / 1024.
             return mem
         else:
             pid = os.getpid()
"
Makefile,Makefile,3f22f6d4b8a21d270a19e6d602150b718e623559,9d55698b5e9b55979c8949f8abde82c8392e33cc,optional variable $PYTHON in makefile,"@@ -1,9 +1,10 @@
+PYTHON ?= python
 
 .PHONY: test
 
 test:
-	python -m memory_profiler test/test_func.py
-	python -m memory_profiler test/test_loop.py
-	python -m memory_profiler test/test_as.py
-	python -m memory_profiler test/test_global.py
-	python test/test_import.py
\ No newline at end of file
+	$(PYTHON) -m memory_profiler test/test_func.py
+	$(PYTHON) -m memory_profiler test/test_loop.py
+	$(PYTHON) -m memory_profiler test/test_as.py
+	$(PYTHON) -m memory_profiler test/test_global.py
+	$(PYTHON) test/test_import.py
\ No newline at end of file
"
,README_DEV.rst,ee3f8bd78afe9f53f6251fadbfd85dcd4b04528a,3f22f6d4b8a21d270a19e6d602150b718e623559,Add file README_DEV,"@@ -0,0 +1,7 @@
+Some information on the internals of this package.
+
+Tests
+-----
+`make test` is the closest thing to tests on this package. It executes some
+example code and prints the information. If you don't see any exceptions nor 
+any strange output then the tests suite ""has succeeded"".
"
memory_profiler.py,memory_profiler.py,0726230a6e8781be1a9a3fd3d13df456e0966b87,ee3f8bd78afe9f53f6251fadbfd85dcd4b04528a,Set version to 0.26-git,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
-__version__ = '0.26'
+__version__ = '0.26-git'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
memory_profiler.py,memory_profiler.py,44b1791416ab504b65d83bb2c0b2b5781dca405f,0726230a6e8781be1a9a3fd3d13df456e0966b87,Cleanup,"@@ -41,8 +41,7 @@ except ImportError:
 
 def _get_memory(pid):
 
-    # .. fastests but just works for current process ..
-    # .. and only available on unix ..
+    # .. only for current process and only on unix..
     if pid == -1:
         if has_resource:
             mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / 1024.
@@ -50,7 +49,7 @@ def _get_memory(pid):
         else:
             pid = os.getpid()
 
-    # .. good compromise but requires psutil ..
+    # .. cross-platform but but requires psutil ..
     if has_psutil:
         process = psutil.Process(pid)
         try:
@@ -273,16 +272,6 @@ class LineProfiler:
             self.disable_by_count()
         return self
 
-    def runcall(self, func, *args, **kw):
-        """""" Profile a single function call.
-        """"""
-        # XXX where is this used ? can be removed ?
-        self.enable_by_count()
-        try:
-            return func(*args, **kw)
-        finally:
-            self.disable_by_count()
-
     def enable_by_count(self):
         """""" Enable the profiler if it hasn't been enabled before.
         """"""
"
memory_profiler.py,memory_profiler.py,99a68d176e334e1e4100f51ba40e5c037e63f5c0,44b1791416ab504b65d83bb2c0b2b5781dca405f,using xrange in python2,"@@ -20,6 +20,11 @@ try:
 except ImportError:
     from multiprocessing.dummy import Process, Pipe
 
+try:
+    xrange
+except NameError:
+    xrange = range
+
 _TWO_20 = float(2 ** 20)
 
 has_psutil = False
@@ -564,7 +569,7 @@ def magic_memit(self, line=''):
         timeout = None
 
     mem_usage = []
-    for _ in range(repeat):
+    for _ in xrange(repeat):
         tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout)
         mem_usage.extend(tmp)
 
"
memory_profiler.py,memory_profiler.py,5f137da4c07fbf68b67d417660a0373fcc2bf8ef,99a68d176e334e1e4100f51ba40e5c037e63f5c0,using while,"@@ -20,11 +20,6 @@ try:
 except ImportError:
     from multiprocessing.dummy import Process, Pipe
 
-try:
-    xrange
-except NameError:
-    xrange = range
-
 _TWO_20 = float(2 ** 20)
 
 has_psutil = False
@@ -569,7 +564,9 @@ def magic_memit(self, line=''):
         timeout = None
 
     mem_usage = []
-    for _ in xrange(repeat):
+    counter = 0
+    while counter < repeat:
+        counter += 1
         tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout)
         mem_usage.extend(tmp)
 
"
README.rst,README.rst,2ff06e707ce79fe294fa85962ae6786662273d80,b51d6d79724ecd5e924a92f6077a77e0572b310d,Update README.rst,"@@ -231,7 +231,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
  Support, bugs & wish list
 ===========================
 For support, please ask your question on `stack overflow
-<http://stackoverflow.com/>`_ and add the *profiling* tag.
+<http://stackoverflow.com/>`_ and add the *memory-profiler* tag.
 Send issues, proposals, etc. to `github's issue tracker
 <https://github.com/fabianp/memory_profiler/issues>`_ .
 
"
README.rst,README.rst,7ec2b316420ee192445910e5aeb4805ee24d23e7,2ff06e707ce79fe294fa85962ae6786662273d80,Update README.rst,"@@ -231,7 +231,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
  Support, bugs & wish list
 ===========================
 For support, please ask your question on `stack overflow
-<http://stackoverflow.com/>`_ and add the *memory-profiler* tag.
+<http://stackoverflow.com/>`_ and add the *memory-profiling* tag.
 Send issues, proposals, etc. to `github's issue tracker
 <https://github.com/fabianp/memory_profiler/issues>`_ .
 
"
memory_profiler.py,memory_profiler.py,10956a8e2a6a173908137cff68cd8e00f59ad2f3,bd5e9007c69d59fbadc7cb858ac56c96019746c5,"Memory usage at entering and leaving functions

When using timestamping, memory usage is now recorded when entering
and leaving functions. This provides for more accurate measurement at
these points.

mplot has been adapted to handle this new piece of information.","@@ -221,10 +221,10 @@ class _TimeStamperCM(object):
         self._timestamps = timestamps
 
     def __enter__(self):
-        self._timestamps.append(time.time())
+        self._timestamps.append(_get_memory(os.getpid(), timestamps=True))
 
     def __exit__(self, *args):
-        self._timestamps.append(time.time())
+        self._timestamps.append(_get_memory(os.getpid(), timestamps=True))
 
 
 class TimeStamper:
@@ -268,13 +268,13 @@ class TimeStamper:
         """"""
         def f(*args, **kwds):
             # Start time
-            timestamps = [time.time()]
+            timestamps = [_get_memory(os.getpid(), timestamps=True)]
             self.functions[func].append(timestamps)
             try:
                 result = func(*args, **kwds)
             finally:
                 # end time
-                timestamps.append(time.time())
+                timestamps.append(_get_memory(os.getpid(), timestamps=True))
             return result
         return f
 
@@ -285,7 +285,9 @@ class TimeStamper:
         for func, timestamps in self.functions.iteritems():
             function_name = ""%s.%s"" % (func.__module__, func.__name__)
             for ts in timestamps:
-                stream.write(""%s %.4f %.4f\n"" % (function_name, ts[0], ts[1]))
+                stream.write(""%s %.4f %.4f %.4f %.4f\n"" % (
+                    (function_name,) + ts[0] + ts[1]))
+                ## stream.write(""%s %.4f %.4f\n"" % (function_name, ts[0], ts[1]))
 
 
 class LineProfiler:
"
mplot,mplot,10956a8e2a6a173908137cff68cd8e00f59ad2f3,bd5e9007c69d59fbadc7cb858ac56c96019746c5,"Memory usage at entering and leaving functions

When using timestamping, memory usage is now recorded when entering
and leaving functions. This provides for more accurate measurement at
these points.

mplot has been adapted to handle this new piece of information.","@@ -13,30 +13,31 @@ import os
 import os.path as osp
 
 
-def add_bracket(xloc, t, mem, color=""r"", label=None):
+def add_bracket(xloc, yloc, xshift=0, color=""r"", label=None):
     """"""Add two brackets on the memory line plot.
 
     This function uses the current figure.
 
     Parameters
     ==========
-    xloc: {tuple with 2 values}
-        bracket location (on horizontal axis).
-    t, mem:
-        memory usage curve. Used to place bracket at the correct location.
+    xloc: tuple with 2 values
+        brackets location (on horizontal axis).
+    yloc: tuple with 2 values
+        brackets location (on vertical axis)
+    xshift: float
+        value to subtract to xloc.
     """"""
 
     height_ratio = 20.
-    yloc = pl.interp(xloc, t, mem)
     vsize = (pl.ylim()[1] - pl.ylim()[0]) / height_ratio
     hsize = (pl.xlim()[1] - pl.xlim()[0]) / (3.*height_ratio)
 
     bracket_x = pl.asarray([hsize, 0, 0, hsize])
     bracket_y = pl.asarray([vsize, vsize, -vsize, -vsize])
 
-    pl.plot(bracket_x + xloc[0], bracket_y + yloc[0],
+    pl.plot(bracket_x + xloc[0] - xshift, bracket_y + yloc[0],
             ""-"" + color, linewidth=2, label=label)
-    pl.plot(-bracket_x + xloc[1], bracket_y + yloc[1],
+    pl.plot(-bracket_x + xloc[1] - xshift, bracket_y + yloc[1],
             ""-"" + color, linewidth=2 )
 
     # TODO: use matplotlib.patches.Polygon to draw a colored background for
@@ -58,9 +59,9 @@ def read_timestamp_file(ts_filename):
     ret = {}
     f = open(ts_filename)
     for l in f:
-        f_name, start, end = l.split()
+        f_name, mem_start, start, mem_end, end = l.split()
         ts = ret.get(f_name, [])
-        ts.append([float(start), float(end)])
+        ts.append([float(start), float(end), float(mem_start), float(mem_end)])
         ret[f_name] = ts
     f.close()
     return ret
@@ -100,7 +101,7 @@ def plot_file(filename, index=0, timestamps=True):
         func_num = 0
         for f, exec_ts in ts.iteritems():
             for execution in exec_ts:
-                add_bracket([ts - global_start for ts in execution], t, mem,
+                add_bracket(execution[:2], execution[2:], xshift=global_start,
                             color= all_colors[func_num % len(all_colors)],
                             label=f.split(""."")[-1] + "" %.3fs"" % (execution[1] - execution[0]))
             func_num += 1
"
maction,maction,f3ec782486a6db33118867f6c060a4ebdd8ec495,10956a8e2a6a173908137cff68cd8e00f59ad2f3,"Added ""clean"" action to maction

This action removes all profile files in the current directory.","@@ -5,6 +5,7 @@ import os
 import os.path as osp
 import sys
 import re
+import copy
 
 from optparse import OptionParser
 
@@ -17,7 +18,7 @@ def print_usage():
 
 def get_action():
     """"""Pop first argument, check it is a valid action.""""""
-    all_actions = (""rm"",)
+    all_actions = (""rm"", ""clean"")
     if len(sys.argv) <= 1:
         print_usage()
         sys.exit(1)
@@ -48,31 +49,32 @@ def get_profile_filenames(args):
     profiles = glob.glob(""mprofile_??????????????.dat"")
     profiles.sort()
 
-    filenames = []
-
-    for arg in args:
-        if arg == ""--"":  # workaround
-            continue
-        try:
-            index = int(arg)
-        except ValueError:
-            index = None
-        if index is not None:
+    if args is ""all"":
+        filenames = copy.copy(profiles)
+    else:
+        for arg in args:
+            if arg == ""--"":  # workaround
+                continue
             try:
-                filename = profiles[index]
-            except IndexError:
-                raise ValueError(""Invalid index (non-existing file): %s"" % arg)
+                index = int(arg)
+            except ValueError:
+                index = None
+            if index is not None:
+                try:
+                    filename = profiles[index]
+                except IndexError:
+                    raise ValueError(""Invalid index (non-existing file): %s"" % arg)
 
-            if filename not in filenames:
-                filenames.append(filename)
-        else:
-            if osp.isfile(arg):
-                if arg not in filenames:
-                    filenames.append(arg)
-            elif osp.isdir(arg):
-                raise ValueError(""Path %s is a directory"" % arg)
+                if filename not in filenames:
+                    filenames.append(filename)
             else:
-                raise ValueError(""File %s not found"" % arg)
+                if osp.isfile(arg):
+                    if arg not in filenames:
+                        filenames.append(arg)
+                elif osp.isdir(arg):
+                    raise ValueError(""Path %s is a directory"" % arg)
+                else:
+                    raise ValueError(""File %s not found"" % arg)
 
     # Add timestamp files, if any
     for filename in reversed(filenames):
@@ -107,6 +109,30 @@ def rm_action():
             os.remove(filename)
 
 
+def clean_action():
+    """"""Remove every profile file in current directory.""""""
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
+                      action=""store_true"",
+                      help=""""""Show what will be done, without actually doing it."""""")
+
+    (options, args) = parser.parse_args()
+
+    if len(args) > 0:
+        print(""This command takes no argument."")
+        sys.exit(1)
+
+    filenames = get_profile_filenames(""all"")
+    if options.dry_run:
+        print(""Files to be removed: "")
+        for filename in filenames:
+            print(filename)
+    else:
+        for filename in filenames:
+            os.remove(filename)
+
+
 if __name__ == ""__main__"":
     # Workaround for optparse limitation: insert -- before first negative number found.
     negint = re.compile(""-[0-9]+"")
@@ -114,7 +140,7 @@ if __name__ == ""__main__"":
         if negint.match(arg):
             sys.argv.insert(n, ""--"")
             break
-    actions = {""rm"": rm_action}
+    actions = {""rm"": rm_action, ""clean"": clean_action}
     actions[get_action()]()
 
 
"
memory_profiler.py,memory_profiler.py,5d241dad8b8c6979d66b73bd0fdb02d780240e4e,b0071d302b6094a9ea0f1484f45615c964c8d9c2,Corrected a small typo left after the merge.,"@@ -59,7 +59,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
             mem = process.get_memory_info()[0] / (_TWO_20)
             if include_children:
                 for p in process.get_children(recursive=True):
-                    mem += p.get_memory_info()[0] / (_TWO_20).
+                    mem += p.get_memory_info()[0] / (_TWO_20)
         except psutil.AccessDenied:
             mem = -1
         if timestamps:
"
README.rst,README.rst,4e967155282a2583e1d49b30a9b722166d96dad5,7ec2b316420ee192445910e5aeb4805ee24d23e7,Update README.rst,"@@ -248,6 +248,11 @@ Latest sources are available from github:
 
     https://github.com/fabianp/memory_profiler
 
+===============================
+Projects using memory_profiler
+===============================
+
+`Benchy <https://github.com/python-recsys/benchy>`_
 
 =========
  Authors
"
memory_profiler.py,memory_profiler.py,92a30905d37ff88a5d959a7d0afc216b0471eb62,4e967155282a2583e1d49b30a9b722166d96dad5,Override builtins,"@@ -616,10 +616,18 @@ if __name__ == '__main__':
     __file__ = _find_script(args[0])
     try:
         if sys.version_info[0] < 3:
+            # we need to ovewrite the builtins to have profile
+            # globally defined (global variables is not enought
+            # for all cases, e.g. a script that imports another
+            # script where @profile is used)
+            import __builtin__
+            __builtin__.__dict__['profile'] = prof
             ns = copy(_clean_globals)
             ns['profile'] = prof # shadow the profile decorator defined above
             execfile(__file__, ns, ns)
         else:
+            import builtins
+            builtins.__dict__['profile'] = prof
             ns = copy(_clean_globals)
             ns['profile'] = prof # shadow the profile decorator defined above
             exec(compile(open(__file__).read(), __file__, 'exec'), ns, ns)
"
memory_profiler.py,memory_profiler.py,6be0021673351d7a6687850056dfbbe9e705e49e,0af6a49662d148086c88b97833f2926aac1d77d3,"Timestamps and memory usage stored in one file

Got rid of the _ts file for timestamp storage. The file format has
been changed just for this. It opens the possibility for many new
features (like per-process memory monitoring).","@@ -312,9 +312,8 @@ class TimeStamper:
         for func, timestamps in self.functions.iteritems():
             function_name = ""%s.%s"" % (func.__module__, func.__name__)
             for ts in timestamps:
-                stream.write(""%s %.4f %.4f %.4f %.4f\n"" % (
+                stream.write(""FUNC %s %.4f %.4f %.4f %.4f\n"" % (
                     (function_name,) + ts[0] + ts[1]))
-                ## stream.write(""%s %.4f %.4f\n"" % (function_name, ts[0], ts[1]))
 
 
 class LineProfiler:
@@ -751,7 +750,7 @@ if __name__ == '__main__':
             exec(compile(open(__file__).read(), __file__, 'exec'), ns, ns)
     finally:
         if options.out_filename is not None:
-            out_file = open(options.out_filename, ""w"")
+            out_file = open(options.out_filename, ""a"")
         else:
             out_file = sys.stdout
 
"
mplot,mplot,6be0021673351d7a6687850056dfbbe9e705e49e,0af6a49662d148086c88b97833f2926aac1d77d3,"Timestamps and memory usage stored in one file

Got rid of the _ts file for timestamp storage. The file format has
been changed just for this. It opens the possibility for many new
features (like per-process memory monitoring).","@@ -6,6 +6,8 @@ try:
 except ImportError:
     print(""matplotlib is needed for plotting."")
     sys.exit(1)
+
+import numpy as np
 import math
 import glob
 import time
@@ -13,7 +15,7 @@ import os
 import os.path as osp
 
 
-def add_bracket(xloc, yloc, xshift=0, color=""r"", label=None):
+def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
     """"""Add two brackets on the memory line plot.
 
     This function uses the current figure.
@@ -50,38 +52,42 @@ def add_bracket(xloc, yloc, xshift=0, color=""r"", label=None):
     ## pl.plot(xloc[1], yloc[1], "">""+color, markersize=7)
 
 
-def read_timestamp_file(ts_filename):
-    """"""Return content of ts_filename or None, if ts_filename
-    is invalid or does not exist""""""
-    if not osp.isfile(ts_filename):
-        return None
-
+def read_mprofile_file(filename):
     ret = {}
-    f = open(ts_filename)
+    mdata = []
+    f = open(filename, ""r"")
     for l in f:
-        f_name, mem_start, start, mem_end, end = l.split()
-        ts = ret.get(f_name, [])
-        ts.append([float(start), float(end), float(mem_start), float(mem_end)])
-        ret[f_name] = ts
+        fields = l.split()
+        if fields[0] == ""MEM"":
+            # mem, timestamp
+            mdata.append((fields[1], fields[2]))
+
+        elif fields[0] == ""FUNC"":
+            f_name, mem_start, start, mem_end, end = fields[1:]
+            ts = ret.get(f_name, [])
+            ts.append([float(start), float(end), float(mem_start), float(mem_end)])
+            ret[f_name] = ts
+
+        else:
+            pass
     f.close()
-    return ret
+
+    mdata = np.asarray(mdata,
+                       dtype=[(""mem"", np.float), (""timestamp"", np.float)])
+    return mdata, ret
+
 
 
 def plot_file(filename, index=0, timestamps=True):
-    # Check for a timestamp file
-    file_parts = osp.splitext(filename)
-    ts_filename = file_parts[0] + ""_ts"" + file_parts[1]
-    ts = read_timestamp_file(ts_filename)
+    mdata, ts = read_mprofile_file(filename)
 
-    mdata = pl.atleast_2d(pl.loadtxt(filename))
+    global_start = float(mdata[""timestamp""][0])
 
-    global_start = float(mdata[0, 1])
-
-    mem = mdata[:, 0]
+    mem = mdata[""mem""]
     max_mem = mem.max()
     max_mem_ind = mem.argmax()
 
-    t = mdata[:, 1] - global_start
+    t = mdata[""timestamp""] - global_start
 
     all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
     mem_line_colors=('k', ""b"", ""r"")
@@ -97,13 +103,14 @@ def plot_file(filename, index=0, timestamps=True):
     top -= 0.001
 
     # plot timestamps, if any
-    if ts is not None and timestamps:
+    if len(ts) > 0 and timestamps:
         func_num = 0
         for f, exec_ts in ts.iteritems():
             for execution in exec_ts:
-                add_bracket(execution[:2], execution[2:], xshift=global_start,
-                            color= all_colors[func_num % len(all_colors)],
-                            label=f.split(""."")[-1] + "" %.3fs"" % (execution[1] - execution[0]))
+                add_brackets(execution[:2], execution[2:], xshift=global_start,
+                             color= all_colors[func_num % len(all_colors)],
+                             label=f.split(""."")[-1]
+                             + "" %.3fs"" % (execution[1] - execution[0]))
             func_num += 1
 
     if timestamps:
@@ -120,8 +127,8 @@ if __name__ == ""__main__"":
 
     if len(sys.argv) == 1:
         if len(profiles) == 0:
-            print(""""""No input file found. This program looks for mprofile_*.dat files,
-    generated by the mprofile command."""""")
+            print(""No input file found. \nThis program looks for ""
+                  ""mprofile_*.dat files, generated by the mprofile command."")
             sys.exit(-1)
         filenames = [profiles[-1]]
     else:
@@ -138,7 +145,7 @@ if __name__ == ""__main__"":
                 if not profiles[n] in filenames:
                     filenames.append(profiles[n])
 
-    pl.figure(figsize=(14,6), dpi=90)
+    pl.figure(figsize=(14, 6), dpi=90)
     if len(filenames) > 1:
         timestamps = False
     else:
"
mprofile,mprofile,6be0021673351d7a6687850056dfbbe9e705e49e,0af6a49662d148086c88b97833f2926aac1d77d3,"Timestamps and memory usage stored in one file

Got rid of the _ts file for timestamp storage. The file format has
been changed just for this. It opens the possibility for many new
features (like per-process memory monitoring).","@@ -44,17 +44,17 @@ mprofile_output = ""mprofile_%s.dat"" % suffix
 
 if options.python:
     print(""running as a Python program..."")
-    timestamp_output = ""mprofile_%s_ts.dat"" % suffix
+#    timestamp_output = ""mprofile_%s_ts.dat"" % suffix
     if not args[0].startswith(""python""):
         args.insert(0, ""python"")
     args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
-                 ""-o"", timestamp_output)
+                 ""-o"", mprofile_output)
     p = subprocess.Popen(args)
 else:
     p = subprocess.Popen(args)
 
 mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
                      include_children=options.include_children)
-with open(mprofile_output, ""w"") as f:
+with open(mprofile_output, ""a"") as f:
     for m, t in mu:
-        f.write(""{0:.6f} {1:.4f}"".format(m, t) + ""\n"")
+        f.write(""MEM {0:.6f} {1:.4f}"".format(m, t) + ""\n"")
"
maction,maction,31a3eae45eed3eae49a7c5b0aec9686da60ee76e,6be0021673351d7a6687850056dfbbe9e705e49e,"Added ""list"" command to maction

And fixed a bad bug in maction (""rm"" wasn't working anymore).","@@ -18,7 +18,7 @@ def print_usage():
 
 def get_action():
     """"""Pop first argument, check it is a valid action.""""""
-    all_actions = (""rm"", ""clean"")
+    all_actions = (""rm"", ""clean"", ""list"")
     if len(sys.argv) <= 1:
         print_usage()
         sys.exit(1)
@@ -52,6 +52,7 @@ def get_profile_filenames(args):
     if args is ""all"":
         filenames = copy.copy(profiles)
     else:
+        filenames = []
         for arg in args:
             if arg == ""--"":  # workaround
                 continue
@@ -86,6 +87,26 @@ def get_profile_filenames(args):
     return filenames
 
 
+def list_action():
+    """"""Display existing profiles, with indices.""""""
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+
+    (options, args) = parser.parse_args()
+
+    if len(args) > 0:
+        print(""This command takes no argument."")
+        sys.exit(1)
+
+    filenames = get_profile_filenames(""all"")
+    for n, filename in enumerate(filenames):
+        ts = osp.splitext(filename)[0].split('_')[-1]
+        print(""{index} {filename} {hour}:{min}:{sec} {day}/{month}/{year}""
+              .format(index=n, filename=filename,
+                      year=ts[:4], month=ts[4:6], day=ts[6:8],
+                      hour=ts[8:10], min=ts[10:12], sec=ts[12:14]))
+
+
 def rm_action():
     parser = OptionParser(version=mp.__version__)
     parser.disable_interspersed_args()
@@ -140,7 +161,9 @@ if __name__ == ""__main__"":
         if negint.match(arg):
             sys.argv.insert(n, ""--"")
             break
-    actions = {""rm"": rm_action, ""clean"": clean_action}
+    actions = {""rm"": rm_action,
+               ""clean"": clean_action,
+               ""list"": list_action}
     actions[get_action()]()
 
 
"
mplot,mplot,7c71e32b69e44570da77e2a8fdf6225639118151,31a3eae45eed3eae49a7c5b0aec9686da60ee76e,Added a workaround for matplotlib strange behaviour,"@@ -37,6 +37,9 @@ def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
     bracket_x = pl.asarray([hsize, 0, 0, hsize])
     bracket_y = pl.asarray([vsize, vsize, -vsize, -vsize])
 
+    # Matplotlib workaround: labels starting with _ aren't displayed
+    if label[0] == '_':
+        label = ' ' + label
     pl.plot(bracket_x + xloc[0] - xshift, bracket_y + yloc[0],
             ""-"" + color, linewidth=2, label=label)
     pl.plot(-bracket_x + xloc[1] - xshift, bracket_y + yloc[1],
"
memory_profiler.py,memory_profiler.py,fd8a891ce4e59dae8177408c983c18fee90ad7ca,92a30905d37ff88a5d959a7d0afc216b0471eb62,"No memory_profiler args is transmitted

Invoked script used to received the memory_profiler options in sys.argv
in addition of their own. This is completely fixed now.","@@ -610,7 +610,7 @@ if __name__ == '__main__':
         sys.exit(2)
 
     (options, args) = parser.parse_args()
-    del sys.argv[0]         # Hide ""memory_profiler.py"" from argument list
+    sys.argv[:] = args  # Remove every memory_profiler arguments
 
     prof = LineProfiler(max_mem=options.max_mem)
     __file__ = _find_script(args[0])
"
README.rst,README.rst,ed8281ab786f79800439a317a473fd1802517e13,1971740d19dde3be64bd1d3af7753b642bfbb42b,Update README.rst,"@@ -271,6 +271,8 @@ cleanup.
 
 `Thomas Kluyver <https://github.com/takluyver>`_ added the IPython extension.
 
+Philippe Gervais made several enhacements and bug fixes.
+
 
 
 =========
"
memory_profiler.py,memory_profiler.py,a05c9c132cc1debffb64fd606ce7fe8a5faf1420,ed8281ab786f79800439a317a473fd1802517e13,"Add max_usage and retval kwargs to memory_usage()

The max_usage parameter modifies the behavior of the function so that it
only keeps track of the peak mem usage over the duration of the
profiling. This is useful for profiling very long running processes.

The retval parameter is for profiling Python functions. If set, the
return value of the profiled function will be kept and returned in a
tuple along with the memory usage.

Signed-off-by: cheesinglee <cheesinglee@gmail.com>","@@ -83,24 +83,31 @@ class Timer(Process):
     Fetch memory consumption from over a time interval
     """"""
 
-    def __init__(self, monitor_pid, interval, pipe, *args, **kw):
+    def __init__(self, monitor_pid, interval, pipe, max_usage=False, *args, **kw):
         self.monitor_pid = monitor_pid
         self.interval = interval
         self.pipe = pipe
         self.cont = True
+        self.max_usage = max_usage
         super(Timer, self).__init__(*args, **kw)
 
     def run(self):
         m = _get_memory(self.monitor_pid)
-        timings = [m]
+        if not self.max_usage:
+            timings = [m]
+        else:
+            timings = m 
         self.pipe.send(0)  # we're ready
         while not self.pipe.poll(self.interval):
             m = _get_memory(self.monitor_pid)
-            timings.append(m)
+            if not self.max_usage:
+                timings.append(m)
+            else:
+                timings = max([m,timings])
         self.pipe.send(timings)
 
 
-def memory_usage(proc=-1, interval=.1, timeout=None):
+def memory_usage(proc=-1, interval=.1, timeout=None, max_usage=False, retval=False):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -119,13 +126,25 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
 
     timeout : float, optional
         Maximum amount of time (in seconds) to wait before returning.
+        
+    max_usage: bool, optional
+        Only return the maximum memory usage (default False)
+        
+    retval: bool, optional
+        For profiling python functions. Save the return value of the profiled
+        function. Return value of memory_usage becomes a tuple:
+        (mem_usage, retval)
 
     Returns
     -------
     mem_usage : list of floating-poing values
         memory usage, in MB. It's length is always < timeout / interval
     """"""
-    ret = []
+    
+    if not max_usage:
+        ret = []
+    else:
+        ret = -1
 
     if timeout is not None:
         max_iter = int(timeout / interval)
@@ -158,17 +177,22 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
             % (n_args, len(args)))
 
         child_conn, parent_conn = Pipe()  # this will store Timer's results
-        p = Timer(-1, interval, child_conn)
+        p = Timer(-1, interval, child_conn,max_usage)
         p.start()
         parent_conn.recv()  # wait until we start getting memory
-        f(*args, **kw)
+        returned = f(*args, **kw)
         parent_conn.send(0)  # finish timing
         ret = parent_conn.recv()
+        if retval:
+            ret = ret,returned
         p.join(5 * interval)
     elif isinstance(proc, subprocess.Popen):
         # external process, launched from Python
         while True:
-            ret.append(_get_memory(proc.pid))
+            if not max_usage:
+                ret.append(_get_memory(proc.pid))
+            else:
+                ret = max([ret,_get_memory(proc.pid)])
             time.sleep(interval)
             if timeout is not None:
                 max_iter -= 1
@@ -183,7 +207,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None):
         counter = 0
         while counter < max_iter:
             counter += 1
-            ret.append(_get_memory(proc))
+            if not max_usage:
+                ret.append(_get_memory(proc.pid))
+            else:
+                ret = max([ret,_get_memory(proc.pid)])
             time.sleep(interval)
     return ret
 
"
memory_profiler.py,memory_profiler.py,673f477fda944cb66e9ae557b6a59d61da97aab6,a05c9c132cc1debffb64fd606ce7fe8a5faf1420,"Minor changes

Fixed stupid copy-paste error in external process part of memory_usage()

Add ret to docstring of memory_usage()

Signed-off-by: cheesinglee <cheesinglee@gmail.com>","@@ -139,6 +139,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, max_usage=False, retval=Fal
     -------
     mem_usage : list of floating-poing values
         memory usage, in MB. It's length is always < timeout / interval
+    ret : return value of the profiled function
+        Only returned if retval is set to True
     """"""
     
     if not max_usage:
@@ -177,7 +179,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, max_usage=False, retval=Fal
             % (n_args, len(args)))
 
         child_conn, parent_conn = Pipe()  # this will store Timer's results
-        p = Timer(-1, interval, child_conn,max_usage)
+        p = Timer(os.getpid(), interval, child_conn,max_usage)
         p.start()
         parent_conn.recv()  # wait until we start getting memory
         returned = f(*args, **kw)
@@ -208,9 +210,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, max_usage=False, retval=Fal
         while counter < max_iter:
             counter += 1
             if not max_usage:
-                ret.append(_get_memory(proc.pid))
+                ret.append(_get_memory(proc))
             else:
-                ret = max([ret,_get_memory(proc.pid)])
+                ret = max([ret,_get_memory(proc)])
             time.sleep(interval)
     return ret
 
"
memory_profiler.py,memory_profiler.py,d5201e1c9e03397ec7dd93322a682e76663ad643,673f477fda944cb66e9ae557b6a59d61da97aab6,Units of getrusage() seem to be different in OSX,"@@ -38,13 +38,18 @@ try:
 except ImportError:
     pass
 
+# divide resource.getrusage() by rusage_denom to get MB
+rusage_denom = 1024.
+if sys.platform == 'darwin':
+    # ... it seems that in OSX the output is different units ...
+    rusage_denom = rusage_denom * rusage_denom
 
 def _get_memory(pid):
 
     # .. only for current process and only on unix..
     if pid == -1:
         if has_resource:
-            mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / 1024.
+            mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / rusage_denom
             return mem
         else:
             pid = os.getpid()
"
test/test_loop.py,test/test_loop.py,825f11296efbfed98ba7a812849edb18199ddc7d,d5201e1c9e03397ec7dd93322a682e76663ad643,test refactoring,"@@ -2,6 +2,13 @@
 
 @profile
 def test_1():
+    a = {}
+    for i in range(10000):
+        a[i] =  i + 1
+    return
+
+@profile
+def test_2():
     a = [1] * (10 ** 6)
     b = [2] * (2 * 10 ** 7)
     del b
@@ -12,13 +19,6 @@ def test_1():
         del b
     return a
 
-@profile
-def test_2():
-    a = {}
-    for i in range(10000):
-        a[i] =  i + 1
-    return
-
 if __name__ == '__main__':
     test_1()
     test_2()
"
memory_profiler.py,memory_profiler.py,13e1192dfcc5d26d0c447a97a62d988d8ba791f6,825f11296efbfed98ba7a812849edb18199ddc7d,"Fix for issue #52

module resource seems to give wrong measurements on some
cases.","@@ -48,7 +48,9 @@ def _get_memory(pid):
 
     # .. only for current process and only on unix..
     if pid == -1:
-        if has_resource:
+        # .. seems to get wrong measurements on some cases, see ..
+        # .. https://github.com/fabianp/memory_profiler/issues/52 ..
+        if False: #has_resource:
             mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / rusage_denom
             return mem
         else:
"
memory_profiler.py,memory_profiler.py,d339c05826646ac3685d4623e87ad0646a9181fc,13e1192dfcc5d26d0c447a97a62d988d8ba791f6,0.27 release,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
-__version__ = '0.26-git'
+__version__ = '0.27'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
README.rst,README.rst,3b59db18b96651e4423e58ae52cf6c2ca5dd8216,d339c05826646ac3685d4623e87ad0646a9181fc,Add refresh interval (-i)) option to %memit,"@@ -29,7 +29,7 @@ The line-by-line profiler is used much in the same way of the
 `line_profiler <https://pypi.python.org/pypi/line_profiler/>`_: first
 decorate the function you would like to profile with ``@profile`` and
 then run the script with a special script (in this case with specific
-arguments to the Python interpreter). 
+arguments to the Python interpreter).
 
 In the following example, we create a simple function ``my_func`` that
 allocates lists ``a``, ``b`` and then deletes ``b``::
@@ -163,7 +163,7 @@ After installing the module, if you use IPython, you can use the `%mprun`
 and `%memit` magics.
 
 For IPython 0.11+, you can use the module directly as an extension, with
-``%load_ext memory_profiler``.
+``%load_ext memory_profiler``
 
 To activate it whenever you start IPython, edit the configuration file for your
 IPython profile, ~/.ipython/profile_default/ipython_config.py, to register the
"
memory_profiler.py,memory_profiler.py,3b59db18b96651e4423e58ae52cf6c2ca5dd8216,d339c05826646ac3685d4623e87ad0646a9181fc,Add refresh interval (-i)) option to %memit,"@@ -103,7 +103,7 @@ class Timer(Process):
         if not self.max_usage:
             timings = [m]
         else:
-            timings = m 
+            timings = m
         self.pipe.send(0)  # we're ready
         while not self.pipe.poll(self.interval):
             m = _get_memory(self.monitor_pid)
@@ -133,10 +133,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, max_usage=False, retval=Fal
 
     timeout : float, optional
         Maximum amount of time (in seconds) to wait before returning.
-        
+
     max_usage: bool, optional
         Only return the maximum memory usage (default False)
-        
+
     retval: bool, optional
         For profiling python functions. Save the return value of the profiled
         function. Return value of memory_usage becomes a tuple:
@@ -149,7 +149,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, max_usage=False, retval=Fal
     ret : return value of the profiled function
         Only returned if retval is set to True
     """"""
-    
+
     if not max_usage:
         ret = []
     else:
@@ -567,7 +567,7 @@ def magic_memit(self, line=''):
     """"""Measure memory usage of a Python statement
 
     Usage, in line mode:
-      %memit [-r<R>t<T>] statement
+      %memit [-r<R>t<T>i<I>] statement
 
     Options:
     -r<R>: repeat the loop iteration <R> times and take the best result.
@@ -575,6 +575,9 @@ def magic_memit(self, line=''):
 
     -t<T>: timeout after <T> seconds. Default: None
 
+    -i<I>: Get time information at an interval of I times per second.
+        Defaults to 0.1 so that there is ten measurements per second.
+
     Examples
     --------
     ::
@@ -591,19 +594,21 @@ def magic_memit(self, line=''):
       maximum of 10: 0.101562 MB per loop
 
     """"""
-    opts, stmt = self.parse_options(line, 'r:t', posix=False, strict=False)
+    opts, stmt = self.parse_options(line, 'r:t:i:', posix=False, strict=False)
     repeat = int(getattr(opts, 'r', 1))
     if repeat < 1:
         repeat == 1
     timeout = int(getattr(opts, 't', 0))
     if timeout <= 0:
         timeout = None
+    interval = float(getattr(opts, 'i', 0.1))
 
     mem_usage = []
     counter = 0
     while counter < repeat:
         counter += 1
-        tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout)
+        tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
+                           timeout=timeout, interval=interval)
         mem_usage.extend(tmp)
 
     if mem_usage:
"
maction,maction,627403aaf0b7bbad7fc608cc27adef98c44f3d44,8796d5ef9a86824670dfd9bfb3d742a236732ba6,refactoring,"@@ -108,6 +108,7 @@ def list_action():
 
 
 def rm_action():
+    """"""TODO: merge with clean_action (@pgervais)""""""
     parser = OptionParser(version=mp.__version__)
     parser.disable_interspersed_args()
     parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
"
mprofile,mprof,627403aaf0b7bbad7fc608cc27adef98c44f3d44,8796d5ef9a86824670dfd9bfb3d742a236732ba6,refactoring,"@@ -27,10 +27,6 @@ if len(args) == 0:
     print(""A program to run must be provided. Use -h for help"")
     sys.exit(1)
 
-## if len(sys.argv) < 2:
-##     print(""""""Memory usage monitoring
-## Usage: %s <command> <argument> ... <argument>
-
 ## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
 ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
 ## directory. This file contains the process memory consumption, in Mb (one
@@ -44,7 +40,6 @@ mprofile_output = ""mprofile_%s.dat"" % suffix
 
 if options.python:
     print(""running as a Python program..."")
-#    timestamp_output = ""mprofile_%s_ts.dat"" % suffix
     if not args[0].startswith(""python""):
         args.insert(0, ""python"")
     args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
"
setup.py,setup.py,627403aaf0b7bbad7fc608cc27adef98c44f3d44,8796d5ef9a86824670dfd9bfb3d742a236732ba6,refactoring,"@@ -28,7 +28,7 @@ setup(
     author_email='fabian@fseoane.net',
     url='http://pypi.python.org/pypi/memory_profiler',
     py_modules=['memory_profiler'],
-    scripts=[""mprofile"", ""mplot""],
+    scripts=['mprof'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='Simplified BSD'
 
"
README.rst,README.rst,e8df9caf862b59d7b704b6318c068831275e632f,627403aaf0b7bbad7fc608cc27adef98c44f3d44,refactoring,"@@ -74,7 +74,6 @@ the code that has been profiled.
 
 Decorator
 =========
-
 A function decorator is also available.  Use as follows::
 
     from memory_profiler import profile
@@ -86,6 +85,16 @@ A function decorator is also available.  Use as follows::
         del b
         return a
 
+In this case the script can be run without specifying ``-m
+memory_profiler`` in the command line.
+
+Executing external scripts
+==========================
+Sometimes it is useful to have full memory usage reports as a function of
+time (not line-by-line) of external processess (be it Python scripts or not).
+In this case the executable ``mprof`` might be useful. To use it
+
+
 Setting debugger breakpoints
 =============================
 It is possible to set breakpoints depending on the amount of memory used.
"
maction,,e8df9caf862b59d7b704b6318c068831275e632f,627403aaf0b7bbad7fc608cc27adef98c44f3d44,refactoring,"@@ -1,170 +0,0 @@
-#! /usr/bin/env python
-
-import glob
-import os
-import os.path as osp
-import sys
-import re
-import copy
-
-from optparse import OptionParser
-
-import memory_profiler as mp
-
-
-def print_usage():
-    print(""Usage: %s <command> <options> <arguments>""
-          % osp.basename(sys.argv[0]))
-
-def get_action():
-    """"""Pop first argument, check it is a valid action.""""""
-    all_actions = (""rm"", ""clean"", ""list"")
-    if len(sys.argv) <= 1:
-        print_usage()
-        sys.exit(1)
-    if not sys.argv[1] in all_actions:
-        print(""Valid actions are: "" + "" "".join(all_actions))
-        sys.exit(1)
-
-    return sys.argv.pop(1)
-
-
-def get_profile_filenames(args):
-    """"""Return list of profile filenames.
-
-    Parameters
-    ==========
-    args (list)
-        list of filename or integer. An integer is the index of the
-        profile in the list of existing profiles. 0 is the oldest,
-        -1 in the more recent.
-        Non-existing files cause a ValueError exception to be thrown.
-
-    Returns
-    =======
-    filenames (list)
-        list of existing memory profile filenames. It is guaranteed
-        that an given file name will not appear twice in this list.
-    """"""
-    profiles = glob.glob(""mprofile_??????????????.dat"")
-    profiles.sort()
-
-    if args is ""all"":
-        filenames = copy.copy(profiles)
-    else:
-        filenames = []
-        for arg in args:
-            if arg == ""--"":  # workaround
-                continue
-            try:
-                index = int(arg)
-            except ValueError:
-                index = None
-            if index is not None:
-                try:
-                    filename = profiles[index]
-                except IndexError:
-                    raise ValueError(""Invalid index (non-existing file): %s"" % arg)
-
-                if filename not in filenames:
-                    filenames.append(filename)
-            else:
-                if osp.isfile(arg):
-                    if arg not in filenames:
-                        filenames.append(arg)
-                elif osp.isdir(arg):
-                    raise ValueError(""Path %s is a directory"" % arg)
-                else:
-                    raise ValueError(""File %s not found"" % arg)
-
-    # Add timestamp files, if any
-    for filename in reversed(filenames):
-        parts = osp.splitext(filename)
-        timestamp_file = parts[0] + ""_ts"" + parts[1]
-        if osp.isfile(timestamp_file) and timestamp_file not in filenames:
-            filenames.append(timestamp_file)
-
-    return filenames
-
-
-def list_action():
-    """"""Display existing profiles, with indices.""""""
-    parser = OptionParser(version=mp.__version__)
-    parser.disable_interspersed_args()
-
-    (options, args) = parser.parse_args()
-
-    if len(args) > 0:
-        print(""This command takes no argument."")
-        sys.exit(1)
-
-    filenames = get_profile_filenames(""all"")
-    for n, filename in enumerate(filenames):
-        ts = osp.splitext(filename)[0].split('_')[-1]
-        print(""{index} {filename} {hour}:{min}:{sec} {day}/{month}/{year}""
-              .format(index=n, filename=filename,
-                      year=ts[:4], month=ts[4:6], day=ts[6:8],
-                      hour=ts[8:10], min=ts[10:12], sec=ts[12:14]))
-
-
-def rm_action():
-    """"""TODO: merge with clean_action (@pgervais)""""""
-    parser = OptionParser(version=mp.__version__)
-    parser.disable_interspersed_args()
-    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
-                      action=""store_true"",
-                      help=""""""Show what will be done, without actually doing it."""""")
-
-    (options, args) = parser.parse_args()
-
-    if len(args) == 0:
-        print(""A profile to remove must be provided (number or filename)"")
-        sys.exit(1)
-
-    filenames = get_profile_filenames(args)
-    if options.dry_run:
-        print(""Files to be removed: "")
-        for filename in filenames:
-            print(filename)
-    else:
-        for filename in filenames:
-            os.remove(filename)
-
-
-def clean_action():
-    """"""Remove every profile file in current directory.""""""
-    parser = OptionParser(version=mp.__version__)
-    parser.disable_interspersed_args()
-    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
-                      action=""store_true"",
-                      help=""""""Show what will be done, without actually doing it."""""")
-
-    (options, args) = parser.parse_args()
-
-    if len(args) > 0:
-        print(""This command takes no argument."")
-        sys.exit(1)
-
-    filenames = get_profile_filenames(""all"")
-    if options.dry_run:
-        print(""Files to be removed: "")
-        for filename in filenames:
-            print(filename)
-    else:
-        for filename in filenames:
-            os.remove(filename)
-
-
-if __name__ == ""__main__"":
-    # Workaround for optparse limitation: insert -- before first negative number found.
-    negint = re.compile(""-[0-9]+"")
-    for n, arg in enumerate(sys.argv):
-        if negint.match(arg):
-            sys.argv.insert(n, ""--"")
-            break
-    actions = {""rm"": rm_action,
-               ""clean"": clean_action,
-               ""list"": list_action}
-    actions[get_action()]()
-
-
"
mprof,mprof,e8df9caf862b59d7b704b6318c068831275e632f,627403aaf0b7bbad7fc608cc27adef98c44f3d44,refactoring,"@@ -1,55 +1,221 @@
 #! /usr/bin/env python
-import subprocess
-import memory_profiler as mp
+
+import glob
+import os
 import os.path as osp
-import time
 import sys
+import re
+import copy
 
 from optparse import OptionParser
 
-parser = OptionParser(version=mp.__version__)
-parser.disable_interspersed_args()
-parser.add_option(""--python"", dest=""python"", default=False,
-                  action=""store_true"",
-                  help=""""""Activates extra features when the profiled executable is
-                  a Python program (currently: function timestamping.)"""""")
-parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.5"",
-                  type=""float"", action=""store"",
-                  help=""Sampling period (in seconds)"")
-parser.add_option(""--include-children"", ""-C"", dest=""include_children"", default=False,
-                  action=""store_true"",
-                  help=""""""Monitors forked processes as well (sum up all process memory)"""""")
+import memory_profiler as mp
 
-(options, args) = parser.parse_args()
-print(""{1}: Sampling memory every {0.interval}s"".format(options, osp.basename(sys.argv[0])))
 
-if len(args) == 0:
-    print(""A program to run must be provided. Use -h for help"")
-    sys.exit(1)
+def print_usage():
+    print(""Usage: %s <command> <options> <arguments>""
+          % osp.basename(sys.argv[0]))
 
-## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
-## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
-## directory. This file contains the process memory consumption, in Mb (one
-## value per line). Memory is sampled twice each second.""""""
-##           % osp.basename(sys.argv[0])
-##           )
-##     sys.exit(1)
+def get_action():
+    """"""Pop first argument, check it is a valid action.""""""
+    all_actions = (""run"", ""rm"", ""clean"", ""list"")
+    if len(sys.argv) <= 1:
+        print_usage()
+        sys.exit(1)
+    if not sys.argv[1] in all_actions:
+        print(""Valid actions are: "" + "" "".join(all_actions))
+        sys.exit(1)
 
-suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
-mprofile_output = ""mprofile_%s.dat"" % suffix
+    return sys.argv.pop(1)
+
+
+def get_profile_filenames(args):
+    """"""Return list of profile filenames.
+
+    Parameters
+    ==========
+    args (list)
+        list of filename or integer. An integer is the index of the
+        profile in the list of existing profiles. 0 is the oldest,
+        -1 in the more recent.
+        Non-existing files cause a ValueError exception to be thrown.
+
+    Returns
+    =======
+    filenames (list)
+        list of existing memory profile filenames. It is guaranteed
+        that an given file name will not appear twice in this list.
+    """"""
+    profiles = glob.glob(""mprofile_??????????????.dat"")
+    profiles.sort()
+
+    if args is ""all"":
+        filenames = copy.copy(profiles)
+    else:
+        filenames = []
+        for arg in args:
+            if arg == ""--"":  # workaround
+                continue
+            try:
+                index = int(arg)
+            except ValueError:
+                index = None
+            if index is not None:
+                try:
+                    filename = profiles[index]
+                except IndexError:
+                    raise ValueError(""Invalid index (non-existing file): %s"" % arg)
+
+                if filename not in filenames:
+                    filenames.append(filename)
+            else:
+                if osp.isfile(arg):
+                    if arg not in filenames:
+                        filenames.append(arg)
+                elif osp.isdir(arg):
+                    raise ValueError(""Path %s is a directory"" % arg)
+                else:
+                    raise ValueError(""File %s not found"" % arg)
+
+    # Add timestamp files, if any
+    for filename in reversed(filenames):
+        parts = osp.splitext(filename)
+        timestamp_file = parts[0] + ""_ts"" + parts[1]
+        if osp.isfile(timestamp_file) and timestamp_file not in filenames:
+            filenames.append(timestamp_file)
+
+    return filenames
+
+
+def list_action():
+    """"""Display existing profiles, with indices.""""""
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+
+    (options, args) = parser.parse_args()
+
+    if len(args) > 0:
+        print(""This command takes no argument."")
+        sys.exit(1)
+
+    filenames = get_profile_filenames(""all"")
+    for n, filename in enumerate(filenames):
+        ts = osp.splitext(filename)[0].split('_')[-1]
+        print(""{index} {filename} {hour}:{min}:{sec} {day}/{month}/{year}""
+              .format(index=n, filename=filename,
+                      year=ts[:4], month=ts[4:6], day=ts[6:8],
+                      hour=ts[8:10], min=ts[10:12], sec=ts[12:14]))
+
+
+def rm_action():
+    """"""TODO: merge with clean_action (@pgervais)""""""
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
+                      action=""store_true"",
+                      help=""""""Show what will be done, without actually doing it."""""")
+
+    (options, args) = parser.parse_args()
+
+    if len(args) == 0:
+        print(""A profile to remove must be provided (number or filename)"")
+        sys.exit(1)
+
+    filenames = get_profile_filenames(args)
+    if options.dry_run:
+        print(""Files to be removed: "")
+        for filename in filenames:
+            print(filename)
+    else:
+        for filename in filenames:
+            os.remove(filename)
+
+
+def clean_action():
+    """"""Remove every profile file in current directory.""""""
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
+                      action=""store_true"",
+                      help=""""""Show what will be done, without actually doing it."""""")
+
+    (options, args) = parser.parse_args()
+
+    if len(args) > 0:
+        print(""This command takes no argument."")
+        sys.exit(1)
+
+    filenames = get_profile_filenames(""all"")
+    if options.dry_run:
+        print(""Files to be removed: "")
+        for filename in filenames:
+            print(filename)
+    else:
+        for filename in filenames:
+            os.remove(filename)
+
+
+
+def run_action():
+    import time, subprocess
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+    parser.add_option(""--python"", dest=""python"", default=False,
+                      action=""store_true"",
+                      help=""""""Activates extra features when the profiled executable is
+                      a Python program (currently: function timestamping.)"""""")
+    parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.5"",
+                      type=""float"", action=""store"",
+                      help=""Sampling period (in seconds)"")
+    parser.add_option(""--include-children"", ""-C"", dest=""include_children"", default=False,
+                      action=""store_true"",
+                      help=""""""Monitors forked processes as well (sum up all process memory)"""""")
+
+    (options, args) = parser.parse_args()
+    print(""{1}: Sampling memory every {0.interval}s"".format(options, osp.basename(sys.argv[0])))
+
+    if len(args) == 0:
+        print(""A program to run must be provided. Use -h for help"")
+        sys.exit(1)
+
+    ## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
+    ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
+    ## directory. This file contains the process memory consumption, in Mb (one
+    ## value per line). Memory is sampled twice each second.""""""
+    ##           % osp.basename(sys.argv[0])
+    ##           )
+    ##     sys.exit(1)
+
+    suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
+    mprofile_output = ""mprofile_%s.dat"" % suffix
+
+    if options.python:
+        print(""running as a Python program..."")
+        if not args[0].startswith(""python""):
+            args.insert(0, ""python"")
+        args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
+                     ""-o"", mprofile_output)
+        p = subprocess.Popen(args)
+    else:
+        p = subprocess.Popen(args)
+
+    mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
+                         include_children=options.include_children)
+    with open(mprofile_output, ""a"") as f:
+        for m, t in mu:
+            f.write(""MEM {0:.6f} {1:.4f}"".format(m, t) + ""\n"")
+
+if __name__ == ""__main__"":
+    # Workaround for optparse limitation: insert -- before first negative number found.
+    negint = re.compile(""-[0-9]+"")
+    for n, arg in enumerate(sys.argv):
+        if negint.match(arg):
+            sys.argv.insert(n, ""--"")
+            break
+    actions = {""rm"": rm_action,
+               ""clean"": clean_action,
+               ""list"": list_action,
+               ""run"" : run_action}
+    actions[get_action()]()
 
-if options.python:
-    print(""running as a Python program..."")
-    if not args[0].startswith(""python""):
-        args.insert(0, ""python"")
-    args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
-                 ""-o"", mprofile_output)
-    p = subprocess.Popen(args)
-else:
-    p = subprocess.Popen(args)
 
-mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
-                     include_children=options.include_children)
-with open(mprofile_output, ""a"") as f:
-    for m, t in mu:
-        f.write(""MEM {0:.6f} {1:.4f}"".format(m, t) + ""\n"")
"
README.rst,README.rst,9bfd761d3ea9929716d94fa055edcad8d196b0c0,e8df9caf862b59d7b704b6318c068831275e632f,refactoring,"@@ -92,8 +92,11 @@ Executing external scripts
 ==========================
 Sometimes it is useful to have full memory usage reports as a function of
 time (not line-by-line) of external processess (be it Python scripts or not).
-In this case the executable ``mprof`` might be useful. To use it
+In this case the executable ``mprof`` might be useful. To use it like::
 
+    ./mprof run --python name_of_script.py
+
+TODO: make it work without the --python option.
 
 Setting debugger breakpoints
 =============================
"
mplot,,9bfd761d3ea9929716d94fa055edcad8d196b0c0,e8df9caf862b59d7b704b6318c068831275e632f,refactoring,"@@ -1,168 +0,0 @@
-#! /usr/bin/env python
-import sys
-
-try:
-    import pylab as pl
-except ImportError:
-    print(""matplotlib is needed for plotting."")
-    sys.exit(1)
-
-import numpy as np
-import math
-import glob
-import time
-import os
-import os.path as osp
-
-
-def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
-    """"""Add two brackets on the memory line plot.
-
-    This function uses the current figure.
-
-    Parameters
-    ==========
-    xloc: tuple with 2 values
-        brackets location (on horizontal axis).
-    yloc: tuple with 2 values
-        brackets location (on vertical axis)
-    xshift: float
-        value to subtract to xloc.
-    """"""
-
-    height_ratio = 20.
-    vsize = (pl.ylim()[1] - pl.ylim()[0]) / height_ratio
-    hsize = (pl.xlim()[1] - pl.xlim()[0]) / (3.*height_ratio)
-
-    bracket_x = pl.asarray([hsize, 0, 0, hsize])
-    bracket_y = pl.asarray([vsize, vsize, -vsize, -vsize])
-
-    # Matplotlib workaround: labels starting with _ aren't displayed
-    if label[0] == '_':
-        label = ' ' + label
-    pl.plot(bracket_x + xloc[0] - xshift, bracket_y + yloc[0],
-            ""-"" + color, linewidth=2, label=label)
-    pl.plot(-bracket_x + xloc[1] - xshift, bracket_y + yloc[1],
-            ""-"" + color, linewidth=2 )
-
-    # TODO: use matplotlib.patches.Polygon to draw a colored background for
-    # each function.
-
-    # with maplotlib 1.2, use matplotlib.path.Path to create proper markers
-    # see http://matplotlib.org/examples/pylab_examples/marker_path.html
-    # This works with matplotlib 0.99.1
-    ## pl.plot(xloc[0], yloc[0], ""<""+color, markersize=7, label=label)
-    ## pl.plot(xloc[1], yloc[1], "">""+color, markersize=7)
-
-
-def read_mprofile_file(filename):
-    ret = {}
-    mdata = []
-    f = open(filename, ""r"")
-    for l in f:
-        fields = l.split()
-        if fields[0] == ""MEM"":
-            # mem, timestamp
-            mdata.append((fields[1], fields[2]))
-
-        elif fields[0] == ""FUNC"":
-            f_name, mem_start, start, mem_end, end = fields[1:]
-            ts = ret.get(f_name, [])
-            ts.append([float(start), float(end), float(mem_start), float(mem_end)])
-            ret[f_name] = ts
-
-        else:
-            pass
-    f.close()
-
-    mdata = np.asarray(mdata,
-                       dtype=[(""mem"", np.float), (""timestamp"", np.float)])
-    return mdata, ret
-
-
-
-def plot_file(filename, index=0, timestamps=True):
-    mdata, ts = read_mprofile_file(filename)
-
-    global_start = float(mdata[""timestamp""][0])
-
-    mem = mdata[""mem""]
-    max_mem = mem.max()
-    max_mem_ind = mem.argmax()
-
-    t = mdata[""timestamp""] - global_start
-
-    all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
-    mem_line_colors=('k', ""b"", ""r"")
-    mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
-                                   time.localtime(global_start)) \
-                                   + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
-
-    pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
-            label=mem_line_label)
-
-    bottom, top = pl.ylim()
-    bottom += 0.001
-    top -= 0.001
-
-    # plot timestamps, if any
-    if len(ts) > 0 and timestamps:
-        func_num = 0
-        for f, exec_ts in ts.iteritems():
-            for execution in exec_ts:
-                add_brackets(execution[:2], execution[2:], xshift=global_start,
-                             color= all_colors[func_num % len(all_colors)],
-                             label=f.split(""."")[-1]
-                             + "" %.3fs"" % (execution[1] - execution[0]))
-            func_num += 1
-
-    if timestamps:
-        pl.hlines(max_mem,
-                  pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
-                  colors=""r"", linestyles=""--"")
-        pl.vlines(t[max_mem_ind], bottom, top,
-                  colors=""r"", linestyles=""--"")
-
-
-if __name__ == ""__main__"":
-    profiles = glob.glob(""mprofile_??????????????.dat"")
-    profiles.sort()
-
-    if len(sys.argv) == 1:
-        if len(profiles) == 0:
-            print(""No input file found. \nThis program looks for ""
-                  ""mprofile_*.dat files, generated by the mprofile command."")
-            sys.exit(-1)
-        filenames = [profiles[-1]]
-    else:
-        filenames = []
-        for arg in sys.argv[1:]:
-            if osp.exists(arg):
-                if not arg in filenames:
-                    filenames.append(arg)
-            else:
-                try:
-                    n = int(arg)
-                except ValueError:
-                    print(""Input file not found: "" + arg)
-                if not profiles[n] in filenames:
-                    filenames.append(profiles[n])
-
-    pl.figure(figsize=(14, 6), dpi=90)
-    if len(filenames) > 1:
-        timestamps = False
-    else:
-        timestamps = True
-    for n, filename in enumerate(filenames):
-        plot_file(filename, index=n, timestamps=timestamps)
-    pl.xlabel(""time [s]"")
-    pl.ylabel(""memory used [MB]"")
-
-    ax = pl.gca()
-    box = ax.get_position()
-    ax.set_position([0.07, 0.1,
-                     0.55, 0.8])
-    ax.legend(loc=""upper left"", bbox_to_anchor=(1.05, 1.))
-    pl.grid()
-    pl.show()
-
"
mprof,mprof,9bfd761d3ea9929716d94fa055edcad8d196b0c0,e8df9caf862b59d7b704b6318c068831275e632f,refactoring,"@@ -6,6 +6,8 @@ import os.path as osp
 import sys
 import re
 import copy
+import time
+import math
 
 from optparse import OptionParser
 
@@ -18,7 +20,7 @@ def print_usage():
 
 def get_action():
     """"""Pop first argument, check it is a valid action.""""""
-    all_actions = (""run"", ""rm"", ""clean"", ""list"")
+    all_actions = (""run"", ""rm"", ""clean"", ""list"", ""plot"")
     if len(sys.argv) <= 1:
         print_usage()
         sys.exit(1)
@@ -164,7 +166,7 @@ def run_action():
                       action=""store_true"",
                       help=""""""Activates extra features when the profiled executable is
                       a Python program (currently: function timestamping.)"""""")
-    parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.5"",
+    parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.1"",
                       type=""float"", action=""store"",
                       help=""Sampling period (in seconds)"")
     parser.add_option(""--include-children"", ""-C"", dest=""include_children"", default=False,
@@ -205,6 +207,177 @@ def run_action():
         for m, t in mu:
             f.write(""MEM {0:.6f} {1:.4f}"".format(m, t) + ""\n"")
 
+
+
+def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
+    """"""Add two brackets on the memory line plot.
+
+    This function uses the current figure.
+
+    Parameters
+    ==========
+    xloc: tuple with 2 values
+        brackets location (on horizontal axis).
+    yloc: tuple with 2 values
+        brackets location (on vertical axis)
+    xshift: float
+        value to subtract to xloc.
+    """"""
+    try:
+        import pylab as pl
+    except ImportError:
+        print(""matplotlib is needed for plotting."")
+        sys.exit(1)
+    height_ratio = 20.
+    vsize = (pl.ylim()[1] - pl.ylim()[0]) / height_ratio
+    hsize = (pl.xlim()[1] - pl.xlim()[0]) / (3.*height_ratio)
+
+    bracket_x = pl.asarray([hsize, 0, 0, hsize])
+    bracket_y = pl.asarray([vsize, vsize, -vsize, -vsize])
+
+    # Matplotlib workaround: labels starting with _ aren't displayed
+    if label[0] == '_':
+        label = ' ' + label
+    pl.plot(bracket_x + xloc[0] - xshift, bracket_y + yloc[0],
+            ""-"" + color, linewidth=2, label=label)
+    pl.plot(-bracket_x + xloc[1] - xshift, bracket_y + yloc[1],
+            ""-"" + color, linewidth=2 )
+
+    # TODO: use matplotlib.patches.Polygon to draw a colored background for
+    # each function.
+
+    # with maplotlib 1.2, use matplotlib.path.Path to create proper markers
+    # see http://matplotlib.org/examples/pylab_examples/marker_path.html
+    # This works with matplotlib 0.99.1
+    ## pl.plot(xloc[0], yloc[0], ""<""+color, markersize=7, label=label)
+    ## pl.plot(xloc[1], yloc[1], "">""+color, markersize=7)
+
+
+def read_mprofile_file(filename):
+    # TODO: would be nice to do without numpy
+
+    import numpy as np
+    ret = {}
+    mdata = []
+    f = open(filename, ""r"")
+    for l in f:
+        fields = l.split()
+        if fields[0] == ""MEM"":
+            # mem, timestamp
+            mdata.append((fields[1], fields[2]))
+
+        elif fields[0] == ""FUNC"":
+            f_name, mem_start, start, mem_end, end = fields[1:]
+            ts = ret.get(f_name, [])
+            ts.append([float(start), float(end), float(mem_start), float(mem_end)])
+            ret[f_name] = ts
+
+        else:
+            pass
+    f.close()
+
+    mdata = np.asarray(mdata,
+                       dtype=[(""mem"", np.float), (""timestamp"", np.float)])
+    return mdata, ret
+
+
+
+def plot_file(filename, index=0, timestamps=True):
+    try:
+        import pylab as pl
+    except ImportError:
+        print(""matplotlib is needed for plotting."")
+        sys.exit(1)
+
+    mdata, ts = read_mprofile_file(filename)
+
+    global_start = float(mdata[""timestamp""][0])
+
+    mem = mdata[""mem""]
+    max_mem = mem.max()
+    max_mem_ind = mem.argmax()
+
+    t = mdata[""timestamp""] - global_start
+
+    all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
+    mem_line_colors=('k', ""b"", ""r"")
+    mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
+                                   time.localtime(global_start)) \
+                                   + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
+
+    pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
+            label=mem_line_label)
+
+    bottom, top = pl.ylim()
+    bottom += 0.001
+    top -= 0.001
+
+    # plot timestamps, if any
+    if len(ts) > 0 and timestamps:
+        func_num = 0
+        for f, exec_ts in ts.iteritems():
+            for execution in exec_ts:
+                add_brackets(execution[:2], execution[2:], xshift=global_start,
+                             color= all_colors[func_num % len(all_colors)],
+                             label=f.split(""."")[-1]
+                             + "" %.3fs"" % (execution[1] - execution[0]))
+            func_num += 1
+
+    if timestamps:
+        pl.hlines(max_mem,
+                  pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
+                  colors=""r"", linestyles=""--"")
+        pl.vlines(t[max_mem_ind], bottom, top,
+                  colors=""r"", linestyles=""--"")
+
+def plot_action():
+    try:
+        import pylab as pl
+    except ImportError:
+        print(""matplotlib is needed for plotting."")
+        sys.exit(1)
+
+    profiles = glob.glob(""mprofile_??????????????.dat"")
+    profiles.sort()
+
+    if len(sys.argv) == 1:
+        if len(profiles) == 0:
+            print(""No input file found. \nThis program looks for ""
+                  ""mprofile_*.dat files, generated by the mprofile command."")
+            sys.exit(-1)
+        filenames = [profiles[-1]]
+    else:
+        filenames = []
+        for arg in sys.argv[1:]:
+            if osp.exists(arg):
+                if not arg in filenames:
+                    filenames.append(arg)
+            else:
+                try:
+                    n = int(arg)
+                except ValueError:
+                    print(""Input file not found: "" + arg)
+                if not profiles[n] in filenames:
+                    filenames.append(profiles[n])
+
+    pl.figure(figsize=(14, 6), dpi=90)
+    if len(filenames) > 1:
+        timestamps = False
+    else:
+        timestamps = True
+    for n, filename in enumerate(filenames):
+        plot_file(filename, index=n, timestamps=timestamps)
+    pl.xlabel(""time [s]"")
+    pl.ylabel(""memory used [MB]"")
+
+    ax = pl.gca()
+    box = ax.get_position()
+    ax.set_position([0.07, 0.1,
+                     0.55, 0.8])
+    ax.legend(loc=""upper left"", bbox_to_anchor=(1.05, 1.))
+    pl.grid()
+    pl.show()
+
 if __name__ == ""__main__"":
     # Workaround for optparse limitation: insert -- before first negative number found.
     negint = re.compile(""-[0-9]+"")
@@ -215,7 +388,6 @@ if __name__ == ""__main__"":
     actions = {""rm"": rm_action,
                ""clean"": clean_action,
                ""list"": list_action,
-               ""run"" : run_action}
+               ""run"": run_action,
+               ""plot"": plot_action}
     actions[get_action()]()
-
-
"
memory_profiler.py,memory_profiler.py,9e79e9293fa7eab9223f8535e040bb02206d3810,9bfd761d3ea9929716d94fa055edcad8d196b0c0,BUG: make it work on OSX 10.8,"@@ -67,12 +67,13 @@ def _get_memory(pid, timestamps=False, include_children=False):
             if include_children:
                 for p in process.get_children(recursive=True):
                     mem += p.get_memory_info()[0] / (_TWO_20)
+            if timestamps:
+                return (mem, time.time())
+            else:
+                return mem
         except psutil.AccessDenied:
-            mem = -1
-        if timestamps:
-            return (mem, time.time())
-        else:
-            return mem
+            pass
+            # continue and try to get this from ps
 
     # .. scary stuff ..
     if os.name == 'posix':
"
memory_profiler.py,memory_profiler.py,6fed905b88f819d7b197a0cfff00b494619f62b7,9e79e9293fa7eab9223f8535e040bb02206d3810,STY: pep8 and related fixes,"@@ -7,7 +7,10 @@ __version__ = '0.27'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
-import time, sys, os, pdb
+import time
+import sys
+import os
+import pdb
 import warnings
 import linecache
 import inspect
@@ -44,14 +47,16 @@ if sys.platform == 'darwin':
     # ... it seems that in OSX the output is different units ...
     rusage_denom = rusage_denom * rusage_denom
 
+
 def _get_memory(pid, timestamps=False, include_children=False):
 
     # .. only for current process and only on unix..
     if pid == -1:
         # .. seems to get wrong measurements on some cases, see ..
         # .. https://github.com/fabianp/memory_profiler/issues/52 ..
-        if False: #has_resource:
-            mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / rusage_denom
+        if False:  # has_resource:
+            mem = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss /
+                   rusage_denom)
             if timestamps:
                 return (mem, time.time())
             else:
@@ -77,25 +82,25 @@ def _get_memory(pid, timestamps=False, include_children=False):
 
     # .. scary stuff ..
     if os.name == 'posix':
-            warnings.warn(""psutil module not found. memory_profiler will be slow"")
-            # ..
-            # .. memory usage in MB ..
-            # .. this should work on both Mac and Linux ..
-            # .. subprocess.check_output appeared in 2.7, using Popen ..
-            # .. for backwards compatibility ..
-            out = subprocess.Popen(['ps', 'v', '-p', str(pid)],
-                  stdout=subprocess.PIPE).communicate()[0].split(b'\n')
-            try:
-                vsz_index = out[0].split().index(b'RSS')
-                mem = float(out[1].split()[vsz_index]) / 1024
-                if timestamps:
-                    return(mem, time.time())
-                else:
-                    return mem
-            except:
-                if timestamps:
-                    return (-1, time.time())
-                else:
+        warnings.warn(""psutil module not found. memory_profiler will be slow"")
+        # ..
+        # .. memory usage in MB ..
+        # .. this should work on both Mac and Linux ..
+        # .. subprocess.check_output appeared in 2.7, using Popen ..
+        # .. for backwards compatibility ..
+        out = subprocess.Popen(['ps', 'v', '-p', str(pid)],
+              stdout=subprocess.PIPE).communicate()[0].split(b'\n')
+        try:
+            vsz_index = out[0].split().index(b'RSS')
+            mem = float(out[1].split()[vsz_index]) / 1024
+            if timestamps:
+                return(mem, time.time())
+            else:
+                return mem
+        except:
+            if timestamps:
+                return (-1, time.time())
+            else:
                     return -1
     else:
         raise NotImplementedError('The psutil module is required for non-unix '
@@ -106,8 +111,8 @@ class Timer(Process):
     """"""
     Fetch memory consumption from over a time interval
     """"""
-
-    def __init__(self, monitor_pid, interval, pipe, max_usage=False, *args, **kw):
+    def __init__(self, monitor_pid, interval, pipe, max_usage=False,
+                 *args, **kw):
         self.monitor_pid = monitor_pid
         self.interval = interval
         self.pipe = pipe
@@ -213,9 +218,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         if aspec.defaults is not None:
             n_args -= len(aspec.defaults)
         if n_args != len(args):
-            raise ValueError(
-                'Function expects %s value(s) but %s where given'
-                % (n_args, len(args)))
+            raise ValueError('Function expects %s value(s) but %s where given'
+                             % (n_args, len(args)))
 
         child_conn, parent_conn = Pipe()  # this will store Timer's results
         p = Timer(os.getpid(), interval, child_conn, timestamps=timestamps,
@@ -266,6 +270,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 # ..
 # .. utility functions for line-by-line ..
 
+
 def _find_script(script_name):
     """""" Find the script.
 
@@ -275,7 +280,7 @@ def _find_script(script_name):
         return script_name
     path = os.getenv('PATH', os.defpath).split(os.pathsep)
     for folder in path:
-        if folder == '':
+        if not folder:
             continue
         fn = os.path.join(folder, script_name)
         if os.path.isfile(fn):
@@ -387,7 +392,7 @@ class LineProfiler:
         except AttributeError:
             import warnings
             warnings.warn(""Could not extract a code object for the object %r""
-                          % (func,))
+                          % func)
             return
         if code not in self.code_map:
             self.code_map[code] = {}
@@ -455,8 +460,8 @@ class LineProfiler:
         if event in ('line', 'return') and frame.f_code in self.code_map:
             c = _get_memory(-1)
             if c >= self.max_mem:
-                t = 'Current memory {0:.2f} MB exceeded the maximum '.format(c) + \
-                    'of {0:.2f} MB\n'.format(self.max_mem)
+                t = ('Current memory {0:.2f} MB exceeded the maximum'
+                     ''.format(c) + 'of {0:.2f} MB\n'.format(self.max_mem))
                 sys.stdout.write(t)
                 sys.stdout.write('Stepping into the debugger \n')
                 frame.f_lineno -= 2
@@ -503,7 +508,8 @@ def show_results(prof, stream=None, precision=3):
         stream.write('Filename: ' + filename + '\n\n')
         if not os.path.exists(filename):
             stream.write('ERROR: Could not find file ' + filename + '\n')
-            if filename.startswith(""ipython-input"") or filename.startswith(""<ipython-input""):
+            if any([filename.startswith(k) for k in
+                    (""ipython-input"", ""<ipython-input"")]):
                 print(""NOTE: %mprun can only be used on functions defined in ""
                       ""physical files, and not in the IPython environment."")
             continue
@@ -582,7 +588,7 @@ def magic_mprun(self, parameter_s=''):
     """"""
     try:
         from StringIO import StringIO
-    except ImportError: # Python 3.x
+    except ImportError:  # Python 3.x
         from io import StringIO
 
     # Local imports to avoid hard dependency.
@@ -678,6 +684,8 @@ def _func_exec(stmt, ns):
     exec(stmt, ns)
 
 # a timeit-style %memit magic for IPython
+
+
 def magic_memit(self, line=''):
     """"""Measure memory usage of a Python statement
 
@@ -729,7 +737,8 @@ def magic_memit(self, line=''):
     if mem_usage:
         print('maximum of %d: %f MB per loop' % (repeat, max(mem_usage)))
     else:
-        print('ERROR: could not read memory usage, try with a lower interval or more iterations')
+        print('ERROR: could not read memory usage, try with a lower interval '
+              'or more iterations')
 
 
 def load_ipython_extension(ip):
@@ -789,13 +798,13 @@ if __name__ == '__main__':
             import __builtin__
             __builtin__.__dict__['profile'] = prof
             ns = copy(_clean_globals)
-            ns['profile'] = prof # shadow the profile decorator defined above
+            ns['profile'] = prof  # shadow the profile decorator defined above
             execfile(__file__, ns, ns)
         else:
             import builtins
             builtins.__dict__['profile'] = prof
             ns = copy(_clean_globals)
-            ns['profile'] = prof # shadow the profile decorator defined above
+            ns['profile'] = prof  # shadow the profile decorator defined above
             exec(compile(open(__file__).read(), __file__, 'exec'), ns, ns)
     finally:
         if options.out_filename is not None:
"
mprof,mprof,d851f99d144cb0bb64948c213fe12c6453a55c49,f2b2550bdaa24b174c6101f819e0dac6ab4654b5,Fixed parameters handling on 'mprof plot',"@@ -169,12 +169,13 @@ def run_action():
     parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.1"",
                       type=""float"", action=""store"",
                       help=""Sampling period (in seconds)"")
-    parser.add_option(""--include-children"", ""-C"", dest=""include_children"", default=False,
-                      action=""store_true"",
+    parser.add_option(""--include-children"", ""-C"", dest=""include_children"",
+                      default=False, action=""store_true"",
                       help=""""""Monitors forked processes as well (sum up all process memory)"""""")
 
     (options, args) = parser.parse_args()
-    print(""{1}: Sampling memory every {0.interval}s"".format(options, osp.basename(sys.argv[0])))
+    print(""{1}: Sampling memory every {0.interval}s"".format(
+        options, osp.basename(sys.argv[0])))
 
     if len(args) == 0:
         print(""A program to run must be provided. Use -h for help"")
@@ -184,9 +185,6 @@ def run_action():
     ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
     ## directory. This file contains the process memory consumption, in Mb (one
     ## value per line). Memory is sampled twice each second.""""""
-    ##           % osp.basename(sys.argv[0])
-    ##           )
-    ##     sys.exit(1)
 
     suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
     mprofile_output = ""mprofile_%s.dat"" % suffix
@@ -348,7 +346,7 @@ def plot_action():
         filenames = [profiles[-1]]
     else:
         filenames = []
-        for arg in sys.argv[1:]:
+        for arg in sys.argv[2:]:
             if osp.exists(arg):
                 if not arg in filenames:
                     filenames.append(arg)
"
memory_profiler.py,memory_profiler.py,55d975445327a742f953133bd4721ce176846cf1,02f33b17f5f1863fb8d7311cf72b577df34e880c,remove code that uses the resource module (unused code),"@@ -26,7 +26,6 @@ except ImportError:
 _TWO_20 = float(2 ** 20)
 
 has_psutil = False
-has_resource = False
 
 # .. get available packages ..
 try:
@@ -35,43 +34,21 @@ try:
 except ImportError:
     pass
 
-try:
-    import resource
-    has_resource = True
-except ImportError:
-    pass
-
-# divide resource.getrusage() by rusage_denom to get MB
-rusage_denom = 1024.
-if sys.platform == 'darwin':
-    # ... it seems that in OSX the output is different units ...
-    rusage_denom = rusage_denom * rusage_denom
-
 
 def _get_memory(pid, timestamps=False, include_children=False):
 
     # .. only for current process and only on unix..
     if pid == -1:
-        # .. seems to get wrong measurements on some cases, see ..
-        # .. https://github.com/fabianp/memory_profiler/issues/52 ..
-        if False:  # has_resource:
-            mem = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss /
-                   rusage_denom)
-            if timestamps:
-                return (mem, time.time())
-            else:
-                return mem
-        else:
-            pid = os.getpid()
+        pid = os.getpid()
 
     # .. cross-platform but but requires psutil ..
     if has_psutil:
         process = psutil.Process(pid)
         try:
-            mem = process.get_memory_info()[0] / (_TWO_20)
+            mem = process.get_memory_info()[0] / _TWO_20
             if include_children:
                 for p in process.get_children(recursive=True):
-                    mem += p.get_memory_info()[0] / (_TWO_20)
+                    mem += p.get_memory_info()[0] / _TWO_20
             if timestamps:
                 return (mem, time.time())
             else:
"
README.rst,README.rst,8d4d71859fbf46c3016570151f7ed6fbd112a3ab,55d975445327a742f953133bd4721ce176846cf1,Added documentation for the 'mprof' script,"@@ -91,12 +91,57 @@ memory_profiler`` in the command line.
 Executing external scripts
 ==========================
 Sometimes it is useful to have full memory usage reports as a function of
-time (not line-by-line) of external processess (be it Python scripts or not).
-In this case the executable ``mprof`` might be useful. To use it like::
+time (not line-by-line) of external processes (be it Python scripts or not).
+In this case the executable ``mprof`` might be useful. Use it like::
 
-    ./mprof run --python name_of_script.py
+    mprof run <executable>
+    mprof plot
 
-TODO: make it work without the --python option.
+The first line run the executable and record memory usage along time,
+in a file written in the current directory.
+Once it's done, a graph plot can be obtained using the second line.
+The recorded file contains a timestamps, that allows for several
+profiles to be kept at the same time.
+
+Help on each `mprof` subcommand can be obtained with the `-h` flag,
+e.g. `mprof run -h`.
+
+In the case of a Python script, using the previous command does not
+give you any information on which function is executed at a given
+time. Depending on the case, it can be difficult to identify the part
+of the code that is causing the highest memory usage. 
+
+Adding the `profile` decorator to a function and running the Python
+script with 
+
+    mprof run --python <script>
+
+will record timestamps when entering/leaving the profiled function,
+and plot them on the graph afterward. 
+An example output can be found 
+`here <https://github.com/scikit-learn/scikit-learn/pull/2248>`_
+
+It is also possible to timestamp a portion of code using a context
+manager like this::
+
+    def my_func():
+        a = [1] * (10 ** 6)
+        with profile.timestamp(""b_computation""):
+            b = [2] * (2 * 10 ** 7)
+        del b
+        return a
+
+the string provided in the call will be displayed in the plot.
+
+The available commands for `mprof` are: 
+
+  - ``mprof run``: running an executable, recording memory usage  
+  - ``mprof plot``: plotting one the recorded memory usage (by default,
+    the last one)
+  - ``mprof list``: listing all recorded memory usage files in a
+    user-friendly way.
+  - ``mprof clean``: removing all recorded memory usage files.
+  - ``mprof rm``: removing specific recorded memory usage files
 
 Setting debugger breakpoints
 =============================
"
README.rst,README.rst,5752f3e1b522a00e88cf13f1651054a18eb818dd,8d4d71859fbf46c3016570151f7ed6fbd112a3ab,"Updated some information, fixed a typo.","@@ -328,8 +328,8 @@ cleanup.
 
 `Thomas Kluyver <https://github.com/takluyver>`_ added the IPython extension.
 
-Philippe Gervais made several enhacements and bug fixes.
-
+`Philippe Gervais <https://github.com/pgervais>`_ created the 'mprof'
+script and fixed bugs. 
 
 
 =========
"
mprof,mprof,adca2ed6ec160a3f35a00a9465b689158d742ca8,318694d32e4d1a748388e39cbab465024df87b64,FIX: shebang line,"@@ -1,4 +1,4 @@
-#! /usr/bin/env python
+#!/usr/bin/env python
 
 import glob
 import os
"
mprof,mprof,03ff6c0b9eb907152ba97bc6ecbcb83a3e5b0610,adca2ed6ec160a3f35a00a9465b689158d742ca8,Detect if it's a Python file and add the --python option automatically.,"@@ -189,6 +189,9 @@ def run_action():
     suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
     mprofile_output = ""mprofile_%s.dat"" % suffix
 
+    # .. TODO: more than one script as argument ? ..
+    if args[0].endswith('.py'):
+        options.python = True
     if options.python:
         print(""running as a Python program..."")
         if not args[0].startswith(""python""):
"
mprof,mprof,205ec4fa558971d4fdf950fef1599583de2ad63c,03ff6c0b9eb907152ba97bc6ecbcb83a3e5b0610,Add the option --nopython,"@@ -166,6 +166,10 @@ def run_action():
                       action=""store_true"",
                       help=""""""Activates extra features when the profiled executable is
                       a Python program (currently: function timestamping.)"""""")
+    parser.add_option(""--nopython"", dest=""nopython"", default=False,
+                      action=""store_true"",
+                      help=""""""Disables extra features when the profiled executable is
+                      a Python program (currently: function timestamping.)"""""")
     parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.1"",
                       type=""float"", action=""store"",
                       help=""Sampling period (in seconds)"")
@@ -190,7 +194,7 @@ def run_action():
     mprofile_output = ""mprofile_%s.dat"" % suffix
 
     # .. TODO: more than one script as argument ? ..
-    if args[0].endswith('.py'):
+    if args[0].endswith('.py') and not options.nopython:
         options.python = True
     if options.python:
         print(""running as a Python program..."")
"
examples/numpy_example.py,examples/numpy_example.py,e1f143f37b84c0eb035e37a546903d465ed389b8,205ec4fa558971d4fdf950fef1599583de2ad63c,MB -> MiB. Thanks @ovillellas for reporting!,"@@ -2,7 +2,7 @@ import numpy as np
 import scipy.signal
 
 
-#@profile
+@profile
 def create_data():
     ret = []
     for n in xrange(70):
@@ -10,7 +10,7 @@ def create_data():
     return ret
 
 
-#@profile
+@profile
 def process_data(data):
     data = np.concatenate(data)
     detrended = scipy.signal.detrend(data, axis=0)
@@ -20,4 +20,3 @@ def process_data(data):
 if __name__ == ""__main__"":
     data1 = create_data()
     data2 = process_data(data1)
-    print (data2.shape)
"
memory_profiler.py,memory_profiler.py,e1f143f37b84c0eb035e37a546903d465ed389b8,205ec4fa558971d4fdf950fef1599583de2ad63c,MB -> MiB. Thanks @ovillellas for reporting!,"@@ -61,7 +61,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
     if os.name == 'posix':
         warnings.warn(""psutil module not found. memory_profiler will be slow"")
         # ..
-        # .. memory usage in MB ..
+        # .. memory usage in MiB ..
         # .. this should work on both Mac and Linux ..
         # .. subprocess.check_output appeared in 2.7, using Popen ..
         # .. for backwards compatibility ..
@@ -159,7 +159,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     Returns
     -------
     mem_usage : list of floating-poing values
-        memory usage, in MB. It's length is always < timeout / interval
+        memory usage, in MiB. It's length is always < timeout / interval
     ret : return value of the profiled function
         Only returned if retval is set to True
     """"""
@@ -437,8 +437,8 @@ class LineProfiler:
         if event in ('line', 'return') and frame.f_code in self.code_map:
             c = _get_memory(-1)
             if c >= self.max_mem:
-                t = ('Current memory {0:.2f} MB exceeded the maximum'
-                     ''.format(c) + 'of {0:.2f} MB\n'.format(self.max_mem))
+                t = ('Current memory {0:.2f} MiB exceeded the maximum'
+                     ''.format(c) + 'of {0:.2f} MiB\n'.format(self.max_mem))
                 sys.stdout.write(t)
                 sys.stdout.write('Stepping into the debugger \n')
                 frame.f_lineno -= 2
@@ -519,7 +519,7 @@ def show_results(prof, stream=None, precision=3):
         first_line = sorted(lines_normalized.keys())[0]
         mem_old = max(lines_normalized[first_line])
         precision = int(precision)
-        template_mem = '{{0:{0}.{1}'.format(precision + 6, precision) + 'f} MB'
+        template_mem = '{{0:{0}.{1}'.format(precision + 6, precision) + 'f} MiB'
         for i, l in enumerate(linenos):
             mem = ''
             inc = ''
@@ -685,13 +685,13 @@ def magic_memit(self, line=''):
       In [1]: import numpy as np
 
       In [2]: %memit np.zeros(1e7)
-      maximum of 1: 76.402344 MB per loop
+      maximum of 1: 76.402344 MiB per loop
 
       In [3]: %memit np.ones(1e6)
-      maximum of 1: 7.820312 MB per loop
+      maximum of 1: 7.820312 MiB per loop
 
       In [4]: %memit -r 10 np.empty(1e8)
-      maximum of 10: 0.101562 MB per loop
+      maximum of 10: 0.101562 MiB per loop
 
     """"""
     opts, stmt = self.parse_options(line, 'r:t:i:', posix=False, strict=False)
@@ -712,7 +712,7 @@ def magic_memit(self, line=''):
         mem_usage.extend(tmp)
 
     if mem_usage:
-        print('maximum of %d: %f MB per loop' % (repeat, max(mem_usage)))
+        print('maximum of %d: %f MiB per loop' % (repeat, max(mem_usage)))
     else:
         print('ERROR: could not read memory usage, try with a lower interval '
               'or more iterations')
"
mprof,mprof,e1f143f37b84c0eb035e37a546903d465ed389b8,205ec4fa558971d4fdf950fef1599583de2ad63c,MB -> MiB. Thanks @ovillellas for reporting!,"@@ -372,8 +372,8 @@ def plot_action():
         timestamps = True
     for n, filename in enumerate(filenames):
         plot_file(filename, index=n, timestamps=timestamps)
-    pl.xlabel(""time [s]"")
-    pl.ylabel(""memory used [MB]"")
+    pl.xlabel(""time (in seconds)"")
+    pl.ylabel(""memory used (in MiB)"")
 
     ax = pl.gca()
     box = ax.get_position()
"
memory_profiler.py,memory_profiler.py,9f89fad064deead5ac99d00bd7bce874be302da7,e1f143f37b84c0eb035e37a546903d465ed389b8,Tighter space in printed output,"@@ -469,7 +469,7 @@ class LineProfiler:
         sys.settrace(None)
 
 
-def show_results(prof, stream=None, precision=3):
+def show_results(prof, stream=None, precision=1):
     if stream is None:
         stream = sys.stdout
     template = '{0:>6} {1:>12} {2:>12}   {3:<}'
@@ -519,7 +519,7 @@ def show_results(prof, stream=None, precision=3):
         first_line = sorted(lines_normalized.keys())[0]
         mem_old = max(lines_normalized[first_line])
         precision = int(precision)
-        template_mem = '{{0:{0}.{1}'.format(precision + 6, precision) + 'f} MiB'
+        template_mem = '{{0:{0}.{1}'.format(precision + 4, precision) + 'f} MiB'
         for i, l in enumerate(linenos):
             mem = ''
             inc = ''
"
mprof,mprof,a981185ff077c7cd3095a0b37f8d26ffce53792d,9f89fad064deead5ac99d00bd7bce874be302da7,"Added --title option to 'mprof plot'

This option allows to set the title of figures created by 'mprof plot'.","@@ -335,6 +335,7 @@ def plot_file(filename, index=0, timestamps=True):
         pl.vlines(t[max_mem_ind], bottom, top,
                   colors=""r"", linestyles=""--"")
 
+
 def plot_action():
     try:
         import pylab as pl
@@ -342,18 +343,26 @@ def plot_action():
         print(""matplotlib is needed for plotting."")
         sys.exit(1)
 
+    parser = OptionParser(version=mp.__version__)
+    parser.disable_interspersed_args()
+    parser.add_option(""--title"", ""-t"", dest=""title"", default="""",
+                      type=""str"", action=""store"",
+                      help=""String shown as plot title"")
+    (options, args) = parser.parse_args()
+
     profiles = glob.glob(""mprofile_??????????????.dat"")
     profiles.sort()
 
-    if len(sys.argv) == 1:
+    if len(args) == 0:
         if len(profiles) == 0:
             print(""No input file found. \nThis program looks for ""
-                  ""mprofile_*.dat files, generated by the mprofile command."")
+                  ""mprofile_*.dat files, generated by the ""
+                  ""'mprof run' command."")
             sys.exit(-1)
         filenames = [profiles[-1]]
     else:
         filenames = []
-        for arg in sys.argv[2:]:
+        for arg in args:
             if osp.exists(arg):
                 if not arg in filenames:
                     filenames.append(arg)
@@ -374,7 +383,7 @@ def plot_action():
         plot_file(filename, index=n, timestamps=timestamps)
     pl.xlabel(""time (in seconds)"")
     pl.ylabel(""memory used (in MiB)"")
-
+    pl.title(options.title)
     ax = pl.gca()
     box = ax.get_position()
     ax.set_position([0.07, 0.1,
@@ -384,7 +393,8 @@ def plot_action():
     pl.show()
 
 if __name__ == ""__main__"":
-    # Workaround for optparse limitation: insert -- before first negative number found.
+    # Workaround for optparse limitation: insert -- before first negative
+    # number found.
     negint = re.compile(""-[0-9]+"")
     for n, arg in enumerate(sys.argv):
         if negint.match(arg):
"
mprof,mprof,78d4ef9f288d0f2be02059fd286e307cc9da7f61,a981185ff077c7cd3095a0b37f8d26ffce53792d,"Got rid of numpy is read_mprofile_file

Numpy is still required for plotting, but only when pylab is used.","@@ -259,31 +259,46 @@ def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
 
 
 def read_mprofile_file(filename):
-    # TODO: would be nice to do without numpy
+    """"""Read an mprofile file and return its content.
 
-    import numpy as np
-    ret = {}
-    mdata = []
+    Returns
+    =======
+    content: dict
+        Keys:
+
+        - ""mem_usage"": (list) memory usage values, in MiB
+        - ""timestamp"": (list) time instant for each memory usage value, in
+            second
+        - ""func_timestamp"": (dict) for each function, timestamps and memory
+            usage upon entering and exiting.
+    """"""
+#    import numpy as np
+    func_ts = {}
+    mem_usage = []
+    timestamp = []
     f = open(filename, ""r"")
     for l in f:
         fields = l.split()
         if fields[0] == ""MEM"":
             # mem, timestamp
-            mdata.append((fields[1], fields[2]))
+            mem_usage.append(float(fields[1]))
+            timestamp.append(float(fields[2]))
 
         elif fields[0] == ""FUNC"":
             f_name, mem_start, start, mem_end, end = fields[1:]
-            ts = ret.get(f_name, [])
-            ts.append([float(start), float(end), float(mem_start), float(mem_end)])
-            ret[f_name] = ts
+            ts = func_ts.get(f_name, [])
+            ts.append([float(start), float(end),
+                       float(mem_start), float(mem_end)])
+            func_ts[f_name] = ts
 
         else:
             pass
     f.close()
 
-    mdata = np.asarray(mdata,
-                       dtype=[(""mem"", np.float), (""timestamp"", np.float)])
-    return mdata, ret
+    ## mdata = np.asarray(mdata,
+    ##                    dtype=[(""mem"", np.float), (""timestamp"", np.float)])
+    return {""mem_usage"": mem_usage, ""timestamp"": timestamp,
+            ""func_timestamp"": func_ts}
 
 
 
@@ -293,16 +308,16 @@ def plot_file(filename, index=0, timestamps=True):
     except ImportError:
         print(""matplotlib is needed for plotting."")
         sys.exit(1)
+    import numpy as np  # pylab requires numpy anyway
+    mprofile = read_mprofile_file(filename)
 
-    mdata, ts = read_mprofile_file(filename)
+    global_start = float(mprofile[""timestamp""][0])
 
-    global_start = float(mdata[""timestamp""][0])
-
-    mem = mdata[""mem""]
+    mem = np.asarray(mprofile[""mem_usage""])
     max_mem = mem.max()
     max_mem_ind = mem.argmax()
 
-    t = mdata[""timestamp""] - global_start
+    t = np.asarray(mprofile[""timestamp""]) - global_start
 
     all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
     mem_line_colors=('k', ""b"", ""r"")
@@ -318,6 +333,7 @@ def plot_file(filename, index=0, timestamps=True):
     top -= 0.001
 
     # plot timestamps, if any
+    ts = mprofile['func_timestamp']
     if len(ts) > 0 and timestamps:
         func_num = 0
         for f, exec_ts in ts.iteritems():
"
mprof,mprof,b4bbce73c438f9e343b228c9bcd45703ce15fac0,78d4ef9f288d0f2be02059fd286e307cc9da7f61,"Proper handling of empty profile files

When interrupting ""mprof run"", an empty file can be generated, which
caused problem with ""mprof plot"". A clear error message is now displayed
to the user.","@@ -272,7 +272,6 @@ def read_mprofile_file(filename):
         - ""func_timestamp"": (dict) for each function, timestamps and memory
             usage upon entering and exiting.
     """"""
-#    import numpy as np
     func_ts = {}
     mem_usage = []
     timestamp = []
@@ -295,10 +294,8 @@ def read_mprofile_file(filename):
             pass
     f.close()
 
-    ## mdata = np.asarray(mdata,
-    ##                    dtype=[(""mem"", np.float), (""timestamp"", np.float)])
     return {""mem_usage"": mem_usage, ""timestamp"": timestamp,
-            ""func_timestamp"": func_ts}
+            ""func_timestamp"": func_ts, 'filename': filename}
 
 
 
@@ -311,6 +308,14 @@ def plot_file(filename, index=0, timestamps=True):
     import numpy as np  # pylab requires numpy anyway
     mprofile = read_mprofile_file(filename)
 
+    if len(mprofile['timestamp']) == 0:
+        print('** No memory usage values have been found in the profile '
+              'file.**\nFile path: {0}\n'
+              'File may be empty or invalid.\n'
+              'It can be deleted with ""mprof rm {0}""'.format(
+              mprofile['filename']))
+        sys.exit(0)
+
     global_start = float(mprofile[""timestamp""][0])
 
     mem = np.asarray(mprofile[""mem_usage""])
"
mprof,mprof,1e791ca55310f24e0565f421f024ec93c27ac3db,b4bbce73c438f9e343b228c9bcd45703ce15fac0,"Command line is saved in profile file

The full command line of what was run during the profiling is now
saved into the profile file. It is used to set the graph title with
'mprof plot'.","@@ -157,6 +157,12 @@ def clean_action():
             os.remove(filename)
 
 
+def get_cmd_line(args):
+    """"""Given a set or arguments, compute command-line.""""""
+    blanks = set(' \t')
+    args = [s if blanks.isdisjoint(s) else ""'"" + s + ""'"" for s in args]
+    return ' '.join(args)
+
 
 def run_action():
     import time, subprocess
@@ -200,15 +206,18 @@ def run_action():
         print(""running as a Python program..."")
         if not args[0].startswith(""python""):
             args.insert(0, ""python"")
+        cmd_line = get_cmd_line(args)
         args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
                      ""-o"", mprofile_output)
         p = subprocess.Popen(args)
     else:
+        cmd_line = get_cmd_line(args)
         p = subprocess.Popen(args)
 
-    mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
-                         include_children=options.include_children)
     with open(mprofile_output, ""a"") as f:
+        f.write(""CMDLINE {0}\n"".format(cmd_line))
+        mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
+                         include_children=options.include_children)
         for m, t in mu:
             f.write(""MEM {0:.6f} {1:.4f}"".format(m, t) + ""\n"")
 
@@ -271,31 +280,38 @@ def read_mprofile_file(filename):
             second
         - ""func_timestamp"": (dict) for each function, timestamps and memory
             usage upon entering and exiting.
+        - 'cmd_line': (str) command-line ran for this profile.
     """"""
     func_ts = {}
     mem_usage = []
     timestamp = []
+    cmd_line = None
     f = open(filename, ""r"")
     for l in f:
-        fields = l.split()
-        if fields[0] == ""MEM"":
+        field, value = l.split(' ', 1)
+        if field == ""MEM"":
             # mem, timestamp
-            mem_usage.append(float(fields[1]))
-            timestamp.append(float(fields[2]))
+            values = value.split(' ')
+            mem_usage.append(float(values[0]))
+            timestamp.append(float(values[1]))
 
-        elif fields[0] == ""FUNC"":
-            f_name, mem_start, start, mem_end, end = fields[1:]
+        elif field == ""FUNC"":
+            values = value.split(' ')
+            f_name, mem_start, start, mem_end, end = values[:5]
             ts = func_ts.get(f_name, [])
             ts.append([float(start), float(end),
                        float(mem_start), float(mem_end)])
             func_ts[f_name] = ts
 
+        elif field == ""CMDLINE"":
+            cmd_line = value
         else:
             pass
     f.close()
 
     return {""mem_usage"": mem_usage, ""timestamp"": timestamp,
-            ""func_timestamp"": func_ts, 'filename': filename}
+            ""func_timestamp"": func_ts, 'filename': filename,
+            'cmd_line': cmd_line}
 
 
 
@@ -355,6 +371,7 @@ def plot_file(filename, index=0, timestamps=True):
                   colors=""r"", linestyles=""--"")
         pl.vlines(t[max_mem_ind], bottom, top,
                   colors=""r"", linestyles=""--"")
+    return mprofile
 
 
 def plot_action():
@@ -366,7 +383,7 @@ def plot_action():
 
     parser = OptionParser(version=mp.__version__)
     parser.disable_interspersed_args()
-    parser.add_option(""--title"", ""-t"", dest=""title"", default="""",
+    parser.add_option(""--title"", ""-t"", dest=""title"", default=None,
                       type=""str"", action=""store"",
                       help=""String shown as plot title"")
     (options, args) = parser.parse_args()
@@ -401,10 +418,16 @@ def plot_action():
     else:
         timestamps = True
     for n, filename in enumerate(filenames):
-        plot_file(filename, index=n, timestamps=timestamps)
+        mprofile = plot_file(filename, index=n, timestamps=timestamps)
     pl.xlabel(""time (in seconds)"")
     pl.ylabel(""memory used (in MiB)"")
-    pl.title(options.title)
+
+    if options.title is None and len(filenames) == 1:
+        pl.title(mprofile['cmd_line'])
+    else:
+        if options.title is not None:
+            pl.title(options.title)
+
     ax = pl.gca()
     box = ax.get_position()
     ax.set_position([0.07, 0.1,
"
mprof,mprof,9eba5ee676ee01d8384638c69e2c129c835f6ace,1e791ca55310f24e0565f421f024ec93c27ac3db,"Plot all memory usage information

Memory usage when entering and leaving a function is now included
with the other measurements. This fixes some discrepancies between
brackets and curves when sampling frequency was low.

Add an option to prevent displaying of timestamps in plots
(mprof plot -n)","@@ -332,14 +332,30 @@ def plot_file(filename, index=0, timestamps=True):
               mprofile['filename']))
         sys.exit(0)
 
-    global_start = float(mprofile[""timestamp""][0])
+    # Merge function timestamps and memory usage together
+    ts = mprofile['func_timestamp']
+    t = mprofile['timestamp']
+    mem = mprofile['mem_usage']
+
+    if len(ts) > 0:
+        for values in ts.itervalues():
+            for v in values:
+                t.extend(v[:2])
+                mem.extend(v[2:4])
+
+    mem = np.asarray(mem)
+    t = np.asarray(t)
+    ind = t.argsort()
+    mem = mem[ind]
+    t = t[ind]
+
+    # Plot curves
+    global_start = float(t[0])
+    t = t - global_start
 
-    mem = np.asarray(mprofile[""mem_usage""])
     max_mem = mem.max()
     max_mem_ind = mem.argmax()
 
-    t = np.asarray(mprofile[""timestamp""]) - global_start
-
     all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
     mem_line_colors=('k', ""b"", ""r"")
     mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
@@ -354,7 +370,6 @@ def plot_file(filename, index=0, timestamps=True):
     top -= 0.001
 
     # plot timestamps, if any
-    ts = mprofile['func_timestamp']
     if len(ts) > 0 and timestamps:
         func_num = 0
         for f, exec_ts in ts.iteritems():
@@ -386,6 +401,9 @@ def plot_action():
     parser.add_option(""--title"", ""-t"", dest=""title"", default=None,
                       type=""str"", action=""store"",
                       help=""String shown as plot title"")
+    parser.add_option(""--no-function-ts"", ""-n"", dest=""no_timestamps"",
+                      default=False, action=""store_true"",
+                      help=""Do not display function timestamps on plot."")
     (options, args) = parser.parse_args()
 
     profiles = glob.glob(""mprofile_??????????????.dat"")
@@ -413,7 +431,7 @@ def plot_action():
                     filenames.append(profiles[n])
 
     pl.figure(figsize=(14, 6), dpi=90)
-    if len(filenames) > 1:
+    if len(filenames) > 1 or options.no_timestamps:
         timestamps = False
     else:
         timestamps = True
"
memory_profiler.py,memory_profiler.py,2fa5f90f97c79a7550521016ba2fe568a65143af,9f89fad064deead5ac99d00bd7bce874be302da7,"'mprof run' writes continuously in file

Memory usage measurement are written to file directly, without waiting
for the monitored process to finish. This has several advantages:

- mprof memory usage is constant (no in-memory storage of measurement)
- allows for some basic on-line monitoring (using 'tail -f' on profile
  file)
- When the child process is killed, every measurement taken so far are
  accessible (which was not the case before)","@@ -128,7 +128,8 @@ class Timer(Process):
 
 
 def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
-                 include_children=False, max_usage=False, retval=False):
+                 include_children=False, max_usage=False, retval=False,
+                 stream=None):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -148,14 +149,23 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     timeout : float, optional
         Maximum amount of time (in seconds) to wait before returning.
 
-    max_usage: bool, optional
+    max_usage : bool, optional
         Only return the maximum memory usage (default False)
 
-    retval: bool, optional
+    retval : bool, optional
         For profiling python functions. Save the return value of the profiled
         function. Return value of memory_usage becomes a tuple:
         (mem_usage, retval)
 
+    timestamps : bool, optional
+        if True, timestamps of memory usage measurement are collected as well.
+
+    stream : File
+        if stream is a File opened with write access, then results are written
+        to this file instead of stored in memory and returned at the end of
+        the subprocess. Useful for long-running processes.
+        Implies timestamps=True.
+
     Returns
     -------
     mem_usage : list of floating-poing values
@@ -164,6 +174,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         Only returned if retval is set to True
     """"""
 
+    if stream is not None:
+        timestamps = True
+
     if not max_usage:
         ret = []
     else:
@@ -211,15 +224,25 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         p.join(5 * interval)
     elif isinstance(proc, subprocess.Popen):
         # external process, launched from Python
+        line_count = 0
         while True:
             if not max_usage:
-                ret.append(_get_memory(proc.pid, timestamps=timestamps,
-                                       include_children=include_children))
+                mem_usage = _get_memory(proc.pid, timestamps=timestamps,
+                                        include_children=include_children)
+                if stream:
+                    stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
+                else:
+                    ret.append(mem_usage)
             else:
                 ret = max([ret,
                            _get_memory(proc.pid,
                                        include_children=include_children)])
             time.sleep(interval)
+            line_count += 1
+            # flush every 50 lines. Make 'tail -f' usable on profile file
+            if line_count > 50:
+                line_count = 0
+                stream.flush()
             if timeout is not None:
                 max_iter -= 1
                 if max_iter == 0:
@@ -234,14 +257,23 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         while counter < max_iter:
             counter += 1
             if not max_usage:
-                ret.append(_get_memory(proc, timestamps=timestamps,
-                                       include_children=include_children))
+                mem_usage = _get_memory(proc, timestamps=timestamps,
+                                        include_children=include_children)
+                if stream:
+                    stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
+                else:
+                    ret.append(mem_usage)
             else:
                 ret = max([ret,
                            _get_memory(proc, include_children=include_children)
                            ])
 
             time.sleep(interval)
+            # Flush every 50 lines.
+            if counter % 50 == 0:
+                stream.flush()
+    if stream:
+        return None
     return ret
 
 # ..
"
mprof,mprof,2fa5f90f97c79a7550521016ba2fe568a65143af,9f89fad064deead5ac99d00bd7bce874be302da7,"'mprof run' writes continuously in file

Memory usage measurement are written to file directly, without waiting
for the monitored process to finish. This has several advantages:

- mprof memory usage is constant (no in-memory storage of measurement)
- allows for some basic on-line monitoring (using 'tail -f' on profile
  file)
- When the child process is killed, every measurement taken so far are
  accessible (which was not the case before)","@@ -206,12 +206,9 @@ def run_action():
     else:
         p = subprocess.Popen(args)
 
-    mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
-                         include_children=options.include_children)
     with open(mprofile_output, ""a"") as f:
-        for m, t in mu:
-            f.write(""MEM {0:.6f} {1:.4f}"".format(m, t) + ""\n"")
-
+        mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
+                        include_children=options.include_children, stream=f)
 
 
 def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
"
README.rst,README.rst,8b232ec211f889e4e60c7efc687255955f4ddbae,de1c88cdf2fe79a04b0f4e161cf4e6f275b17a6b,Update README.rst,"@@ -314,7 +314,8 @@ Projects using memory_profiler
 =========
  Authors
 =========
-This module was written by `Fabian Pedregosa <http://fseoane.net>`_
+This module was written by `Fabian Pedregosa <http://fseoane.net>`_ 
+and `Philippe Gervais <https://github.com/pgervais>`_
 inspired by Robert Kern's `line profiler
 <http://packages.python.org/line_profiler/>`_.
 
@@ -328,9 +329,6 @@ cleanup.
 
 `Thomas Kluyver <https://github.com/takluyver>`_ added the IPython extension.
 
-`Philippe Gervais <https://github.com/pgervais>`_ created the 'mprof'
-script and fixed bugs. 
-
 
 =========
  License
"
memory_profiler.py,memory_profiler.py,7ab61c046b290971f81e5f83e21caf3fe0f67780,d3bf1cdb645eb5478bae28cfdd0f924b8d1f58e6,"[BUG] Fixed some bugs left by merging

And a bug preventing memory_usage() to be used with stream=None.","@@ -229,7 +229,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             if not max_usage:
                 mem_usage = _get_memory(proc.pid, timestamps=timestamps,
                                         include_children=include_children)
-                if stream:
+                if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
                 else:
                     ret.append(mem_usage)
@@ -242,7 +242,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             # flush every 50 lines. Make 'tail -f' usable on profile file
             if line_count > 50:
                 line_count = 0
-                stream.flush()
+                if stream is not None:
+                    stream.flush()
             if timeout is not None:
                 max_iter -= 1
                 if max_iter == 0:
@@ -259,7 +260,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             if not max_usage:
                 mem_usage = _get_memory(proc, timestamps=timestamps,
                                         include_children=include_children)
-                if stream:
+                if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
                 else:
                     ret.append(mem_usage)
@@ -270,7 +271,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
             time.sleep(interval)
             # Flush every 50 lines.
-            if counter % 50 == 0:
+            if counter % 50 == 0 and stream is not None:
                 stream.flush()
     if stream:
         return None
"
mprof,mprof,7ab61c046b290971f81e5f83e21caf3fe0f67780,d3bf1cdb645eb5478bae28cfdd0f924b8d1f58e6,"[BUG] Fixed some bugs left by merging

And a bug preventing memory_usage() to be used with stream=None.","@@ -216,10 +216,8 @@ def run_action():
 
     with open(mprofile_output, ""a"") as f:
         f.write(""CMDLINE {0}\n"".format(cmd_line))
-        mu = mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
-                         include_children=options.include_children)
-        for m, t in mu:
-            f.write(""MEM {0:.6f} {1:.4f}"".format(m, t) + ""\n"")
+        mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
+                         include_children=options.include_children, stream=f)
 
 
 def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
"
memory_profiler.py,memory_profiler.py,0174ffdf2226ea85ebba11b6f770d1e7659e6945,7ab61c046b290971f81e5f83e21caf3fe0f67780,0.28 release,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
-__version__ = '0.27'
+__version__ = '0.28'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
memory_profiler.py,memory_profiler.py,d2223b73de6e8e98da640bcf7907a11ec1d6be1b,0174ffdf2226ea85ebba11b6f770d1e7659e6945,"fixed issue 7 ""ignores last line""
also better solution for issue 8 ""strange behavior for growing dictionaries/tuples""
- trace_memory_usage() inside the loops no longer create list objects
- trace_memory_usage() currently saves first line of the function
- fixed line number count in show_results()","@@ -379,10 +379,10 @@ class LineProfiler:
     """""" A profiler that records the amount of memory for each line """"""
 
     def __init__(self, **kw):
-        self.functions = list()
         self.code_map = {}
         self.enable_count = 0
         self.max_mem = kw.get('max_mem', None)
+        self.prevline = None        
 
     def __call__(self, func):
         self.add_function(func)
@@ -406,7 +406,6 @@ class LineProfiler:
             return
         if code not in self.code_map:
             self.code_map[code] = {}
-            self.functions.append(func)
 
     def wrap_function(self, func):
         """""" Wrap a function to profile it.
@@ -456,13 +455,12 @@ class LineProfiler:
 
     def trace_memory_usage(self, frame, event, arg):
         """"""Callback for sys.settrace""""""
-        if event in ('line', 'return') and frame.f_code in self.code_map:
-            lineno = frame.f_lineno
-            if event == 'return':
-                lineno += 1
-            entry = self.code_map[frame.f_code].setdefault(lineno, [])
-            entry.append(_get_memory(-1))
-
+        if event in ('call', 'line', 'return') and frame.f_code in self.code_map:
+            if event != 'call':
+                # ""call"" event just saves the lineno but not the memory
+                mem = _get_memory(-1)                
+                self.code_map[frame.f_code][self.prevline] = mem
+            self.prevline = frame.f_lineno
         return self.trace_memory_usage
 
     def trace_max_mem(self, frame, event, arg):
@@ -525,44 +523,26 @@ def show_results(prof, stream=None, precision=1):
             continue
         all_lines = linecache.getlines(filename)
         sub_lines = inspect.getblock(all_lines[code.co_firstlineno - 1:])
-        linenos = range(code.co_firstlineno, code.co_firstlineno +
-                        len(sub_lines))
-        lines_normalized = {}
-
+        linenos = range(code.co_firstlineno,
+                        code.co_firstlineno + len(sub_lines))
+        
         header = template.format('Line #', 'Mem usage', 'Increment',
                                  'Line Contents')
         stream.write(header + '\n')
         stream.write('=' * len(header) + '\n')
-        # move everything one frame up
-        keys = sorted(lines.keys())
 
-        k_old = keys[0] - 1
-        lines_normalized[keys[0] - 1] = lines[keys[0]]
-        for i in range(1, len(lines_normalized[keys[0] - 1])):
-            lines_normalized[keys[0] - 1][i] = -1.
-        k = keys.pop(0)
-        while keys:
-            lines_normalized[k] = lines[keys[0]]
-            for i in range(len(lines_normalized[k_old]),
-                           len(lines_normalized[k])):
-                lines_normalized[k][i] = -1.
-            k_old = k
-            k = keys.pop(0)
-
-        first_line = sorted(lines_normalized.keys())[0]
-        mem_old = max(lines_normalized[first_line])
-        precision = int(precision)
+        mem_old = lines[min(lines.keys())]        
         template_mem = '{{0:{0}.{1}'.format(precision + 4, precision) + 'f} MiB'
-        for i, l in enumerate(linenos):
+        for line in linenos:
             mem = ''
             inc = ''
-            if l in lines_normalized:
-                mem = max(lines_normalized[l])
+            if line in lines:
+                mem = lines[line]
                 inc = mem - mem_old
                 mem_old = mem
                 mem = template_mem.format(mem)
                 inc = template_mem.format(inc)
-            stream.write(template.format(l, mem, inc, sub_lines[i]))
+            stream.write(template.format(line, mem, inc, all_lines[line - 1]))
         stream.write('\n\n')
 
 
"
memory_profiler.py,memory_profiler.py,0caa43eda3469ba4099945cd8c2edca66a3dbd2c,d2223b73de6e8e98da640bcf7907a11ec1d6be1b,Use maximum memory usage for loops,"@@ -458,8 +458,10 @@ class LineProfiler:
         if event in ('call', 'line', 'return') and frame.f_code in self.code_map:
             if event != 'call':
                 # ""call"" event just saves the lineno but not the memory
-                mem = _get_memory(-1)                
-                self.code_map[frame.f_code][self.prevline] = mem
+                mem = _get_memory(-1)
+                # if there is already a measurement for that line get the max
+                old_mem = self.code_map[frame.f_code].get(self.prevline, 0)
+                self.code_map[frame.f_code][self.prevline] = max(mem, old_mem)
             self.prevline = frame.f_lineno
         return self.trace_memory_usage
 
"
memory_profiler.py,memory_profiler.py,7db71ebee09e2b10d6f7143fca05248d2020b7a8,0caa43eda3469ba4099945cd8c2edca66a3dbd2c,0.29 release,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
-__version__ = '0.28'
+__version__ = '0.29'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
memory_profiler.py,memory_profiler.py,51adf6bf86b5a63aabca29b538c1822f754db63e,7db71ebee09e2b10d6f7143fca05248d2020b7a8,FIX: errors reported by flake8 (pyflakes + pep8),"@@ -66,7 +66,8 @@ def _get_memory(pid, timestamps=False, include_children=False):
         # .. subprocess.check_output appeared in 2.7, using Popen ..
         # .. for backwards compatibility ..
         out = subprocess.Popen(['ps', 'v', '-p', str(pid)],
-              stdout=subprocess.PIPE).communicate()[0].split(b'\n')
+                               stdout=subprocess.PIPE
+                               ).communicate()[0].split(b'\n')
         try:
             vsz_index = out[0].split().index(b'RSS')
             mem = float(out[1].split()[vsz_index]) / 1024
@@ -375,14 +376,14 @@ class TimeStamper:
                     (function_name,) + ts[0] + ts[1]))
 
 
-class LineProfiler:
+class LineProfiler(object):
     """""" A profiler that records the amount of memory for each line """"""
 
     def __init__(self, **kw):
         self.code_map = {}
         self.enable_count = 0
         self.max_mem = kw.get('max_mem', None)
-        self.prevline = None        
+        self.prevline = None
 
     def __call__(self, func):
         self.add_function(func)
@@ -455,7 +456,8 @@ class LineProfiler:
 
     def trace_memory_usage(self, frame, event, arg):
         """"""Callback for sys.settrace""""""
-        if event in ('call', 'line', 'return') and frame.f_code in self.code_map:
+        if (event in ('call', 'line', 'return')
+                and frame.f_code in self.code_map):
             if event != 'call':
                 # ""call"" event just saves the lineno but not the memory
                 mem = _get_memory(-1)
@@ -527,14 +529,15 @@ def show_results(prof, stream=None, precision=1):
         sub_lines = inspect.getblock(all_lines[code.co_firstlineno - 1:])
         linenos = range(code.co_firstlineno,
                         code.co_firstlineno + len(sub_lines))
-        
+
         header = template.format('Line #', 'Mem usage', 'Increment',
                                  'Line Contents')
         stream.write(header + '\n')
         stream.write('=' * len(header) + '\n')
 
-        mem_old = lines[min(lines.keys())]        
-        template_mem = '{{0:{0}.{1}'.format(precision + 4, precision) + 'f} MiB'
+        mem_old = lines[min(lines.keys())]
+        float_format = '{0}.{1}f'.format(precision + 4, precision)
+        template_mem = '{{0:' + float_format + '} MiB'
         for line in linenos:
             mem = ''
             inc = ''
@@ -611,7 +614,7 @@ def magic_mprun(self, parameter_s=''):
             funcs.append(eval(name, global_ns, local_ns))
         except Exception as e:
             raise UsageError('Could not find function %r.\n%s: %s' % (name,
-                e.__class__.__name__, e))
+                             e.__class__.__name__, e))
 
     profile = LineProfiler()
     for func in funcs:
@@ -639,7 +642,7 @@ def magic_mprun(self, parameter_s=''):
             message = ""*** SystemExit exception caught in code being profiled.""
         except KeyboardInterrupt:
             message = (""*** KeyboardInterrupt exception caught in code being ""
-                ""profiled."")
+                       ""profiled."")
     finally:
         if had_profile:
             builtins.__dict__['profile'] = old_profile
@@ -755,10 +758,12 @@ if __name__ == '__main__':
     from optparse import OptionParser
     parser = OptionParser(usage=_CMD_USAGE, version=__version__)
     parser.disable_interspersed_args()
-    parser.add_option(""--pdb-mmem"", dest=""max_mem"", metavar=""MAXMEM"",
+    parser.add_option(
+        ""--pdb-mmem"", dest=""max_mem"", metavar=""MAXMEM"",
         type=""float"", action=""store"",
         help=""step into the debugger when memory exceeds MAXMEM"")
-    parser.add_option('--precision', dest=""precision"", type=""int"",
+    parser.add_option(
+        '--precision', dest=""precision"", type=""int"",
         action=""store"", default=3,
         help=""precision of memory output in number of significant digits"")
     parser.add_option(""-o"", dest=""out_filename"", type=""str"",
@@ -784,7 +789,7 @@ if __name__ == '__main__':
     try:
         if sys.version_info[0] < 3:
             # we need to ovewrite the builtins to have profile
-            # globally defined (global variables is not enought
+            # globally defined (global variables is not enough
             # for all cases, e.g. a script that imports another
             # script where @profile is used)
             import __builtin__
"
memory_profiler.py,memory_profiler.py,183a4bc9de7b512eef49a38968d618aed7750d5d,c09c04a18e29479615ad937b47c3620bf07f5133,"use max_usage=True in %memit (less memory consumption)

Also some refactoring","@@ -85,7 +85,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
                                   'platforms')
 
 
-class Timer(Process):
+class MemTimer(Process):
     """"""
     Fetch memory consumption from over a time interval
     """"""
@@ -108,7 +108,7 @@ class Timer(Process):
         else:
             self.include_children = False
 
-        super(Timer, self).__init__(*args, **kw)
+        super(MemTimer, self).__init__(*args, **kw)
 
     def run(self):
         m = _get_memory(self.monitor_pid, timestamps=self.timestamps,
@@ -212,8 +212,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             raise ValueError('Function expects %s value(s) but %s where given'
                              % (n_args, len(args)))
 
-        child_conn, parent_conn = Pipe()  # this will store Timer's results
-        p = Timer(os.getpid(), interval, child_conn, timestamps=timestamps,
+        child_conn, parent_conn = Pipe()  # this will store MemTimer's results
+        p = MemTimer(os.getpid(), interval, child_conn, timestamps=timestamps,
                   max_usage=max_usage)
         p.start()
         parent_conn.recv()  # wait until we start getting memory
@@ -424,6 +424,7 @@ class LineProfiler(object):
     def run(self, cmd):
         """""" Profile a single executable statement in the main namespace.
         """"""
+        # TODO: can this be removed ?
         import __main__
         main_dict = __main__.__dict__
         return self.runctx(cmd, main_dict, main_dict)
@@ -721,16 +722,16 @@ def magic_memit(self, line=''):
         timeout = None
     interval = float(getattr(opts, 'i', 0.1))
 
-    mem_usage = []
+    mem_usage = 0.
     counter = 0
     while counter < repeat:
         counter += 1
         tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
-                           timeout=timeout, interval=interval)
-        mem_usage.extend(tmp)
+                           timeout=timeout, interval=interval, max_usage=True)
+        mem_usage = max(mem_usage, tmp)
 
     if mem_usage:
-        print('maximum of %d: %f MiB per loop' % (repeat, max(mem_usage)))
+        print('maximum of %d: %f MiB per loop' % (repeat, mem_usage))
     else:
         print('ERROR: could not read memory usage, try with a lower interval '
               'or more iterations')
"
memory_profiler.py,memory_profiler.py,369f940a34dcb148cccb8799c6741bb450229236,183a4bc9de7b512eef49a38968d618aed7750d5d,Better output of %memit,"@@ -96,6 +96,7 @@ class MemTimer(Process):
         self.pipe = pipe
         self.cont = True
         self.max_usage = max_usage
+        self.n_measurements = 1
 
         if ""timestamps"" in kw:
             self.timestamps = kw[""timestamps""]
@@ -107,25 +108,31 @@ class MemTimer(Process):
             del kw[""include_children""]
         else:
             self.include_children = False
-
+        # get baseline memory usage
+        self.mem_usage = [
+            _get_memory(self.monitor_pid, timestamps=self.timestamps,
+                        include_children=self.include_children)]
         super(MemTimer, self).__init__(*args, **kw)
 
+
     def run(self):
-        m = _get_memory(self.monitor_pid, timestamps=self.timestamps,
-                        include_children=self.include_children)
-        if not self.max_usage:
-            timings = [m]
-        else:
-            timings = m
         self.pipe.send(0)  # we're ready
-        while not self.pipe.poll(self.interval):
-            m = _get_memory(self.monitor_pid, timestamps=self.timestamps,
+        stop = False
+        while True:
+            cur_mem = _get_memory(self.monitor_pid, timestamps=self.timestamps,
                             include_children=self.include_children)
             if not self.max_usage:
-                timings.append(m)
+                self.mem_usage.append(cur_mem)
             else:
-                timings = max([m, timings])
-        self.pipe.send(timings)
+                self.mem_usage[0] = max(cur_mem, self.mem_usage[0])
+            self.n_measurements += 1
+            if stop:
+                break
+            stop = self.pipe.poll(self.interval)
+            # do one more iteration
+
+        self.pipe.send(self.mem_usage)
+        self.pipe.send(self.n_measurements)
 
 
 def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
@@ -171,6 +178,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     -------
     mem_usage : list of floating-poing values
         memory usage, in MiB. It's length is always < timeout / interval
+        if max_usage is given, returns the two elements maximum memory and
+        number of measurements effectuated
     ret : return value of the profiled function
         Only returned if retval is set to True
     """"""
@@ -212,17 +221,22 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             raise ValueError('Function expects %s value(s) but %s where given'
                              % (n_args, len(args)))
 
-        child_conn, parent_conn = Pipe()  # this will store MemTimer's results
-        p = MemTimer(os.getpid(), interval, child_conn, timestamps=timestamps,
-                  max_usage=max_usage)
-        p.start()
-        parent_conn.recv()  # wait until we start getting memory
-        returned = f(*args, **kw)
-        parent_conn.send(0)  # finish timing
-        ret = parent_conn.recv()
-        if retval:
-            ret = ret, returned
-        p.join(5 * interval)
+        while True:
+            child_conn, parent_conn = Pipe()  # this will store MemTimer's results
+            p = MemTimer(os.getpid(), interval, child_conn, timestamps=timestamps,
+                      max_usage=max_usage)
+            p.start()
+            parent_conn.recv()  # wait until we start getting memory
+            returned = f(*args, **kw)
+            parent_conn.send(0)  # finish timing
+            ret = parent_conn.recv()
+            n_measurements = parent_conn.recv()
+            if retval:
+                ret = ret, returned
+            p.join(5 * interval)
+            if n_measurements > 4 or interval < 1e-6:
+                break
+            interval /= 10.
     elif isinstance(proc, subprocess.Popen):
         # external process, launched from Python
         line_count = 0
@@ -722,16 +736,23 @@ def magic_memit(self, line=''):
         timeout = None
     interval = float(getattr(opts, 'i', 0.1))
 
-    mem_usage = 0.
+    # I've noticed we get less noisier measurements if we run
+    # a garbage collection first
+    import gc
+    gc.collect()
+
+    mem_usage = 0
     counter = 0
+    baseline = memory_usage()[0]
     while counter < repeat:
         counter += 1
         tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
                            timeout=timeout, interval=interval, max_usage=True)
-        mem_usage = max(mem_usage, tmp)
+        mem_usage = max(mem_usage, tmp[0])
 
     if mem_usage:
-        print('maximum of %d: %f MiB per loop' % (repeat, mem_usage))
+        print('peak memory: %.02f MiB, increment: %.02f MiB' %
+              (mem_usage, mem_usage - baseline))
     else:
         print('ERROR: could not read memory usage, try with a lower interval '
               'or more iterations')
"
memory_profiler.py,memory_profiler.py,317a93ac3de7589592e6dac8e09154195b2e47d9,369f940a34dcb148cccb8799c6741bb450229236,fix typo in stdout template,"@@ -552,7 +552,7 @@ def show_results(prof, stream=None, precision=1):
 
         mem_old = lines[min(lines.keys())]
         float_format = '{0}.{1}f'.format(precision + 4, precision)
-        template_mem = '{{0:' + float_format + '} MiB'
+        template_mem = '{0:' + float_format + '} MiB'
         for line in linenos:
             mem = ''
             inc = ''
"
memory_profiler.py,memory_profiler.py,1da5ed8b34cb5d7dded80cbf4fce1108d7b1760b,6bbda1e23705d0889469e35e4286c897027e3cd7,version 0.30,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
-__version__ = '0.29'
+__version__ = '0.30'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
memory_profiler.py,memory_profiler.py,4b1d470323ad9963757d05f3801b7933c55aa119,1da5ed8b34cb5d7dded80cbf4fce1108d7b1760b,#63 Run original trace callback also. Restore original trace callback once LineProfiler is disabled.,"@@ -480,6 +480,10 @@ class LineProfiler(object):
                 old_mem = self.code_map[frame.f_code].get(self.prevline, 0)
                 self.code_map[frame.f_code][self.prevline] = max(mem, old_mem)
             self.prevline = frame.f_lineno
+
+        if self._original_trace_function is not None:
+            (self._original_trace_function)(frame, event, arg)
+
         return self.trace_memory_usage
 
     def trace_max_mem(self, frame, event, arg):
@@ -500,6 +504,9 @@ class LineProfiler(object):
                 p.botframe = None
                 return p.trace_dispatch
 
+        if self._original_trace_function is not None:
+            (self._original_trace_function)(frame, event, arg)
+
         return self.trace_max_mem
 
     def __enter__(self):
@@ -509,6 +516,7 @@ class LineProfiler(object):
         self.disable_by_count()
 
     def enable(self):
+        self._original_trace_function = sys.gettrace()
         if self.max_mem is not None:
             sys.settrace(self.trace_max_mem)
         else:
@@ -516,7 +524,7 @@ class LineProfiler(object):
 
     def disable(self):
         self.last_time = {}
-        sys.settrace(None)
+        sys.settrace(self._original_trace_function)
 
 
 def show_results(prof, stream=None, precision=1):
"
Makefile,Makefile,9f91aa03aaf45d73ee32586a054a5f0044fae7ef,4b1d470323ad9963757d05f3801b7933c55aa119,FIX: make it possible to call memory_usage on functions with anonymous args,"@@ -7,4 +7,5 @@ test:
 	$(PYTHON) -m memory_profiler test/test_loop.py
 	$(PYTHON) -m memory_profiler test/test_as.py
 	$(PYTHON) -m memory_profiler test/test_global.py
-	$(PYTHON) test/test_import.py
\ No newline at end of file
+	$(PYTHON) test/test_import.py
+	$(PYTHON) test/test_memory_usage.py
"
memory_profiler.py,memory_profiler.py,9f91aa03aaf45d73ee32586a054a5f0044fae7ef,4b1d470323ad9963757d05f3801b7933c55aa119,FIX: make it possible to call memory_usage on functions with anonymous args,"@@ -213,14 +213,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         else:
             raise ValueError
 
-        aspec = inspect.getargspec(f)
-        n_args = len(aspec.args)
-        if aspec.defaults is not None:
-            n_args -= len(aspec.defaults)
-        if n_args != len(args):
-            raise ValueError('Function expects %s value(s) but %s where given'
-                             % (n_args, len(args)))
-
         while True:
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
             p = MemTimer(os.getpid(), interval, child_conn, timestamps=timestamps,
"
test/test_import.py,test/test_import.py,9f91aa03aaf45d73ee32586a054a5f0044fae7ef,4b1d470323ad9963757d05f3801b7933c55aa119,FIX: make it possible to call memory_usage on functions with anonymous args,"@@ -1,5 +1,6 @@
 from memory_profiler import profile
 
+
 @profile
 def my_func():
     a = [1] * (10 ** 6)
@@ -8,4 +9,4 @@ def my_func():
     return a
 
 if __name__ == '__main__':
-	my_func()
\ No newline at end of file
+    my_func()
"
,test/test_memory_usage.py,9f91aa03aaf45d73ee32586a054a5f0044fae7ef,4b1d470323ad9963757d05f3801b7933c55aa119,FIX: make it possible to call memory_usage on functions with anonymous args,"@@ -0,0 +1,15 @@
+from memory_profiler import memory_usage
+
+
+def some_func(*args, **kwargs):
+    return args, kwargs
+
+
+def test_memory_usage():
+    # Check that memory_usage works with functions with star args.
+    mem, ret = memory_usage((some_func, (1, 2), dict(a=1)), retval=True)
+    assert ret[0] == (1, 2)
+    assert ret[1] == dict(a=1)
+
+if __name__ == ""__main__"":
+    test_memory_usage()
"
memory_profiler.py,memory_profiler.py,6de83c296a9d7ca2d6c55aee19a4285674fd8dd1,34e7f9b9aac5acb612f12a6d32c9cfacf38df777,"FIX: Change `itervalues`, `iteritems` to `values`, `items` to work on both Python 2 and Python 3..","@@ -375,7 +375,7 @@ class TimeStamper:
         if stream is None:
             stream = sys.stdout
 
-        for func, timestamps in self.functions.iteritems():
+        for func, timestamps in self.functions.items():
             function_name = ""%s.%s"" % (func.__module__, func.__name__)
             for ts in timestamps:
                 stream.write(""FUNC %s %.4f %.4f %.4f %.4f\n"" % (
"
mprof,mprof,6de83c296a9d7ca2d6c55aee19a4285674fd8dd1,34e7f9b9aac5acb612f12a6d32c9cfacf38df777,"FIX: Change `itervalues`, `iteritems` to `values`, `items` to work on both Python 2 and Python 3..","@@ -335,7 +335,7 @@ def plot_file(filename, index=0, timestamps=True):
     mem = mprofile['mem_usage']
 
     if len(ts) > 0:
-        for values in ts.itervalues():
+        for values in ts.values():
             for v in values:
                 t.extend(v[:2])
                 mem.extend(v[2:4])
@@ -369,7 +369,7 @@ def plot_file(filename, index=0, timestamps=True):
     # plot timestamps, if any
     if len(ts) > 0 and timestamps:
         func_num = 0
-        for f, exec_ts in ts.iteritems():
+        for f, exec_ts in ts.items():
             for execution in exec_ts:
                 add_brackets(execution[:2], execution[2:], xshift=global_start,
                              color= all_colors[func_num % len(all_colors)],
"
memory_profiler.py,memory_profiler.py,b38cc15febd6c3de49f878a88024e83be84ba6ff,1e911e3dff9efd9c1822e7695024a3af2dc80726,Profile nested functions,"@@ -400,6 +400,13 @@ class LineProfiler(object):
         f.__dict__.update(getattr(func, '__dict__', {}))
         return f
 
+    def add_code(self, code, toplevel_code=None):
+        if code not in self.code_map:
+            self.code_map[code] = {}
+
+            for subcode in filter(inspect.iscode, code.co_consts):
+                self.add_code(subcode)
+
     def add_function(self, func):
         """""" Record line profiling information for the given Python function.
         """"""
@@ -410,9 +417,8 @@ class LineProfiler(object):
             import warnings
             warnings.warn(""Could not extract a code object for the object %r""
                           % func)
-            return
-        if code not in self.code_map:
-            self.code_map[code] = {}
+        else:
+            self.add_code(code)
 
     def wrap_function(self, func):
         """""" Wrap a function to profile it.
"
,test/test_nested.py,b38cc15febd6c3de49f878a88024e83be84ba6ff,1e911e3dff9efd9c1822e7695024a3af2dc80726,Profile nested functions,"@@ -0,0 +1,29 @@
+# .. an example with a for loop ..
+
+import time
+
+@profile
+def test_1():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    del b
+
+    def test_2():
+        a = [1] * (10 ** 6)
+        b = [2] * (2 * 10 ** 7)
+        del b
+
+        return a
+
+    return test_2
+
+
+if __name__ == '__main__':
+    profile.enable_by_count()
+
+    test_2 = test_1()
+    time.sleep(1)
+    test_2()
+    time.sleep(1)
+
+    profile.disable_by_count()
"
memory_profiler.py,memory_profiler.py,f6924d68df5b05bd3f31d5c02c62c032d7e97b86,1e911e3dff9efd9c1822e7695024a3af2dc80726,Add include_children parameter when creating MemTimer object for external processes. Fix #69,"@@ -58,7 +58,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
             # continue and try to get this from ps
 
     # .. scary stuff ..
-    if os.name == 'posix':
+    elif os.name == 'posix':
         warnings.warn(""psutil module not found. memory_profiler will be slow"")
         # ..
         # .. memory usage in MiB ..
@@ -216,7 +216,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         while True:
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
             p = MemTimer(os.getpid(), interval, child_conn, timestamps=timestamps,
-                      max_usage=max_usage)
+                      max_usage=max_usage, include_children=include_children)
             p.start()
             parent_conn.recv()  # wait until we start getting memory
             returned = f(*args, **kw)
"
memory_profiler.py,memory_profiler.py,3b25886d0a3ec3b089826b42af71ee481cd5bde9,f6924d68df5b05bd3f31d5c02c62c032d7e97b86,return mem avoids entering the next block. This is not en if else case,"@@ -58,7 +58,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
             # continue and try to get this from ps
 
     # .. scary stuff ..
-    elif os.name == 'posix':
+    if os.name == 'posix':
         warnings.warn(""psutil module not found. memory_profiler will be slow"")
         # ..
         # .. memory usage in MiB ..
"
memory_profiler.py,memory_profiler.py,2e38041201d3653e562a751cc2926658e1c3c33d,3fa7aafb0ac9c05c83fd9726ba1ffd6a7c27ec82,0.31 release,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
-__version__ = '0.30'
+__version__ = '0.31'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
mprof,mprof,9cafafa1ba117e2784f49d16afeb5721f431afc7,8ecc4dab2224c69b02e2593e28d40ba903190419,tweak to legend placement,"@@ -445,9 +445,12 @@ def plot_action():
 
     ax = pl.gca()
     box = ax.get_position()
-    ax.set_position([0.07, 0.1,
-                     0.55, 0.8])
-    ax.legend(loc=""upper left"", bbox_to_anchor=(1.05, 1.))
+    # IAN FIX
+    #ax.set_position([0.07, 0.1,
+    #                 0.55, 0.8])
+    #ax.legend(loc=""upper left"", bbox_to_anchor=(1.05, 1.))
+    leg = ax.legend(loc='best', fancybox=True)
+    leg.get_frame().set_alpha(0.5)  # make the legend partially transparent
     pl.grid()
     pl.show()
 
"
mprof,mprof,e3bc89a70d44ad1733d0037ac1e33dbe3d4fa60c,9cafafa1ba117e2784f49d16afeb5721f431afc7,removed dead code,"@@ -444,13 +444,10 @@ def plot_action():
             pl.title(options.title)
 
     ax = pl.gca()
-    box = ax.get_position()
-    # IAN FIX
-    #ax.set_position([0.07, 0.1,
-    #                 0.55, 0.8])
-    #ax.legend(loc=""upper left"", bbox_to_anchor=(1.05, 1.))
+    # place legend within the plot, make partially transparent in
+    # case it obscures part of the lineplot
     leg = ax.legend(loc='best', fancybox=True)
-    leg.get_frame().set_alpha(0.5)  # make the legend partially transparent
+    leg.get_frame().set_alpha(0.5)
     pl.grid()
     pl.show()
 
"
memory_profiler.py,memory_profiler.py,74c6d0408248d91e91e5b12fe674811a3a8d3a62,2e38041201d3653e562a751cc2926658e1c3c33d,ENH: magic cmd option to set include_children=True,"@@ -390,6 +390,7 @@ class LineProfiler(object):
         self.enable_count = 0
         self.max_mem = kw.get('max_mem', None)
         self.prevline = None
+        self.include_children = kw.get('include_children', False)
 
     def __call__(self, func):
         self.add_function(func)
@@ -467,7 +468,7 @@ class LineProfiler(object):
                 and frame.f_code in self.code_map):
             if event != 'call':
                 # ""call"" event just saves the lineno but not the memory
-                mem = _get_memory(-1)
+                mem = _get_memory(-1, include_children=self.include_children)
                 # if there is already a measurement for that line get the max
                 old_mem = self.code_map[frame.f_code].get(self.prevline, 0)
                 self.code_map[frame.f_code][self.prevline] = max(mem, old_mem)
@@ -595,6 +596,8 @@ def magic_mprun(self, parameter_s=''):
     side-by-side out to a text file.
 
     -r: return the LineProfiler object after it has completed profiling.
+
+    -c: If present, add the memory usage of any children process to the report.
     """"""
     try:
         from StringIO import StringIO
@@ -617,7 +620,7 @@ def magic_mprun(self, parameter_s=''):
     # Escape quote markers.
     opts_def = Struct(T=[''], f=[])
     parameter_s = parameter_s.replace('""', r'\""').replace(""'"", r""\'"")
-    opts, arg_str = self.parse_options(parameter_s, 'rf:T:', list_all=True)
+    opts, arg_str = self.parse_options(parameter_s, 'rf:T:c', list_all=True)
     opts.merge(opts_def)
     global_ns = self.shell.user_global_ns
     local_ns = self.shell.user_ns
@@ -631,7 +634,8 @@ def magic_mprun(self, parameter_s=''):
             raise UsageError('Could not find function %r.\n%s: %s' % (name,
                              e.__class__.__name__, e))
 
-    profile = LineProfiler()
+    include_children = bool(getattr(opts, 'c', False))
+    profile = LineProfiler(include_children=include_children)
     for func in funcs:
         profile(func)
 
@@ -711,6 +715,8 @@ def magic_memit(self, line=''):
     -i<I>: Get time information at an interval of I times per second.
         Defaults to 0.1 so that there is ten measurements per second.
 
+    -c: If present, add the memory usage of any children process to the report.
+
     Examples
     --------
     ::
@@ -727,7 +733,7 @@ def magic_memit(self, line=''):
       maximum of 10: 0.101562 MiB per loop
 
     """"""
-    opts, stmt = self.parse_options(line, 'r:t:i:', posix=False, strict=False)
+    opts, stmt = self.parse_options(line, 'r:t:i:c', posix=False, strict=False)
     repeat = int(getattr(opts, 'r', 1))
     if repeat < 1:
         repeat == 1
@@ -735,6 +741,7 @@ def magic_memit(self, line=''):
     if timeout <= 0:
         timeout = None
     interval = float(getattr(opts, 'i', 0.1))
+    include_children = bool(getattr(opts, 'c', False))
 
     # I've noticed we get less noisier measurements if we run
     # a garbage collection first
@@ -747,7 +754,8 @@ def magic_memit(self, line=''):
     while counter < repeat:
         counter += 1
         tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
-                           timeout=timeout, interval=interval, max_usage=True)
+                           timeout=timeout, interval=interval, max_usage=True,
+                           include_children=include_children)
         mem_usage = max(mem_usage, tmp[0])
 
     if mem_usage:
"
memory_profiler.py,memory_profiler.py,b59c898928bf709febd21ca3ab6a58f62ddc4a04,2e38041201d3653e562a751cc2926658e1c3c33d,"remove double import warnings

seems that warnings is already imported at the top level of the module","@@ -407,7 +407,6 @@ class LineProfiler(object):
             # func_code does not exist in Python3
             code = func.__code__
         except AttributeError:
-            import warnings
             warnings.warn(""Could not extract a code object for the object %r""
                           % func)
             return
"
test/test_as.py,test/test_as.py,58df1969abff7df427a6922112e10bfd4caec54c,364c3ef9e22acc0391d93fcc59c7ba24583a2cd7,"Inconsistent indentation: previous line used spaces, this line uses tabs","@@ -6,4 +6,4 @@ def f():
     return o
 
 if __name__ == '__main__':
-	f()
\ No newline at end of file
+    f()
"
memory_profiler.py,memory_profiler.py,ba8ada6c94ca0ebac7366a43c3ac2211f20206ad,74c6d0408248d91e91e5b12fe674811a3a8d3a62,explicitly fail if psutil is missing and include_children is True,"@@ -59,6 +59,10 @@ def _get_memory(pid, timestamps=False, include_children=False):
 
     # .. scary stuff ..
     if os.name == 'posix':
+        if include_children:
+            raise NotImplementedError('The psutil module is required when to'
+                                      ' monitor memory usage of children'
+                                      ' processes')
         warnings.warn(""psutil module not found. memory_profiler will be slow"")
         # ..
         # .. memory usage in MiB ..
"
memory_profiler.py,memory_profiler.py,1f9f63aedb233c74ed8a0f98756b1fb8052f31fd,ba8ada6c94ca0ebac7366a43c3ac2211f20206ad,FIX: bad test for the detection of the -c flag,"@@ -187,7 +187,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     ret : return value of the profiled function
         Only returned if retval is set to True
     """"""
-
     if stream is not None:
         timestamps = True
 
@@ -638,7 +637,7 @@ def magic_mprun(self, parameter_s=''):
             raise UsageError('Could not find function %r.\n%s: %s' % (name,
                              e.__class__.__name__, e))
 
-    include_children = bool(getattr(opts, 'c', False))
+    include_children = 'c' in opts
     profile = LineProfiler(include_children=include_children)
     for func in funcs:
         profile(func)
@@ -745,7 +744,7 @@ def magic_memit(self, line=''):
     if timeout <= 0:
         timeout = None
     interval = float(getattr(opts, 'i', 0.1))
-    include_children = bool(getattr(opts, 'c', False))
+    include_children = 'c' in opts
 
     # I've noticed we get less noisier measurements if we run
     # a garbage collection first
"
memory_profiler.py,memory_profiler.py,3689a28b6eac9bef291e95e7b972cb8a05198956,1692b503eeb4c7f4176f1b275963001c31d7a3c6,Remove unused code (thanks @peter1000),"@@ -524,7 +524,6 @@ class LineProfiler(object):
             sys.settrace(self.trace_memory_usage)
 
     def disable(self):
-        self.last_time = {}
         sys.settrace(self._original_trace_function)
 
 
"
memory_profiler.py,memory_profiler.py,f91780a59eed60bcb20787754ae893282c8998b5,3689a28b6eac9bef291e95e7b972cb8a05198956,"Replace psutil methods deprecated on v2.0.0

- Replaced deprecated psutil.get_memory_info() by
psutil.memory_info()","@@ -45,10 +45,10 @@ def _get_memory(pid, timestamps=False, include_children=False):
     if has_psutil:
         process = psutil.Process(pid)
         try:
-            mem = process.get_memory_info()[0] / _TWO_20
+            mem = process.memory_info()[0] / _TWO_20
             if include_children:
                 for p in process.get_children(recursive=True):
-                    mem += p.get_memory_info()[0] / _TWO_20
+                    mem += p.memory_info()[0] / _TWO_20
             if timestamps:
                 return (mem, time.time())
             else:
"
memory_profiler.py,memory_profiler.py,155765b696cd5c50851dc2a53bdd50ab5951f822,f91780a59eed60bcb20787754ae893282c8998b5,Added backward compatibility for psutil < 2.0.0,"@@ -45,10 +45,12 @@ def _get_memory(pid, timestamps=False, include_children=False):
     if has_psutil:
         process = psutil.Process(pid)
         try:
-            mem = process.memory_info()[0] / _TWO_20
+            mem_info = getattr(process, 'memory_info', process.get_memory_info)
+            mem = mem_info()[0] / _TWO_20
             if include_children:
                 for p in process.get_children(recursive=True):
-                    mem += p.memory_info()[0] / _TWO_20
+                    mem_info = getattr(p, 'memory_info', p.get_memory_info)
+                    mem += mem_info()[0] / _TWO_20
             if timestamps:
                 return (mem, time.time())
             else:
"
Makefile,Makefile,baf0fccd7a098742c2ed9e94c9be183c841fa86d,b0b4a3caa5f738b80899381411e8d93ac83c0928,"Parameterize @profile decorator with precision

Add precision parameter to @profile decorator to specify precision if import is
used instead of -m memory_profiler","@@ -7,5 +7,7 @@ test:
 	$(PYTHON) -m memory_profiler test/test_loop.py
 	$(PYTHON) -m memory_profiler test/test_as.py
 	$(PYTHON) -m memory_profiler test/test_global.py
+	$(PYTHON) -m memory_profiler test/test_precision_command_line.py
 	$(PYTHON) test/test_import.py
 	$(PYTHON) test/test_memory_usage.py
+	$(PYTHON) test/test_precision_import.py
"
README.rst,README.rst,baf0fccd7a098742c2ed9e94c9be183c841fa86d,b0b4a3caa5f738b80899381411e8d93ac83c0928,"Parameterize @profile decorator with precision

Add precision parameter to @profile decorator to specify precision if import is
used instead of -m memory_profiler","@@ -88,6 +88,21 @@ A function decorator is also available.  Use as follows::
 In this case the script can be run without specifying ``-m
 memory_profiler`` in the command line.
 
+In function decorator, you can specify the precision as an argument to the
+decorator function.  Use as follows::
+
+    from memory_profiler import profile
+
+    @profile(precision=4)
+    def my_func():
+        a = [1] * (10 ** 6)
+        b = [2] * (2 * 10 ** 7)
+        del b
+        return a
+
+If a python script with decorator ``@profile`` is called using ``-m 
+memory_profiler`` in the command line, the ``precision`` parameter is ignored.
+
 Executing external scripts
 ==========================
 Sometimes it is useful to have full memory usage reports as a function of
"
memory_profiler.py,memory_profiler.py,baf0fccd7a098742c2ed9e94c9be183c841fa86d,b0b4a3caa5f738b80899381411e8d93ac83c0928,"Parameterize @profile decorator with precision

Add precision parameter to @profile decorator to specify precision if import is
used instead of -m memory_profiler","@@ -332,17 +332,22 @@ class TimeStamper:
     def __init__(self):
         self.functions = {}
 
-    def __call__(self, func):
-        if not hasattr(func, ""__call__""):
-            raise ValueError(""Value must be callable"")
+    def __call__(self, func=None, precision=None):
+        if func is not None:
+            if not hasattr(func, ""__call__""):
+                raise ValueError(""Value must be callable"")
 
-        self.add_function(func)
-        f = self.wrap_function(func)
-        f.__module__ = func.__module__
-        f.__name__ = func.__name__
-        f.__doc__ = func.__doc__
-        f.__dict__.update(getattr(func, '__dict__', {}))
-        return f
+            self.add_function(func)
+            f = self.wrap_function(func)
+            f.__module__ = func.__module__
+            f.__name__ = func.__name__
+            f.__doc__ = func.__doc__
+            f.__dict__.update(getattr(func, '__dict__', {}))
+            return f
+        else:
+            def inner_partial(func):
+                return self.__call__(func, precision=precision)
+            return inner_partial
 
     def timestamp(self, name=""<block>""):
         """"""Returns a context manager for timestamping a block of code.""""""
@@ -397,14 +402,19 @@ class LineProfiler(object):
         self.prevline = None
         self.include_children = kw.get('include_children', False)
 
-    def __call__(self, func):
-        self.add_function(func)
-        f = self.wrap_function(func)
-        f.__module__ = func.__module__
-        f.__name__ = func.__name__
-        f.__doc__ = func.__doc__
-        f.__dict__.update(getattr(func, '__dict__', {}))
-        return f
+    def __call__(self, func=None, precision=1):
+        if func is not None:
+            self.add_function(func)
+            f = self.wrap_function(func)
+            f.__module__ = func.__module__
+            f.__name__ = func.__name__
+            f.__doc__ = func.__doc__
+            f.__dict__.update(getattr(func, '__dict__', {}))
+            return f
+        else:
+            def inner_partial(func):
+                return self.__call__(func, precision=precision)
+            return inner_partial
 
     def add_code(self, code, toplevel_code=None):
         if code not in self.code_map:
@@ -781,16 +791,21 @@ def load_ipython_extension(ip):
     ip.define_magic('memit', magic_memit)
 
 
-def profile(func, stream=None):
+def profile(func=None, stream=None, precision=1):
     """"""
     Decorator that will run the function and print a line-by-line profile
     """"""
-    def wrapper(*args, **kwargs):
-        prof = LineProfiler()
-        val = prof(func)(*args, **kwargs)
-        show_results(prof, stream=stream)
-        return val
-    return wrapper
+    if func is not None:
+        def wrapper(*args, **kwargs):
+            prof = LineProfiler()
+            val = prof(func)(*args, **kwargs)
+            show_results(prof, stream=stream, precision=precision)
+            return val
+        return wrapper
+    else:
+        def inner_wrapper(func):
+            return profile(func, stream=stream, precision=precision)
+        return inner_wrapper
 
 
 if __name__ == '__main__':
"
,test/test_precision_command_line.py,baf0fccd7a098742c2ed9e94c9be183c841fa86d,b0b4a3caa5f738b80899381411e8d93ac83c0928,"Parameterize @profile decorator with precision

Add precision parameter to @profile decorator to specify precision if import is
used instead of -m memory_profiler","@@ -0,0 +1,35 @@
+# .. an example to test decorator with precision keyword argument ..
+""""""
+Test profiling using command line ``profile`` function (either
+``TimeStamper`` or ``LineProfiler``) with precision specified as command
+line parameter.
+The precision argument specified in the decorator, therefore, is not used.
+""""""
+
+import time
+
+@profile(precision=4)
+def test_1():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    time.sleep(0.6)
+    del b
+
+    for i in range(2):
+        a = [1] * (10 ** 6)
+        b = [2] * (2 * 10 ** 7)
+        del b
+    return a
+
+@profile(precision=2)
+def test_2():
+    a = {}
+    time.sleep(0.5)
+    for i in range(10000):
+        a[i] = i + 1
+    time.sleep(0.6)
+    return
+
+if __name__ == '__main__':
+    test_1()
+    test_2()
"
,test/test_precision_import.py,baf0fccd7a098742c2ed9e94c9be183c841fa86d,b0b4a3caa5f738b80899381411e8d93ac83c0928,"Parameterize @profile decorator with precision

Add precision parameter to @profile decorator to specify precision if import is
used instead of -m memory_profiler","@@ -0,0 +1,37 @@
+# .. an example to test decorator with precision keyword argument ..
+""""""
+Test profiling using imported ``profile`` function with precision
+specified as parameter to ``profile`` function.
+This is useful if the python script we're trying to profile is called as a
+module (like `python -m test_module`) and so we can't specify command line
+precision parameter.
+""""""
+
+import time
+from memory_profiler import profile
+
+@profile(precision=4)
+def test_1():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    time.sleep(0.6)
+    del b
+
+    for i in range(2):
+        a = [1] * (10 ** 6)
+        b = [2] * (2 * 10 ** 7)
+        del b
+    return a
+
+@profile(precision=5)
+def test_2():
+    a = {}
+    time.sleep(0.5)
+    for i in range(10000):
+        a[i] = i + 1
+    time.sleep(0.6)
+    return
+
+if __name__ == '__main__':
+    test_1()
+    test_2()
"
README.rst,README.rst,186799b23eb2a49623ee8dadbf9d13f68205f08a,b0b4a3caa5f738b80899381411e8d93ac83c0928,added SpeedIT to: Projects using memory_profiler,"@@ -311,6 +311,8 @@ Projects using memory_profiler
 
 `Benchy <https://github.com/python-recsys/benchy>`_
 
+`SpeedIT <https://github.com/peter1000/SpeedIT>`_ (uses a reduced version of memory_profiler)
+
 =========
  Authors
 =========
"
memory_profiler.py,memory_profiler.py,3247a33c21bcb1a3a465dd2f915c8cc9a75ff62c,baf0fccd7a098742c2ed9e94c9be183c841fa86d,Change parameter name to avoid name conflict,"@@ -345,8 +345,8 @@ class TimeStamper:
             f.__dict__.update(getattr(func, '__dict__', {}))
             return f
         else:
-            def inner_partial(func):
-                return self.__call__(func, precision=precision)
+            def inner_partial(f):
+                return self.__call__(f, precision=precision)
             return inner_partial
 
     def timestamp(self, name=""<block>""):
@@ -412,8 +412,8 @@ class LineProfiler(object):
             f.__dict__.update(getattr(func, '__dict__', {}))
             return f
         else:
-            def inner_partial(func):
-                return self.__call__(func, precision=precision)
+            def inner_partial(f):
+                return self.__call__(f, precision=precision)
             return inner_partial
 
     def add_code(self, code, toplevel_code=None):
@@ -803,8 +803,8 @@ def profile(func=None, stream=None, precision=1):
             return val
         return wrapper
     else:
-        def inner_wrapper(func):
-            return profile(func, stream=stream, precision=precision)
+        def inner_wrapper(f):
+            return profile(f, stream=stream, precision=precision)
         return inner_wrapper
 
 
"
setup.py,setup.py,40963ebdeb2874eab00ad1dac5ee181cde0f7455,3689a28b6eac9bef291e95e7b972cb8a05198956,import setuptools because I love `python setup.py develop`,"@@ -1,5 +1,6 @@
 import memory_profiler
 from distutils.core import setup
+import setuptools
 
 CLASSIFIERS = """"""\
 Development Status :: 5 - Production/Stable
"
README.rst,README.rst,3d44876ae8979b1a2c7f94b5acd3135a59529a44,40963ebdeb2874eab00ad1dac5ee181cde0f7455,IPython memory usage,"@@ -311,6 +311,9 @@ Projects using memory_profiler
 
 `Benchy <https://github.com/python-recsys/benchy>`_
 
+`IPython memory usage <https://github.com/ianozsvald/ipython_memory_usage_>`_
+
+
 =========
  Authors
 =========
"
mprof,mprof,de9a92884f7111dd2f3417705fcd21dac00aa0a3,47d65baa13abc8b3887a4ded6bd1a96b36853b35,"mprof plot: add option to save plot to file

Use as: mprof plot -o <filename>.<ext>","@@ -401,6 +401,8 @@ def plot_action():
     parser.add_option(""--no-function-ts"", ""-n"", dest=""no_timestamps"",
                       default=False, action=""store_true"",
                       help=""Do not display function timestamps on plot."")
+    parser.add_option(""--output"", ""-o"",
+                      help=""Save plot to file instead of displaying it."")
     (options, args) = parser.parse_args()
 
     profiles = glob.glob(""mprofile_??????????????.dat"")
@@ -449,7 +451,10 @@ def plot_action():
     leg = ax.legend(loc='best', fancybox=True)
     leg.get_frame().set_alpha(0.5)
     pl.grid()
-    pl.show()
+    if options.output:
+        pl.savefig(options.output)
+    else:
+        pl.show()
 
 if __name__ == ""__main__"":
     # Workaround for optparse limitation: insert -- before first negative
"
mprof,mprof,cfc9be15a9eb3b1211ea98e614d8a3a6853c03f5,de9a92884f7111dd2f3417705fcd21dac00aa0a3,mprof plot: more line colors,"@@ -354,7 +354,7 @@ def plot_file(filename, index=0, timestamps=True):
     max_mem_ind = mem.argmax()
 
     all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
-    mem_line_colors=('k', ""b"", ""r"")
+    mem_line_colors=(""k"", ""b"", ""r"", ""g"", ""c"", ""y"", ""m"")
     mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
                                    time.localtime(global_start)) \
                                    + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
"
README.rst,README.rst,829c379a22313be9ddfa2e2dd1624e513787f38a,2a8e81bf271392327301825e551fc4114a2d5857,"FIX: new ref link update

FIX: new ref link update","@@ -328,7 +328,7 @@ Projects using memory_profiler
 
 `IPython memory usage <https://github.com/ianozsvald/ipython_memory_usage_>`_
 
-`SpeedIT <https://github.com/peter1000/SpeedIT>`_ (uses a reduced version of memory_profiler)
+`PySpeedIT <https://github.com/peter1000/PySpeedIT>`_ (uses a reduced version of memory_profiler)
 
 =========
  Authors
"
,COPYING,7175b2943f67eeffc97e4a43656e069b6edb64ad,4da80112472c1eea5a90d86059220027e08f90fd,add lincese file,"@@ -0,0 +1,32 @@
+New BSD License
+
+Copyright (c) 2007–2014 Fabian Pedregosa.
+All rights reserved.
+
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+  a. Redistributions of source code must retain the above copyright notice,
+     this list of conditions and the following disclaimer.
+  b. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+  c. Neither the name of the Scikit-learn Developers  nor the names of
+     its contributors may be used to endorse or promote products
+     derived from this software without specific prior written
+     permission. 
+
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGE.
+
"
memory_profiler.py,memory_profiler.py,538dd0393cf4485e7e8d56e774c6a93343b53431,7175b2943f67eeffc97e4a43656e069b6edb64ad,version 0.32,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _clean_globals = globals().copy()
 
-__version__ = '0.31'
+__version__ = '0.32'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
setup.py,setup.py,538dd0393cf4485e7e8d56e774c6a93343b53431,7175b2943f67eeffc97e4a43656e069b6edb64ad,version 0.32,"@@ -26,7 +26,7 @@ setup(
     long_description=open('README.rst').read(),
     version=memory_profiler.__version__,
     author='Fabian Pedregosa',
-    author_email='fabian@fseoane.net',
+    author_email='f@bianp.net',
     url='http://pypi.python.org/pypi/memory_profiler',
     py_modules=['memory_profiler'],
     scripts=['mprof'],
"
COPYING,COPYING,5be9f83706cea6a6cae1ad4eb0ca072c89832938,538dd0393cf4485e7e8d56e774c6a93343b53431,Update COPYING,"@@ -12,7 +12,7 @@ modification, are permitted provided that the following conditions are met:
   b. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
-  c. Neither the name of the Scikit-learn Developers  nor the names of
+  c. Neither the name of the memory_profiler developers nor the names of
      its contributors may be used to endorse or promote products
      derived from this software without specific prior written
      permission. 
"
README.rst,README.rst,721c5b5536f8e22dbc5ecb785eb86056d4818fb2,5be9f83706cea6a6cae1ad4eb0ca072c89832938,Update README.rst,"@@ -352,4 +352,4 @@ cleanup.
 =========
  License
 =========
-Simplified BSD
+BSD License, see file COPYING for full text.
"
setup.py,setup.py,30cf67fc403d54fec5e42dd0b07a25ebb36a4070,721c5b5536f8e22dbc5ecb785eb86056d4818fb2,Correct the license,"@@ -6,7 +6,7 @@ CLASSIFIERS = """"""\
 Development Status :: 5 - Production/Stable
 Intended Audience :: Science/Research
 Intended Audience :: Developers
-License :: OSI Approved
+License :: OSI Approved :: BSD License
 Programming Language :: Python
 Programming Language :: Python :: 2
 Programming Language :: Python :: 2.6
@@ -31,6 +31,6 @@ setup(
     py_modules=['memory_profiler'],
     scripts=['mprof'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
-    license='Simplified BSD'
+    license='BSD'
 
 )
"
mprof,mprof,fe9415e207d1b7c1e222a02cf3c9f19ef8f9fa49,43393405ca0e8e5cf549a9358382287d0c93df6d,better doc and example for mprof,"@@ -13,19 +13,23 @@ from optparse import OptionParser
 
 import memory_profiler as mp
 
+ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"")
 
 def print_usage():
     print(""Usage: %s <command> <options> <arguments>""
-          % osp.basename(sys.argv[0]))
+                  % osp.basename(sys.argv[0]))
+    print(""Where <command> is one of: "" + "" "".join(ALL_ACTIONS))
+    print(""Type mprof <command> --help for usage help"")
+
+
 
 def get_action():
     """"""Pop first argument, check it is a valid action.""""""
-    all_actions = (""run"", ""rm"", ""clean"", ""list"", ""plot"")
     if len(sys.argv) <= 1:
         print_usage()
         sys.exit(1)
-    if not sys.argv[1] in all_actions:
-        print(""Valid actions are: "" + "" "".join(all_actions))
+    if not sys.argv[1] in ALL_ACTIONS:
+        print_usage()
         sys.exit(1)
 
     return sys.argv.pop(1)
@@ -178,7 +182,7 @@ def run_action():
                       a Python program (currently: function timestamping.)"""""")
     parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.1"",
                       type=""float"", action=""store"",
-                      help=""Sampling period (in seconds)"")
+                      help=""Sampling period (in seconds), defaults to 0.1"")
     parser.add_option(""--include-children"", ""-C"", dest=""include_children"",
                       default=False, action=""store_true"",
                       help=""""""Monitors forked processes as well (sum up all process memory)"""""")
@@ -285,6 +289,8 @@ def read_mprofile_file(filename):
     cmd_line = None
     f = open(filename, ""r"")
     for l in f:
+        if l == '\n':
+            raise ValueError('Sampling time was too short')
         field, value = l.split(' ', 1)
         if field == ""MEM"":
             # mem, timestamp
"
test/test_func.py,test/test_func.py,fe9415e207d1b7c1e222a02cf3c9f19ef8f9fa49,43393405ca0e8e5cf549a9358382287d0c93df6d,better doc and example for mprof,"@@ -1,11 +1,11 @@
 
 @profile
-def test_1():
+def test_1(i):
     # .. will be called twice ..
     c = {}
-    for i in range(1000):
+    for i in range(i):
         c[i] = 2
 
 if __name__ == '__main__':
-    test_1()
-    test_1()
+    test_1(10)
+    test_1(10000)
"
test/test_mprofile.py,test/test_mprofile.py,fe9415e207d1b7c1e222a02cf3c9f19ef8f9fa49,43393405ca0e8e5cf549a9358382287d0c93df6d,better doc and example for mprof,"@@ -3,21 +3,19 @@
 import time
 
 @profile
-def test1():
-    a = [1] * 100000
+def test1(l):
+    a = [1] * l
     time.sleep(1)
     return a
 
 @profile
 def test2(l):
-    b = [2 * n for n in l]
+    b = [1] * l
     time.sleep(1)
-    del b
-
+    return b
 
 if __name__ == ""__main__"":
-    time.sleep(1)
-    l = test1()
-    test2(l)
-    time.sleep(1)
+    l = 100000
+    test1(l)
+    test2(2 * l)
 
"
mprof,mprof,8d72e54c395d7d721bd4101a7f8fed3c6ecc9b41,fe9415e207d1b7c1e222a02cf3c9f19ef8f9fa49,Better help message for mprof,"@@ -14,12 +14,23 @@ from optparse import OptionParser
 import memory_profiler as mp
 
 ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"")
+help_msg = """"""
+Available commands:
+
+    run      run a given command or python file
+    rm       remove a given file generated by mprof
+    clean    clean the current directory from files created by mprof
+    list     display existing profiles, with indices
+    plot     plot memory consumption generated by mprof run
+
+Type mprof <command> --help for usage help on a specific command.
+For example, mprof plot --help will list all plotting options.
+""""""
 
 def print_usage():
     print(""Usage: %s <command> <options> <arguments>""
                   % osp.basename(sys.argv[0]))
-    print(""Where <command> is one of: "" + "" "".join(ALL_ACTIONS))
-    print(""Type mprof <command> --help for usage help"")
+    print(help_msg)
 
 
 
"
memory_profiler.py,memory_profiler.py,aaf3ae481774d31316e71a58450f0ce8fe651635,8d72e54c395d7d721bd4101a7f8fed3c6ecc9b41,avoid loading attribute if not exists,"@@ -45,12 +45,11 @@ def _get_memory(pid, timestamps=False, include_children=False):
     if has_psutil:
         process = psutil.Process(pid)
         try:
-            mem_info = getattr(process, 'memory_info', process.get_memory_info)
-            mem = mem_info()[0] / _TWO_20
+            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
+            mem = getattr(process, meminfo_attr)()[0] / _TWO_20
             if include_children:
                 for p in process.get_children(recursive=True):
-                    mem_info = getattr(p, 'memory_info', p.get_memory_info)
-                    mem += mem_info()[0] / _TWO_20
+                    mem += getattr(process, meminfo_attr)()[0] / _TWO_20
             if timestamps:
                 return (mem, time.time())
             else:
"
memory_profiler.py,memory_profiler.py,6694c530d1d60a9e00cda8578fb98c3056937016,7cf3b3eea920684955f1f093389a76e35bc49aea,Add comment on psutil 2.0,"@@ -45,6 +45,8 @@ def _get_memory(pid, timestamps=False, include_children=False):
     if has_psutil:
         process = psutil.Process(pid)
         try:
+            # avoid useing get_memory_info since it does not exists 
+            # in psutil > 2.0 and accessing it will cause exception.
             meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
             mem = getattr(process, meminfo_attr)()[0] / _TWO_20
             if include_children:
"
mprof,mprof,9ff038f85734afbdb9a25d7626eb13f3a3081b56,6694c530d1d60a9e00cda8578fb98c3056937016,only append if profile number is converted,"@@ -441,10 +441,10 @@ def plot_action():
             else:
                 try:
                     n = int(arg)
+                    if not profiles[n] in filenames:
+                        filenames.append(profiles[n])
                 except ValueError:
                     print(""Input file not found: "" + arg)
-                if not profiles[n] in filenames:
-                    filenames.append(profiles[n])
 
     pl.figure(figsize=(14, 6), dpi=90)
     if len(filenames) > 1 or options.no_timestamps:
"
mprof,mprof,05e9714eac18a6d9d8c581391cd5604360331b70,9ff038f85734afbdb9a25d7626eb13f3a3081b56,Quit if no file found at all and tell when using last profile data,"@@ -431,6 +431,7 @@ def plot_action():
                   ""mprofile_*.dat files, generated by the ""
                   ""'mprof run' command."")
             sys.exit(-1)
+        print(""Using last profile data."")
         filenames = [profiles[-1]]
     else:
         filenames = []
@@ -445,6 +446,9 @@ def plot_action():
                         filenames.append(profiles[n])
                 except ValueError:
                     print(""Input file not found: "" + arg)
+    if not len(filenames):
+        print(""No files found from given input."")
+        sys.exit(-1)
 
     pl.figure(figsize=(14, 6), dpi=90)
     if len(filenames) > 1 or options.no_timestamps:
"
README.rst,README.rst,95d5cafefe3c4124861eb7ba0afd5a7f43d44bd8,42f683fb3155dfd96edd5ee1ffc80c384715a235,"- Generation of report from memory_profiler
- Added reporting feature via logging module","@@ -227,6 +227,45 @@ args, kw)``. For example::
 This will execute the code `f(1, n=int(1e6))` and return the memory
 consumption during this execution.
 
+=====
+ REPORTING
+=====
+
+The output can be redirected to a log file by passing IO stream as
+parameter to the decorator like @profile(stream=fp)
+
+    >>> fp=open('hi.txt','w+')
+    >>> @profile(stream=fp)
+    >>> def my_func():
+        ...     a = [1] * (10 ** 6)
+        ...     b = [2] * (2 * 10 ** 7)
+        ...     del b
+        ...     return a
+
+Reporting via logger Module:
+
+Sometime it'd be very convenient to use logger module specially when
+we need to use RotatingFileHandler.
+
+The output can be redirected to logger module by simply making use of
+LogFile of memory profiler module.
+
+    >>> from memory_profiler import LogFile
+    >>> import sys
+    >>> sys.stdout = LogFile('memory_profile_log')
+
+Customised reporting:
+
+Sending everything to the log file while running the memory_profiler
+could be cumbersome and one can choose only entries with increments
+by passing True to reportIncrementFlag, where reportIncrementFlag is
+a parameter to LogFile class of memory profiler module.
+
+    >>> from memory_profiler import LogFile
+    >>> import sys
+    >>> sys.stdout = LogFile('memory_profile_log', reportIncrementFlag=False)
+
+Refer examples section for details.
 
 =====================
  IPython integration
"
examples/example.py,examples/example.py,95d5cafefe3c4124861eb7ba0afd5a7f43d44bd8,42f683fb3155dfd96edd5ee1ffc80c384715a235,"- Generation of report from memory_profiler
- Added reporting feature via logging module","@@ -1,4 +1,4 @@
-
+from memory_profiler import profile
 @profile
 def my_func():
     a = [1] * (10 ** 6)
"
,examples/reportingViaLogger.py,95d5cafefe3c4124861eb7ba0afd5a7f43d44bd8,42f683fb3155dfd96edd5ee1ffc80c384715a235,"- Generation of report from memory_profiler
- Added reporting feature via logging module","@@ -0,0 +1,39 @@
+from memory_profiler import profile
+import logging
+
+# create logger
+logger = logging.getLogger('memory_profile_log')
+logger.setLevel(logging.DEBUG)
+
+# create file handler which logs even debug messages
+fh = logging.FileHandler(""memory_profile.log"")
+fh.setLevel(logging.DEBUG)
+
+# create formatter
+formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
+fh.setFormatter(formatter)
+
+# add the handlers to the logger
+logger.addHandler(fh)
+
+from memory_profiler import LogFile
+import sys
+sys.stdout = LogFile('memory_profile_log', reportIncrementFlag=False)
+
+@profile
+def my_func():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    del b
+    return a
+
+@profile
+def my_func1():
+    a = [2] * (10 ** 6)
+    b = [3] * (2 * 10 ** 7)
+    del b
+    return a
+
+if __name__ == '__main__':
+    my_func()
+    my_func1()
\ No newline at end of file
"
,examples/reporting_file.py,95d5cafefe3c4124861eb7ba0afd5a7f43d44bd8,42f683fb3155dfd96edd5ee1ffc80c384715a235,"- Generation of report from memory_profiler
- Added reporting feature via logging module","@@ -0,0 +1,21 @@
+from memory_profiler import profile
+
+f=open('hi.txt','w+')
+
+@profile(stream=f)
+def my_func():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    del b
+    return a
+
+@profile(stream=f)
+def my_func1():
+    a = [2] * (10 ** 6)
+    b = [3] * (2 * 10 ** 7)
+    del b
+    return a
+
+if __name__ == '__main__':
+    my_func()
+    my_func1()
\ No newline at end of file
"
memory_profiler.py,memory_profiler.py,744c5abe0724f91e86b358e5170a97247619bf37,95d5cafefe3c4124861eb7ba0afd5a7f43d44bd8,"- Generation of report from memory_profiler
- Added reporting feature via logging module","@@ -16,6 +16,7 @@ import linecache
 import inspect
 import subprocess
 from copy import copy
+import logging
 
 # TODO: provide alternative when multprocessing is not available
 try:
@@ -808,6 +809,25 @@ def profile(func=None, stream=None, precision=1):
             return profile(f, stream=stream, precision=precision)
         return inner_wrapper
 
+class LogFile(object):
+    """"""File-like object to log text using the `logging` module and the log report can be customised.""""""
+
+    def __init__(self, name=None, reportIncrementFlag=False):
+        self.logger = logging.getLogger(name)
+        self.reportIncrementFlag = reportIncrementFlag
+
+    def write(self, msg, level=logging.INFO):
+        if self.reportIncrementFlag:
+            if ""MiB"" in msg and float(msg.split(""MiB"")[1].strip())>0:
+                self.logger.log(level, msg)
+            elif msg.__contains__(""Filename:"") or msg.__contains__(""Line Contents""):
+                self.logger.log(level, msg)
+        else:
+            self.logger.log(level, msg)
+
+    def flush(self):
+        for handler in self.logger.handlers:
+            handler.flush()
 
 if __name__ == '__main__':
     from optparse import OptionParser
"
README.rst,README.rst,9d605c869e01de505ed513cdb0adb50508e9792d,744c5abe0724f91e86b358e5170a97247619bf37,updated README,"@@ -234,7 +234,7 @@ consumption during this execution.
 The output can be redirected to a log file by passing IO stream as
 parameter to the decorator like @profile(stream=fp)
 
-    >>> fp=open('hi.txt','w+')
+    >>> fp=open('memory_profiler.log','w+')
     >>> @profile(stream=fp)
     >>> def my_func():
         ...     a = [1] * (10 ** 6)
@@ -242,10 +242,12 @@ parameter to the decorator like @profile(stream=fp)
         ...     del b
         ...     return a
 
+    For details refer: examples/reporting_file.py
+
 Reporting via logger Module:
 
-Sometime it'd be very convenient to use logger module specially when
-we need to use RotatingFileHandler.
+Sometime it would be very convenient to use logger module specially
+when we need to use RotatingFileHandler.
 
 The output can be redirected to logger module by simply making use of
 LogFile of memory profiler module.
@@ -265,7 +267,7 @@ a parameter to LogFile class of memory profiler module.
     >>> import sys
     >>> sys.stdout = LogFile('memory_profile_log', reportIncrementFlag=False)
 
-Refer examples section for details.
+    For details refer: examples/reportingViaLogger.py
 
 =====================
  IPython integration
"
examples/reportingViaLogger.py,examples/reporting_logger.py,f855b6fc45d0c11759a865064c15a1dd4e4a2f6d,9d605c869e01de505ed513cdb0adb50508e9792d,"Rename reportingViaLogger.py to reporting_logger.py

Renamed filename","@@ -36,4 +36,4 @@ def my_func1():
 
 if __name__ == '__main__':
     my_func()
-    my_func1()
\ No newline at end of file
+    my_func1()
"
README.rst,README.rst,ce73d205d86c3f4e30f9130f8f9238d682f3cd2c,f855b6fc45d0c11759a865064c15a1dd4e4a2f6d,Update README.rst,"@@ -267,7 +267,7 @@ a parameter to LogFile class of memory profiler module.
     >>> import sys
     >>> sys.stdout = LogFile('memory_profile_log', reportIncrementFlag=False)
 
-    For details refer: examples/reportingViaLogger.py
+    For details refer: examples/reporting_logger.py
 
 =====================
  IPython integration
"
README.rst,README.rst,96272299e46e9fb85764b6ffcc9e5012456df4ee,ce73d205d86c3f4e30f9130f8f9238d682f3cd2c,Updated based on review comments,"@@ -244,7 +244,7 @@ parameter to the decorator like @profile(stream=fp)
 
     For details refer: examples/reporting_file.py
 
-Reporting via logger Module:
+``Reporting via logger Module:``
 
 Sometime it would be very convenient to use logger module specially
 when we need to use RotatingFileHandler.
@@ -256,7 +256,7 @@ LogFile of memory profiler module.
     >>> import sys
     >>> sys.stdout = LogFile('memory_profile_log')
 
-Customised reporting:
+``Customised reporting:``
 
 Sending everything to the log file while running the memory_profiler
 could be cumbersome and one can choose only entries with increments
@@ -389,6 +389,8 @@ cleanup.
 
 `Thomas Kluyver <https://github.com/takluyver>`_ added the IPython extension.
 
+`Sagar UDAY KUMAR <https://github.com/sagaru>`_ added Report generation feature and examples.
+
 
 =========
  License
"
memory_profiler.py,memory_profiler.py,96272299e46e9fb85764b6ffcc9e5012456df4ee,ce73d205d86c3f4e30f9130f8f9238d682f3cd2c,Updated based on review comments,"@@ -813,6 +813,14 @@ class LogFile(object):
     """"""File-like object to log text using the `logging` module and the log report can be customised.""""""
 
     def __init__(self, name=None, reportIncrementFlag=False):
+        """"""
+        :param name: name of the logger module
+               reportIncrementFlag: This must be set to True if only the steps with memory increments are to be reported
+
+        :type self: object
+              name: string
+              reportIncrementFlag: bool
+        """"""
         self.logger = logging.getLogger(name)
         self.reportIncrementFlag = reportIncrementFlag
 
"
README.rst,README.rst,8b50ac14e37f6e52407c7b1428aa3aa17a610143,96272299e46e9fb85764b6ffcc9e5012456df4ee,"Update README.rst

Updated project list","@@ -371,6 +371,8 @@ Projects using memory_profiler
 
 `PySpeedIT <https://github.com/peter1000/PySpeedIT>`_ (uses a reduced version of memory_profiler)
 
+`pydio-sync <https://github.com/pydio/pydio-sync>`_ (uses custom wrapper on top of memory_profiler)
+
 =========
  Authors
 =========
"
README.rst,README.rst,46d47ae38f98e72d02bca3cba9bb1b987c5983bc,0e032d99388d7e1468fa38984ed700b29646b2f7,Update README.rst,"@@ -344,7 +344,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
  Support, bugs & wish list
 ===========================
 For support, please ask your question on `stack overflow
-<http://stackoverflow.com/>`_ and add the *memory-profiling* tag.
+<http://stackoverflow.com/>`_ and add the [*memory-profiling* tag](http://stackoverflow.com/questions/tagged/memory-profiling).
 Send issues, proposals, etc. to `github's issue tracker
 <https://github.com/fabianp/memory_profiler/issues>`_ .
 
"
README.rst,README.rst,29c5f4bd38eaade075e5b0587dbfbaed1db0452d,46d47ae38f98e72d02bca3cba9bb1b987c5983bc,Update README.rst,"@@ -344,7 +344,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
  Support, bugs & wish list
 ===========================
 For support, please ask your question on `stack overflow
-<http://stackoverflow.com/>`_ and add the [*memory-profiling* tag](http://stackoverflow.com/questions/tagged/memory-profiling).
+<http://stackoverflow.com/>`_ and add the `*memory-profiling* tag <http://stackoverflow.com/questions/tagged/memory-profiling>`_.
 Send issues, proposals, etc. to `github's issue tracker
 <https://github.com/fabianp/memory_profiler/issues>`_ .
 
"
mprof,mprof,16ffef7b23ac720d45b0bb6be14bf1732cf75c44,29c5f4bd38eaade075e5b0587dbfbaed1db0452d,Check arguments before logging in run_action.,"@@ -199,13 +199,14 @@ def run_action():
                       help=""""""Monitors forked processes as well (sum up all process memory)"""""")
 
     (options, args) = parser.parse_args()
-    print(""{1}: Sampling memory every {0.interval}s"".format(
-        options, osp.basename(sys.argv[0])))
 
     if len(args) == 0:
         print(""A program to run must be provided. Use -h for help"")
         sys.exit(1)
 
+    print(""{1}: Sampling memory every {0.interval}s"".format(
+        options, osp.basename(sys.argv[0])))
+
     ## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
     ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
     ## directory. This file contains the process memory consumption, in Mb (one
"
memory_profiler.py,memory_profiler.py,73772a8bd7cba8cac674d6a0f8f437c9a8f6b9df,29c5f4bd38eaade075e5b0587dbfbaed1db0452d,Switch case for _clean_locals variable.,"@@ -1,7 +1,7 @@
 """"""Profile the memory usage of a Python program""""""
 
 # .. we'll use this to pass it to the child script ..
-_clean_globals = globals().copy()
+_CLEAN_GLOBALS = globals().copy()
 
 __version__ = '0.32'
 
@@ -46,7 +46,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
     if has_psutil:
         process = psutil.Process(pid)
         try:
-            # avoid useing get_memory_info since it does not exists 
+            # avoid useing get_memory_info since it does not exists
             # in psutil > 2.0 and accessing it will cause exception.
             meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
             mem = getattr(process, meminfo_attr)()[0] / _TWO_20
@@ -877,13 +877,13 @@ if __name__ == '__main__':
             # script where @profile is used)
             import __builtin__
             __builtin__.__dict__['profile'] = prof
-            ns = copy(_clean_globals)
+            ns = copy(_CLEAN_GLOBALS)
             ns['profile'] = prof  # shadow the profile decorator defined above
             execfile(__file__, ns, ns)
         else:
             import builtins
             builtins.__dict__['profile'] = prof
-            ns = copy(_clean_globals)
+            ns = copy(_CLEAN_GLOBALS)
             ns['profile'] = prof  # shadow the profile decorator defined above
             exec(compile(open(__file__).read(), __file__, 'exec'), ns, ns)
     finally:
"
README.rst,README.rst,4a37b2abdb25f1e527e7d4512ed5009219c21f93,a05270f16bd18087a1c7f2c46ae9c9ef2ce49eed,New release,"@@ -131,22 +131,16 @@ script with
 
     mprof run --python <script>
 
-will record timestamps when entering/leaving the profiled function,
-and plot them on the graph afterward. 
-An example output can be found 
-`here <https://github.com/scikit-learn/scikit-learn/pull/2248>`_
+will record timestamps when entering/leaving the profiled function. Runnning
 
-It is also possible to timestamp a portion of code using a context
-manager like this::
+    mprof plot
 
-    def my_func():
-        a = [1] * (10 ** 6)
-        with profile.timestamp(""b_computation""):
-            b = [2] * (2 * 10 ** 7)
-        del b
-        return a
+afterward will plot the result, making plots (using matplotlib) similar to these:
 
-the string provided in the call will be displayed in the plot.
+.. image:: https://camo.githubusercontent.com/3a584c7cfbae38c9220a755aa21b5ef926c1031d/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313930383631382f3836313332302f63623865376337382d663563632d313165322d386531652d3539373237623636663462322e706e67
+   :target: https://github.com/scikit-learn/scikit-learn/pull/2248
+
+A discussion of these capabilities can be found `here <http://fa.bianp.net/blog/2014/plot-memory-usage-as-a-function-of-time/>`_.
 
 The available commands for `mprof` are: 
 
"
memory_profiler.py,memory_profiler.py,4a37b2abdb25f1e527e7d4512ed5009219c21f93,a05270f16bd18087a1c7f2c46ae9c9ef2ce49eed,New release,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.32'
+__version__ = '0.33'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
memory_profiler.py,memory_profiler.py,77d06a3b5b33c897f18c48d9e22d28506eb0878c,4a37b2abdb25f1e527e7d4512ed5009219c21f93,new release,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.33'
+__version__ = '0.34'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
README.rst,README.rst,fe77c9b92ed439b05d34a69ff5d8b096e5827dfc,77d06a3b5b33c897f18c48d9e22d28506eb0878c,new version,"@@ -139,6 +139,7 @@ afterward will plot the result, making plots (using matplotlib) similar to these
 
 .. image:: https://camo.githubusercontent.com/3a584c7cfbae38c9220a755aa21b5ef926c1031d/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313930383631382f3836313332302f63623865376337382d663563632d313165322d386531652d3539373237623636663462322e706e67
    :target: https://github.com/scikit-learn/scikit-learn/pull/2248
+   :height: 350px
 
 A discussion of these capabilities can be found `here <http://fa.bianp.net/blog/2014/plot-memory-usage-as-a-function-of-time/>`_.
 
@@ -221,9 +222,9 @@ args, kw)``. For example::
 This will execute the code `f(1, n=int(1e6))` and return the memory
 consumption during this execution.
 
-=====
- REPORTING
-=====
+=========
+REPORTING
+=========
 
 The output can be redirected to a log file by passing IO stream as
 parameter to the decorator like @profile(stream=fp)
"
memory_profiler.py,memory_profiler.py,fe77c9b92ed439b05d34a69ff5d8b096e5827dfc,77d06a3b5b33c897f18c48d9e22d28506eb0878c,new version,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.34'
+__version__ = '0.36'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
memory_profiler.py,memory_profiler.py,0e53367d24128ed4960c0f8210e8d046303c2a9d,fe77c9b92ed439b05d34a69ff5d8b096e5827dfc,Fix for issue #101,"@@ -51,8 +51,13 @@ def _get_memory(pid, timestamps=False, include_children=False):
             meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
             mem = getattr(process, meminfo_attr)()[0] / _TWO_20
             if include_children:
-                for p in process.get_children(recursive=True):
-                    mem += getattr(process, meminfo_attr)()[0] / _TWO_20
+                try:
+                    for p in process.get_children(recursive=True):
+                        mem += getattr(process, meminfo_attr)()[0] / _TWO_20
+                except AttributeError:
+                    # fix for newer psutil
+                    for p in process.children(recursive=True):
+                        mem += getattr(process, meminfo_attr)()[0] / _TWO_20
             if timestamps:
                 return (mem, time.time())
             else:
"
README.rst,README.rst,18dccd18565763459ecb49434db81c9bf8b5fab3,0e53367d24128ed4960c0f8210e8d046303c2a9d,"Warn about memory_profiler/mprof interplay

This took me time to track down - running memory_profiler in a script run via mprof will prevent the function timings being recorded & plotted on the graph.","@@ -143,6 +143,8 @@ afterward will plot the result, making plots (using matplotlib) similar to these
 
 A discussion of these capabilities can be found `here <http://fa.bianp.net/blog/2014/plot-memory-usage-as-a-function-of-time/>`_.
 
+.. warning:: If your Python file imports the memory profiler `from memory_profiler import profile` these timestamps will not be recorded. Comment out the import, leave your functions decorated, and re-run.
+
 The available commands for `mprof` are: 
 
   - ``mprof run``: running an executable, recording memory usage  
"
examples/numpy_example.py,examples/numpy_example.py,fdab5be7fe335f834b60f7beee1632f72a96eb4c,0e53367d24128ed4960c0f8210e8d046303c2a9d,fix for plots cut out of figure,"@@ -5,7 +5,7 @@ import scipy.signal
 @profile
 def create_data():
     ret = []
-    for n in xrange(70):
+    for n in range(70):
         ret.append(np.random.randn(1, 70, 71, 72))
     return ret
 
"
memory_profiler.py,memory_profiler.py,fdab5be7fe335f834b60f7beee1632f72a96eb4c,0e53367d24128ed4960c0f8210e8d046303c2a9d,fix for plots cut out of figure,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.36'
+__version__ = '0.37'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
mprof,mprof,fdab5be7fe335f834b60f7beee1632f72a96eb4c,0e53367d24128ed4960c0f8210e8d046303c2a9d,fix for plots cut out of figure,"@@ -451,7 +451,8 @@ def plot_action():
         print(""No files found from given input."")
         sys.exit(-1)
 
-    pl.figure(figsize=(14, 6), dpi=90)
+    fig = pl.figure(figsize=(14, 6), dpi=90)
+    ax = fig.add_axes([0.1, 0.1, 0.6, 0.75])
     if len(filenames) > 1 or options.no_timestamps:
         timestamps = False
     else:
@@ -467,10 +468,9 @@ def plot_action():
         if options.title is not None:
             pl.title(options.title)
 
-    ax = pl.gca()
     # place legend within the plot, make partially transparent in
     # case it obscures part of the lineplot
-    leg = ax.legend(loc='best', fancybox=True)
+    leg = ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))
     leg.get_frame().set_alpha(0.5)
     pl.grid()
     if options.output:
"
README.rst,README.rst,8ad99995cc04210451ab7cc41ad409945fe130f5,018a4775bd5a03ec68769b3061728ee5d52b3511,Add %%mprun and %%memit cell magics.,"@@ -269,8 +269,8 @@ a parameter to LogFile class of memory profiler module.
 =====================
  IPython integration
 =====================
-After installing the module, if you use IPython, you can use the `%mprun`
-and `%memit` magics.
+After installing the module, if you use IPython, you can use the `%mprun`, `%%mprun`,
+`%memit` and `%%memit` magics.
 
 For IPython 0.11+, you can use the module directly as an extension, with
 ``%load_ext memory_profiler``
@@ -288,22 +288,36 @@ the list)::
 a terminal.)
 
 It then can be used directly from IPython to obtain a line-by-line
-report using the `%mprun` magic command. In this case, you can skip
+report using the `%mprun` or `%%mprun` magic command. In this case, you can skip
 the `@profile` decorator and instead use the `-f` parameter, like
 this. Note however that function my_func must be defined in a file
 (cannot have been defined interactively in the Python interpreter)::
 
-    In [1] from example import my_func
+    In [1]: from example import my_func, my_func_2
 
-    In [2] %mprun -f my_func my_func()
+    In [2]: %mprun -f my_func my_func()
+
+or in cell mode::
+
+    In [3]: %%mprun -f my_func -f my_func_2
+       ...: my_func()
+       ...: my_func_2()
 
 Another useful magic that we define is `%memit`, which is analogous to
 `%timeit`. It can be used as follows::
 
-    In [1]: import numpy as np
+    In [1]: %memit range(10000)
+    peak memory: 21.42 MiB, increment: 0.41 MiB
 
-    In [2]: %memit np.zeros(1e7)
-    maximum of 3: 76.402344 MB per loop
+    In [2]: %memit range(1000000)
+    peak memory: 52.10 MiB, increment: 31.08 MiB
+
+or in cell mode (with setup code)::
+
+    In [3]: %%memit l=range(1000000)
+       ...: len(l)
+       ...:
+    peak memory: 52.14 MiB, increment: 0.08 MiB
 
 For more details, see the docstrings of the magics.
 
@@ -316,8 +330,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
 
     # These two are the important ones.
     import memory_profiler
-    ip.expose_magic('mprun', memory_profiler.magic_mprun)
-    ip.expose_magic('memit', memory_profiler.magic_memit)
+    memory_profiler.load_ipython_extension(ip)
 
 ============================
  Frequently Asked Questions
@@ -373,7 +386,7 @@ Projects using memory_profiler
 =========
  Authors
 =========
-This module was written by `Fabian Pedregosa <http://fseoane.net>`_ 
+This module was written by `Fabian Pedregosa <http://fseoane.net>`_
 and `Philippe Gervais <https://github.com/pgervais>`_
 inspired by Robert Kern's `line profiler
 <http://packages.python.org/line_profiler/>`_.
"
memory_profiler.py,memory_profiler.py,8ad99995cc04210451ab7cc41ad409945fe130f5,018a4775bd5a03ec68769b3061728ee5d52b3511,Add %%mprun and %%memit cell magics.,"@@ -24,6 +24,16 @@ try:
 except ImportError:
     from multiprocessing.dummy import Process, Pipe
 
+try:
+    from IPython.core.magic import Magics, line_cell_magic, magics_class
+except ImportError:
+    # ipython_version < '0.13'
+    Magics = object
+    line_cell_magic = lambda func: func
+    magics_class = lambda cls: cls
+
+PY3 = sys.version_info[0] == 3
+
 _TWO_20 = float(2 ** 20)
 
 has_psutil = False
@@ -593,209 +603,271 @@ def show_results(prof, stream=None, precision=1):
         stream.write('\n\n')
 
 
-# A lprun-style %mprun magic for IPython.
-def magic_mprun(self, parameter_s=''):
-    """""" Execute a statement under the line-by-line memory profiler from the
-    memory_profiler module.
-
-    Usage:
-      %mprun -f func1 -f func2 <statement>
-
-    The given statement (which doesn't require quote marks) is run via the
-    LineProfiler. Profiling is enabled for the functions specified by the -f
-    options. The statistics will be shown side-by-side with the code through
-    the pager once the statement has completed.
-
-    Options:
-
-    -f <function>: LineProfiler only profiles functions and methods it is told
-    to profile.  This option tells the profiler about these functions. Multiple
-    -f options may be used. The argument may be any expression that gives
-    a Python function or method object. However, one must be careful to avoid
-    spaces that may confuse the option parser. Additionally, functions defined
-    in the interpreter at the In[] prompt or via %run currently cannot be
-    displayed.  Write these functions out to a separate file and import them.
-
-    One or more -f options are required to get any useful results.
-
-    -T <filename>: dump the text-formatted statistics with the code
-    side-by-side out to a text file.
-
-    -r: return the LineProfiler object after it has completed profiling.
-
-    -c: If present, add the memory usage of any children process to the report.
-    """"""
-    try:
-        from StringIO import StringIO
-    except ImportError:  # Python 3.x
-        from io import StringIO
-
-    # Local imports to avoid hard dependency.
-    from distutils.version import LooseVersion
-    import IPython
-    ipython_version = LooseVersion(IPython.__version__)
-    if ipython_version < '0.11':
-        from IPython.genutils import page
-        from IPython.ipstruct import Struct
-        from IPython.ipapi import UsageError
-    else:
-        from IPython.core.page import page
-        from IPython.utils.ipstruct import Struct
-        from IPython.core.error import UsageError
-
-    # Escape quote markers.
-    opts_def = Struct(T=[''], f=[])
-    parameter_s = parameter_s.replace('""', r'\""').replace(""'"", r""\'"")
-    opts, arg_str = self.parse_options(parameter_s, 'rf:T:c', list_all=True)
-    opts.merge(opts_def)
-    global_ns = self.shell.user_global_ns
-    local_ns = self.shell.user_ns
-
-    # Get the requested functions.
-    funcs = []
-    for name in opts.f:
-        try:
-            funcs.append(eval(name, global_ns, local_ns))
-        except Exception as e:
-            raise UsageError('Could not find function %r.\n%s: %s' % (name,
-                             e.__class__.__name__, e))
-
-    include_children = 'c' in opts
-    profile = LineProfiler(include_children=include_children)
-    for func in funcs:
-        profile(func)
-
-    # Add the profiler to the builtins for @profile.
-    try:
-        import builtins
-    except ImportError:  # Python 3x
-        import __builtin__ as builtins
-
-    if 'profile' in builtins.__dict__:
-        had_profile = True
-        old_profile = builtins.__dict__['profile']
-    else:
-        had_profile = False
-        old_profile = None
-    builtins.__dict__['profile'] = profile
-
-    try:
-        try:
-            profile.runctx(arg_str, global_ns, local_ns)
-            message = ''
-        except SystemExit:
-            message = ""*** SystemExit exception caught in code being profiled.""
-        except KeyboardInterrupt:
-            message = (""*** KeyboardInterrupt exception caught in code being ""
-                       ""profiled."")
-    finally:
-        if had_profile:
-            builtins.__dict__['profile'] = old_profile
-
-    # Trap text output.
-    stdout_trap = StringIO()
-    show_results(profile, stdout_trap)
-    output = stdout_trap.getvalue()
-    output = output.rstrip()
-
-    if ipython_version < '0.11':
-        page(output, screen_lines=self.shell.rc.screen_length)
-    else:
-        page(output)
-    print(message,)
-
-    text_file = opts.T[0]
-    if text_file:
-        with open(text_file, 'w') as pfile:
-            pfile.write(output)
-        print('\n*** Profile printout saved to text file %s. %s' % (text_file,
-                                                                    message))
-
-    return_value = None
-    if 'r' in opts:
-        return_value = profile
-
-    return return_value
-
-
 def _func_exec(stmt, ns):
     # helper for magic_memit, just a function proxy for the exec
     # statement
     exec(stmt, ns)
 
-# a timeit-style %memit magic for IPython
 
+@magics_class
+class MemoryProfilerMagics(Magics):
 
-def magic_memit(self, line=''):
-    """"""Measure memory usage of a Python statement
+    # A lprun-style %mprun magic for IPython.
+    @line_cell_magic
+    def mprun(self, parameter_s='', cell=None):
+        """""" Execute a statement under the line-by-line memory profiler from the
+        memory_profiler module.
 
-    Usage, in line mode:
-      %memit [-r<R>t<T>i<I>] statement
+        Usage, in line mode:
+          %mprun -f func1 -f func2 <statement>
 
-    Options:
-    -r<R>: repeat the loop iteration <R> times and take the best result.
-    Default: 1
+        Usage, in cell mode:
+          %%mprun -f func1 -f func2 [statement]
+          code...
+          code...
 
-    -t<T>: timeout after <T> seconds. Default: None
+        In cell mode, the additional code lines are appended to the (possibly
+        empty) statement in the first line. Cell mode allows you to easily
+        profile multiline blocks without having to put them in a separate
+        function.
 
-    -i<I>: Get time information at an interval of I times per second.
-        Defaults to 0.1 so that there is ten measurements per second.
+        The given statement (which doesn't require quote marks) is run via the
+        LineProfiler. Profiling is enabled for the functions specified by the -f
+        options. The statistics will be shown side-by-side with the code through
+        the pager once the statement has completed.
 
-    -c: If present, add the memory usage of any children process to the report.
+        Options:
 
-    Examples
-    --------
-    ::
+        -f <function>: LineProfiler only profiles functions and methods it is told
+        to profile.  This option tells the profiler about these functions. Multiple
+        -f options may be used. The argument may be any expression that gives
+        a Python function or method object. However, one must be careful to avoid
+        spaces that may confuse the option parser. Additionally, functions defined
+        in the interpreter at the In[] prompt or via %run currently cannot be
+        displayed.  Write these functions out to a separate file and import them.
 
-      In [1]: import numpy as np
+        One or more -f options are required to get any useful results.
 
-      In [2]: %memit np.zeros(1e7)
-      maximum of 1: 76.402344 MiB per loop
+        -T <filename>: dump the text-formatted statistics with the code
+        side-by-side out to a text file.
 
-      In [3]: %memit np.ones(1e6)
-      maximum of 1: 7.820312 MiB per loop
+        -r: return the LineProfiler object after it has completed profiling.
 
-      In [4]: %memit -r 10 np.empty(1e8)
-      maximum of 10: 0.101562 MiB per loop
+        -c: If present, add the memory usage of any children process to the report.
+        """"""
+        from memory_profiler import show_results, LineProfiler
+        try:
+            from StringIO import StringIO
+        except ImportError:  # Python 3.x
+            from io import StringIO
 
-    """"""
-    opts, stmt = self.parse_options(line, 'r:t:i:c', posix=False, strict=False)
-    repeat = int(getattr(opts, 'r', 1))
-    if repeat < 1:
-        repeat == 1
-    timeout = int(getattr(opts, 't', 0))
-    if timeout <= 0:
-        timeout = None
-    interval = float(getattr(opts, 'i', 0.1))
-    include_children = 'c' in opts
+        # Local imports to avoid hard dependency.
+        from distutils.version import LooseVersion
+        import IPython
+        ipython_version = LooseVersion(IPython.__version__)
+        if ipython_version < '0.11':
+            from IPython.genutils import page
+            from IPython.ipstruct import Struct
+            from IPython.ipapi import UsageError
+        else:
+            from IPython.core.page import page
+            from IPython.utils.ipstruct import Struct
+            from IPython.core.error import UsageError
 
-    # I've noticed we get less noisier measurements if we run
-    # a garbage collection first
-    import gc
-    gc.collect()
+        # Escape quote markers.
+        opts_def = Struct(T=[''], f=[])
+        parameter_s = parameter_s.replace('""', r'\""').replace(""'"", r""\'"")
+        opts, arg_str = self.parse_options(parameter_s, 'rf:T:c', list_all=True)
+        opts.merge(opts_def)
+        global_ns = self.shell.user_global_ns
+        local_ns = self.shell.user_ns
 
-    mem_usage = 0
-    counter = 0
-    baseline = memory_usage()[0]
-    while counter < repeat:
-        counter += 1
-        tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
-                           timeout=timeout, interval=interval, max_usage=True,
-                           include_children=include_children)
-        mem_usage = max(mem_usage, tmp[0])
+        if cell is not None:
+            arg_str += '\n' + cell
 
-    if mem_usage:
-        print('peak memory: %.02f MiB, increment: %.02f MiB' %
-              (mem_usage, mem_usage - baseline))
-    else:
-        print('ERROR: could not read memory usage, try with a lower interval '
-              'or more iterations')
+        # Get the requested functions.
+        funcs = []
+        for name in opts.f:
+            try:
+                funcs.append(eval(name, global_ns, local_ns))
+            except Exception as e:
+                raise UsageError('Could not find function %r.\n%s: %s' % (name,
+                                 e.__class__.__name__, e))
+
+        include_children = 'c' in opts
+        profile = LineProfiler(include_children=include_children)
+        for func in funcs:
+            profile(func)
+
+        # Add the profiler to the builtins for @profile.
+        if PY3:
+            import builtins
+        else:
+            import __builtin__ as builtins
+
+        if 'profile' in builtins.__dict__:
+            had_profile = True
+            old_profile = builtins.__dict__['profile']
+        else:
+            had_profile = False
+            old_profile = None
+        builtins.__dict__['profile'] = profile
+
+        try:
+            try:
+                profile.runctx(arg_str, global_ns, local_ns)
+                message = ''
+            except SystemExit:
+                message = ""*** SystemExit exception caught in code being profiled.""
+            except KeyboardInterrupt:
+                message = (""*** KeyboardInterrupt exception caught in code being ""
+                           ""profiled."")
+        finally:
+            if had_profile:
+                builtins.__dict__['profile'] = old_profile
+
+        # Trap text output.
+        stdout_trap = StringIO()
+        show_results(profile, stdout_trap)
+        output = stdout_trap.getvalue()
+        output = output.rstrip()
+
+        if ipython_version < '0.11':
+            page(output, screen_lines=self.shell.rc.screen_length)
+        else:
+            page(output)
+        print(message,)
+
+        text_file = opts.T[0]
+        if text_file:
+            with open(text_file, 'w') as pfile:
+                pfile.write(output)
+            print('\n*** Profile printout saved to text file %s. %s' % (text_file,
+                                                                        message))
+
+        return_value = None
+        if 'r' in opts:
+            return_value = profile
+
+        return return_value
+
+    # a timeit-style %memit magic for IPython
+    @line_cell_magic
+    def memit(self, line='', cell=None):
+        """"""Measure memory usage of a Python statement
+
+        Usage, in line mode:
+          %memit [-r<R>t<T>i<I>] statement
+
+        Usage, in cell mode:
+          %%memit [-r<R>t<T>i<I>] setup_code
+          code...
+          code...
+
+        This function can be used both as a line and cell magic:
+
+        - In line mode you can measure a single-line statement (though multiple
+          ones can be chained with using semicolons).
+
+        - In cell mode, the statement in the first line is used as setup code
+          (executed but not measured) and the body of the cell is measured.
+          The cell body has access to any variables created in the setup code.
+
+        Options:
+        -r<R>: repeat the loop iteration <R> times and take the best result.
+        Default: 1
+
+        -t<T>: timeout after <T> seconds. Default: None
+
+        -i<I>: Get time information at an interval of I times per second.
+            Defaults to 0.1 so that there is ten measurements per second.
+
+        -c: If present, add the memory usage of any children process to the report.
+
+        Examples
+        --------
+        ::
+
+          In [1]: %memit range(10000)
+          peak memory: 21.42 MiB, increment: 0.41 MiB
+
+          In [2]: %memit range(1000000)
+          peak memory: 52.10 MiB, increment: 31.08 MiB
+
+          In [3]: %%memit l=range(1000000)
+             ...: len(l)
+             ...:
+          peak memory: 52.14 MiB, increment: 0.08 MiB
+
+        """"""
+        from memory_profiler import memory_usage, _func_exec
+        opts, stmt = self.parse_options(line, 'r:t:i:c', posix=False, strict=False)
+
+        if cell is None:
+            setup = 'pass'
+        else:
+            setup = stmt
+            stmt = cell
+
+        repeat = int(getattr(opts, 'r', 1))
+        if repeat < 1:
+            repeat == 1
+        timeout = int(getattr(opts, 't', 0))
+        if timeout <= 0:
+            timeout = None
+        interval = float(getattr(opts, 'i', 0.1))
+        include_children = 'c' in opts
+
+        # I've noticed we get less noisier measurements if we run
+        # a garbage collection first
+        import gc
+        gc.collect()
+
+        _func_exec(setup, self.shell.user_ns)
+
+        mem_usage = 0
+        counter = 0
+        baseline = memory_usage()[0]
+        while counter < repeat:
+            counter += 1
+            tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
+                               timeout=timeout, interval=interval, max_usage=True,
+                               include_children=include_children)
+            mem_usage = max(mem_usage, tmp[0])
+
+        if mem_usage:
+            print('peak memory: %.02f MiB, increment: %.02f MiB' %
+                  (mem_usage, mem_usage - baseline))
+        else:
+            print('ERROR: could not read memory usage, try with a lower interval '
+                  'or more iterations')
+
+    @classmethod
+    def register_magics(cls, ip):
+        from distutils.version import LooseVersion
+        import IPython
+        ipython_version = LooseVersion(IPython.__version__)
+
+        if ipython_version < '0.13':
+            try:
+                _register_magic = ip.define_magic
+            except AttributeError:  # ipython 0.10
+                _register_magic = ip.expose_magic
+
+            _register_magic('mprun', cls.mprun.__func__)
+            _register_magic('memit', cls.memit.__func__)
+        else:
+            ip.register_magics(cls)
+
+# Ensuring old interface of magics expose for IPython 0.10
+magic_mprun = MemoryProfilerMagics.mprun.__func__
+magic_memit = MemoryProfilerMagics.memit.__func__
 
 
 def load_ipython_extension(ip):
     """"""This is called to load the module as an IPython extension.""""""
-    ip.define_magic('mprun', magic_mprun)
-    ip.define_magic('memit', magic_memit)
+
+    MemoryProfilerMagics.register_magics(ip)
 
 
 def profile(func=None, stream=None, precision=1):
@@ -875,7 +947,7 @@ if __name__ == '__main__':
         prof = LineProfiler(max_mem=options.max_mem)
     __file__ = _find_script(args[0])
     try:
-        if sys.version_info[0] < 3:
+        if not PY3:
             # we need to ovewrite the builtins to have profile
             # globally defined (global variables is not enough
             # for all cases, e.g. a script that imports another
"
memory_profiler.py,memory_profiler.py,909017dea183338da8d72ad2cc2a6f266015cf07,219e9b92aaa1e9775e0ede8f89f543d83ce3b7ac,FIX __func__ attribute under Python 3,"@@ -860,8 +860,8 @@ class MemoryProfilerMagics(Magics):
             ip.register_magics(cls)
 
 # Ensuring old interface of magics expose for IPython 0.10
-magic_mprun = MemoryProfilerMagics.mprun.__func__
-magic_memit = MemoryProfilerMagics.memit.__func__
+magic_mprun = MemoryProfilerMagics().mprun.__func__
+magic_memit = MemoryProfilerMagics().memit.__func__
 
 
 def load_ipython_extension(ip):
"
mprof,mprof,beca98e4dc206fdc6acdedc35f645bd02d918110,909017dea183338da8d72ad2cc2a6f266015cf07,Add 'window' support to plot a particular time range,"@@ -236,7 +236,7 @@ def run_action():
                          include_children=options.include_children, stream=f)
 
 
-def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
+def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
     """"""Add two brackets on the memory line plot.
 
     This function uses the current figure.
@@ -265,10 +265,12 @@ def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None):
     # Matplotlib workaround: labels starting with _ aren't displayed
     if label[0] == '_':
         label = ' ' + label
-    pl.plot(bracket_x + xloc[0] - xshift, bracket_y + yloc[0],
-            ""-"" + color, linewidth=2, label=label)
-    pl.plot(-bracket_x + xloc[1] - xshift, bracket_y + yloc[1],
-            ""-"" + color, linewidth=2 )
+    if options.xlim is None or options.xlim[0] <= (xloc[0] - xshift) <= options.xlim[1]:
+        pl.plot(bracket_x + xloc[0] - xshift, bracket_y + yloc[0],
+                ""-"" + color, linewidth=2, label=label)
+    if options.xlim is None or options.xlim[0] <= (xloc[1] - xshift) <= options.xlim[1]:
+        pl.plot(-bracket_x + xloc[1] - xshift, bracket_y + yloc[1],
+                ""-"" + color, linewidth=2 )
 
     # TODO: use matplotlib.patches.Polygon to draw a colored background for
     # each function.
@@ -330,7 +332,7 @@ def read_mprofile_file(filename):
 
 
 
-def plot_file(filename, index=0, timestamps=True):
+def plot_file(filename, index=0, timestamps=True, options=None):
     try:
         import pylab as pl
     except ImportError:
@@ -392,7 +394,7 @@ def plot_file(filename, index=0, timestamps=True):
                 add_brackets(execution[:2], execution[2:], xshift=global_start,
                              color= all_colors[func_num % len(all_colors)],
                              label=f.split(""."")[-1]
-                             + "" %.3fs"" % (execution[1] - execution[0]))
+                             + "" %.3fs"" % (execution[1] - execution[0]), options=options)
             func_num += 1
 
     if timestamps:
@@ -405,6 +407,15 @@ def plot_file(filename, index=0, timestamps=True):
 
 
 def plot_action():
+    def get_comma_separated_args(option, opt, value, parser):
+        try:
+            newvalue = [float(x) for x in value.split(',')]
+        except:
+            raise OptionValueError(""'%s' option must contain two numbers separated with a comma"" % value)
+        if len(newvalue) != 2:
+            raise OptionValueError(""'%s' option must contain two numbers separated with a comma"" % value)
+        setattr(parser.values, option.dest, newvalue)
+
     try:
         import pylab as pl
     except ImportError:
@@ -421,6 +432,10 @@ def plot_action():
                       help=""Do not display function timestamps on plot."")
     parser.add_option(""--output"", ""-o"",
                       help=""Save plot to file instead of displaying it."")
+    parser.add_option(""--window"", ""-w"", dest=""xlim"",
+                      type=""str"", action=""callback"",
+                      callback=get_comma_separated_args,
+                      help=""Plot a time-subset of the data. E.g. to plot between 0 and 20.5 seconds: --window 0,20.5"")
     (options, args) = parser.parse_args()
 
     profiles = glob.glob(""mprofile_??????????????.dat"")
@@ -453,12 +468,15 @@ def plot_action():
 
     fig = pl.figure(figsize=(14, 6), dpi=90)
     ax = fig.add_axes([0.1, 0.1, 0.6, 0.75])
+    if options.xlim is not None:
+        pl.xlim(options.xlim[0], options.xlim[1])
+
     if len(filenames) > 1 or options.no_timestamps:
         timestamps = False
     else:
         timestamps = True
     for n, filename in enumerate(filenames):
-        mprofile = plot_file(filename, index=n, timestamps=timestamps)
+        mprofile = plot_file(filename, index=n, timestamps=timestamps, options=options)
     pl.xlabel(""time (in seconds)"")
     pl.ylabel(""memory used (in MiB)"")
 
"
README.rst,README.rst,b894c6e4d8065fed49ded1f87b4950b3658b1921,909017dea183338da8d72ad2cc2a6f266015cf07,Update README.rst,"@@ -25,7 +25,11 @@ To install from source, download the package, extract and type::
  Usage
 =======
 
-The line-by-line profiler is used much in the same way of the
+
+line-by-line memory usage
+=========================
+
+The line-by-line memory usage mode is used much in the same way of the
 `line_profiler <https://pypi.python.org/pypi/line_profiler/>`_: first
 decorate the function you would like to profile with ``@profile`` and
 then run the script with a special script (in this case with specific
@@ -103,7 +107,7 @@ decorator function.  Use as follows::
 If a python script with decorator ``@profile`` is called using ``-m 
 memory_profiler`` in the command line, the ``precision`` parameter is ignored.
 
-Executing external scripts
+Time-based memory usage 
 ==========================
 Sometimes it is useful to have full memory usage reports as a function of
 time (not line-by-line) of external processes (be it Python scripts or not).
@@ -129,7 +133,7 @@ of the code that is causing the highest memory usage.
 Adding the `profile` decorator to a function and running the Python
 script with 
 
-    mprof run --python <script>
+    mprof run <script>
 
 will record timestamps when entering/leaving the profiled function. Runnning
 
"
memory_profiler.py,memory_profiler.py,23d8a23665af56e77fb0903e8818dd46f51f5b36,b894c6e4d8065fed49ded1f87b4950b3658b1921,New version,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.37'
+__version__ = '0.38'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
mprof,mprof,1af4784db76fd44095fa9a1d2a04c24955301347,beca98e4dc206fdc6acdedc35f645bd02d918110,"Fix ""NameError: name 'OptionValueError' is not defined""","@@ -9,7 +9,7 @@ import copy
 import time
 import math
 
-from optparse import OptionParser
+from optparse import OptionParser, OptionValueError
 
 import memory_profiler as mp
 
"
memory_profiler.py,memory_profiler.py,fdf9ef3ab33bb8b57857979a91571728376fa762,23d8a23665af56e77fb0903e8818dd46f51f5b36,temporary fix for #106,"@@ -859,9 +859,11 @@ class MemoryProfilerMagics(Magics):
         else:
             ip.register_magics(cls)
 
-# Ensuring old interface of magics expose for IPython 0.10
-magic_mprun = MemoryProfilerMagics().mprun.__func__
-magic_memit = MemoryProfilerMagics().memit.__func__
+# commenting out due to failures with some versions of IPython
+# see https://github.com/fabianp/memory_profiler/issues/106
+# # Ensuring old interface of magics expose for IPython 0.10
+# magic_mprun = MemoryProfilerMagics().mprun.__func__
+# magic_memit = MemoryProfilerMagics().memit.__func__
 
 
 def load_ipython_extension(ip):
"
memory_profiler.py,memory_profiler.py,7aad92e4b6254c49cc298ac25a426616c47febc0,d3c57424665cb2304f40d469f9e73fc3b9c76257,Bogus computation of memory for process children,"@@ -63,11 +63,11 @@ def _get_memory(pid, timestamps=False, include_children=False):
             if include_children:
                 try:
                     for p in process.get_children(recursive=True):
-                        mem += getattr(process, meminfo_attr)()[0] / _TWO_20
+                        mem += getattr(p, meminfo_attr)()[0] / _TWO_20
                 except AttributeError:
                     # fix for newer psutil
                     for p in process.children(recursive=True):
-                        mem += getattr(process, meminfo_attr)()[0] / _TWO_20
+                        mem += getattr(p, meminfo_attr)()[0] / _TWO_20
             if timestamps:
                 return (mem, time.time())
             else:
"
.gitignore,.gitignore,17156325f6cab26e5e387045a3da968fb1ab9b5e,2bd93b6494e80525f06fdbb278ebedc720f9765e,Ignore *.egg-info,"@@ -1,6 +1,7 @@
 .idea
 dist
 build
-*.pyc
 MANIFEST
+*.egg-info
+*.pyc
 *~
"
memory_profiler.py,memory_profiler.py,f30ff08b0d5aafe3202233d5f7224548163119ee,17156325f6cab26e5e387045a3da968fb1ab9b5e,Review code,"@@ -15,10 +15,9 @@ import warnings
 import linecache
 import inspect
 import subprocess
-from copy import copy
 import logging
 
-# TODO: provide alternative when multprocessing is not available
+# TODO: provide alternative when multiprocessing is not available
 try:
     from multiprocessing import Process, Pipe
 except ImportError:
@@ -36,14 +35,17 @@ PY3 = sys.version_info[0] == 3
 
 _TWO_20 = float(2 ** 20)
 
-has_psutil = False
+if PY3:
+    import builtins
+else:
+    import __builtin__ as builtins
 
 # .. get available packages ..
 try:
     import psutil
     has_psutil = True
 except ImportError:
-    pass
+    has_psutil = False
 
 
 def _get_memory(pid, timestamps=False, include_children=False):
@@ -102,7 +104,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
             if timestamps:
                 return (-1, time.time())
             else:
-                    return -1
+                return -1
     else:
         raise NotImplementedError('The psutil module is required for non-unix '
                                   'platforms')
@@ -121,29 +123,21 @@ class MemTimer(Process):
         self.max_usage = max_usage
         self.n_measurements = 1
 
-        if ""timestamps"" in kw:
-            self.timestamps = kw[""timestamps""]
-            del kw[""timestamps""]
-        else:
-            self.timestamps = False
-        if ""include_children"" in kw:
-            self.include_children = kw[""include_children""]
-            del kw[""include_children""]
-        else:
-            self.include_children = False
+        self.timestamps = kw.pop(""timestamps"", False)
+        self.include_children = kw.pop(""include_children"", False)
+
         # get baseline memory usage
         self.mem_usage = [
             _get_memory(self.monitor_pid, timestamps=self.timestamps,
                         include_children=self.include_children)]
         super(MemTimer, self).__init__(*args, **kw)
 
-
     def run(self):
         self.pipe.send(0)  # we're ready
         stop = False
         while True:
             cur_mem = _get_memory(self.monitor_pid, timestamps=self.timestamps,
-                            include_children=self.include_children)
+                                  include_children=self.include_children)
             if not self.max_usage:
                 self.mem_usage.append(cur_mem)
             else:
@@ -223,7 +217,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         # for a Python function wait until it finishes
         max_iter = float('inf')
 
-    if hasattr(proc, '__call__'):
+    if callable(proc):
         proc = (proc, (), {})
     if isinstance(proc, (list, tuple)):
         if len(proc) == 1:
@@ -238,7 +232,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         while True:
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
             p = MemTimer(os.getpid(), interval, child_conn, timestamps=timestamps,
-                      max_usage=max_usage, include_children=include_children)
+                         max_usage=max_usage, include_children=include_children)
             p.start()
             parent_conn.recv()  # wait until we start getting memory
             returned = f(*args, **kw)
@@ -263,9 +257,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 else:
                     ret.append(mem_usage)
             else:
-                ret = max([ret,
-                           _get_memory(proc.pid,
-                                       include_children=include_children)])
+                ret = max(ret,
+                          _get_memory(proc.pid,
+                                      include_children=include_children))
             time.sleep(interval)
             line_count += 1
             # flush every 50 lines. Make 'tail -f' usable on profile file
@@ -351,7 +345,7 @@ class TimeStamper:
 
     def __call__(self, func=None, precision=None):
         if func is not None:
-            if not hasattr(func, ""__call__""):
+            if not callable(func):
                 raise ValueError(""Value must be callable"")
 
             self.add_function(func)
@@ -380,7 +374,7 @@ class TimeStamper:
         return _TimeStamperCM(timestamps)
 
     def add_function(self, func):
-        if not func in self.functions:
+        if func not in self.functions:
             self.functions[func] = []
 
     def wrap_function(self, func):
@@ -391,11 +385,10 @@ class TimeStamper:
             timestamps = [_get_memory(os.getpid(), timestamps=True)]
             self.functions[func].append(timestamps)
             try:
-                result = func(*args, **kwds)
+                return func(*args, **kwds)
             finally:
                 # end time
                 timestamps.append(_get_memory(os.getpid(), timestamps=True))
-            return result
         return f
 
     def show_results(self, stream=None):
@@ -459,10 +452,9 @@ class LineProfiler(object):
         def f(*args, **kwds):
             self.enable_by_count()
             try:
-                result = func(*args, **kwds)
+                return func(*args, **kwds)
             finally:
                 self.disable_by_count()
-            return result
         return f
 
     def run(self, cmd):
@@ -521,8 +513,8 @@ class LineProfiler(object):
         if event in ('line', 'return') and frame.f_code in self.code_map:
             c = _get_memory(-1)
             if c >= self.max_mem:
-                t = ('Current memory {0:.2f} MiB exceeded the maximum'
-                     ''.format(c) + 'of {0:.2f} MiB\n'.format(self.max_mem))
+                t = ('Current memory {0:.2f} MiB exceeded the '
+                     'maximum of {1:.2f} MiB\n'.format(c, self.max_mem))
                 sys.stdout.write(t)
                 sys.stdout.write('Stepping into the debugger \n')
                 frame.f_lineno -= 2
@@ -655,11 +647,8 @@ class MemoryProfilerMagics(Magics):
 
         -c: If present, add the memory usage of any children process to the report.
         """"""
+        from io import StringIO
         from memory_profiler import show_results, LineProfiler
-        try:
-            from StringIO import StringIO
-        except ImportError:  # Python 3.x
-            from io import StringIO
 
         # Local imports to avoid hard dependency.
         from distutils.version import LooseVersion
@@ -700,11 +689,6 @@ class MemoryProfilerMagics(Magics):
             profile(func)
 
         # Add the profiler to the builtins for @profile.
-        if PY3:
-            import builtins
-        else:
-            import __builtin__ as builtins
-
         if 'profile' in builtins.__dict__:
             had_profile = True
             old_profile = builtins.__dict__['profile']
@@ -714,14 +698,13 @@ class MemoryProfilerMagics(Magics):
         builtins.__dict__['profile'] = profile
 
         try:
-            try:
-                profile.runctx(arg_str, global_ns, local_ns)
-                message = ''
-            except SystemExit:
-                message = ""*** SystemExit exception caught in code being profiled.""
-            except KeyboardInterrupt:
-                message = (""*** KeyboardInterrupt exception caught in code being ""
-                           ""profiled."")
+            profile.runctx(arg_str, global_ns, local_ns)
+            message = ''
+        except SystemExit:
+            message = ""*** SystemExit exception caught in code being profiled.""
+        except KeyboardInterrupt:
+            message = (""*** KeyboardInterrupt exception caught in code being ""
+                       ""profiled."")
         finally:
             if had_profile:
                 builtins.__dict__['profile'] = old_profile
@@ -888,6 +871,25 @@ def profile(func=None, stream=None, precision=1):
             return profile(f, stream=stream, precision=precision)
         return inner_wrapper
 
+
+# Insert in the built-ins to have profile
+# globally defined (global variables is not enough
+# for all cases, e.g. a script that imports another
+# script where @profile is used)
+if PY3:
+    def exec_with_profiler(filename, profiler):
+        builtins.__dict__['profile'] = profiler
+        # shadow the profile decorator defined above
+        ns = dict(_CLEAN_GLOBALS, profile=profiler)
+        with open(filename) as f:
+            exec(compile(f.read(), filename, 'exec'), ns, ns)
+else:
+    def exec_with_profiler(filename, profiler):
+        builtins.__dict__['profile'] = profiler
+        ns = dict(_CLEAN_GLOBALS, profile=profiler)
+        execfile(filename, ns, ns)
+
+
 class LogFile(object):
     """"""File-like object to log text using the `logging` module and the log report can be customised.""""""
 
@@ -905,7 +907,7 @@ class LogFile(object):
 
     def write(self, msg, level=logging.INFO):
         if self.reportIncrementFlag:
-            if ""MiB"" in msg and float(msg.split(""MiB"")[1].strip())>0:
+            if ""MiB"" in msg and float(msg.split(""MiB"")[1].strip()) > 0:
                 self.logger.log(level, msg)
             elif msg.__contains__(""Filename:"") or msg.__contains__(""Line Contents""):
                 self.logger.log(level, msg)
@@ -916,6 +918,7 @@ class LogFile(object):
         for handler in self.logger.handlers:
             handler.flush()
 
+
 if __name__ == '__main__':
     from optparse import OptionParser
     parser = OptionParser(usage=_CMD_USAGE, version=__version__)
@@ -947,24 +950,9 @@ if __name__ == '__main__':
         prof = TimeStamper()
     else:
         prof = LineProfiler(max_mem=options.max_mem)
-    __file__ = _find_script(args[0])
+    script_filename = _find_script(args[0])
     try:
-        if not PY3:
-            # we need to ovewrite the builtins to have profile
-            # globally defined (global variables is not enough
-            # for all cases, e.g. a script that imports another
-            # script where @profile is used)
-            import __builtin__
-            __builtin__.__dict__['profile'] = prof
-            ns = copy(_CLEAN_GLOBALS)
-            ns['profile'] = prof  # shadow the profile decorator defined above
-            execfile(__file__, ns, ns)
-        else:
-            import builtins
-            builtins.__dict__['profile'] = prof
-            ns = copy(_CLEAN_GLOBALS)
-            ns['profile'] = prof  # shadow the profile decorator defined above
-            exec(compile(open(__file__).read(), __file__, 'exec'), ns, ns)
+        exec_with_profiler(script_filename, prof)
     finally:
         if options.out_filename is not None:
             out_file = open(options.out_filename, ""a"")
"
Makefile,Makefile,372b290a0ab8217d1780ae7624d486debd4e190a,f30ff08b0d5aafe3202233d5f7224548163119ee,Refactor to compute memory of generators and list/set/dict comprehensions,"@@ -8,6 +8,7 @@ test:
 	$(PYTHON) -m memory_profiler test/test_as.py
 	$(PYTHON) -m memory_profiler test/test_global.py
 	$(PYTHON) -m memory_profiler test/test_precision_command_line.py
+	$(PYTHON) -m memory_profiler test/test_gen.py
 	$(PYTHON) test/test_import.py
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
"
memory_profiler.py,memory_profiler.py,372b290a0ab8217d1780ae7624d486debd4e190a,f30ff08b0d5aafe3202233d5f7224548163119ee,Refactor to compute memory of generators and list/set/dict comprehensions,"@@ -402,15 +402,64 @@ class TimeStamper:
                     (function_name,) + ts[0] + ts[1]))
 
 
+class CodeMap(dict):
+
+    def __init__(self, include_children):
+        self.include_children = include_children
+        self._toplevel = []
+
+    def add(self, code, toplevel_code=None):
+        if code in self:
+            return
+
+        if toplevel_code is None:
+            filename = code.co_filename
+            if filename.endswith(("".pyc"", "".pyo"")):
+                filename = filename[:-1]
+            if not os.path.exists(filename):
+                print('ERROR: Could not find file ' + filename)
+                if filename.startswith((""ipython-input"", ""<ipython-input"")):
+                    print(""NOTE: %mprun can only be used on functions defined in ""
+                          ""physical files, and not in the IPython environment."")
+                return
+
+            toplevel_code = code
+            (sub_lines, start_line) = inspect.getsourcelines(code)
+            linenos = range(start_line,
+                            start_line + len(sub_lines))
+            self._toplevel.append((filename, code, linenos))
+            self[code] = {}
+        else:
+            self[code] = self[toplevel_code]
+
+        for subcode in filter(inspect.iscode, code.co_consts):
+            self.add(subcode, toplevel_code=toplevel_code)
+
+    def trace(self, code, lineno):
+        memory = _get_memory(-1, include_children=self.include_children)
+        # if there is already a measurement for that line get the max
+        previous_memory = self[code].get(lineno, 0)
+        self[code][lineno] = max(memory, previous_memory)
+
+    def items(self):
+        """"""Iterate on the toplevel code blocks.""""""
+        for (filename, code, linenos) in self._toplevel:
+            measures = self[code]
+            if not measures:
+                continue    # skip if no measurement
+            line_iterator = ((line, measures.get(line)) for line in linenos)
+            yield (filename, line_iterator)
+
+
 class LineProfiler(object):
     """""" A profiler that records the amount of memory for each line """"""
 
     def __init__(self, **kw):
-        self.code_map = {}
+        include_children = kw.get('include_children', False)
+        self.code_map = CodeMap(include_children=include_children)
         self.enable_count = 0
         self.max_mem = kw.get('max_mem', None)
-        self.prevline = None
-        self.include_children = kw.get('include_children', False)
+        self.prevlines = []
 
     def __call__(self, func=None, precision=1):
         if func is not None:
@@ -426,13 +475,6 @@ class LineProfiler(object):
                 return self.__call__(f, precision=precision)
             return inner_partial
 
-    def add_code(self, code, toplevel_code=None):
-        if code not in self.code_map:
-            self.code_map[code] = {}
-
-            for subcode in filter(inspect.iscode, code.co_consts):
-                self.add_code(subcode)
-
     def add_function(self, func):
         """""" Record line profiling information for the given Python function.
         """"""
@@ -443,7 +485,7 @@ class LineProfiler(object):
             warnings.warn(""Could not extract a code object for the object %r""
                           % func)
         else:
-            self.add_code(code)
+            self.code_map.add(code)
 
     def wrap_function(self, func):
         """""" Wrap a function to profile it.
@@ -493,15 +535,15 @@ class LineProfiler(object):
 
     def trace_memory_usage(self, frame, event, arg):
         """"""Callback for sys.settrace""""""
-        if (event in ('call', 'line', 'return')
-                and frame.f_code in self.code_map):
-            if event != 'call':
+        if frame.f_code in self.code_map:
+            if event == 'call':
                 # ""call"" event just saves the lineno but not the memory
-                mem = _get_memory(-1, include_children=self.include_children)
-                # if there is already a measurement for that line get the max
-                old_mem = self.code_map[frame.f_code].get(self.prevline, 0)
-                self.code_map[frame.f_code][self.prevline] = max(mem, old_mem)
-            self.prevline = frame.f_lineno
+                self.prevlines.append(frame.f_lineno)
+            elif event == 'line':
+                self.code_map.trace(frame.f_code, self.prevlines[-1])
+                self.prevlines[-1] = frame.f_lineno
+            elif event == 'return':
+                self.code_map.trace(frame.f_code, self.prevlines.pop())
 
         if self._original_trace_function is not None:
             (self._original_trace_function)(frame, event, arg)
@@ -553,45 +595,28 @@ def show_results(prof, stream=None, precision=1):
         stream = sys.stdout
     template = '{0:>6} {1:>12} {2:>12}   {3:<}'
 
-    for code in prof.code_map:
-        lines = prof.code_map[code]
-        if not lines:
-            # .. measurements are empty ..
-            continue
-        filename = code.co_filename
-        if filename.endswith(("".pyc"", "".pyo"")):
-            filename = filename[:-1]
-        stream.write('Filename: ' + filename + '\n\n')
-        if not os.path.exists(filename):
-            stream.write('ERROR: Could not find file ' + filename + '\n')
-            if any([filename.startswith(k) for k in
-                    (""ipython-input"", ""<ipython-input"")]):
-                print(""NOTE: %mprun can only be used on functions defined in ""
-                      ""physical files, and not in the IPython environment."")
-            continue
-        all_lines = linecache.getlines(filename)
-        sub_lines = inspect.getblock(all_lines[code.co_firstlineno - 1:])
-        linenos = range(code.co_firstlineno,
-                        code.co_firstlineno + len(sub_lines))
-
+    for (filename, lines) in prof.code_map.items():
         header = template.format('Line #', 'Mem usage', 'Increment',
                                  'Line Contents')
+
+        stream.write('Filename: ' + filename + '\n\n')
         stream.write(header + '\n')
         stream.write('=' * len(header) + '\n')
 
-        mem_old = lines[min(lines.keys())]
+        all_lines = linecache.getlines(filename)
+        mem_old = None
         float_format = '{0}.{1}f'.format(precision + 4, precision)
         template_mem = '{0:' + float_format + '} MiB'
-        for line in linenos:
-            mem = ''
-            inc = ''
-            if line in lines:
-                mem = lines[line]
-                inc = mem - mem_old
+        for (lineno, mem) in lines:
+            if mem:
+                inc = (mem - mem_old) if mem_old else 0
                 mem_old = mem
                 mem = template_mem.format(mem)
                 inc = template_mem.format(inc)
-            stream.write(template.format(line, mem, inc, all_lines[line - 1]))
+            else:
+                mem = ''
+                inc = ''
+            stream.write(template.format(lineno, mem, inc, all_lines[lineno - 1]))
         stream.write('\n\n')
 
 
"
,test/test_gen.py,372b290a0ab8217d1780ae7624d486debd4e190a,f30ff08b0d5aafe3202233d5f7224548163119ee,Refactor to compute memory of generators and list/set/dict comprehensions,"@@ -0,0 +1,41 @@
+
+@profile
+def test_comprehension():
+    # Dict comprehension
+    d_comp = {str(k*k): [v] * (1<<17)
+              for (v, k) in enumerate(range(99, 111))}
+
+    # List comprehension
+    l_comp = [[i] * (i<<9) for i in range(99)]
+    del l_comp
+    del d_comp
+
+    def hh(x=1):
+        # Set comprehension
+        s_comp = {('Z',) * (k<<13) for k in range(x, 19 + 2*x)}
+        return s_comp
+
+    val = [range(1, 4), max(1, 4), 42 + len(hh())]
+    val = hh() | hh(4)
+    val.add(40)
+    l1_comp = [[(1, i)] * (i<<9) for i in range(99)]
+    l2_comp = [[(3, i)] * (i<<9) for i in range(99)]
+
+    return val
+
+
+@profile
+def test_generator():
+    a_gen = ([42] * (1<<20) for __ in '123')
+    huge_lst = list(a_gen)
+
+    b_gen = ([24] * (1<<20) for __ in '123')
+    del b_gen
+    del huge_lst
+
+    return a_gen
+
+
+if __name__ == '__main__':
+    test_generator()
+    test_comprehension()
"
test/test_gen.py,test/test_gen.py,cc2f4f194188fda358f3487b06f0840fbf68471a,372b290a0ab8217d1780ae7624d486debd4e190a,Test issue #42,"@@ -1,4 +1,12 @@
 
+@profile
+def my_func():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    del b
+    yield a
+
+
 @profile
 def test_comprehension():
     # Dict comprehension
@@ -37,5 +45,8 @@ def test_generator():
 
 
 if __name__ == '__main__':
+    with profile:
+        next(my_func())     # Issue #42
+
     test_generator()
     test_comprehension()
"
memory_profiler.py,memory_profiler.py,0e25b08045aadf86d95a1dd2a98076e23d65d837,0a4e3e7f4d0f9c5c30028302ae1e535f8044a089,release 0.39,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.38'
+__version__ = '0.39'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
memory_profiler.py,memory_profiler.py,ad64aa0059dc73727c37f6e4b7060d7ca85d1d01,0e25b08045aadf86d95a1dd2a98076e23d65d837,release 0.40,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.39'
+__version__ = '0.40'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
,.travis.yml,239992d205f684b0d096c871afe7f8d10547144f,0a4e3e7f4d0f9c5c30028302ae1e535f8044a089,add travis-ci file,"@@ -0,0 +1,27 @@
+language: python
+python:
+  - ""2.7""
+  - ""3.3""
+install:
+  - sudo apt-get update
+  # We do this conditionally because it saves us some downloading if the
+  # version is the same.
+  - if [[ ""$TRAVIS_PYTHON_VERSION"" == ""2.7"" ]]; then
+      wget https://repo.continuum.io/miniconda/Miniconda-latest-Linux-x86_64.sh -O miniconda.sh;
+    else
+      wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh -O miniconda.sh;
+    fi
+  - bash miniconda.sh -b -p $HOME/miniconda
+  - export PATH=""$HOME/miniconda/bin:$PATH""
+  - hash -r
+  - conda config --set always_yes yes --set changeps1 no
+  - conda update -q conda
+  # Useful for debugging any issues with conda
+  - conda info -a
+
+  # Replace dep1 dep2 ... with your dependencies
+  - conda create -q -n test-environment python=$TRAVIS_PYTHON_VERSION numpy nose
+  - source activate test-environment
+  - make test
+script:
+- nosetests -v
\ No newline at end of file
"
.travis.yml,.travis.yml,109f449b254ad90e106edc29a3a7cc942c6f8f21,239992d205f684b0d096c871afe7f8d10547144f,update travis,"@@ -22,6 +22,7 @@ install:
   # Replace dep1 dep2 ... with your dependencies
   - conda create -q -n test-environment python=$TRAVIS_PYTHON_VERSION numpy nose
   - source activate test-environment
+  - python setup.py install
   - make test
 script:
 - nosetests -v
\ No newline at end of file
"
README.rst,README.rst,44f2a71b502aa2cf8d693947a3dd51bc609d698d,109f449b254ad90e106edc29a3a7cc942c6f8f21,Add travis build to README,"@@ -1,3 +1,6 @@
+.. image:: https://travis-ci.org/fabianp/memory_profiler.svg?branch=master
+    :target: https://travis-ci.org/fabianp/memory_profiler
+
 =================
  Memory Profiler
 =================
"
.travis.yml,.travis.yml,423729c7e2f9a6455351e9bc33004ff408bafefe,44f2a71b502aa2cf8d693947a3dd51bc609d698d,update travis,"@@ -23,6 +23,5 @@ install:
   - conda create -q -n test-environment python=$TRAVIS_PYTHON_VERSION numpy nose
   - source activate test-environment
   - python setup.py install
-  - make test
 script:
-- nosetests -v
\ No newline at end of file
+  - make test
\ No newline at end of file
"
Makefile,Makefile,c7442affea9325fd646a65be9bf313216a9127de,423729c7e2f9a6455351e9bc33004ff408bafefe,Make mprun python-2 compatible,"@@ -1,4 +1,5 @@
 PYTHON ?= python
+IPYTHON ?= ipython
 
 .PHONY: test
 
@@ -12,3 +13,4 @@ test:
 	$(PYTHON) test/test_import.py
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
+	$(IPYTHON) test/test_ipython.py
"
memory_profiler.py,memory_profiler.py,c7442affea9325fd646a65be9bf313216a9127de,423729c7e2f9a6455351e9bc33004ff408bafefe,Make mprun python-2 compatible,"@@ -599,14 +599,14 @@ def show_results(prof, stream=None, precision=1):
         header = template.format('Line #', 'Mem usage', 'Increment',
                                  'Line Contents')
 
-        stream.write('Filename: ' + filename + '\n\n')
-        stream.write(header + '\n')
-        stream.write('=' * len(header) + '\n')
+        stream.write(u'Filename: ' + filename + '\n\n')
+        stream.write(header + u'\n')
+        stream.write(u'=' * len(header) + '\n')
 
         all_lines = linecache.getlines(filename)
         mem_old = None
-        float_format = '{0}.{1}f'.format(precision + 4, precision)
-        template_mem = '{0:' + float_format + '} MiB'
+        float_format = u'{0}.{1}f'.format(precision + 4, precision)
+        template_mem = u'{0:' + float_format + '} MiB'
         for (lineno, mem) in lines:
             if mem:
                 inc = (mem - mem_old) if mem_old else 0
@@ -614,10 +614,11 @@ def show_results(prof, stream=None, precision=1):
                 mem = template_mem.format(mem)
                 inc = template_mem.format(inc)
             else:
-                mem = ''
-                inc = ''
-            stream.write(template.format(lineno, mem, inc, all_lines[lineno - 1]))
-        stream.write('\n\n')
+                mem = u''
+                inc = u''
+            tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
+            stream.write(unicode(tmp))
+        stream.write(u'\n\n')
 
 
 def _func_exec(stmt, ns):
"
memory_profiler.py,memory_profiler.py,b2b936c2200b49482ce87faaadca966d8828df8e,c7442affea9325fd646a65be9bf313216a9127de,"FIX: unicode in python3, function does not exist","@@ -37,6 +37,7 @@ _TWO_20 = float(2 ** 20)
 
 if PY3:
     import builtins
+    def unicode(x): return str(x)
 else:
     import __builtin__ as builtins
 
"
memory_profiler.py,memory_profiler.py,5b973822b365dfee327009c6fc4f6e9fe37086fe,b2b936c2200b49482ce87faaadca966d8828df8e,new version,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.38'
+__version__ = '0.41'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
.travis.yml,.travis.yml,c08a8860a694b2374840aa1ed164d42260834b9a,5b973822b365dfee327009c6fc4f6e9fe37086fe,add ipython to travis,"@@ -20,7 +20,7 @@ install:
   - conda info -a
 
   # Replace dep1 dep2 ... with your dependencies
-  - conda create -q -n test-environment python=$TRAVIS_PYTHON_VERSION numpy nose
+  - conda create -q -n test-environment python=$TRAVIS_PYTHON_VERSION numpy nose ipython
   - source activate test-environment
   - python setup.py install
 script:
"
memory_profiler.py,memory_profiler.py,d52f82a3c0be67b839ff37254dec7a489cf508f0,c08a8860a694b2374840aa1ed164d42260834b9a,updated python version verification so it doesn't break on future python 4 release,"@@ -31,15 +31,15 @@ except ImportError:
     line_cell_magic = lambda func: func
     magics_class = lambda cls: cls
 
-PY3 = sys.version_info[0] == 3
+PY2 = sys.version_info[0] == 2
 
 _TWO_20 = float(2 ** 20)
 
-if PY3:
+if PY2:
+    import __builtin__ as builtins
+else:
     import builtins
     def unicode(x): return str(x)
-else:
-    import __builtin__ as builtins
 
 # .. get available packages ..
 try:
@@ -903,18 +903,18 @@ def profile(func=None, stream=None, precision=1):
 # globally defined (global variables is not enough
 # for all cases, e.g. a script that imports another
 # script where @profile is used)
-if PY3:
+if PY2:
+    def exec_with_profiler(filename, profiler):
+        builtins.__dict__['profile'] = profiler
+        ns = dict(_CLEAN_GLOBALS, profile=profiler)
+        execfile(filename, ns, ns)
+else:
     def exec_with_profiler(filename, profiler):
         builtins.__dict__['profile'] = profiler
         # shadow the profile decorator defined above
         ns = dict(_CLEAN_GLOBALS, profile=profiler)
         with open(filename) as f:
             exec(compile(f.read(), filename, 'exec'), ns, ns)
-else:
-    def exec_with_profiler(filename, profiler):
-        builtins.__dict__['profile'] = profiler
-        ns = dict(_CLEAN_GLOBALS, profile=profiler)
-        execfile(filename, ns, ns)
 
 
 class LogFile(object):
"
Makefile,Makefile,8fb44f180cb85ca19a358dc4c60cec05190ffc0f,ad64aa0059dc73727c37f6e4b7060d7ca85d1d01,Add unicode tests,"@@ -9,6 +9,7 @@ test:
 	$(PYTHON) -m memory_profiler test/test_global.py
 	$(PYTHON) -m memory_profiler test/test_precision_command_line.py
 	$(PYTHON) -m memory_profiler test/test_gen.py
+	$(PYTHON) -m memory_profiler test/test_unicode.py
 	$(PYTHON) test/test_import.py
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
"
,test/test_unicode.py,8fb44f180cb85ca19a358dc4c60cec05190ffc0f,ad64aa0059dc73727c37f6e4b7060d7ca85d1d01,Add unicode tests,"@@ -0,0 +1,15 @@
+# coding: utf-8
+
+import time
+
+@profile
+def test_unicode():
+    # test when unicode is present
+    eval(""β = 0"")
+    return
+
+if __name__ == '__main__':
+    # run only for Python 3
+    import sys
+    if sys.version_info >= (3, 0):
+        test_unicode()
"
test/test_unicode.py,test/test_unicode.py,cc593b316c7b61b4d37ae81282fa6898b59d5879,6bb856bfddcc63dcec302b6f8145dadc04279af5,FIX test,"@@ -5,7 +5,7 @@ import time
 @profile
 def test_unicode():
     # test when unicode is present
-    eval(""β = 0"")
+    exec(""β = 0"")
     return
 
 if __name__ == '__main__':
"
memory_profiler.py,memory_profiler.py,5db8084a3d88868632a6d1d0abed665782c103ce,cc593b316c7b61b4d37ae81282fa6898b59d5879,FIX: fix issue #113 reported by @reza1615,"@@ -618,7 +618,7 @@ def show_results(prof, stream=None, precision=1):
                 mem = u''
                 inc = u''
             tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
-            stream.write(unicode(tmp))
+            stream.write(unicode(tmp, 'UTF-8'))
         stream.write(u'\n\n')
 
 
"
test/test_unicode.py,test/test_unicode.py,5db8084a3d88868632a6d1d0abed665782c103ce,cc593b316c7b61b4d37ae81282fa6898b59d5879,FIX: fix issue #113 reported by @reza1615,"@@ -1,15 +1,9 @@
-# coding: utf-8
-
-import time
-
+# -*- coding: utf-8  -*-
+# run only for Python 2.xx
 @profile
-def test_unicode():
+def test_unicode(txt):
     # test when unicode is present
-    exec(""β = 0"")
-    return
-
+    txt = txt.replace (u""ی"", u""ي"") #Arabic Yah = ي
+    return txt
 if __name__ == '__main__':
-    # run only for Python 3
-    import sys
-    if sys.version_info >= (3, 0):
-        test_unicode()
+	test_unicode (u""ایست"")
\ No newline at end of file
"
memory_profiler.py,memory_profiler.py,f836d57d50b416af9fd124c4acecf9a57f8b9ea6,5db8084a3d88868632a6d1d0abed665782c103ce,FIX: unicode for Python3,"@@ -39,7 +39,7 @@ if PY2:
     import __builtin__ as builtins
 else:
     import builtins
-    def unicode(x): return str(x)
+    def unicode(x, *args): return str(x)
 
 # .. get available packages ..
 try:
"
memory_profiler.py,memory_profiler.py,e496c5d9430f3675e89a186e855c99c34d096e61,f836d57d50b416af9fd124c4acecf9a57f8b9ea6,ENH: allow memit magic to return a result object,"@@ -49,6 +49,28 @@ except ImportError:
     has_psutil = False
 
 
+class MemitResult(object):
+    """"""memit magic run details.
+
+    Object based on IPython's TimeitResult
+    """"""
+    def __init__(self, mem_usage, baseline, repeat, timeout, interval,
+                 include_children):
+        self.mem_usage = mem_usage
+        self.baseline = baseline
+        self.repeat = repeat
+        self.timeout = timeout
+        self.interval = interval
+        self.include_children = include_children
+
+    def _repr_pretty_(self, p , cycle):
+        max_mem = max(self.mem_usage)
+        inc = max_mem - self.baseline
+        msg = 'peak memory: %.02f MiB, increment: %.02f MiB' % (max_mem, inc)
+
+        p.text(u'<MemitResult : '+msg+u'>')
+
+
 def _get_memory(pid, timestamps=False, include_children=False):
 
     # .. only for current process and only on unix..
@@ -794,6 +816,7 @@ class MemoryProfilerMagics(Magics):
 
         -c: If present, add the memory usage of any children process to the report.
 
+        -o: If present, return a object containing memit run details
         Examples
         --------
         ::
@@ -811,7 +834,7 @@ class MemoryProfilerMagics(Magics):
 
         """"""
         from memory_profiler import memory_usage, _func_exec
-        opts, stmt = self.parse_options(line, 'r:t:i:c', posix=False, strict=False)
+        opts, stmt = self.parse_options(line, 'r:t:i:co', posix=False, strict=False)
 
         if cell is None:
             setup = 'pass'
@@ -827,6 +850,7 @@ class MemoryProfilerMagics(Magics):
             timeout = None
         interval = float(getattr(opts, 'i', 0.1))
         include_children = 'c' in opts
+        return_result = 'o' in opts
 
         # I've noticed we get less noisier measurements if we run
         # a garbage collection first
@@ -835,7 +859,7 @@ class MemoryProfilerMagics(Magics):
 
         _func_exec(setup, self.shell.user_ns)
 
-        mem_usage = 0
+        mem_usage = []
         counter = 0
         baseline = memory_usage()[0]
         while counter < repeat:
@@ -843,15 +867,20 @@ class MemoryProfilerMagics(Magics):
             tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
                                timeout=timeout, interval=interval, max_usage=True,
                                include_children=include_children)
-            mem_usage = max(mem_usage, tmp[0])
+            mem_usage.append(tmp[0])
 
         if mem_usage:
+            max_mem = max(mem_usage)
             print('peak memory: %.02f MiB, increment: %.02f MiB' %
-                  (mem_usage, mem_usage - baseline))
+                  (max_mem, max_mem - baseline))
         else:
             print('ERROR: could not read memory usage, try with a lower interval '
                   'or more iterations')
 
+        if return_result:
+            return MemitResult(mem_usage, baseline, repeat, timeout, interval,
+                               include_children)
+
     @classmethod
     def register_magics(cls, ip):
         from distutils.version import LooseVersion
"
memory_profiler.py,memory_profiler.py,5eef560b0ddf74446760baadddd27d4e0b987fe1,e496c5d9430f3675e89a186e855c99c34d096e61,ENH: added quiet as well,"@@ -817,6 +817,9 @@ class MemoryProfilerMagics(Magics):
         -c: If present, add the memory usage of any children process to the report.
 
         -o: If present, return a object containing memit run details
+
+        -q: If present, be quiet and do not output a result.
+
         Examples
         --------
         ::
@@ -834,7 +837,7 @@ class MemoryProfilerMagics(Magics):
 
         """"""
         from memory_profiler import memory_usage, _func_exec
-        opts, stmt = self.parse_options(line, 'r:t:i:co', posix=False, strict=False)
+        opts, stmt = self.parse_options(line, 'r:t:i:coq', posix=False, strict=False)
 
         if cell is None:
             setup = 'pass'
@@ -851,6 +854,7 @@ class MemoryProfilerMagics(Magics):
         interval = float(getattr(opts, 'i', 0.1))
         include_children = 'c' in opts
         return_result = 'o' in opts
+        quiet = 'q' in opts
 
         # I've noticed we get less noisier measurements if we run
         # a garbage collection first
@@ -869,13 +873,14 @@ class MemoryProfilerMagics(Magics):
                                include_children=include_children)
             mem_usage.append(tmp[0])
 
-        if mem_usage:
-            max_mem = max(mem_usage)
-            print('peak memory: %.02f MiB, increment: %.02f MiB' %
-                  (max_mem, max_mem - baseline))
-        else:
-            print('ERROR: could not read memory usage, try with a lower interval '
-                  'or more iterations')
+        if not quiet:
+            if mem_usage:
+                max_mem = max(mem_usage)
+                print('peak memory: %.02f MiB, increment: %.02f MiB' %
+                      (max_mem, max_mem - baseline))
+            else:
+                print('ERROR: could not read memory usage, try with a lower interval '
+                      'or more iterations')
 
         if return_result:
             return MemitResult(mem_usage, baseline, repeat, timeout, interval,
"
memory_profiler.py,memory_profiler.py,0c5f6f736178ae7124e0ade4ae9843f2d97f4634,5eef560b0ddf74446760baadddd27d4e0b987fe1,Addressing @superbobry's comments,"@@ -63,11 +63,13 @@ class MemitResult(object):
         self.interval = interval
         self.include_children = include_children
 
-    def _repr_pretty_(self, p , cycle):
+    def __str__(self):
         max_mem = max(self.mem_usage)
         inc = max_mem - self.baseline
-        msg = 'peak memory: %.02f MiB, increment: %.02f MiB' % (max_mem, inc)
+        return 'peak memory: %.02f MiB, increment: %.02f MiB' % (max_mem, inc)
 
+    def _repr_pretty_(self, p , cycle):
+        msg = str(self)
         p.text(u'<MemitResult : '+msg+u'>')
 
 
@@ -873,18 +875,18 @@ class MemoryProfilerMagics(Magics):
                                include_children=include_children)
             mem_usage.append(tmp[0])
 
+        result = MemitResult(mem_usage, baseline, repeat, timeout, interval,
+                             include_children)
+
         if not quiet:
             if mem_usage:
-                max_mem = max(mem_usage)
-                print('peak memory: %.02f MiB, increment: %.02f MiB' %
-                      (max_mem, max_mem - baseline))
+                print(result)
             else:
                 print('ERROR: could not read memory usage, try with a lower interval '
                       'or more iterations')
 
         if return_result:
-            return MemitResult(mem_usage, baseline, repeat, timeout, interval,
-                               include_children)
+            return result
 
     @classmethod
     def register_magics(cls, ip):
"
memory_profiler.py,memory_profiler.py,86acef852c15e071ddbda5e4619c1de220fcb0a7,aa8b30cfee6e34056f6eac1b6b2eefaccf90cbfd,"ENH added optional ``tracemalloc`` backend

It is now possible to use ``tracemalloc`` to analyze memory usage Python
code on Python 3.4 and above. ``tracemalloc`` allows for more precise
measurements compared to ``psutil``. However, it only works either for
pure Python code or for C extensions allocating memory via ``PyMem_Alloc``.

To use the new backend code run ``memory_profiler`` with ``--backend``
option, e.g.

    $ python -m memory_profiler --backend=tracemalloc script.py

Also if you use ``memory_profiler`` with imported decorator you can specify
backend as an argument to the decorator function:

    @profile(backend='tracemalloc')
    def f(n):
        a = [0] * n
        return a

``backend`` parameter to ``@profile`` has priority over ``--backend``.

Note that using ``tracemalloc`` in ``mprof`` and IPython magic is not
supported at the moment.","@@ -17,6 +17,8 @@ import inspect
 import subprocess
 import logging
 
+from collections import OrderedDict
+
 # TODO: provide alternative when multiprocessing is not available
 try:
     from multiprocessing import Process, Pipe
@@ -39,7 +41,9 @@ if PY2:
     import __builtin__ as builtins
 else:
     import builtins
-    def unicode(x, *args): return str(x)
+
+    def unicode(x, *args):
+        return str(x)
 
 # .. get available packages ..
 try:
@@ -48,6 +52,15 @@ try:
 except ImportError:
     has_psutil = False
 
+try:
+    import tracemalloc
+    has_tracemalloc = True
+except ImportError:
+    has_tracemalloc = False
+
+_backend_chosen = False
+_backend = 'psutil'
+
 
 class MemitResult(object):
     """"""memit magic run details.
@@ -73,14 +86,24 @@ class MemitResult(object):
         p.text(u'<MemitResult : '+msg+u'>')
 
 
-def _get_memory(pid, timestamps=False, include_children=False):
+def _get_memory(pid, timestamps=False, include_children=False, filename=None):
 
     # .. only for current process and only on unix..
     if pid == -1:
         pid = os.getpid()
 
-    # .. cross-platform but but requires psutil ..
-    if has_psutil:
+    def tracemalloc_tool():
+        # .. cross-platform but but requires Python 3.4 or higher
+        stat = next(filter(lambda item: str(item).startswith(filename),
+                           tracemalloc.take_snapshot().statistics('filename')))
+        mem = stat.size / _TWO_20
+        if timestamps:
+            return mem, time.time()
+        else:
+            return mem
+
+    def ps_util_tool():
+        # .. cross-platform but but requires psutil ..
         process = psutil.Process(pid)
         try:
             # avoid useing get_memory_info since it does not exists
@@ -96,15 +119,15 @@ def _get_memory(pid, timestamps=False, include_children=False):
                     for p in process.children(recursive=True):
                         mem += getattr(p, meminfo_attr)()[0] / _TWO_20
             if timestamps:
-                return (mem, time.time())
+                return mem, time.time()
             else:
                 return mem
         except psutil.AccessDenied:
             pass
             # continue and try to get this from ps
 
-    # .. scary stuff ..
-    if os.name == 'posix':
+    def posix_tool():
+        # .. scary stuff ..
         if include_children:
             raise NotImplementedError('The psutil module is required when to'
                                       ' monitor memory usage of children'
@@ -122,17 +145,20 @@ def _get_memory(pid, timestamps=False, include_children=False):
             vsz_index = out[0].split().index(b'RSS')
             mem = float(out[1].split()[vsz_index]) / 1024
             if timestamps:
-                return(mem, time.time())
+                return mem, time.time()
             else:
                 return mem
         except:
             if timestamps:
-                return (-1, time.time())
+                return -1, time.time()
             else:
                 return -1
-    else:
-        raise NotImplementedError('The psutil module is required for non-unix '
-                                  'platforms')
+
+    if _backend == 'tracemalloc' and (filename is None or filename == '<unknown>'):
+        raise RuntimeError('There is no access to source file of the profiled function')
+
+    tools = {'tracemalloc': tracemalloc_tool, 'psutil': ps_util_tool, 'posix': posix_tool}
+    return tools[_backend]()
 
 
 class MemTimer(Process):
@@ -152,6 +178,7 @@ class MemTimer(Process):
         self.include_children = kw.pop(""include_children"", False)
 
         # get baseline memory usage
+        # TODO: add filename
         self.mem_usage = [
             _get_memory(self.monitor_pid, timestamps=self.timestamps,
                         include_children=self.include_children)]
@@ -161,6 +188,7 @@ class MemTimer(Process):
         self.pipe.send(0)  # we're ready
         stop = False
         while True:
+            # TODO: add filename
             cur_mem = _get_memory(self.monitor_pid, timestamps=self.timestamps,
                                   include_children=self.include_children)
             if not self.max_usage:
@@ -275,6 +303,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         line_count = 0
         while True:
             if not max_usage:
+                # TODO: add filename
                 mem_usage = _get_memory(proc.pid, timestamps=timestamps,
                                         include_children=include_children)
                 if stream is not None:
@@ -282,6 +311,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 else:
                     ret.append(mem_usage)
             else:
+                # TODO: add filename
                 ret = max(ret,
                           _get_memory(proc.pid,
                                       include_children=include_children))
@@ -306,6 +336,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         while counter < max_iter:
             counter += 1
             if not max_usage:
+                # TODO: add filename
                 mem_usage = _get_memory(proc, timestamps=timestamps,
                                         include_children=include_children)
                 if stream is not None:
@@ -313,6 +344,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 else:
                     ret.append(mem_usage)
             else:
+                # TODO: add filename
                 ret = max([ret,
                            _get_memory(proc, include_children=include_children)
                            ])
@@ -351,14 +383,15 @@ def _find_script(script_name):
 class _TimeStamperCM(object):
     """"""Time-stamping context manager.""""""
 
-    def __init__(self, timestamps):
+    def __init__(self, timestamps, filename):
         self._timestamps = timestamps
+        self._filename = filename
 
     def __enter__(self):
-        self._timestamps.append(_get_memory(os.getpid(), timestamps=True))
+        self._timestamps.append(_get_memory(os.getpid(), timestamps=True, filename=self._filename))
 
     def __exit__(self, *args):
-        self._timestamps.append(_get_memory(os.getpid(), timestamps=True))
+        self._timestamps.append(_get_memory(os.getpid(), timestamps=True, filename=self._filename))
 
 
 class TimeStamper:
@@ -396,7 +429,11 @@ class TimeStamper:
         self.functions[func].append(timestamps)
         # A new object is required each time, since there can be several
         # nested context managers.
-        return _TimeStamperCM(timestamps)
+        try:
+            filename = inspect.getsourcefile(func)
+        except TypeError:
+            filename = '<unknown>'
+        return _TimeStamperCM(timestamps, filename)
 
     def add_function(self, func):
         if func not in self.functions:
@@ -407,13 +444,17 @@ class TimeStamper:
         """"""
         def f(*args, **kwds):
             # Start time
-            timestamps = [_get_memory(os.getpid(), timestamps=True)]
+            try:
+                filename = inspect.getsourcefile(func)
+            except TypeError:
+                filename = '<unknown>'
+            timestamps = [_get_memory(os.getpid(), timestamps=True, filename=filename)]
             self.functions[func].append(timestamps)
             try:
                 return func(*args, **kwds)
             finally:
                 # end time
-                timestamps.append(_get_memory(os.getpid(), timestamps=True))
+                timestamps.append(_get_memory(os.getpid(), timestamps=True, filename=filename))
         return f
 
     def show_results(self, stream=None):
@@ -461,7 +502,7 @@ class CodeMap(dict):
             self.add(subcode, toplevel_code=toplevel_code)
 
     def trace(self, code, lineno):
-        memory = _get_memory(-1, include_children=self.include_children)
+        memory = _get_memory(-1, include_children=self.include_children, filename=code.co_filename)
         # if there is already a measurement for that line get the max
         previous_memory = self[code].get(lineno, 0)
         self[code][lineno] = max(memory, previous_memory)
@@ -578,7 +619,7 @@ class LineProfiler(object):
     def trace_max_mem(self, frame, event, arg):
         # run into PDB as soon as memory is higher than MAX_MEM
         if event in ('line', 'return') and frame.f_code in self.code_map:
-            c = _get_memory(-1)
+            c = _get_memory(-1, filename=frame.f_code.co_filename)
             if c >= self.max_mem:
                 t = ('Current memory {0:.2f} MiB exceeded the '
                      'maximum of {1:.2f} MiB\n'.format(c, self.max_mem))
@@ -918,10 +959,16 @@ def load_ipython_extension(ip):
     MemoryProfilerMagics.register_magics(ip)
 
 
-def profile(func=None, stream=None, precision=1):
+def profile(func=None, stream=None, precision=1, backend='psutil'):
     """"""
     Decorator that will run the function and print a line-by-line profile
     """"""
+    global _backend
+    _backend = backend
+    if not _backend_chosen:
+        choose_backend()
+    if _backend == 'tracemalloc' and not tracemalloc.is_tracing():
+        tracemalloc.start()
     if func is not None:
         def wrapper(*args, **kwargs):
             prof = LineProfiler()
@@ -931,10 +978,37 @@ def profile(func=None, stream=None, precision=1):
         return wrapper
     else:
         def inner_wrapper(f):
-            return profile(f, stream=stream, precision=precision)
+            return profile(f, stream=stream, precision=precision, backend=backend)
         return inner_wrapper
 
 
+def choose_backend():
+    """"""
+    Function that tries to setup backend, chosen by user, and if failed,
+    setup one of the allowable backends
+    """"""
+    global _backend
+    old_backend = _backend
+    backends = OrderedDict([
+        ('psutil', has_psutil),
+        ('posix', os.name == 'posix'),
+        ('tracemalloc', has_tracemalloc),
+        ('no_backend', True)
+    ])
+    backends.move_to_end(_backend, last=False)
+    for n_backend, is_available in backends.items():
+        if is_available:
+            _backend = n_backend
+            break
+    if _backend == 'no_backend':
+        raise NotImplementedError('Tracemalloc or psutil module is required for non-unix '
+                                  'platforms')
+    if _backend != old_backend:
+        print('{} can not be used, {} used instead'.format(old_backend, _backend))
+    global _backend_chosen
+    _backend_chosen = True
+
+
 # Insert in the built-ins to have profile
 # globally defined (global variables is not enough
 # for all cases, e.g. a script that imports another
@@ -943,14 +1017,22 @@ if PY2:
     def exec_with_profiler(filename, profiler):
         builtins.__dict__['profile'] = profiler
         ns = dict(_CLEAN_GLOBALS, profile=profiler)
+        choose_backend()
         execfile(filename, ns, ns)
 else:
     def exec_with_profiler(filename, profiler):
+        if _backend == 'tracemalloc' and has_tracemalloc:
+            tracemalloc.start()
         builtins.__dict__['profile'] = profiler
         # shadow the profile decorator defined above
         ns = dict(_CLEAN_GLOBALS, profile=profiler)
-        with open(filename) as f:
-            exec(compile(f.read(), filename, 'exec'), ns, ns)
+        choose_backend()
+        try:
+            with open(filename) as f:
+                exec(compile(f.read(), filename, 'exec'), ns, ns)
+        finally:
+            if tracemalloc.is_tracing():
+                tracemalloc.stop()
 
 
 class LogFile(object):
@@ -987,20 +1069,23 @@ if __name__ == '__main__':
     parser = OptionParser(usage=_CMD_USAGE, version=__version__)
     parser.disable_interspersed_args()
     parser.add_option(
-        ""--pdb-mmem"", dest=""max_mem"", metavar=""MAXMEM"",
-        type=""float"", action=""store"",
-        help=""step into the debugger when memory exceeds MAXMEM"")
+        '--pdb-mmem', dest='max_mem', metavar='MAXMEM',
+        type='float', action='store',
+        help='step into the debugger when memory exceeds MAXMEM')
     parser.add_option(
-        '--precision', dest=""precision"", type=""int"",
-        action=""store"", default=3,
-        help=""precision of memory output in number of significant digits"")
-    parser.add_option(""-o"", dest=""out_filename"", type=""str"",
-                      action=""store"", default=None,
-                      help=""path to a file where results will be written"")
-    parser.add_option(""--timestamp"", dest=""timestamp"", default=False,
-                      action=""store_true"",
-                      help=""""""print timestamp instead of memory measurement for
-                      decorated functions"""""")
+        '--precision', dest='precision', type='int',
+        action='store', default=3,
+        help='precision of memory output in number of significant digits')
+    parser.add_option('-o', dest='out_filename', type='str',
+                      action='store', default=None,
+                      help='path to a file where results will be written')
+    parser.add_option('--timestamp', dest='timestamp', default=False,
+                      action='store_true',
+                      help='''print timestamp instead of memory measurement for
+                      decorated functions''')
+    parser.add_option('--backend', dest='backend', type='choice', action='store',
+                      choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
+                      help='backend using for getting memory info (one of the {tracemalloc, psutil, posix})')
 
     if not sys.argv[1:]:
         parser.print_help()
@@ -1008,12 +1093,14 @@ if __name__ == '__main__':
 
     (options, args) = parser.parse_args()
     sys.argv[:] = args  # Remove every memory_profiler arguments
+    _backend = options.backend
 
+    script_filename = _find_script(args[0])
     if options.timestamp:
         prof = TimeStamper()
     else:
         prof = LineProfiler(max_mem=options.max_mem)
-    script_filename = _find_script(args[0])
+
     try:
         exec_with_profiler(script_filename, prof)
     finally:
"
mprof,mprof,86acef852c15e071ddbda5e4619c1de220fcb0a7,aa8b30cfee6e34056f6eac1b6b2eefaccf90cbfd,"ENH added optional ``tracemalloc`` backend

It is now possible to use ``tracemalloc`` to analyze memory usage Python
code on Python 3.4 and above. ``tracemalloc`` allows for more precise
measurements compared to ``psutil``. However, it only works either for
pure Python code or for C extensions allocating memory via ``PyMem_Alloc``.

To use the new backend code run ``memory_profiler`` with ``--backend``
option, e.g.

    $ python -m memory_profiler --backend=tracemalloc script.py

Also if you use ``memory_profiler`` with imported decorator you can specify
backend as an argument to the decorator function:

    @profile(backend='tracemalloc')
    def f(n):
        a = [0] * n
        return a

``backend`` parameter to ``@profile`` has priority over ``--backend``.

Note that using ``tracemalloc`` in ``mprof`` and IPython magic is not
supported at the moment.","@@ -27,13 +27,13 @@ Type mprof <command> --help for usage help on a specific command.
 For example, mprof plot --help will list all plotting options.
 """"""
 
+
 def print_usage():
     print(""Usage: %s <command> <options> <arguments>""
-                  % osp.basename(sys.argv[0]))
+          % osp.basename(sys.argv[0]))
     print(help_msg)
 
 
-
 def get_action():
     """"""Pop first argument, check it is a valid action.""""""
     if len(sys.argv) <= 1:
@@ -233,7 +233,7 @@ def run_action():
     with open(mprofile_output, ""a"") as f:
         f.write(""CMDLINE {0}\n"".format(cmd_line))
         mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
-                         include_children=options.include_children, stream=f)
+                        include_children=options.include_children, stream=f)
 
 
 def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
@@ -257,7 +257,7 @@ def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
         sys.exit(1)
     height_ratio = 20.
     vsize = (pl.ylim()[1] - pl.ylim()[0]) / height_ratio
-    hsize = (pl.xlim()[1] - pl.xlim()[0]) / (3.*height_ratio)
+    hsize = (pl.xlim()[1] - pl.xlim()[0]) / (3. * height_ratio)
 
     bracket_x = pl.asarray([hsize, 0, 0, hsize])
     bracket_y = pl.asarray([vsize, vsize, -vsize, -vsize])
@@ -270,16 +270,16 @@ def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
                 ""-"" + color, linewidth=2, label=label)
     if options.xlim is None or options.xlim[0] <= (xloc[1] - xshift) <= options.xlim[1]:
         pl.plot(-bracket_x + xloc[1] - xshift, bracket_y + yloc[1],
-                ""-"" + color, linewidth=2 )
+                ""-"" + color, linewidth=2)
 
-    # TODO: use matplotlib.patches.Polygon to draw a colored background for
-    # each function.
+        # TODO: use matplotlib.patches.Polygon to draw a colored background for
+        # each function.
 
-    # with maplotlib 1.2, use matplotlib.path.Path to create proper markers
-    # see http://matplotlib.org/examples/pylab_examples/marker_path.html
-    # This works with matplotlib 0.99.1
-    ## pl.plot(xloc[0], yloc[0], ""<""+color, markersize=7, label=label)
-    ## pl.plot(xloc[1], yloc[1], "">""+color, markersize=7)
+        # with maplotlib 1.2, use matplotlib.path.Path to create proper markers
+        # see http://matplotlib.org/examples/pylab_examples/marker_path.html
+        # This works with matplotlib 0.99.1
+        ## pl.plot(xloc[0], yloc[0], ""<""+color, markersize=7, label=label)
+        ## pl.plot(xloc[1], yloc[1], "">""+color, markersize=7)
 
 
 def read_mprofile_file(filename):
@@ -331,7 +331,6 @@ def read_mprofile_file(filename):
             'cmd_line': cmd_line}
 
 
-
 def plot_file(filename, index=0, timestamps=True, options=None):
     try:
         import pylab as pl
@@ -346,7 +345,7 @@ def plot_file(filename, index=0, timestamps=True, options=None):
               'file.**\nFile path: {0}\n'
               'File may be empty or invalid.\n'
               'It can be deleted with ""mprof rm {0}""'.format(
-              mprofile['filename']))
+            mprofile['filename']))
         sys.exit(0)
 
     # Merge function timestamps and memory usage together
@@ -373,11 +372,11 @@ def plot_file(filename, index=0, timestamps=True, options=None):
     max_mem = mem.max()
     max_mem_ind = mem.argmax()
 
-    all_colors=(""c"", ""y"", ""g"", ""r"", ""b"")
-    mem_line_colors=(""k"", ""b"", ""r"", ""g"", ""c"", ""y"", ""m"")
+    all_colors = (""c"", ""y"", ""g"", ""r"", ""b"")
+    mem_line_colors = (""k"", ""b"", ""r"", ""g"", ""c"", ""y"", ""m"")
     mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
                                    time.localtime(global_start)) \
-                                   + "".{0:03d}"".format(int(round(math.modf(global_start)[0]*1000)))
+                     + "".{0:03d}"".format(int(round(math.modf(global_start)[0] * 1000)))
 
     pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
             label=mem_line_label)
@@ -392,9 +391,9 @@ def plot_file(filename, index=0, timestamps=True, options=None):
         for f, exec_ts in ts.items():
             for execution in exec_ts:
                 add_brackets(execution[:2], execution[2:], xshift=global_start,
-                             color= all_colors[func_num % len(all_colors)],
+                             color=all_colors[func_num % len(all_colors)],
                              label=f.split(""."")[-1]
-                             + "" %.3fs"" % (execution[1] - execution[0]), options=options)
+                                   + "" %.3fs"" % (execution[1] - execution[0]), options=options)
             func_num += 1
 
     if timestamps:
@@ -496,6 +495,7 @@ def plot_action():
     else:
         pl.show()
 
+
 if __name__ == ""__main__"":
     # Workaround for optparse limitation: insert -- before first negative
     # number found.
"
,test/test_tracemalloc.py,86acef852c15e071ddbda5e4619c1de220fcb0a7,aa8b30cfee6e34056f6eac1b6b2eefaccf90cbfd,"ENH added optional ``tracemalloc`` backend

It is now possible to use ``tracemalloc`` to analyze memory usage Python
code on Python 3.4 and above. ``tracemalloc`` allows for more precise
measurements compared to ``psutil``. However, it only works either for
pure Python code or for C extensions allocating memory via ``PyMem_Alloc``.

To use the new backend code run ``memory_profiler`` with ``--backend``
option, e.g.

    $ python -m memory_profiler --backend=tracemalloc script.py

Also if you use ``memory_profiler`` with imported decorator you can specify
backend as an argument to the decorator function:

    @profile(backend='tracemalloc')
    def f(n):
        a = [0] * n
        return a

``backend`` parameter to ``@profile`` has priority over ``--backend``.

Note that using ``tracemalloc`` in ``mprof`` and IPython magic is not
supported at the moment.","@@ -0,0 +1,47 @@
+import pytest
+import tracemalloc
+from io import StringIO
+from time import sleep
+
+from memory_profiler import profile
+import memory_profiler
+
+tracemalloc.start()
+output = StringIO()
+
+# allowable error in MB
+EPSILON = 0.0001
+
+memory_profiler._backend = 'tracemalloc'
+
+
+@pytest.mark.parametrize('test_input,expected', [
+    (100, 0.00012302398681640625),
+    (1000, 0.0009813308715820312),
+    (10000, 0.009564399719238281),
+    (100000, 0.09539508819580078),
+    (1000000, 0.9537019729614258),
+    (10000000, 9.536770820617676),
+    (100000000, 95.36745929718018),
+])
+def test_memory_profiler(test_input, expected):
+    mem_prof(test_input)
+    inc, dec = parse_mem_prof()
+    assert abs(inc - dec) <= EPSILON, 'inc = {}, dec = {}, err = {}'.format(inc, dec, abs(inc - dec))
+    assert abs(inc - expected) <= EPSILON, 'inc = {}, size = {}, err = {}'.format(inc, expected, abs(inc - expected))
+
+
+@profile(stream=output, precision=6)
+def mem_prof(n):
+    a = bytearray(n)
+    del a
+    sleep(1)
+
+
+def parse_mem_prof():
+    text = output.getvalue().split('\n')
+
+    def f(s):
+        return float(s.split()[3])
+
+    return f(text[-6]), -f(text[-5])
"
memory_profiler.py,memory_profiler.py,9e83dfc23236306c0279190fd97ed59135bebece,86acef852c15e071ddbda5e4619c1de220fcb0a7,FIX little fix for Python 3.3-,"@@ -1031,7 +1031,7 @@ else:
             with open(filename) as f:
                 exec(compile(f.read(), filename, 'exec'), ns, ns)
         finally:
-            if tracemalloc.is_tracing():
+            if has_tracemalloc and tracemalloc.is_tracing():
                 tracemalloc.stop()
 
 
"
memory_profiler.py,memory_profiler.py,30a1617b636e9ae470705d433f76a34094716521,9e83dfc23236306c0279190fd97ed59135bebece,FIX added a workaround for ``OrderedDict.move_to_end``,"@@ -995,7 +995,19 @@ def choose_backend():
         ('tracemalloc', has_tracemalloc),
         ('no_backend', True)
     ])
-    backends.move_to_end(_backend, last=False)
+
+    def move_to_start(d, key):
+        """"""
+        Emulation of OrderedDict.move_to_end(last=False) for old versions of Python
+        """"""
+        items = [(key, d[key])]
+        for _key, _value in d.items():
+            if _key != key:
+                items.append((_key, _value))
+        return OrderedDict(items)
+
+    backends = move_to_start(backends, _backend)
+
     for n_backend, is_available in backends.items():
         if is_available:
             _backend = n_backend
"
memory_profiler.py,memory_profiler.py,d0c8a3943ffeee25d96b7d65e158fe405728ba4c,30a1617b636e9ae470705d433f76a34094716521,FIX added a choosing backend in memory_usage function,"@@ -253,6 +253,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     ret : return value of the profiled function
         Only returned if retval is set to True
     """"""
+    if not _backend_chosen:
+        choose_backend()
     if stream is not None:
         timestamps = True
 
"
memory_profiler.py,memory_profiler.py,361c75133663bbf31a40d00f5614916fc5bde1a2,d0c8a3943ffeee25d96b7d65e158fe405728ba4c,FIX choosing backend in ``profile`` decorator fixed,"@@ -966,8 +966,8 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
     Decorator that will run the function and print a line-by-line profile
     """"""
     global _backend
-    _backend = backend
     if not _backend_chosen:
+        _backend = backend
         choose_backend()
     if _backend == 'tracemalloc' and not tracemalloc.is_tracing():
         tracemalloc.start()
"
Makefile,Makefile,fc44641d566e58f3274421eb6a1c10718dd67e64,361c75133663bbf31a40d00f5614916fc5bde1a2,TEST added test for ``tracemalloc``,"@@ -11,7 +11,9 @@ test:
 	$(PYTHON) -m memory_profiler test/test_precision_command_line.py
 	$(PYTHON) -m memory_profiler test/test_gen.py
 	$(PYTHON) -m memory_profiler test/test_unicode.py
+	$(PYTHON) test/test_tracemalloc.py
 	$(PYTHON) test/test_import.py
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
 	$(IPYTHON) test/test_ipython.py
+
"
test/test_tracemalloc.py,test/test_tracemalloc.py,fc44641d566e58f3274421eb6a1c10718dd67e64,361c75133663bbf31a40d00f5614916fc5bde1a2,TEST added test for ``tracemalloc``,"@@ -1,29 +1,20 @@
-import pytest
-import tracemalloc
 from io import StringIO
 from time import sleep
 
 from memory_profiler import profile
-import memory_profiler
 
-tracemalloc.start()
+try:
+    import tracemalloc
+    has_tracemalloc = True
+except ImportError:
+    has_tracemalloc = False
+
 output = StringIO()
 
 # allowable error in MB
 EPSILON = 0.0001
 
-memory_profiler._backend = 'tracemalloc'
 
-
-@pytest.mark.parametrize('test_input,expected', [
-    (100, 0.00012302398681640625),
-    (1000, 0.0009813308715820312),
-    (10000, 0.009564399719238281),
-    (100000, 0.09539508819580078),
-    (1000000, 0.9537019729614258),
-    (10000000, 9.536770820617676),
-    (100000000, 95.36745929718018),
-])
 def test_memory_profiler(test_input, expected):
     mem_prof(test_input)
     inc, dec = parse_mem_prof()
@@ -31,7 +22,7 @@ def test_memory_profiler(test_input, expected):
     assert abs(inc - expected) <= EPSILON, 'inc = {}, size = {}, err = {}'.format(inc, expected, abs(inc - expected))
 
 
-@profile(stream=output, precision=6)
+@profile(stream=output, precision=6, backend='tracemalloc')
 def mem_prof(n):
     a = bytearray(n)
     del a
@@ -45,3 +36,17 @@ def parse_mem_prof():
         return float(s.split()[3])
 
     return f(text[-6]), -f(text[-5])
+
+if __name__ == '__main__':
+    if has_tracemalloc:
+        tests = [
+            (100, 0.00012302398681640625),
+            (1000, 0.0009813308715820312),
+            (10000, 0.009564399719238281),
+            (100000, 0.09539508819580078),
+            (1000000, 0.9537019729614258),
+            (10000000, 9.536770820617676),
+            (100000000, 95.36745929718018),
+        ]
+        for test_input, expected in tests:
+            test_memory_profiler(test_input, expected)
"
memory_profiler.py,memory_profiler.py,e0b37a5336ca9b22978d7d4966cf8bd5c5bddb99,fc44641d566e58f3274421eb6a1c10718dd67e64,FIX line length according to PEP8,"@@ -42,18 +42,21 @@ if PY2:
 else:
     import builtins
 
+
     def unicode(x, *args):
         return str(x)
 
 # .. get available packages ..
 try:
     import psutil
+
     has_psutil = True
 except ImportError:
     has_psutil = False
 
 try:
     import tracemalloc
+
     has_tracemalloc = True
 except ImportError:
     has_tracemalloc = False
@@ -67,6 +70,7 @@ class MemitResult(object):
 
     Object based on IPython's TimeitResult
     """"""
+
     def __init__(self, mem_usage, baseline, repeat, timeout, interval,
                  include_children):
         self.mem_usage = mem_usage
@@ -81,13 +85,12 @@ class MemitResult(object):
         inc = max_mem - self.baseline
         return 'peak memory: %.02f MiB, increment: %.02f MiB' % (max_mem, inc)
 
-    def _repr_pretty_(self, p , cycle):
+    def _repr_pretty_(self, p, cycle):
         msg = str(self)
-        p.text(u'<MemitResult : '+msg+u'>')
+        p.text(u'<MemitResult : ' + msg + u'>')
 
 
 def _get_memory(pid, timestamps=False, include_children=False, filename=None):
-
     # .. only for current process and only on unix..
     if pid == -1:
         pid = os.getpid()
@@ -108,7 +111,8 @@ def _get_memory(pid, timestamps=False, include_children=False, filename=None):
         try:
             # avoid useing get_memory_info since it does not exists
             # in psutil > 2.0 and accessing it will cause exception.
-            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
+            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') \
+                else 'get_memory_info'
             mem = getattr(process, meminfo_attr)()[0] / _TWO_20
             if include_children:
                 try:
@@ -154,10 +158,15 @@ def _get_memory(pid, timestamps=False, include_children=False, filename=None):
             else:
                 return -1
 
-    if _backend == 'tracemalloc' and (filename is None or filename == '<unknown>'):
-        raise RuntimeError('There is no access to source file of the profiled function')
+    if _backend == 'tracemalloc' and \
+            (filename is None or filename == '<unknown>'):
+        raise RuntimeError(
+            'There is no access to source file of the profiled function'
+        )
 
-    tools = {'tracemalloc': tracemalloc_tool, 'psutil': ps_util_tool, 'posix': posix_tool}
+    tools = {'tracemalloc': tracemalloc_tool,
+             'psutil': ps_util_tool,
+             'posix': posix_tool}
     return tools[_backend]()
 
 
@@ -165,6 +174,7 @@ class MemTimer(Process):
     """"""
     Fetch memory consumption from over a time interval
     """"""
+
     def __init__(self, monitor_pid, interval, pipe, max_usage=False,
                  *args, **kw):
         self.monitor_pid = monitor_pid
@@ -286,8 +296,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
         while True:
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
-            p = MemTimer(os.getpid(), interval, child_conn, timestamps=timestamps,
-                         max_usage=max_usage, include_children=include_children)
+            p = MemTimer(os.getpid(), interval, child_conn,
+                         timestamps=timestamps,
+                         max_usage=max_usage,
+                         include_children=include_children)
             p.start()
             parent_conn.recv()  # wait until we start getting memory
             returned = f(*args, **kw)
@@ -359,6 +371,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         return None
     return ret
 
+
 # ..
 # .. utility functions for line-by-line ..
 
@@ -390,16 +403,19 @@ class _TimeStamperCM(object):
         self._filename = filename
 
     def __enter__(self):
-        self._timestamps.append(_get_memory(os.getpid(), timestamps=True, filename=self._filename))
+        self._timestamps.append(
+            _get_memory(os.getpid(), timestamps=True, filename=self._filename))
 
     def __exit__(self, *args):
-        self._timestamps.append(_get_memory(os.getpid(), timestamps=True, filename=self._filename))
+        self._timestamps.append(
+            _get_memory(os.getpid(), timestamps=True, filename=self._filename))
 
 
 class TimeStamper:
     """""" A profiler that just records start and end execution times for
     any decorated function.
     """"""
+
     def __init__(self):
         self.functions = {}
 
@@ -418,6 +434,7 @@ class TimeStamper:
         else:
             def inner_partial(f):
                 return self.__call__(f, precision=precision)
+
             return inner_partial
 
     def timestamp(self, name=""<block>""):
@@ -444,19 +461,23 @@ class TimeStamper:
     def wrap_function(self, func):
         """""" Wrap a function to timestamp it.
         """"""
+
         def f(*args, **kwds):
             # Start time
             try:
                 filename = inspect.getsourcefile(func)
             except TypeError:
                 filename = '<unknown>'
-            timestamps = [_get_memory(os.getpid(), timestamps=True, filename=filename)]
+            timestamps = [
+                _get_memory(os.getpid(), timestamps=True, filename=filename)]
             self.functions[func].append(timestamps)
             try:
                 return func(*args, **kwds)
             finally:
                 # end time
-                timestamps.append(_get_memory(os.getpid(), timestamps=True, filename=filename))
+                timestamps.append(_get_memory(os.getpid(), timestamps=True,
+                                              filename=filename))
+
         return f
 
     def show_results(self, stream=None):
@@ -471,7 +492,6 @@ class TimeStamper:
 
 
 class CodeMap(dict):
-
     def __init__(self, include_children):
         self.include_children = include_children
         self._toplevel = []
@@ -487,8 +507,9 @@ class CodeMap(dict):
             if not os.path.exists(filename):
                 print('ERROR: Could not find file ' + filename)
                 if filename.startswith((""ipython-input"", ""<ipython-input"")):
-                    print(""NOTE: %mprun can only be used on functions defined in ""
-                          ""physical files, and not in the IPython environment."")
+                    print(
+                        ""NOTE: %mprun can only be used on functions defined in""
+                        "" physical files, and not in the IPython environment."")
                 return
 
             toplevel_code = code
@@ -504,7 +525,8 @@ class CodeMap(dict):
             self.add(subcode, toplevel_code=toplevel_code)
 
     def trace(self, code, lineno):
-        memory = _get_memory(-1, include_children=self.include_children, filename=code.co_filename)
+        memory = _get_memory(-1, include_children=self.include_children,
+                             filename=code.co_filename)
         # if there is already a measurement for that line get the max
         previous_memory = self[code].get(lineno, 0)
         self[code][lineno] = max(memory, previous_memory)
@@ -514,7 +536,7 @@ class CodeMap(dict):
         for (filename, code, linenos) in self._toplevel:
             measures = self[code]
             if not measures:
-                continue    # skip if no measurement
+                continue  # skip if no measurement
             line_iterator = ((line, measures.get(line)) for line in linenos)
             yield (filename, line_iterator)
 
@@ -541,6 +563,7 @@ class LineProfiler(object):
         else:
             def inner_partial(f):
                 return self.__call__(f, precision=precision)
+
             return inner_partial
 
     def add_function(self, func):
@@ -565,6 +588,7 @@ class LineProfiler(object):
                 return func(*args, **kwds)
             finally:
                 self.disable_by_count()
+
         return f
 
     def run(self, cmd):
@@ -697,7 +721,6 @@ def _func_exec(stmt, ns):
 
 @magics_class
 class MemoryProfilerMagics(Magics):
-
     # A lprun-style %mprun magic for IPython.
     @line_cell_magic
     def mprun(self, parameter_s='', cell=None):
@@ -760,7 +783,8 @@ class MemoryProfilerMagics(Magics):
         # Escape quote markers.
         opts_def = Struct(T=[''], f=[])
         parameter_s = parameter_s.replace('""', r'\""').replace(""'"", r""\'"")
-        opts, arg_str = self.parse_options(parameter_s, 'rf:T:c', list_all=True)
+        opts, arg_str = self.parse_options(parameter_s, 'rf:T:c',
+                                           list_all=True)
         opts.merge(opts_def)
         global_ns = self.shell.user_global_ns
         local_ns = self.shell.user_ns
@@ -775,7 +799,8 @@ class MemoryProfilerMagics(Magics):
                 funcs.append(eval(name, global_ns, local_ns))
             except Exception as e:
                 raise UsageError('Could not find function %r.\n%s: %s' % (name,
-                                 e.__class__.__name__, e))
+                                                                          e.__class__.__name__,
+                                                                          e))
 
         include_children = 'c' in opts
         profile = LineProfiler(include_children=include_children)
@@ -813,14 +838,15 @@ class MemoryProfilerMagics(Magics):
             page(output, screen_lines=self.shell.rc.screen_length)
         else:
             page(output)
-        print(message,)
+        print(message, )
 
         text_file = opts.T[0]
         if text_file:
             with open(text_file, 'w') as pfile:
                 pfile.write(output)
-            print('\n*** Profile printout saved to text file %s. %s' % (text_file,
-                                                                        message))
+            print('\n*** Profile printout saved to text file %s. %s' % (
+                text_file,
+                message))
 
         return_value = None
         if 'r' in opts:
@@ -882,7 +908,8 @@ class MemoryProfilerMagics(Magics):
 
         """"""
         from memory_profiler import memory_usage, _func_exec
-        opts, stmt = self.parse_options(line, 'r:t:i:coq', posix=False, strict=False)
+        opts, stmt = self.parse_options(line, 'r:t:i:coq', posix=False,
+                                        strict=False)
 
         if cell is None:
             setup = 'pass'
@@ -914,7 +941,8 @@ class MemoryProfilerMagics(Magics):
         while counter < repeat:
             counter += 1
             tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
-                               timeout=timeout, interval=interval, max_usage=True,
+                               timeout=timeout, interval=interval,
+                               max_usage=True,
                                include_children=include_children)
             mem_usage.append(tmp[0])
 
@@ -925,8 +953,9 @@ class MemoryProfilerMagics(Magics):
             if mem_usage:
                 print(result)
             else:
-                print('ERROR: could not read memory usage, try with a lower interval '
-                      'or more iterations')
+                print(
+                    'ERROR: could not read memory usage, try with a lower interval '
+                    'or more iterations')
 
         if return_result:
             return result
@@ -948,6 +977,7 @@ class MemoryProfilerMagics(Magics):
         else:
             ip.register_magics(cls)
 
+
 # commenting out due to failures with some versions of IPython
 # see https://github.com/fabianp/memory_profiler/issues/106
 # # Ensuring old interface of magics expose for IPython 0.10
@@ -977,10 +1007,13 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
             val = prof(func)(*args, **kwargs)
             show_results(prof, stream=stream, precision=precision)
             return val
+
         return wrapper
     else:
         def inner_wrapper(f):
-            return profile(f, stream=stream, precision=precision, backend=backend)
+            return profile(f, stream=stream, precision=precision,
+                           backend=backend)
+
         return inner_wrapper
 
 
@@ -1015,10 +1048,12 @@ def choose_backend():
             _backend = n_backend
             break
     if _backend == 'no_backend':
-        raise NotImplementedError('Tracemalloc or psutil module is required for non-unix '
-                                  'platforms')
+        raise NotImplementedError(
+            'Tracemalloc or psutil module is required for non-unix '
+            'platforms')
     if _backend != old_backend:
-        print('{} can not be used, {} used instead'.format(old_backend, _backend))
+        print('{} can not be used, {} used instead'.format(old_backend,
+                                                           _backend))
     global _backend_chosen
     _backend_chosen = True
 
@@ -1050,12 +1085,14 @@ else:
 
 
 class LogFile(object):
-    """"""File-like object to log text using the `logging` module and the log report can be customised.""""""
+    """"""File-like object to log text using the `logging` module and the log
+    report can be customised.""""""
 
     def __init__(self, name=None, reportIncrementFlag=False):
         """"""
         :param name: name of the logger module
-               reportIncrementFlag: This must be set to True if only the steps with memory increments are to be reported
+               reportIncrementFlag: This must be set to True if only the steps
+               with memory increments are to be reported
 
         :type self: object
               name: string
@@ -1068,7 +1105,8 @@ class LogFile(object):
         if self.reportIncrementFlag:
             if ""MiB"" in msg and float(msg.split(""MiB"")[1].strip()) > 0:
                 self.logger.log(level, msg)
-            elif msg.__contains__(""Filename:"") or msg.__contains__(""Line Contents""):
+            elif msg.__contains__(""Filename:"") or msg.__contains__(
+                    ""Line Contents""):
                 self.logger.log(level, msg)
         else:
             self.logger.log(level, msg)
@@ -1080,6 +1118,7 @@ class LogFile(object):
 
 if __name__ == '__main__':
     from optparse import OptionParser
+
     parser = OptionParser(usage=_CMD_USAGE, version=__version__)
     parser.disable_interspersed_args()
     parser.add_option(
@@ -1097,9 +1136,12 @@ if __name__ == '__main__':
                       action='store_true',
                       help='''print timestamp instead of memory measurement for
                       decorated functions''')
-    parser.add_option('--backend', dest='backend', type='choice', action='store',
-                      choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
-                      help='backend using for getting memory info (one of the {tracemalloc, psutil, posix})')
+    parser.add_option('--backend', dest='backend', type='choice',
+                      action='store',
+                      choices=['tracemalloc', 'psutil', 'posix'],
+                      default='psutil',
+                      help='backend using for getting memory info '
+                           '(one of the {tracemalloc, psutil, posix})')
 
     if not sys.argv[1:]:
         parser.print_help()
"
test/test_tracemalloc.py,test/test_tracemalloc.py,e0b37a5336ca9b22978d7d4966cf8bd5c5bddb99,fc44641d566e58f3274421eb6a1c10718dd67e64,FIX line length according to PEP8,"@@ -18,8 +18,12 @@ EPSILON = 0.0001
 def test_memory_profiler(test_input, expected):
     mem_prof(test_input)
     inc, dec = parse_mem_prof()
-    assert abs(inc - dec) <= EPSILON, 'inc = {}, dec = {}, err = {}'.format(inc, dec, abs(inc - dec))
-    assert abs(inc - expected) <= EPSILON, 'inc = {}, size = {}, err = {}'.format(inc, expected, abs(inc - expected))
+    assert abs(inc - dec) <= EPSILON, \
+        'inc = {}, dec = {}, err = {}'.format(inc, dec, abs(inc - dec))
+    assert abs(inc - expected) <= EPSILON, \
+        'inc = {}, size = {}, err = {}'.format(
+            inc, expected, abs(inc - expected)
+        )
 
 
 @profile(stream=output, precision=6, backend='tracemalloc')
"
memory_profiler.py,memory_profiler.py,4565b8f559f931473f495e96130250da418a3179,e0b37a5336ca9b22978d7d4966cf8bd5c5bddb99,FIX global variable _backend_choosen removed,"@@ -61,8 +61,7 @@ try:
 except ImportError:
     has_tracemalloc = False
 
-_backend_chosen = False
-_backend = 'psutil'
+_backend = None
 
 
 class MemitResult(object):
@@ -995,10 +994,7 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
     """"""
     Decorator that will run the function and print a line-by-line profile
     """"""
-    global _backend
-    if not _backend_chosen:
-        _backend = backend
-        choose_backend()
+    choose_backend(backend)
     if _backend == 'tracemalloc' and not tracemalloc.is_tracing():
         tracemalloc.start()
     if func is not None:
@@ -1017,13 +1013,12 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
         return inner_wrapper
 
 
-def choose_backend():
+def choose_backend(new_backend=None):
     """"""
     Function that tries to setup backend, chosen by user, and if failed,
     setup one of the allowable backends
     """"""
-    global _backend
-    old_backend = _backend
+
     backends = OrderedDict([
         ('psutil', has_psutil),
         ('posix', os.name == 'posix'),
@@ -1040,19 +1035,20 @@ def choose_backend():
             if _key != key:
                 items.append((_key, _value))
         return OrderedDict(items)
-
-    backends = move_to_start(backends, _backend)
+    if new_backend is not None:
+        backends = move_to_start(backends, new_backend)
 
     for n_backend, is_available in backends.items():
         if is_available:
+            global _backend
             _backend = n_backend
             break
     if _backend == 'no_backend':
         raise NotImplementedError(
             'Tracemalloc or psutil module is required for non-unix '
             'platforms')
-    if _backend != old_backend:
-        print('{} can not be used, {} used instead'.format(old_backend,
+    if _backend != new_backend and new_backend is not None:
+        print('{} can not be used, {} used instead'.format(new_backend,
                                                            _backend))
     global _backend_chosen
     _backend_chosen = True
@@ -1063,19 +1059,19 @@ def choose_backend():
 # for all cases, e.g. a script that imports another
 # script where @profile is used)
 if PY2:
-    def exec_with_profiler(filename, profiler):
+    def exec_with_profiler(filename, profiler, backend):
         builtins.__dict__['profile'] = profiler
         ns = dict(_CLEAN_GLOBALS, profile=profiler)
-        choose_backend()
+        choose_backend(backend)
         execfile(filename, ns, ns)
 else:
-    def exec_with_profiler(filename, profiler):
+    def exec_with_profiler(filename, profiler, backend):
+        choose_backend(backend)
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
         builtins.__dict__['profile'] = profiler
         # shadow the profile decorator defined above
         ns = dict(_CLEAN_GLOBALS, profile=profiler)
-        choose_backend()
         try:
             with open(filename) as f:
                 exec(compile(f.read(), filename, 'exec'), ns, ns)
@@ -1149,7 +1145,6 @@ if __name__ == '__main__':
 
     (options, args) = parser.parse_args()
     sys.argv[:] = args  # Remove every memory_profiler arguments
-    _backend = options.backend
 
     script_filename = _find_script(args[0])
     if options.timestamp:
@@ -1158,7 +1153,7 @@ if __name__ == '__main__':
         prof = LineProfiler(max_mem=options.max_mem)
 
     try:
-        exec_with_profiler(script_filename, prof)
+        exec_with_profiler(script_filename, prof, options.backend)
     finally:
         if options.out_filename is not None:
             out_file = open(options.out_filename, ""a"")
"
memory_profiler.py,memory_profiler.py,636b3448d272b2b66a509ae16ad210471bd87f58,4565b8f559f931473f495e96130250da418a3179,FIX string format changed to support Python 2,"@@ -1048,7 +1048,7 @@ def choose_backend(new_backend=None):
             'Tracemalloc or psutil module is required for non-unix '
             'platforms')
     if _backend != new_backend and new_backend is not None:
-        print('{} can not be used, {} used instead'.format(new_backend,
+        print('{0} can not be used, {1} used instead'.format(new_backend,
                                                            _backend))
     global _backend_chosen
     _backend_chosen = True
"
.gitignore,.gitignore,0d956a1df6d1ebc5353e6ac0f54265028a27b59d,aa8b30cfee6e34056f6eac1b6b2eefaccf90cbfd,multiprocessing example,"@@ -5,3 +5,6 @@ MANIFEST
 *.egg-info
 *.pyc
 *~
+
+# Ignore mprof generated files
+mprofile_*.dat
"
,examples/multiprocessing_example.py,0d956a1df6d1ebc5353e6ac0f54265028a27b59d,aa8b30cfee6e34056f6eac1b6b2eefaccf90cbfd,multiprocessing example,"@@ -0,0 +1,55 @@
+""""""
+An undecorated example of a script that allocates memory in multiprocessing
+workers to demonstrate the use of memory_profiler with multiple processes.
+
+Run this script with mprof run -C python multiprocessing_example.py
+You can then visualize the usage with mprof plot.
+""""""
+
+import time
+import multiprocessing as mp
+
+# Big numbers
+X6 = 10 ** 6
+X7 = 10 ** 7
+
+
+def worker(num, wait, amt=X6):
+    """"""
+    A function that allocates memory over time.
+    """"""
+    frame = []
+
+    for idx in range(num):
+        frame.extend([1] * amt)
+        time.sleep(wait)
+
+    del frame
+
+
+def main_sequential():
+    """"""
+    A sequential version of the work, where one worker is called at a time.
+    """"""
+    worker(5, 5, X6)
+    worker(5, 2, X7)
+    worker(5, 5, X6)
+    worker(5, 2, X7)
+
+
+def main_multiproc():
+    """"""
+    A multiprocessing version of the work, where workers work in their own
+    child processes and are collected by the master process.
+    """"""
+    pool    = mp.Pool(processes=4)
+    tasks   = [
+        pool.apply_async(worker, args) for args in
+        [(5, 5, X6), (5, 2, X7), (5, 5, X6), (5, 2, X7)]
+    ]
+
+    results = [p.get() for p in tasks]
+
+
+if __name__ == '__main__':
+    main_multiproc()
"
memory_profiler.py,memory_profiler.py,a846fa63db2c32e0b6ce1db70176fb4e268bbdfc,0d956a1df6d1ebc5353e6ac0f54265028a27b59d,child process memory now recorded seperately in mpmprof,"@@ -73,6 +73,34 @@ class MemitResult(object):
         p.text(u'<MemitResult : '+msg+u'>')
 
 
+def _get_child_memory(process, meminfo_attr=None):
+    """"""
+    Returns a generator that yields memory for all child processes.
+    """"""
+    if not has_psutil:
+        raise NotImplementedError((
+            ""The psutil module is required to monitor the ""
+            ""memory usage of child processes.""
+        ))
+
+    # Convert a pid to a process
+    if isinstance(process, int):
+        if process == -1: process = os.getpid()
+        process = psutil.Process(process)
+
+    if not meminfo_attr:
+        # Use the psutil 2.0 attr if the older version isn't passed in.
+        meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
+
+    # Select the psutil function get the children similar to how we selected
+    # the memory_info attr (a change from excepting the AttributeError).
+    children_attr = 'children' if hasattr(process, 'children') else 'get_children'
+
+    # Loop over the child processes and yield their memory
+    for child in getattr(process, children_attr)(recursive=True):
+        yield getattr(child, meminfo_attr)()[0] / _TWO_20
+
+
 def _get_memory(pid, timestamps=False, include_children=False):
 
     # .. only for current process and only on unix..
@@ -88,13 +116,7 @@ def _get_memory(pid, timestamps=False, include_children=False):
             meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
             mem = getattr(process, meminfo_attr)()[0] / _TWO_20
             if include_children:
-                try:
-                    for p in process.get_children(recursive=True):
-                        mem += getattr(p, meminfo_attr)()[0] / _TWO_20
-                except AttributeError:
-                    # fix for newer psutil
-                    for p in process.children(recursive=True):
-                        mem += getattr(p, meminfo_attr)()[0] / _TWO_20
+                mem +=  sum(_get_child_memory(process, meminfo_attr))
             if timestamps:
                 return (mem, time.time())
             else:
@@ -106,9 +128,11 @@ def _get_memory(pid, timestamps=False, include_children=False):
     # .. scary stuff ..
     if os.name == 'posix':
         if include_children:
-            raise NotImplementedError('The psutil module is required when to'
-                                      ' monitor memory usage of children'
-                                      ' processes')
+            raise NotImplementedError((
+                ""The psutil module is required to monitor the ""
+                ""memory usage of child processes.""
+            ))
+
         warnings.warn(""psutil module not found. memory_profiler will be slow"")
         # ..
         # .. memory usage in MiB ..
"
,mpmprof,a846fa63db2c32e0b6ce1db70176fb4e268bbdfc,0d956a1df6d1ebc5353e6ac0f54265028a27b59d,child process memory now recorded seperately in mpmprof,"@@ -0,0 +1,184 @@
+#!/usr/bin/env python3
+""""""
+Multiprocessing version of memory profiling of Python programs.
+""""""
+
+import os
+import time
+import glob
+import argparse
+import subprocess
+import memory_profiler as mp
+
+
+# Command Descriptions and Constants
+DESCRIPTION = ""Multiprocessing memory profiling over time.""
+EPILOG      = ""If there are any bugs or concerns, submit an issue on Github""
+VERSION     = ""mpmprof v{}"".format(mp.__version__)
+FILETIME    = ""%Y%m%d%H%M%S""
+BLANKS      = set(' \t')
+
+
+def run_action(args):
+    """"""
+    Run the given program and profile its memory usage.
+    """"""
+
+    # Determine where to write the output to
+    if args.output is None:
+        args.output = ""mprofile_{}.dat"".format(
+            time.strftime(FILETIME, time.localtime())
+        )
+
+    # Determine if the command is a Python command
+    if args.command[0].endswith('.py') and not args.nopython:
+        args.python = True
+
+    # Run the executable with the extra features
+    if args.python:
+        print(""running as a Python program ..."")
+        if not args.command[0].startswith('python'):
+            args.command.insert(0, 'python')
+
+    # Inform the user we're sampling
+    print(""mpmprof: Sampling memory every {} seconds"".format(args.interval))
+
+    # Put the command back together from the argument parsing
+    command = "" "".join([
+        c if BLANKS.isdisjoint(c) else ""'{}'"".format(c) for c in args.command
+    ])
+
+    # Open a subprocess to the given command
+    proc = subprocess.Popen(args.command)
+
+    # This is where a call to mp.memory_usage should go.
+    # Instead we're adding the custom code for sampling spawned memory
+    with open(args.output, ""a"") as f:
+
+        # Write the command to the data file
+        f.write(""CMDLINE {}\n"".format(command))
+
+        # Continue sampling until the subprocess is over, counting lines
+        lines = 0
+        while True:
+            # Determine if the subprocess is still running
+            if proc.poll() is not None: break
+
+            # Collect memory usage of master program and write to profile
+            mem = mp._get_memory(proc.pid)
+            f.write(""MEM {0:.6f} {1:.4f}\n"".format(mem, time.time()))
+            lines += 1
+
+            # Collect memory usage of spawned children and write to profile
+            for idx, mem in enumerate(mp._get_child_memory(proc.pid)):
+                f.write(""CHLD{0} {1:.6f} {2:.4f}\n"".format(idx, mem, time.time()))
+                lines += 1
+
+            # Flush every 50 lines
+            if lines > 50:
+                lines = 0
+                f.flush()
+
+            # Sleep for the given interval
+            time.sleep(args.interval)
+
+    return ""memory profile written to {}"".format(args.output)
+
+
+def plot_action(args):
+    """"""
+    Use matplotlib to draw the memory usage of a mprofile .dat file.
+    """"""
+    raise NotImplementedError(""Not implemented yet."")
+
+
+if __name__ == '__main__':
+    # Create the argument parser and subparsers for each command
+    parser = argparse.ArgumentParser(description=DESCRIPTION, epilog=EPILOG)
+    subparsers = parser.add_subparsers(title='commands')
+
+    # Add the version command
+    parser.add_argument('-v', '--version', action='version', version=VERSION)
+
+    # Commands defined in an dictionary for easy adding
+    commands = (
+        # Run command definition
+        {
+            'name': 'run',
+            'action': run_action,
+            'help': 'monitor the memory usage of a command',
+            'args': {
+                '--python': {
+                    'default': False,
+                    'action': 'store_true',
+                    'help': 'activates extra features for Python programs',
+                },
+                '--nopython': {
+                    'default': False,
+                    'action': 'store_true',
+                    'help': 'disables extra features for Python programs',
+                },
+                ('-T', '--interval'): {
+                    'type': float,
+                    'default': 0.1,
+                    'metavar': 'S',
+                    'help': 'sampling period (in seconds), defaults to 0.1',
+                },
+                ('-o', '--output'): {
+                    'type': str,
+                    'default': None,
+                    'metavar': 'PATH',
+                    'help': 'location to write the memory profiler output to',
+                },
+                'command': {
+                    'nargs': argparse.REMAINDER,
+                    'help': 'command to run and profile memory usage',
+                }
+            }
+        },
+
+        # Plot command definition
+        {
+            'name': 'plot',
+            'action': plot_action,
+            'help': 'plot the memory usage of a mprofile data file',
+            'args': {
+                ('-t', '--title'): {
+                    'type': str,
+                    'default': None,
+                    'metavar': 'S',
+                    'help': 'set the title of the figure',
+                },
+                ('-o', '--output'): {
+                    'type': str,
+                    'default': None,
+                    'metavar': 'PATH',
+                    'help': 'write the figure as a png to disk'
+                },
+                'profile': {
+                    'nargs': '*',
+                    'help': 'profile to plot, omit to use the latest',
+                }
+            }
+        }
+    )
+
+    # Add the commands and their arguments.
+    for cmd in commands:
+        # Create the command subparser and add the action
+        cmd_parser = subparsers.add_parser(cmd['name'], help=cmd['help'])
+        cmd_parser.set_defaults(func=cmd['action'])
+
+        # Add the arguments
+        for args, kwargs in cmd['args'].items():
+            if isinstance(args, str):
+                args = (args,)
+            cmd_parser.add_argument(*args, **kwargs)
+
+    # Handle input from the command line
+    args = parser.parse_args()            # Parse the arguments
+    # try:
+    msg = args.func(args)             # Call the default function
+    parser.exit(0, msg+""\n"")          # Exit cleanly with message
+    # except Exception as e:
+    #     parser.error(str(e))              # Exit with error
"
mpmprof,mpmprof,e32679b9c91c66e3eaf9ebfe6882cbf7410233b6,a846fa63db2c32e0b6ce1db70176fb4e268bbdfc,plot function for mpmproc,"@@ -4,12 +4,22 @@ Multiprocessing version of memory profiling of Python programs.
 """"""
 
 import os
+import re
 import time
 import glob
 import argparse
 import subprocess
 import memory_profiler as mp
 
+from collections import defaultdict
+
+try:
+    import numpy as np
+    import matplotlib.pyplot as plt
+except ImportError:
+    plt = None
+    np  = None
+
 
 # Command Descriptions and Constants
 DESCRIPTION = ""Multiprocessing memory profiling over time.""
@@ -82,6 +92,7 @@ def run_action(args):
             # Sleep for the given interval
             time.sleep(args.interval)
 
+    # Return the results of the run action
     return ""memory profile written to {}"".format(args.output)
 
 
@@ -89,7 +100,122 @@ def plot_action(args):
     """"""
     Use matplotlib to draw the memory usage of a mprofile .dat file.
     """"""
-    raise NotImplementedError(""Not implemented yet."")
+    if plt is None:
+        raise ImportError(
+            ""matplotlib is needed for plotting.""
+        )
+
+    def read_mprofile_file(path):
+        """"""
+        Reads the specialized version of the mprofile for multiprocessing
+        """"""
+        # Regular expression line parsers for parsing data
+        cmdre = re.compile(r""^CMDLINE\s+(.+)$"")
+        memre = re.compile(r""^MEM\s+([\d\.e]+)\s+([\d\.e]+)$"")
+        cldre = re.compile(r""^CHLD(\d+)\s+([\d\.e]+)\s+([\d\.e]+)$"")
+
+        # Data structure returned is a series of names (mem, ts) tuples.
+        series  = defaultdict(list)
+        command = None
+
+        with open(path, 'r') as f:
+            for line in f:
+
+                # Match children memory usage lines
+                match = cldre.match(line)
+                if match:
+                    idx, mem, ts = match.groups()
+                    series[""child "" + idx].append((float(mem), float(ts)))
+                    continue
+
+                # Match main process memory usage lines
+                match = memre.match(line)
+                if match:
+                    series['main'].append(tuple(map(float, match.groups())))
+                    continue
+
+                # Match command line(s)
+                # NOTE: mprofile files are openeded for appending, could be multiple
+                match = cmdre.match(line)
+                if match:
+                    command = match.groups()[0]
+
+        return command, series
+
+
+    def plot_mprofile_file(path, title=None):
+        """"""
+        Plots an mprofile file that contains specialized child process data.
+        """"""
+        # Parse the mprofile file to get the data
+        command, series = read_mprofile_file(path)
+        title = title or command
+
+        # Create and configure the figure
+        fig = plt.figure(figsize=(14, 6), dpi=90)
+        axe = fig.add_axes([0.1, 0.1, 0.6, 0.75])
+        axe.set_xlabel(""time (in seconds)"")
+        axe.set_ylabel(""memory used (in MiB)"")
+        axe.set_title(title)
+
+        # Find the start timestamp for the process and track the maximal memory point
+        # This currently assumes that the series were written in order
+        start  = series['main'][0][1]
+        mpoint = (0, 0)
+
+        # Plot all of the series, the main process and the child.
+        for proc, data in series.items():
+            # Create the numpy arrays from the series data
+            ts  = np.asarray([item[1] for item in data]) - start
+            mem = np.asarray([item[0] for item in data])
+
+            # Plot the line to the figure
+            plt.plot(ts, mem, ""+-"", label=proc)
+
+            # Detect the maximal memory point
+            max_mem = mem.max()
+            if max_mem > mpoint[1]:
+                mpoint = (mem.argmax(), max_mem)
+
+        # Add the marker lines for the maximal memory usage
+        plt.hlines(mpoint[1], plt.xlim()[0]+0.001, plt.xlim()[1] - 0.001, 'r', '--')
+        plt.vlines(ts[mpoint[0]], plt.ylim()[0]+0.001, plt.ylim()[1] - 0.001, 'r', '--')
+
+        # Add the legend
+        legend = axe.legend(loc='center left', bbox_to_anchor=(1, 0.5))
+        legend.get_frame().set_alpha(0.5)
+        axe.grid()
+
+    # Get the latest profile if no profile files were passed in.
+    if not args.profile:
+
+        # Glob profiles of our format and sort them.
+        profiles = glob.glob(""mprofile_??????????????.dat"")
+        profiles.sort()
+
+        if not profiles:
+            raise ValueError((
+                ""No input file found.\nThis program looks for mprofile_*.dat ""
+                ""files generated by the `mpmprof run` command.""
+            ))
+
+        # Assign the latest profile to visualize
+        args.profile = profiles[0:1]
+
+    # Filter out any files that do not exist
+    args.profile = list(filter(os.path.exists, args.profile))
+    if not args.profile:
+        raise ValueError(""No input files found!"")
+
+    # For each passed in file, create a figure from the mprofile.
+    for path in args.profile:
+        axe = plot_mprofile_file(path, args.title)
+        if args.output:
+            plt.savefig(args.output)
+        else:
+            plt.show()
+
+    return ""{} memory profiles plotted."".format(len(args.profile))
 
 
 if __name__ == '__main__':
"
memory_profiler.py,memory_profiler.py,4a268812c97ce2b550d38b7812fc6eabec16a858,636b3448d272b2b66a509ae16ad210471bd87f58,FIX ``_backend_chosen`` variable deleted from everywhere,"@@ -262,7 +262,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     ret : return value of the profiled function
         Only returned if retval is set to True
     """"""
-    if not _backend_chosen:
+    if _backend is None:
         choose_backend()
     if stream is not None:
         timestamps = True
@@ -952,9 +952,8 @@ class MemoryProfilerMagics(Magics):
             if mem_usage:
                 print(result)
             else:
-                print(
-                    'ERROR: could not read memory usage, try with a lower interval '
-                    'or more iterations')
+                print('ERROR: could not read memory usage, try with a '
+                      'lower interval or more iterations')
 
         if return_result:
             return result
@@ -1050,8 +1049,6 @@ def choose_backend(new_backend=None):
     if _backend != new_backend and new_backend is not None:
         print('{0} can not be used, {1} used instead'.format(new_backend,
                                                            _backend))
-    global _backend_chosen
-    _backend_chosen = True
 
 
 # Insert in the built-ins to have profile
"
memory_profiler.py,memory_profiler.py,eba604c1ab7dec31dd561329b79efa7fd45fbeda,4a268812c97ce2b550d38b7812fc6eabec16a858,FIX TODO's removed,"@@ -187,7 +187,6 @@ class MemTimer(Process):
         self.include_children = kw.pop(""include_children"", False)
 
         # get baseline memory usage
-        # TODO: add filename
         self.mem_usage = [
             _get_memory(self.monitor_pid, timestamps=self.timestamps,
                         include_children=self.include_children)]
@@ -197,7 +196,6 @@ class MemTimer(Process):
         self.pipe.send(0)  # we're ready
         stop = False
         while True:
-            # TODO: add filename
             cur_mem = _get_memory(self.monitor_pid, timestamps=self.timestamps,
                                   include_children=self.include_children)
             if not self.max_usage:
@@ -316,7 +314,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         line_count = 0
         while True:
             if not max_usage:
-                # TODO: add filename
                 mem_usage = _get_memory(proc.pid, timestamps=timestamps,
                                         include_children=include_children)
                 if stream is not None:
@@ -324,7 +321,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 else:
                     ret.append(mem_usage)
             else:
-                # TODO: add filename
                 ret = max(ret,
                           _get_memory(proc.pid,
                                       include_children=include_children))
@@ -349,7 +345,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         while counter < max_iter:
             counter += 1
             if not max_usage:
-                # TODO: add filename
                 mem_usage = _get_memory(proc, timestamps=timestamps,
                                         include_children=include_children)
                 if stream is not None:
@@ -357,7 +352,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 else:
                     ret.append(mem_usage)
             else:
-                # TODO: add filename
                 ret = max([ret,
                            _get_memory(proc, include_children=include_children)
                            ])
"
memory_profiler.py,memory_profiler.py,946aa5e006916fb752b3060dbc83b68790e0762b,eba604c1ab7dec31dd561329b79efa7fd45fbeda,FIX OrderedDict changed to list in ``choose_backend`` function,"@@ -17,7 +17,6 @@ import inspect
 import subprocess
 import logging
 
-from collections import OrderedDict
 
 # TODO: provide alternative when multiprocessing is not available
 try:
@@ -1012,26 +1011,18 @@ def choose_backend(new_backend=None):
     setup one of the allowable backends
     """"""
 
-    backends = OrderedDict([
+    backends = [
         ('psutil', has_psutil),
         ('posix', os.name == 'posix'),
         ('tracemalloc', has_tracemalloc),
         ('no_backend', True)
-    ])
+    ]
+    backends_indices = {b[0]: i for i, b in enumerate(backends)}
 
-    def move_to_start(d, key):
-        """"""
-        Emulation of OrderedDict.move_to_end(last=False) for old versions of Python
-        """"""
-        items = [(key, d[key])]
-        for _key, _value in d.items():
-            if _key != key:
-                items.append((_key, _value))
-        return OrderedDict(items)
     if new_backend is not None:
-        backends = move_to_start(backends, new_backend)
+        backends.insert(0, backends.pop(backends_indices[new_backend]))
 
-    for n_backend, is_available in backends.items():
+    for n_backend, is_available in backends:
         if is_available:
             global _backend
             _backend = n_backend
"
memory_profiler.py,memory_profiler.py,03411e9a5e77452df1eda2091101c76958bcf0da,946aa5e006916fb752b3060dbc83b68790e0762b,remove global variable _backend,"@@ -60,8 +60,6 @@ try:
 except ImportError:
     has_tracemalloc = False
 
-_backend = None
-
 
 class MemitResult(object):
     """"""memit magic run details.
@@ -88,13 +86,13 @@ class MemitResult(object):
         p.text(u'<MemitResult : ' + msg + u'>')
 
 
-def _get_memory(pid, timestamps=False, include_children=False, filename=None):
-    # .. only for current process and only on unix..
+def _get_memory(pid, backend, timestamps=False, include_children=False, filename=None):
+    # .. low function to get memory consumption ..
     if pid == -1:
         pid = os.getpid()
 
     def tracemalloc_tool():
-        # .. cross-platform but but requires Python 3.4 or higher
+        # .. cross-platform but but requires Python 3.4 or higher ..
         stat = next(filter(lambda item: str(item).startswith(filename),
                            tracemalloc.take_snapshot().statistics('filename')))
         mem = stat.size / _TWO_20
@@ -156,7 +154,7 @@ def _get_memory(pid, timestamps=False, include_children=False, filename=None):
             else:
                 return -1
 
-    if _backend == 'tracemalloc' and \
+    if backend == 'tracemalloc' and \
             (filename is None or filename == '<unknown>'):
         raise RuntimeError(
             'There is no access to source file of the profiled function'
@@ -165,7 +163,7 @@ def _get_memory(pid, timestamps=False, include_children=False, filename=None):
     tools = {'tracemalloc': tracemalloc_tool,
              'psutil': ps_util_tool,
              'posix': posix_tool}
-    return tools[_backend]()
+    return tools[backend]()
 
 
 class MemTimer(Process):
@@ -173,12 +171,13 @@ class MemTimer(Process):
     Fetch memory consumption from over a time interval
     """"""
 
-    def __init__(self, monitor_pid, interval, pipe, max_usage=False,
+    def __init__(self, monitor_pid, interval, pipe, backend, max_usage=False,
                  *args, **kw):
         self.monitor_pid = monitor_pid
         self.interval = interval
         self.pipe = pipe
         self.cont = True
+        self.backend = backend
         self.max_usage = max_usage
         self.n_measurements = 1
 
@@ -187,7 +186,7 @@ class MemTimer(Process):
 
         # get baseline memory usage
         self.mem_usage = [
-            _get_memory(self.monitor_pid, timestamps=self.timestamps,
+            _get_memory(self.monitor_pid, self.backend, timestamps=self.timestamps,
                         include_children=self.include_children)]
         super(MemTimer, self).__init__(*args, **kw)
 
@@ -195,8 +194,9 @@ class MemTimer(Process):
         self.pipe.send(0)  # we're ready
         stop = False
         while True:
-            cur_mem = _get_memory(self.monitor_pid, timestamps=self.timestamps,
-                                  include_children=self.include_children)
+            cur_mem = _get_memory(
+                self.monitor_pid, self.backend, timestamps=self.timestamps,
+                include_children=self.include_children,)
             if not self.max_usage:
                 self.mem_usage.append(cur_mem)
             else:
@@ -213,7 +213,7 @@ class MemTimer(Process):
 
 def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                  include_children=False, max_usage=False, retval=False,
-                 stream=None):
+                 stream=None, backend=None):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -259,8 +259,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     ret : return value of the profiled function
         Only returned if retval is set to True
     """"""
-    if _backend is None:
-        choose_backend()
+    backend = choose_backend(backend)
     if stream is not None:
         timestamps = True
 
@@ -292,7 +291,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
         while True:
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
-            p = MemTimer(os.getpid(), interval, child_conn,
+            p = MemTimer(os.getpid(), interval, child_conn, backend,
                          timestamps=timestamps,
                          max_usage=max_usage,
                          include_children=include_children)
@@ -313,16 +312,17 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         line_count = 0
         while True:
             if not max_usage:
-                mem_usage = _get_memory(proc.pid, timestamps=timestamps,
-                                        include_children=include_children)
+                mem_usage = _get_memory(
+                    proc.pid, backend, timestamps=timestamps,
+                    include_children=include_children)
                 if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
                 else:
                     ret.append(mem_usage)
             else:
                 ret = max(ret,
-                          _get_memory(proc.pid,
-                                      include_children=include_children))
+                          _get_memory(
+                              proc.pid, backend, include_children=include_children))
             time.sleep(interval)
             line_count += 1
             # flush every 50 lines. Make 'tail -f' usable on profile file
@@ -344,15 +344,16 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         while counter < max_iter:
             counter += 1
             if not max_usage:
-                mem_usage = _get_memory(proc, timestamps=timestamps,
-                                        include_children=include_children)
+                mem_usage = _get_memory(
+                    proc, backend, timestamps=timestamps,
+                    include_children=include_children)
                 if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
                 else:
                     ret.append(mem_usage)
             else:
                 ret = max([ret,
-                           _get_memory(proc, include_children=include_children)
+                           _get_memory(proc, backend, include_children=include_children)
                            ])
 
             time.sleep(interval)
@@ -390,17 +391,18 @@ def _find_script(script_name):
 class _TimeStamperCM(object):
     """"""Time-stamping context manager.""""""
 
-    def __init__(self, timestamps, filename):
-        self._timestamps = timestamps
-        self._filename = filename
+    def __init__(self, timestamps, filename, backend):
+        self.timestamps = timestamps
+        self.filename = filename
+        self.backend = backend
 
     def __enter__(self):
-        self._timestamps.append(
-            _get_memory(os.getpid(), timestamps=True, filename=self._filename))
+        self.timestamps.append(
+            _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
 
     def __exit__(self, *args):
-        self._timestamps.append(
-            _get_memory(os.getpid(), timestamps=True, filename=self._filename))
+        self.timestamps.append(
+            _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
 
 
 class TimeStamper:
@@ -408,8 +410,9 @@ class TimeStamper:
     any decorated function.
     """"""
 
-    def __init__(self):
+    def __init__(self, backend):
         self.functions = {}
+        self.backend = backend
 
     def __call__(self, func=None, precision=None):
         if func is not None:
@@ -444,7 +447,7 @@ class TimeStamper:
             filename = inspect.getsourcefile(func)
         except TypeError:
             filename = '<unknown>'
-        return _TimeStamperCM(timestamps, filename)
+        return _TimeStamperCM(timestamps, filename, self.backend)
 
     def add_function(self, func):
         if func not in self.functions:
@@ -461,13 +464,13 @@ class TimeStamper:
             except TypeError:
                 filename = '<unknown>'
             timestamps = [
-                _get_memory(os.getpid(), timestamps=True, filename=filename)]
+                _get_memory(os.getpid(), self.backend, timestamps=True, filename=filename)]
             self.functions[func].append(timestamps)
             try:
                 return func(*args, **kwds)
             finally:
                 # end time
-                timestamps.append(_get_memory(os.getpid(), timestamps=True,
+                timestamps.append(_get_memory(os.getpid(), self.backend, timestamps=True,
                                               filename=filename))
 
         return f
@@ -484,9 +487,10 @@ class TimeStamper:
 
 
 class CodeMap(dict):
-    def __init__(self, include_children):
+    def __init__(self, include_children, backend):
         self.include_children = include_children
         self._toplevel = []
+        self.backend = backend
 
     def add(self, code, toplevel_code=None):
         if code in self:
@@ -517,7 +521,7 @@ class CodeMap(dict):
             self.add(subcode, toplevel_code=toplevel_code)
 
     def trace(self, code, lineno):
-        memory = _get_memory(-1, include_children=self.include_children,
+        memory = _get_memory(-1, self.backend, include_children=self.include_children,
                              filename=code.co_filename)
         # if there is already a measurement for that line get the max
         previous_memory = self[code].get(lineno, 0)
@@ -538,10 +542,13 @@ class LineProfiler(object):
 
     def __init__(self, **kw):
         include_children = kw.get('include_children', False)
-        self.code_map = CodeMap(include_children=include_children)
+        backend = kw.get('backend', 'psutil')
+        self.code_map = CodeMap(
+            include_children=include_children, backend=backend)
         self.enable_count = 0
         self.max_mem = kw.get('max_mem', None)
         self.prevlines = []
+        self.backend = choose_backend(kw.get('backend', None))
 
     def __call__(self, func=None, precision=1):
         if func is not None:
@@ -583,14 +590,6 @@ class LineProfiler(object):
 
         return f
 
-    def run(self, cmd):
-        """""" Profile a single executable statement in the main namespace.
-        """"""
-        # TODO: can this be removed ?
-        import __main__
-        main_dict = __main__.__dict__
-        return self.runctx(cmd, main_dict, main_dict)
-
     def runctx(self, cmd, globals, locals):
         """""" Profile a single executable statement in the given namespaces.
         """"""
@@ -630,14 +629,14 @@ class LineProfiler(object):
                 self.code_map.trace(frame.f_code, self.prevlines.pop())
 
         if self._original_trace_function is not None:
-            (self._original_trace_function)(frame, event, arg)
+            self._original_trace_function(frame, event, arg)
 
         return self.trace_memory_usage
 
     def trace_max_mem(self, frame, event, arg):
         # run into PDB as soon as memory is higher than MAX_MEM
         if event in ('line', 'return') and frame.f_code in self.code_map:
-            c = _get_memory(-1, filename=frame.f_code.co_filename)
+            c = _get_memory(-1, self.backend, filename=frame.f_code.co_filename)
             if c >= self.max_mem:
                 t = ('Current memory {0:.2f} MiB exceeded the '
                      'maximum of {1:.2f} MiB\n'.format(c, self.max_mem))
@@ -986,12 +985,11 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
     """"""
     Decorator that will run the function and print a line-by-line profile
     """"""
-    choose_backend(backend)
-    if _backend == 'tracemalloc' and not tracemalloc.is_tracing():
+    if backend == 'tracemalloc' and not tracemalloc.is_tracing():
         tracemalloc.start()
     if func is not None:
         def wrapper(*args, **kwargs):
-            prof = LineProfiler()
+            prof = LineProfiler(backend=backend)
             val = prof(func)(*args, **kwargs)
             show_results(prof, stream=stream, precision=precision)
             return val
@@ -1024,7 +1022,6 @@ def choose_backend(new_backend=None):
 
     for n_backend, is_available in backends:
         if is_available:
-            global _backend
             _backend = n_backend
             break
     if _backend == 'no_backend':
@@ -1032,8 +1029,9 @@ def choose_backend(new_backend=None):
             'Tracemalloc or psutil module is required for non-unix '
             'platforms')
     if _backend != new_backend and new_backend is not None:
-        print('{0} can not be used, {1} used instead'.format(new_backend,
-                                                           _backend))
+        raise ValueError('{0} can not be used, {1} used instead'.format(
+            new_backend, _backend))
+    return _backend
 
 
 # Insert in the built-ins to have profile
@@ -1129,10 +1127,11 @@ if __name__ == '__main__':
     sys.argv[:] = args  # Remove every memory_profiler arguments
 
     script_filename = _find_script(args[0])
+    _backend = choose_backend(options.backend)
     if options.timestamp:
-        prof = TimeStamper()
+        prof = TimeStamper(_backend)
     else:
-        prof = LineProfiler(max_mem=options.max_mem)
+        prof = LineProfiler(max_mem=options.max_mem, backend=_backend)
 
     try:
         exec_with_profiler(script_filename, prof, options.backend)
"
memory_profiler.py,memory_profiler.py,62b8560a48f0cee39c231bdb1126c70c3a9fef92,03411e9a5e77452df1eda2091101c76958bcf0da,ValueError was too much. Use warning instead.,"@@ -1029,7 +1029,7 @@ def choose_backend(new_backend=None):
             'Tracemalloc or psutil module is required for non-unix '
             'platforms')
     if _backend != new_backend and new_backend is not None:
-        raise ValueError('{0} can not be used, {1} used instead'.format(
+        raise warnings.warn('{0} can not be used, {1} used instead'.format(
             new_backend, _backend))
     return _backend
 
"
README.rst,README.rst,ac3ab35cc81de8c7c8307d61521cfd983e3d833c,62b8560a48f0cee39c231bdb1126c70c3a9fef92,Update acknowledgements,"@@ -410,6 +410,7 @@ cleanup.
 
 `Sagar UDAY KUMAR <https://github.com/sagaru>`_ added Report generation feature and examples.
 
+`Dmitriy Novozhilov <https://github.com/demiurg906>`_ and `Sergei Lebedev <https://github.com/superbobry>`_ added support for `tracemalloc <https://docs.python.org/3/library/tracemalloc.html>`_.
 
 =========
  License
"
memory_profiler.py,memory_profiler.py,036bd76bcb721fdddec0a8f780bef86c07180547,ac3ab35cc81de8c7c8307d61521cfd983e3d833c,bug fixes,"@@ -1029,7 +1029,7 @@ def choose_backend(new_backend=None):
             'Tracemalloc or psutil module is required for non-unix '
             'platforms')
     if _backend != new_backend and new_backend is not None:
-        raise warnings.warn('{0} can not be used, {1} used instead'.format(
+        warnings.warn('{0} can not be used, {1} used instead'.format(
             new_backend, _backend))
     return _backend
 
"
memory_profiler.py,memory_profiler.py,925a587c1f86fdde3ceb8887fe23792c9350f9e9,036bd76bcb721fdddec0a8f780bef86c07180547,cosmetic,"@@ -1009,6 +1009,7 @@ def choose_backend(new_backend=None):
     setup one of the allowable backends
     """"""
 
+    _backend = 'no_backend'
     backends = [
         ('psutil', has_psutil),
         ('posix', os.name == 'posix'),
"
memory_profiler.py,memory_profiler.py,386a0bfd0f4532d887b800bce928e559c30137c9,925a587c1f86fdde3ceb8887fe23792c9350f9e9,Bug fixes,"@@ -985,8 +985,9 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
     """"""
     Decorator that will run the function and print a line-by-line profile
     """"""
-    if backend == 'tracemalloc' and not tracemalloc.is_tracing():
-        tracemalloc.start()
+    if backend == 'tracemalloc' and has_tracemalloc:
+        if not tracemalloc.is_tracing():
+            tracemalloc.start()
     if func is not None:
         def wrapper(*args, **kwargs):
             prof = LineProfiler(backend=backend)
"
memory_profiler.py,memory_profiler.py,5a92a5f7ae7d90d7bd561ce5e66d7bde81855d03,386a0bfd0f4532d887b800bce928e559c30137c9,bug fixes,"@@ -985,6 +985,7 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
     """"""
     Decorator that will run the function and print a line-by-line profile
     """"""
+    backend = choose_backend(backend)
     if backend == 'tracemalloc' and has_tracemalloc:
         if not tracemalloc.is_tracing():
             tracemalloc.start()
"
memory_profiler.py,memory_profiler.py,987e621c6a94299bb0eed01ce7f6b39dda16b8f7,5a92a5f7ae7d90d7bd561ce5e66d7bde81855d03,cosmetic,"@@ -1012,18 +1012,18 @@ def choose_backend(new_backend=None):
     """"""
 
     _backend = 'no_backend'
-    backends = [
+    all_backends = [
         ('psutil', has_psutil),
         ('posix', os.name == 'posix'),
         ('tracemalloc', has_tracemalloc),
         ('no_backend', True)
     ]
-    backends_indices = {b[0]: i for i, b in enumerate(backends)}
+    backends_indices = {b[0]: i for i, b in enumerate(all_backends)}
 
     if new_backend is not None:
-        backends.insert(0, backends.pop(backends_indices[new_backend]))
+        all_backends.insert(0, all_backends.pop(backends_indices[new_backend]))
 
-    for n_backend, is_available in backends:
+    for n_backend, is_available in all_backends:
         if is_available:
             _backend = n_backend
             break
"
mprof,mprof,237492a61ec5a302f64d63cdf70ccb4ed9d0d354,ac1193c43efcde3d403e4cf037d2eae7ff398ba6,"More user friendly error message

This is helpful as if tkinter is not installed the ImportError is caught
here and although the user has installed matplotlib the error message
says matplotlib is needed.
So this small change fixes this.","@@ -253,7 +253,7 @@ def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
     try:
         import pylab as pl
     except ImportError:
-        print(""matplotlib is needed for plotting."")
+        print(""matplotlib is needed for plotting and tkinter for visualisation."")
         sys.exit(1)
     height_ratio = 20.
     vsize = (pl.ylim()[1] - pl.ylim()[0]) / height_ratio
"
mprof,mprof,4e8089d577683d9db94b3d2da70b8554b613eef9,237492a61ec5a302f64d63cdf70ccb4ed9d0d354,More general solution,"@@ -252,8 +252,9 @@ def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
     """"""
     try:
         import pylab as pl
-    except ImportError:
-        print(""matplotlib is needed for plotting and tkinter for visualisation."")
+    except ImportError as e:
+        print(""matplotlib is needed for plotting."")
+        print(e)
         sys.exit(1)
     height_ratio = 20.
     vsize = (pl.ylim()[1] - pl.ylim()[0]) / height_ratio
"
MANIFEST.in,MANIFEST.in,bf31b8c8d6aa6e1137296fb0d5f606c946bec636,e0ca6031136b3a5ab9cbb964eda184f61ed9bc57,MANIFEST.in: Include the license file.,"@@ -1 +1,2 @@
 include README.rst
+include COPYING
"
mprof,mprof,861f53116529d32d0f669e3eec9686e3a519c0c4,271e17399f4978715edd956d4ff6d2525c83439b,"Better error message for mprof run

thanks to @anntzer for reporting!","@@ -181,16 +181,14 @@ def get_cmd_line(args):
 
 def run_action():
     import time, subprocess
-    parser = OptionParser(version=mp.__version__)
+    parser = OptionParser(version=mp.__version__, usage=""mprof run [options]"")
     parser.disable_interspersed_args()
     parser.add_option(""--python"", dest=""python"", default=False,
                       action=""store_true"",
-                      help=""""""Activates extra features when the profiled executable is
-                      a Python program (currently: function timestamping.)"""""")
+                      help=""""""Activates extra features when the profiling executable is a Python program (currently: function timestamping.)"""""")
     parser.add_option(""--nopython"", dest=""nopython"", default=False,
                       action=""store_true"",
-                      help=""""""Disables extra features when the profiled executable is
-                      a Python program (currently: function timestamping.)"""""")
+                      help=""""""Disables extra features when the profiled executable is a Python program (currently: function timestamping.)"""""")
     parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.1"",
                       type=""float"", action=""store"",
                       help=""Sampling period (in seconds), defaults to 0.1"")
"
memory_profiler.py,memory_profiler.py,fe3027f4099de7e69053b5b6729d660b3059c431,861f53116529d32d0f669e3eec9686e3a519c0c4,"Fix 1 typo in the comments of function mem_usage

Very helpful program, thanks!","@@ -252,7 +252,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
     Returns
     -------
-    mem_usage : list of floating-poing values
+    mem_usage : list of floating-point values
         memory usage, in MiB. It's length is always < timeout / interval
         if max_usage is given, returns the two elements maximum memory and
         number of measurements effectuated
"
memory_profiler.py,memory_profiler.py,a9e5a026a1c5a588ce0c51101af966980b9e3311,a6d4ea45d7a21f30c6adb37985792b06394ca25a,Fix for issue #71,"@@ -118,6 +118,9 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
                     # fix for newer psutil
                     for p in process.children(recursive=True):
                         mem += getattr(p, meminfo_attr)()[0] / _TWO_20
+                except os.OSError:
+                    # https://github.com/fabianp/memory_profiler/issues/71
+                    pass
             if timestamps:
                 return mem, time.time()
             else:
"
memory_profiler.py,memory_profiler.py,4fe1d5725fbc01d32ce0bfb1781b449fef7b6049,a9e5a026a1c5a588ce0c51101af966980b9e3311,Fix issue #131,"@@ -112,10 +112,6 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
             mem = getattr(process, meminfo_attr)()[0] / _TWO_20
             if include_children:
                 try:
-                    for p in process.get_children(recursive=True):
-                        mem += getattr(p, meminfo_attr)()[0] / _TWO_20
-                except AttributeError:
-                    # fix for newer psutil
                     for p in process.children(recursive=True):
                         mem += getattr(p, meminfo_attr)()[0] / _TWO_20
                 except os.OSError:
"
memory_profiler.py,memory_profiler.py,d38c3c59cee8d899ce2b414e277afa293d6b57cd,4fe1d5725fbc01d32ce0bfb1781b449fef7b6049,0.42 release,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.41'
+__version__ = '0.42'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
memory_profiler.py,memory_profiler.py,1c38945944749e7005e09db6eb90d245c117f818,d38c3c59cee8d899ce2b414e277afa293d6b57cd,Catch the right exception for issue #71,"@@ -114,7 +114,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
                 try:
                     for p in process.children(recursive=True):
                         mem += getattr(p, meminfo_attr)()[0] / _TWO_20
-                except os.OSError:
+                except psutil.NoSuchProcess:
                     # https://github.com/fabianp/memory_profiler/issues/71
                     pass
             if timestamps:
"
memory_profiler.py,memory_profiler.py,bed17eaaf18d2dc114a5c3c635f63cb7512d0e8e,1c38945944749e7005e09db6eb90d245c117f818,release 0.43,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.42'
+__version__ = '0.43'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
examples/multiprocessing_example.py,examples/multiprocessing_example.py,aab15edbc9f45968f1faf54a92a539b7a8a946bb,bdf9995643ae14606e0fbeb1d82b9e5f94c9b48b,merge mpmprof into mprof,"@@ -2,7 +2,7 @@
 An undecorated example of a script that allocates memory in multiprocessing
 workers to demonstrate the use of memory_profiler with multiple processes.
 
-Run this script with mprof run -C python multiprocessing_example.py
+Run this script with mprof run -M python multiprocessing_example.py
 You can then visualize the usage with mprof plot.
 """"""
 
"
memory_profiler.py,memory_profiler.py,aab15edbc9f45968f1faf54a92a539b7a8a946bb,bdf9995643ae14606e0fbeb1d82b9e5f94c9b48b,merge mpmprof into mprof,"@@ -240,8 +240,8 @@ class MemTimer(Process):
 
 
 def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
-                 include_children=False, max_usage=False, retval=False,
-                 stream=None, backend=None):
+                 include_children=False, multiprocess=False, max_usage=False,
+                 retval=False, stream=None, backend=None):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -272,6 +272,12 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     timestamps : bool, optional
         if True, timestamps of memory usage measurement are collected as well.
 
+    include_children : bool, optional
+        if True, sum the memory of all forked processes as well
+
+    multiprocess : bool, optional
+        if True, track the memory usage of all forked processes.
+
     stream : File
         if stream is a File opened with write access, then results are written
         to this file instead of stored in memory and returned at the end of
@@ -343,10 +349,18 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 mem_usage = _get_memory(
                     proc.pid, backend, timestamps=timestamps,
                     include_children=include_children)
+
                 if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
+
+                    # Only write children to the stream file, warn if appending to the return.
+                    if multiprocess:
+                        for idx, chldmem in enumerate(_get_child_memory(proc.pid)):
+                            stream.write(""CHLD {0} {1:.6f} {2:.4f}\n"".format(idx, chldmem, time.time()))
                 else:
                     ret.append(mem_usage)
+                    if multiprocess:
+                        warnings.warn(""use include_children not multiprocess without a stream"")
             else:
                 ret = max(ret,
                           _get_memory(
@@ -377,8 +391,16 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                     include_children=include_children)
                 if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
+
+                    # Only write children to the stream file, warn if appending to the return.
+                    if multiprocess:
+                        for idx, chldmem in enumerate(_get_child_memory(proc.pid)):
+                            stream.write(""CHLD {0} {1:.6f} {2:.4f}\n"".format(idx, chldmem, time.time()))
                 else:
                     ret.append(mem_usage)
+
+                    if multiprocess:
+                        warnings.warn(""use include_children not multiprocess without a stream"")
             else:
                 ret = max([ret,
                            _get_memory(proc, backend, include_children=include_children)
"
mpmprof,,aab15edbc9f45968f1faf54a92a539b7a8a946bb,bdf9995643ae14606e0fbeb1d82b9e5f94c9b48b,merge mpmprof into mprof,"@@ -1,310 +0,0 @@
-#!/usr/bin/env python3
-""""""
-Multiprocessing version of memory profiling of Python programs.
-""""""
-
-import os
-import re
-import time
-import glob
-import argparse
-import subprocess
-import memory_profiler as mp
-
-from collections import defaultdict
-
-try:
-    import numpy as np
-    import matplotlib.pyplot as plt
-except ImportError:
-    plt = None
-    np  = None
-
-
-# Command Descriptions and Constants
-DESCRIPTION = ""Multiprocessing memory profiling over time.""
-EPILOG      = ""If there are any bugs or concerns, submit an issue on Github""
-VERSION     = ""mpmprof v{}"".format(mp.__version__)
-FILETIME    = ""%Y%m%d%H%M%S""
-BLANKS      = set(' \t')
-
-
-def run_action(args):
-    """"""
-    Run the given program and profile its memory usage.
-    """"""
-
-    # Determine where to write the output to
-    if args.output is None:
-        args.output = ""mprofile_{}.dat"".format(
-            time.strftime(FILETIME, time.localtime())
-        )
-
-    # Determine if the command is a Python command
-    if args.command[0].endswith('.py') and not args.nopython:
-        args.python = True
-
-    # Run the executable with the extra features
-    if args.python:
-        print(""running as a Python program ..."")
-        if not args.command[0].startswith('python'):
-            args.command.insert(0, 'python')
-
-    # Inform the user we're sampling
-    print(""mpmprof: Sampling memory every {} seconds"".format(args.interval))
-
-    # Put the command back together from the argument parsing
-    command = "" "".join([
-        c if BLANKS.isdisjoint(c) else ""'{}'"".format(c) for c in args.command
-    ])
-
-    # Open a subprocess to the given command
-    proc = subprocess.Popen(args.command)
-
-    # This is where a call to mp.memory_usage should go.
-    # Instead we're adding the custom code for sampling spawned memory
-    with open(args.output, ""a"") as f:
-
-        # Write the command to the data file
-        f.write(""CMDLINE {}\n"".format(command))
-
-        # Continue sampling until the subprocess is over, counting lines
-        lines = 0
-        while True:
-            # Determine if the subprocess is still running
-            if proc.poll() is not None: break
-
-            # Collect memory usage of master program and write to profile
-            mem = mp._get_memory(proc.pid)
-            f.write(""MEM {0:.6f} {1:.4f}\n"".format(mem, time.time()))
-            lines += 1
-
-            # Collect memory usage of spawned children and write to profile
-            for idx, mem in enumerate(mp._get_child_memory(proc.pid)):
-                f.write(""CHLD{0} {1:.6f} {2:.4f}\n"".format(idx, mem, time.time()))
-                lines += 1
-
-            # Flush every 50 lines
-            if lines > 50:
-                lines = 0
-                f.flush()
-
-            # Sleep for the given interval
-            time.sleep(args.interval)
-
-    # Return the results of the run action
-    return ""memory profile written to {}"".format(args.output)
-
-
-def plot_action(args):
-    """"""
-    Use matplotlib to draw the memory usage of a mprofile .dat file.
-    """"""
-    if plt is None:
-        raise ImportError(
-            ""matplotlib is needed for plotting.""
-        )
-
-    def read_mprofile_file(path):
-        """"""
-        Reads the specialized version of the mprofile for multiprocessing
-        """"""
-        # Regular expression line parsers for parsing data
-        cmdre = re.compile(r""^CMDLINE\s+(.+)$"")
-        memre = re.compile(r""^MEM\s+([\d\.e]+)\s+([\d\.e]+)$"")
-        cldre = re.compile(r""^CHLD(\d+)\s+([\d\.e]+)\s+([\d\.e]+)$"")
-
-        # Data structure returned is a series of names (mem, ts) tuples.
-        series  = defaultdict(list)
-        command = None
-
-        with open(path, 'r') as f:
-            for line in f:
-
-                # Match children memory usage lines
-                match = cldre.match(line)
-                if match:
-                    idx, mem, ts = match.groups()
-                    series[""child "" + idx].append((float(mem), float(ts)))
-                    continue
-
-                # Match main process memory usage lines
-                match = memre.match(line)
-                if match:
-                    series['main'].append(tuple(map(float, match.groups())))
-                    continue
-
-                # Match command line(s)
-                # NOTE: mprofile files are openeded for appending, could be multiple
-                match = cmdre.match(line)
-                if match:
-                    command = match.groups()[0]
-
-        return command, series
-
-
-    def plot_mprofile_file(path, title=None):
-        """"""
-        Plots an mprofile file that contains specialized child process data.
-        """"""
-        # Parse the mprofile file to get the data
-        command, series = read_mprofile_file(path)
-        title = title or command
-
-        # Create and configure the figure
-        fig = plt.figure(figsize=(14, 6), dpi=90)
-        axe = fig.add_axes([0.1, 0.1, 0.6, 0.75])
-        axe.set_xlabel(""time (in seconds)"")
-        axe.set_ylabel(""memory used (in MiB)"")
-        axe.set_title(title)
-
-        # Find the start timestamp for the process and track the maximal memory point
-        # This currently assumes that the series were written in order
-        start  = series['main'][0][1]
-        mpoint = (0, 0)
-
-        # Plot all of the series, the main process and the child.
-        for proc, data in series.items():
-            # Create the numpy arrays from the series data
-            ts  = np.asarray([item[1] for item in data]) - start
-            mem = np.asarray([item[0] for item in data])
-
-            # Plot the line to the figure
-            plt.plot(ts, mem, ""+-"", label=proc)
-
-            # Detect the maximal memory point
-            max_mem = mem.max()
-            if max_mem > mpoint[1]:
-                mpoint = (mem.argmax(), max_mem)
-
-        # Add the marker lines for the maximal memory usage
-        plt.hlines(mpoint[1], plt.xlim()[0]+0.001, plt.xlim()[1] - 0.001, 'r', '--')
-        plt.vlines(ts[mpoint[0]], plt.ylim()[0]+0.001, plt.ylim()[1] - 0.001, 'r', '--')
-
-        # Add the legend
-        legend = axe.legend(loc='center left', bbox_to_anchor=(1, 0.5))
-        legend.get_frame().set_alpha(0.5)
-        axe.grid()
-
-    # Get the latest profile if no profile files were passed in.
-    if not args.profile:
-
-        # Glob profiles of our format and sort them.
-        profiles = glob.glob(""mprofile_??????????????.dat"")
-        profiles.sort()
-
-        if not profiles:
-            raise ValueError((
-                ""No input file found.\nThis program looks for mprofile_*.dat ""
-                ""files generated by the `mpmprof run` command.""
-            ))
-
-        # Assign the latest profile to visualize
-        args.profile = profiles[0:1]
-
-    # Filter out any files that do not exist
-    args.profile = list(filter(os.path.exists, args.profile))
-    if not args.profile:
-        raise ValueError(""No input files found!"")
-
-    # For each passed in file, create a figure from the mprofile.
-    for path in args.profile:
-        axe = plot_mprofile_file(path, args.title)
-        if args.output:
-            plt.savefig(args.output)
-        else:
-            plt.show()
-
-    return ""{} memory profiles plotted."".format(len(args.profile))
-
-
-if __name__ == '__main__':
-    # Create the argument parser and subparsers for each command
-    parser = argparse.ArgumentParser(description=DESCRIPTION, epilog=EPILOG)
-    subparsers = parser.add_subparsers(title='commands')
-
-    # Add the version command
-    parser.add_argument('-v', '--version', action='version', version=VERSION)
-
-    # Commands defined in an dictionary for easy adding
-    commands = (
-        # Run command definition
-        {
-            'name': 'run',
-            'action': run_action,
-            'help': 'monitor the memory usage of a command',
-            'args': {
-                '--python': {
-                    'default': False,
-                    'action': 'store_true',
-                    'help': 'activates extra features for Python programs',
-                },
-                '--nopython': {
-                    'default': False,
-                    'action': 'store_true',
-                    'help': 'disables extra features for Python programs',
-                },
-                ('-T', '--interval'): {
-                    'type': float,
-                    'default': 0.1,
-                    'metavar': 'S',
-                    'help': 'sampling period (in seconds), defaults to 0.1',
-                },
-                ('-o', '--output'): {
-                    'type': str,
-                    'default': None,
-                    'metavar': 'PATH',
-                    'help': 'location to write the memory profiler output to',
-                },
-                'command': {
-                    'nargs': argparse.REMAINDER,
-                    'help': 'command to run and profile memory usage',
-                }
-            }
-        },
-
-        # Plot command definition
-        {
-            'name': 'plot',
-            'action': plot_action,
-            'help': 'plot the memory usage of a mprofile data file',
-            'args': {
-                ('-t', '--title'): {
-                    'type': str,
-                    'default': None,
-                    'metavar': 'S',
-                    'help': 'set the title of the figure',
-                },
-                ('-o', '--output'): {
-                    'type': str,
-                    'default': None,
-                    'metavar': 'PATH',
-                    'help': 'write the figure as a png to disk'
-                },
-                'profile': {
-                    'nargs': '*',
-                    'help': 'profile to plot, omit to use the latest',
-                }
-            }
-        }
-    )
-
-    # Add the commands and their arguments.
-    for cmd in commands:
-        # Create the command subparser and add the action
-        cmd_parser = subparsers.add_parser(cmd['name'], help=cmd['help'])
-        cmd_parser.set_defaults(func=cmd['action'])
-
-        # Add the arguments
-        for args, kwargs in cmd['args'].items():
-            if isinstance(args, str):
-                args = (args,)
-            cmd_parser.add_argument(*args, **kwargs)
-
-    # Handle input from the command line
-    args = parser.parse_args()            # Parse the arguments
-    # try:
-    msg = args.func(args)             # Call the default function
-    parser.exit(0, msg+""\n"")          # Exit cleanly with message
-    # except Exception as e:
-    #     parser.error(str(e))              # Exit with error
"
mprof,mprof,aab15edbc9f45968f1faf54a92a539b7a8a946bb,bdf9995643ae14606e0fbeb1d82b9e5f94c9b48b,merge mpmprof into mprof,"@@ -9,6 +9,7 @@ import copy
 import time
 import math
 
+from collections import defaultdict
 from optparse import OptionParser, OptionValueError
 
 import memory_profiler as mp
@@ -195,6 +196,9 @@ def run_action():
     parser.add_option(""--include-children"", ""-C"", dest=""include_children"",
                       default=False, action=""store_true"",
                       help=""""""Monitors forked processes as well (sum up all process memory)"""""")
+    parser.add_option(""--multiprocess"", ""-M"", dest=""multiprocess"",
+                      default=False, action=""store_true"",
+                      help=""""""Monitors forked processes creating individual plots for each child"""""")
 
     (options, args) = parser.parse_args()
 
@@ -231,7 +235,8 @@ def run_action():
     with open(mprofile_output, ""a"") as f:
         f.write(""CMDLINE {0}\n"".format(cmd_line))
         mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
-                        include_children=options.include_children, stream=f)
+                        include_children=options.include_children,
+                        multiprocess=options.multiprocess, stream=f)
 
 
 def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
@@ -299,6 +304,7 @@ def read_mprofile_file(filename):
     func_ts = {}
     mem_usage = []
     timestamp = []
+    children  = defaultdict(list)
     cmd_line = None
     f = open(filename, ""r"")
     for l in f:
@@ -319,6 +325,13 @@ def read_mprofile_file(filename):
                        float(mem_start), float(mem_end)])
             func_ts[f_name] = ts
 
+        elif field == ""CHLD"":
+            values = value.split(' ')
+            chldnum = values[0]
+            children[chldnum].append(
+                (float(values[1]), float(values[2]))
+            )
+
         elif field == ""CMDLINE"":
             cmd_line = value
         else:
@@ -327,10 +340,10 @@ def read_mprofile_file(filename):
 
     return {""mem_usage"": mem_usage, ""timestamp"": timestamp,
             ""func_timestamp"": func_ts, 'filename': filename,
-            'cmd_line': cmd_line}
+            'cmd_line': cmd_line, 'children': children}
 
 
-def plot_file(filename, index=0, timestamps=True, options=None):
+def plot_file(filename, index=0, timestamps=True, children=True, options=None):
     try:
         import pylab as pl
     except ImportError:
@@ -351,6 +364,7 @@ def plot_file(filename, index=0, timestamps=True, options=None):
     ts = mprofile['func_timestamp']
     t = mprofile['timestamp']
     mem = mprofile['mem_usage']
+    chld = mprofile['children']
 
     if len(ts) > 0:
         for values in ts.values():
@@ -384,6 +398,17 @@ def plot_file(filename, index=0, timestamps=True, options=None):
     bottom += 0.001
     top -= 0.001
 
+    # plot children, if any
+    if len(chld) > 0 and children:
+        for idx, (proc, data) in enumerate(chld.items()):
+            # Create the numpy arrays from the series data
+            cts  = np.asarray([item[1] for item in data]) - global_start
+            cmem = np.asarray([item[0] for item in data])
+
+            # Plot the line to the figure
+            pl.plot(cts, cmem, ""+-""  + mem_line_colors[idx+1 % len(mem_line_colors)],
+                     label=""child {}"".format(proc))
+
     # plot timestamps, if any
     if len(ts) > 0 and timestamps:
         func_num = 0
"
README.rst,README.rst,f1cee23af020607ff0c76f23db7f902752dd8d6a,aab15edbc9f45968f1faf54a92a539b7a8a946bb,added max child usage marker and update readme,"@@ -107,10 +107,10 @@ decorator function.  Use as follows::
         del b
         return a
 
-If a python script with decorator ``@profile`` is called using ``-m 
+If a python script with decorator ``@profile`` is called using ``-m
 memory_profiler`` in the command line, the ``precision`` parameter is ignored.
 
-Time-based memory usage 
+Time-based memory usage
 ==========================
 Sometimes it is useful to have full memory usage reports as a function of
 time (not line-by-line) of external processes (be it Python scripts or not).
@@ -131,14 +131,14 @@ e.g. `mprof run -h`.
 In the case of a Python script, using the previous command does not
 give you any information on which function is executed at a given
 time. Depending on the case, it can be difficult to identify the part
-of the code that is causing the highest memory usage. 
+of the code that is causing the highest memory usage.
 
 Adding the `profile` decorator to a function and running the Python
-script with 
+script with
 
     mprof run <script>
 
-will record timestamps when entering/leaving the profiled function. Runnning
+will record timestamps when entering/leaving the profiled function. Running
 
     mprof plot
 
@@ -152,9 +152,9 @@ A discussion of these capabilities can be found `here <http://fa.bianp.net/blog/
 
 .. warning:: If your Python file imports the memory profiler `from memory_profiler import profile` these timestamps will not be recorded. Comment out the import, leave your functions decorated, and re-run.
 
-The available commands for `mprof` are: 
+The available commands for `mprof` are:
 
-  - ``mprof run``: running an executable, recording memory usage  
+  - ``mprof run``: running an executable, recording memory usage
   - ``mprof plot``: plotting one the recorded memory usage (by default,
     the last one)
   - ``mprof list``: listing all recorded memory usage files in a
@@ -162,6 +162,39 @@ The available commands for `mprof` are:
   - ``mprof clean``: removing all recorded memory usage files.
   - ``mprof rm``: removing specific recorded memory usage files
 
+Tracking forked child processes
+===============================
+In a multiprocessing context the main process will spawn child processes whose
+system resources are allocated separately from the parent process. This can
+lead to an inaccurate report of memory usage since by default only the parent
+process is being tracked. The ``mprof`` utility provides two mechanisms to
+track the usage of child processes: sum the memory of all children to the
+parent's usage and track each child individual.
+
+To create a report that combines memory usage of all the children and the
+parent, use the ``include_children`` flag in either the ``profile`` decorator or
+ass a command line argument to ``mprof``::
+
+    mprof run --include-children <script>
+
+The second method tracks each child independently of the main process,
+serializing child rows by index to the output stream. Use the ``multiprocess``
+flag and plot as follows::
+
+    mprof run --multiprocess <script>
+    mprof plot
+
+This will create a plot using matplotlib similar to this:
+
+.. image:: https://cloud.githubusercontent.com/assets/745966/24075879/2e85b43a-0bfa-11e7-8dfe-654320dbd2ce.png
+    : target: https://github.com/fabianp/memory_profiler/pull/134
+    : height: 350px
+
+You can combine both the ``include_children`` and ``multiprocess`` flags to show
+the total memory of the program as well as each child individually.
+
+.. warning:: currently the child tracking only works if a ``stream`` is provided to the ``profile`` (e.g. from the command line or in the decorator).
+
 Setting debugger breakpoints
 =============================
 It is possible to set breakpoints depending on the amount of memory used.
@@ -260,7 +293,7 @@ LogFile of memory profiler module.
     >>> import sys
     >>> sys.stdout = LogFile('memory_profile_log')
 
-``Customised reporting:``
+``Customized reporting:``
 
 Sending everything to the log file while running the memory_profiler
 could be cumbersome and one can choose only entries with increments
@@ -412,6 +445,8 @@ cleanup.
 
 `Dmitriy Novozhilov <https://github.com/demiurg906>`_ and `Sergei Lebedev <https://github.com/superbobry>`_ added support for `tracemalloc <https://docs.python.org/3/library/tracemalloc.html>`_.
 
+`Benjamin Bengfort <https://github.com/bbengfort>`_ added support for tracking the usage of individual child processes and plotting them.
+
 =========
  License
 =========
"
mprof,mprof,f1cee23af020607ff0c76f23db7f902752dd8d6a,aab15edbc9f45968f1faf54a92a539b7a8a946bb,added max child usage marker and update readme,"@@ -400,6 +400,8 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
 
     # plot children, if any
     if len(chld) > 0 and children:
+        cmpoint = (0,0) # maximal child memory
+
         for idx, (proc, data) in enumerate(chld.items()):
             # Create the numpy arrays from the series data
             cts  = np.asarray([item[1] for item in data]) - global_start
@@ -409,6 +411,15 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
             pl.plot(cts, cmem, ""+-""  + mem_line_colors[idx+1 % len(mem_line_colors)],
                      label=""child {}"".format(proc))
 
+            # Detect the maximal child memory point
+            cmax_mem = cmem.max()
+            if cmax_mem > cmpoint[1]:
+                cmpoint = (cts[cmem.argmax()], cmax_mem)
+
+        # Add the marker lines for the maximal child memory usage
+        pl.vlines(cmpoint[0], pl.ylim()[0]+0.001, pl.ylim()[1] - 0.001, 'r', '--')
+        pl.hlines(cmpoint[1], pl.xlim()[0]+0.001, pl.xlim()[1] - 0.001, 'r', '--')
+
     # plot timestamps, if any
     if len(ts) > 0 and timestamps:
         func_num = 0
"
README.rst,README.rst,099c5c88f1731e971094d7a0da6b02103ab8e479,f1cee23af020607ff0c76f23db7f902752dd8d6a,fixed image,"@@ -187,13 +187,13 @@ flag and plot as follows::
 This will create a plot using matplotlib similar to this:
 
 .. image:: https://cloud.githubusercontent.com/assets/745966/24075879/2e85b43a-0bfa-11e7-8dfe-654320dbd2ce.png
-    : target: https://github.com/fabianp/memory_profiler/pull/134
-    : height: 350px
+    :target: https://github.com/fabianp/memory_profiler/pull/134
+    :height: 350px
 
 You can combine both the ``include_children`` and ``multiprocess`` flags to show
 the total memory of the program as well as each child individually.
 
-.. warning:: currently the child tracking only works if a ``stream`` is provided to the ``profile`` (e.g. from the command line or in the decorator).
+.. warning:: Currently the child tracking only works if a ``stream`` is provided to the ``profile`` (e.g. from the command line or in the decorator). If you are using the API to retrieve values then the flag will not do anything.
 
 Setting debugger breakpoints
 =============================
"
README.rst,README.rst,9c62f0a99ecd9b63547ad37fcae2583fa6874b07,099c5c88f1731e971094d7a0da6b02103ab8e479,return child as nested list from memory_usage,"@@ -191,9 +191,9 @@ This will create a plot using matplotlib similar to this:
     :height: 350px
 
 You can combine both the ``include_children`` and ``multiprocess`` flags to show
-the total memory of the program as well as each child individually.
-
-.. warning:: Currently the child tracking only works if a ``stream`` is provided to the ``profile`` (e.g. from the command line or in the decorator). If you are using the API to retrieve values then the flag will not do anything.
+the total memory of the program as well as each child individually. If using
+the API directly, note that the return from ``memory_usage`` will include the
+child memory along with an index identifying the specific child.
 
 Setting debugger breakpoints
 =============================
"
memory_profiler.py,memory_profiler.py,9c62f0a99ecd9b63547ad37fcae2583fa6874b07,099c5c88f1731e971094d7a0da6b02103ab8e479,return child as nested list from memory_usage,"@@ -353,14 +353,19 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
 
-                    # Only write children to the stream file, warn if appending to the return.
+                    # Write children to the stream file
                     if multiprocess:
                         for idx, chldmem in enumerate(_get_child_memory(proc.pid)):
                             stream.write(""CHLD {0} {1:.6f} {2:.4f}\n"".format(idx, chldmem, time.time()))
                 else:
-                    ret.append(mem_usage)
+                    # Create a nested list with the child memory
                     if multiprocess:
-                        warnings.warn(""use include_children not multiprocess without a stream"")
+                        mem_usage = [mem_usage]
+                        for chldmem in _get_child_memory(proc.pid):
+                            mem_usage.append(chldmem)
+
+                    # Append the memory usage to the return value
+                    ret.append(mem_usage)
             else:
                 ret = max(ret,
                           _get_memory(
@@ -392,15 +397,19 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 if stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
 
-                    # Only write children to the stream file, warn if appending to the return.
+                    # Write children to the stream file
                     if multiprocess:
                         for idx, chldmem in enumerate(_get_child_memory(proc.pid)):
                             stream.write(""CHLD {0} {1:.6f} {2:.4f}\n"".format(idx, chldmem, time.time()))
                 else:
-                    ret.append(mem_usage)
-
+                    # Create a nested list with the child memory
                     if multiprocess:
-                        warnings.warn(""use include_children not multiprocess without a stream"")
+                        mem_usage = [mem_usage]
+                        for chldmem in _get_child_memory(proc.pid):
+                            mem_usage.append(chldmem)
+
+                    # Append the memory usage to the return value
+                    ret.append(mem_usage)
             else:
                 ret = max([ret,
                            _get_memory(proc, backend, include_children=include_children)
"
README.rst,README.rst,d333fdac11e2ca17179d602e94de81ab7d6dfca7,9c62f0a99ecd9b63547ad37fcae2583fa6874b07,minor update to readme,"@@ -193,7 +193,7 @@ This will create a plot using matplotlib similar to this:
 You can combine both the ``include_children`` and ``multiprocess`` flags to show
 the total memory of the program as well as each child individually. If using
 the API directly, note that the return from ``memory_usage`` will include the
-child memory along with an index identifying the specific child.
+child memory in a nested list along with the main process memory.
 
 Setting debugger breakpoints
 =============================
"
examples/multiprocessing_example.py,examples/multiprocessing_example.py,52c5788f7e47c748a3c9db15d16a763442c34fe1,d333fdac11e2ca17179d602e94de81ab7d6dfca7,launch multiprocessing programs without in python mode,"@@ -2,7 +2,7 @@
 An undecorated example of a script that allocates memory in multiprocessing
 workers to demonstrate the use of memory_profiler with multiple processes.
 
-Run this script with mprof run -M python multiprocessing_example.py
+Run this script with mprof run -M multiprocessing_example.py
 You can then visualize the usage with mprof plot.
 """"""
 
"
mprof,mprof,52c5788f7e47c748a3c9db15d16a763442c34fe1,d333fdac11e2ca17179d602e94de81ab7d6dfca7,launch multiprocessing programs without in python mode,"@@ -219,7 +219,15 @@ def run_action():
 
     # .. TODO: more than one script as argument ? ..
     if args[0].endswith('.py') and not options.nopython:
-        options.python = True
+        if options.multiprocess and not args[0].startswith(""python""):
+            # in multiprocessing mode you want to spawn a separate
+            # python process
+            args.insert(0, ""python"")
+        else:
+            options.python = True
+    if options.multiprocess:
+        # multiprocess can't work in python mode
+        options.python = False
     if options.python:
         print(""running as a Python program..."")
         if not args[0].startswith(""python""):
"
mprof,mprof,4ea1d2b08b7c9772ee133df6ae8d607fc0b87c52,52c5788f7e47c748a3c9db15d16a763442c34fe1,cleanup redundant code,"@@ -223,11 +223,7 @@ def run_action():
             # in multiprocessing mode you want to spawn a separate
             # python process
             args.insert(0, ""python"")
-        else:
-            options.python = True
-    if options.multiprocess:
-        # multiprocess can't work in python mode
-        options.python = False
+            options.python = False
     if options.python:
         print(""running as a Python program..."")
         if not args[0].startswith(""python""):
"
memory_profiler.py,memory_profiler.py,8a81c2218e96235527feb2cc733867d31f1d7c1e,4ea1d2b08b7c9772ee133df6ae8d607fc0b87c52,new release,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.43'
+__version__ = '0.44'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
mprof,mprof,fe430ffdfab6f755eebd5b386f9628e4a3c78618,8a81c2218e96235527feb2cc733867d31f1d7c1e,FIX: run without the python keyword,"@@ -219,10 +219,11 @@ def run_action():
 
     # .. TODO: more than one script as argument ? ..
     if args[0].endswith('.py') and not options.nopython:
-        if options.multiprocess and not args[0].startswith(""python""):
+        if not args[0].startswith(""python""):
+            args.insert(0, ""python"")
+        if options.multiprocess:
             # in multiprocessing mode you want to spawn a separate
             # python process
-            args.insert(0, ""python"")
             options.python = False
     if options.python:
         print(""running as a Python program..."")
"
memory_profiler.py,memory_profiler.py,9f4fc0710405db3a22020e83d855b9c361c8b9fe,fe430ffdfab6f755eebd5b386f9628e4a3c78618,new release,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.44'
+__version__ = '0.45'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
memory_profiler.py,memory_profiler.py,f61af67938809e1cff8eeb313876cc47ab8f4dd4,9f4fc0710405db3a22020e83d855b9c361c8b9fe,make compatible with python 2.6,"@@ -1077,7 +1077,7 @@ def choose_backend(new_backend=None):
         ('tracemalloc', has_tracemalloc),
         ('no_backend', True)
     ]
-    backends_indices = {b[0]: i for i, b in enumerate(all_backends)}
+    backends_indices = dict((b[0], i) for i, b in enumerate(all_backends))
 
     if new_backend is not None:
         all_backends.insert(0, all_backends.pop(backends_indices[new_backend]))
"
test/test_gen.py,test/test_gen.py,f61af67938809e1cff8eeb313876cc47ab8f4dd4,9f4fc0710405db3a22020e83d855b9c361c8b9fe,make compatible with python 2.6,"@@ -10,8 +10,8 @@ def my_func():
 @profile
 def test_comprehension():
     # Dict comprehension
-    d_comp = {str(k*k): [v] * (1<<17)
-              for (v, k) in enumerate(range(99, 111))}
+    d_comp = dict((str(k*k), [v] * (1<<17))
+                  for (v, k) in enumerate(range(99, 111)))
 
     # List comprehension
     l_comp = [[i] * (i<<9) for i in range(99)]
@@ -20,7 +20,7 @@ def test_comprehension():
 
     def hh(x=1):
         # Set comprehension
-        s_comp = {('Z',) * (k<<13) for k in range(x, 19 + 2*x)}
+        s_comp = set(('Z',) * (k<<13) for k in range(x, 19 + 2*x))
         return s_comp
 
     val = [range(1, 4), max(1, 4), 42 + len(hh())]
"
Makefile,Makefile,cd0f00d3de5896f701cba7e56115719f7b3b6a56,f61af67938809e1cff8eeb313876cc47ab8f4dd4,test_ipython does not exist,"@@ -1,5 +1,4 @@
 PYTHON ?= python
-IPYTHON ?= ipython
 
 .PHONY: test
 
@@ -15,5 +14,3 @@ test:
 	$(PYTHON) test/test_import.py
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
-	$(IPYTHON) test/test_ipython.py
-
"
mprof,mprof,dd33068184dedebc58fcf8f9f19230d9a66f8acf,ddc8f9c7da01b62ce365dc155e295006fb060765,"Fix idx out of range

Mod operator precedes add","@@ -413,7 +413,7 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
             cmem = np.asarray([item[0] for item in data])
 
             # Plot the line to the figure
-            pl.plot(cts, cmem, ""+-""  + mem_line_colors[idx+1 % len(mem_line_colors)],
+            pl.plot(cts, cmem, ""+-""  + mem_line_colors[(idx+1) % len(mem_line_colors)],
                      label=""child {}"".format(proc))
 
             # Detect the maximal child memory point
"
mprof,mprof,6b7335053d16c4d40b626d4d306704538f1f885b,7675442697233fccc01ec4dc4634d8ffff34ae3f,"mprof: use sys.executable instead of system-wide python

Thanks @acs @superbobry!","@@ -220,7 +220,7 @@ def run_action():
     # .. TODO: more than one script as argument ? ..
     if args[0].endswith('.py') and not options.nopython:
         if not args[0].startswith(""python""):
-            args.insert(0, ""python"")
+            args.insert(0, sys.executable)
         if options.multiprocess:
             # in multiprocessing mode you want to spawn a separate
             # python process
"
memory_profiler.py,memory_profiler.py,4ee712608cb9307d7fc9e5b495d496f991313d7d,6b7335053d16c4d40b626d4d306704538f1f885b,0.46 release,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.45'
+__version__ = '0.46'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
mprof,mprof,f9287016f54209c28a83122e117b9b2a49b530db,4ee712608cb9307d7fc9e5b495d496f991313d7d,mprof: use sys.executable instead of system-wide python (take 2),"@@ -228,7 +228,7 @@ def run_action():
     if options.python:
         print(""running as a Python program..."")
         if not args[0].startswith(""python""):
-            args.insert(0, ""python"")
+            args.insert(0, sys.executable)
         cmd_line = get_cmd_line(args)
         args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
                      ""-o"", mprofile_output)
"
mprof,mprof,962ae2a5a2fb97dcd10d47be072887ce13abbced,f9287016f54209c28a83122e117b9b2a49b530db,Better description for mprof plot,"@@ -460,8 +460,10 @@ def plot_action():
     except ImportError:
         print(""matplotlib is needed for plotting."")
         sys.exit(1)
-
-    parser = OptionParser(version=mp.__version__)
+    desc = """"""Plots using matplotlib the data file `file.dat` generated
+using `mprof run`. If no .dat file is given, it will take the most recent
+such file in the current directory.""""""
+    parser = OptionParser(version=mp.__version__, usage=""mprof plot [options] [file.dat]"", description=desc)
     parser.disable_interspersed_args()
     parser.add_option(""--title"", ""-t"", dest=""title"", default=None,
                       type=""str"", action=""store"",
"
memory_profiler.py,memory_profiler.py,3801038cb6e2725a6193cfad3415c35a7de51e8b,962ae2a5a2fb97dcd10d47be072887ce13abbced,new release 0.47,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.46'
+__version__ = '0.47'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
memory_profiler.py,memory_profiler.py,5005a6244bf29b9bfb1255682d19a98c1f409443,962ae2a5a2fb97dcd10d47be072887ce13abbced,"BF: Capture return value of `choose_backend`

Without this fix, I get `NameError: name '_backend' is not defined` when calling `exec_with_profiler` directly","@@ -1108,7 +1108,7 @@ if PY2:
         execfile(filename, ns, ns)
 else:
     def exec_with_profiler(filename, profiler, backend):
-        choose_backend(backend)
+        _backend = choose_backend(backend)
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
         builtins.__dict__['profile'] = profiler
"
mprof,mprof,46be3704c21c4a9bee0f746094762a1b6948840b,598784833285195ac1a45356aa7ce9705b5219ad,Matplotlib backend option,"@@ -351,8 +351,9 @@ def read_mprofile_file(filename):
 def plot_file(filename, index=0, timestamps=True, children=True, options=None):
     try:
         import pylab as pl
-    except ImportError:
+    except ImportError as e:
         print(""matplotlib is needed for plotting."")
+        print(e)
         sys.exit(1)
     import numpy as np  # pylab requires numpy anyway
     mprofile = read_mprofile_file(filename)
@@ -455,11 +456,6 @@ def plot_action():
             raise OptionValueError(""'%s' option must contain two numbers separated with a comma"" % value)
         setattr(parser.values, option.dest, newvalue)
 
-    try:
-        import pylab as pl
-    except ImportError:
-        print(""matplotlib is needed for plotting."")
-        sys.exit(1)
     desc = """"""Plots using matplotlib the data file `file.dat` generated
 using `mprof run`. If no .dat file is given, it will take the most recent
 such file in the current directory.""""""
@@ -477,8 +473,21 @@ such file in the current directory.""""""
                       type=""str"", action=""callback"",
                       callback=get_comma_separated_args,
                       help=""Plot a time-subset of the data. E.g. to plot between 0 and 20.5 seconds: --window 0,20.5"")
+    parser.add_option(""--backend"", 
+                      help=""Specify the Matplotlib backend to use"")
     (options, args) = parser.parse_args()
 
+    try:
+        if options.backend is not None:
+            import matplotlib
+            matplotlib.use(options.backend)
+
+        import pylab as pl
+    except ImportError as e:
+        print(""matplotlib is needed for plotting."")
+        print(e)
+        sys.exit(1)
+
     profiles = glob.glob(""mprofile_??????????????.dat"")
     profiles.sort()
 
"
memory_profiler.py,memory_profiler.py,5f3906a987db109db9d73767996b89f40ba32619,1eff08e9150429ee07efe475d9d8790b9db02377,https://github.com/fabianp/memory_profiler/issues/152,"@@ -16,6 +16,8 @@ import linecache
 import inspect
 import subprocess
 import logging
+import traceback
+from signal import SIGKILL
 
 
 # TODO: provide alternative when multiprocessing is not available
@@ -239,9 +241,9 @@ class MemTimer(Process):
         self.pipe.send(self.n_measurements)
 
 
-def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
-                 include_children=False, multiprocess=False, max_usage=False,
-                 retval=False, stream=None, backend=None):
+def memory_usage_actual(proc=-1, interval=.1, timeout=None, timestamps=False,
+                        include_children=False, multiprocess=False, max_usage=False,
+                        retval=False, stream=None, backend=None):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -424,6 +426,27 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     return ret
 
 
+def memory_usage(*args, **kwargs):
+    """"""
+    The wrapper function that calls the memory_usage_actual (see above) function!
+
+    When there is an exception in the ""proc"" - the (spawned) monitoring processes don't get killed.
+    Therefore, the whole process hangs indefinitely. Here, we are ensuring that the process gets killed!
+    """"""
+    try:
+        return memory_usage_actual(*args, **kwargs)
+    except Exception:
+        print(traceback.format_exc(), file=sys.stderr)
+        try:  # catch ImportError for psutil
+            import psutil
+            parent = psutil.Process(os.getpid())
+            for child in parent.children(recursive=True):
+                os.kill(child.pid, SIGKILL)
+            os.kill(os.getpid(), SIGKILL)
+        except ImportError:
+            sys.exit()
+
+
 # ..
 # .. utility functions for line-by-line ..
 
"
memory_profiler.py,memory_profiler.py,fde9234d01d4edc124d14bb561ac21049096ee3c,5f3906a987db109db9d73767996b89f40ba32619,Using has_psutil,"@@ -437,13 +437,12 @@ def memory_usage(*args, **kwargs):
         return memory_usage_actual(*args, **kwargs)
     except Exception:
         print(traceback.format_exc(), file=sys.stderr)
-        try:  # catch ImportError for psutil
-            import psutil
+        if has_psutil:
             parent = psutil.Process(os.getpid())
             for child in parent.children(recursive=True):
                 os.kill(child.pid, SIGKILL)
             os.kill(os.getpid(), SIGKILL)
-        except ImportError:
+        else:
             sys.exit()
 
 
"
memory_profiler.py,memory_profiler.py,2cd53678065bf81ab018503f046054d746f9a8a2,fde9234d01d4edc124d14bb561ac21049096ee3c,Python 3 SyntaxError for print,"@@ -1,3 +1,5 @@
+from __future__ import print_function
+
 """"""Profile the memory usage of a Python program""""""
 
 # .. we'll use this to pass it to the child script ..
"
memory_profiler.py,memory_profiler.py,091d314389211dce5191a095443e28b9c3b16c01,2cd53678065bf81ab018503f046054d746f9a8a2,Feedback,"@@ -1,5 +1,3 @@
-from __future__ import print_function
-
 """"""Profile the memory usage of a Python program""""""
 
 # .. we'll use this to pass it to the child script ..
@@ -243,9 +241,9 @@ class MemTimer(Process):
         self.pipe.send(self.n_measurements)
 
 
-def memory_usage_actual(proc=-1, interval=.1, timeout=None, timestamps=False,
-                        include_children=False, multiprocess=False, max_usage=False,
-                        retval=False, stream=None, backend=None):
+def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
+                 include_children=False, multiprocess=False, max_usage=False,
+                 retval=False, stream=None, backend=None):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -335,7 +333,21 @@ def memory_usage_actual(proc=-1, interval=.1, timeout=None, timestamps=False,
                          include_children=include_children)
             p.start()
             parent_conn.recv()  # wait until we start getting memory
-            returned = f(*args, **kw)
+
+            # When there is an exception in the ""proc"" - the (spawned) monitoring processes don't get killed.
+            # Therefore, the whole process hangs indefinitely. Here, we are ensuring that the process gets killed!
+            try:
+                returned = f(*args, **kw)
+            except Exception:
+                sys.stderr.write(traceback.format_exc())
+                if has_psutil:
+                    parent = psutil.Process(os.getpid())
+                    for child in parent.children(recursive=True):
+                        os.kill(child.pid, SIGKILL)
+                    os.kill(os.getpid(), SIGKILL)
+                else:
+                    sys.exit()
+
             parent_conn.send(0)  # finish timing
             ret = parent_conn.recv()
             n_measurements = parent_conn.recv()
@@ -428,26 +440,6 @@ def memory_usage_actual(proc=-1, interval=.1, timeout=None, timestamps=False,
     return ret
 
 
-def memory_usage(*args, **kwargs):
-    """"""
-    The wrapper function that calls the memory_usage_actual (see above) function!
-
-    When there is an exception in the ""proc"" - the (spawned) monitoring processes don't get killed.
-    Therefore, the whole process hangs indefinitely. Here, we are ensuring that the process gets killed!
-    """"""
-    try:
-        return memory_usage_actual(*args, **kwargs)
-    except Exception:
-        print(traceback.format_exc(), file=sys.stderr)
-        if has_psutil:
-            parent = psutil.Process(os.getpid())
-            for child in parent.children(recursive=True):
-                os.kill(child.pid, SIGKILL)
-            os.kill(os.getpid(), SIGKILL)
-        else:
-            sys.exit()
-
-
 # ..
 # .. utility functions for line-by-line ..
 
"
Makefile,Makefile,995980b788860778cea995eb01008fd39240c6de,091d314389211dce5191a095443e28b9c3b16c01,"Test: add non-regression test for handling of exceptions.

Also, make memory_profiler return in case of exception
instead of shutting down the full program.","@@ -14,3 +14,4 @@ test:
 	$(PYTHON) test/test_import.py
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
+	$(PYTHON) test/test_exception.py
"
README.rst,README.rst,995980b788860778cea995eb01008fd39240c6de,091d314389211dce5191a095443e28b9c3b16c01,"Test: add non-regression test for handling of exceptions.

Also, make memory_profiler return in case of exception
instead of shutting down the full program.","@@ -447,6 +447,8 @@ cleanup.
 
 `Benjamin Bengfort <https://github.com/bbengfort>`_ added support for tracking the usage of individual child processes and plotting them.
 
+`Muhammad Haseeb Tariq <https://github.com/mhaseebtariq>`_ fixed issue #152, which made the whole interpreter hang on functions that launched an exception.
+
 =========
  License
 =========
"
memory_profiler.py,memory_profiler.py,995980b788860778cea995eb01008fd39240c6de,091d314389211dce5191a095443e28b9c3b16c01,"Test: add non-regression test for handling of exceptions.

Also, make memory_profiler return in case of exception
instead of shutting down the full program.","@@ -326,6 +326,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             raise ValueError
 
         while True:
+            exit_block = False
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
             p = MemTimer(os.getpid(), interval, child_conn, backend,
                          timestamps=timestamps,
@@ -338,23 +339,21 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             # Therefore, the whole process hangs indefinitely. Here, we are ensuring that the process gets killed!
             try:
                 returned = f(*args, **kw)
+                parent_conn.send(0)  # finish timing
+                ret = parent_conn.recv()
+                n_measurements = parent_conn.recv()
+                if retval:
+                    ret = ret, returned
             except Exception:
-                sys.stderr.write(traceback.format_exc())
                 if has_psutil:
                     parent = psutil.Process(os.getpid())
                     for child in parent.children(recursive=True):
                         os.kill(child.pid, SIGKILL)
-                    os.kill(os.getpid(), SIGKILL)
-                else:
-                    sys.exit()
+                p.join(0)
+                raise
 
-            parent_conn.send(0)  # finish timing
-            ret = parent_conn.recv()
-            n_measurements = parent_conn.recv()
-            if retval:
-                ret = ret, returned
             p.join(5 * interval)
-            if n_measurements > 4 or interval < 1e-6:
+            if exit_block or n_measurements > 4 or interval < 1e-6:
                 break
             interval /= 10.
     elif isinstance(proc, subprocess.Popen):
"
,test/test_exception.py,995980b788860778cea995eb01008fd39240c6de,091d314389211dce5191a095443e28b9c3b16c01,"Test: add non-regression test for handling of exceptions.

Also, make memory_profiler return in case of exception
instead of shutting down the full program.","@@ -0,0 +1,12 @@
+
+# make sure that memory profiler does not hang on exception
+from memory_profiler import memory_usage
+
+def foo():
+    raise NotImplementedError('Error')
+
+try:
+    out = memory_usage((foo, tuple(), {}), timeout=1)
+except NotImplementedError:
+    pass
+print('Success')
"
memory_profiler.py,memory_profiler.py,1432dda4cd9793dd7fbfb984d9d7f0f564805763,f9fe75c67ebd48656fa5a9073d1e9a3e3df603f3,Remove unused variable,"@@ -326,7 +326,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
             raise ValueError
 
         while True:
-            exit_block = False
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
             p = MemTimer(os.getpid(), interval, child_conn, backend,
                          timestamps=timestamps,
@@ -353,7 +352,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 raise
 
             p.join(5 * interval)
-            if exit_block or n_measurements > 4 or interval < 1e-6:
+            if n_measurements > 4 or interval < 1e-6:
                 break
             interval /= 10.
     elif isinstance(proc, subprocess.Popen):
"
memory_profiler.py,memory_profiler.py,456388bdb22da0d9cde2b5c418daf5f4aa2a385e,1432dda4cd9793dd7fbfb984d9d7f0f564805763,correct spelling mistake,"@@ -139,7 +139,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
         # .. cross-platform but but requires psutil ..
         process = psutil.Process(pid)
         try:
-            # avoid useing get_memory_info since it does not exists
+            # avoid using get_memory_info since it does not exists
             # in psutil > 2.0 and accessing it will cause exception.
             meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') \
                 else 'get_memory_info'
"
README.rst,README.rst,176743215545c2384e8a6e29b64a0b1dd21d1543,2b4a86b6d05e29d9b4659d5e23dea33ef73b4a43,Fix typo in readme,"@@ -173,7 +173,7 @@ parent's usage and track each child individual.
 
 To create a report that combines memory usage of all the children and the
 parent, use the ``include_children`` flag in either the ``profile`` decorator or
-ass a command line argument to ``mprof``::
+as a command line argument to ``mprof``::
 
     mprof run --include-children <script>
 
"
README.rst,README.rst,a3c4b58ca3f9a18559f7ef6fea1651c72f06ef1c,e2a97b936de6c4c8473c74cdd800c7271435934e,"WIP: Make psutil required

Now the import does not work, needs fixing.","@@ -7,9 +7,8 @@
 
 This is a python module for monitoring memory consumption of a process
 as well as line-by-line analysis of memory consumption for python
-programs. It is a pure python module and has the `psutil
-<http://pypi.python.org/pypi/psutil>`_ module as optional (but highly
-recommended) dependencies.
+programs. It is a pure python module which depends on the `psutil
+<http://pypi.python.org/pypi/psutil>`_ module.
 
 
 ==============
@@ -385,7 +384,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
       between runs.
 
     * Q: Does it work under windows ?
-    * A: Yes, but you will need the
+    * A: Yes, thanks to the
       `psutil <http://pypi.python.org/pypi/psutil>`_ module.
 
 
"
memory_profiler.py,memory_profiler.py,a3c4b58ca3f9a18559f7ef6fea1651c72f06ef1c,e2a97b936de6c4c8473c74cdd800c7271435934e,"WIP: Make psutil required

Now the import does not work, needs fixing.","@@ -19,6 +19,8 @@ import logging
 import traceback
 from signal import SIGKILL
 
+import psutil
+
 
 # TODO: provide alternative when multiprocessing is not available
 try:
@@ -48,13 +50,6 @@ else:
         return str(x)
 
 # .. get available packages ..
-try:
-    import psutil
-
-    has_psutil = True
-except ImportError:
-    has_psutil = False
-
 try:
     import tracemalloc
 
@@ -92,12 +87,6 @@ def _get_child_memory(process, meminfo_attr=None):
     """"""
     Returns a generator that yields memory for all child processes.
     """"""
-    if not has_psutil:
-        raise NotImplementedError((
-            ""The psutil module is required to monitor the ""
-            ""memory usage of child processes.""
-        ))
-
     # Convert a pid to a process
     if isinstance(process, int):
         if process == -1: process = os.getpid()
@@ -344,10 +333,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 if retval:
                     ret = ret, returned
             except Exception:
-                if has_psutil:
-                    parent = psutil.Process(os.getpid())
-                    for child in parent.children(recursive=True):
-                        os.kill(child.pid, SIGKILL)
+                parent = psutil.Process(os.getpid())
+                for child in parent.children(recursive=True):
+                    os.kill(child.pid, SIGKILL)
                 p.join(0)
                 raise
 
@@ -1086,10 +1074,9 @@ def choose_backend(new_backend=None):
 
     _backend = 'no_backend'
     all_backends = [
-        ('psutil', has_psutil),
+        ('psutil', True),
         ('posix', os.name == 'posix'),
         ('tracemalloc', has_tracemalloc),
-        ('no_backend', True)
     ]
     backends_indices = dict((b[0], i) for i, b in enumerate(all_backends))
 
@@ -1100,10 +1087,6 @@ def choose_backend(new_backend=None):
         if is_available:
             _backend = n_backend
             break
-    if _backend == 'no_backend':
-        raise NotImplementedError(
-            'Tracemalloc or psutil module is required for non-unix '
-            'platforms')
     if _backend != new_backend and new_backend is not None:
         warnings.warn('{0} can not be used, {1} used instead'.format(
             new_backend, _backend))
"
setup.py,setup.py,a3c4b58ca3f9a18559f7ef6fea1651c72f06ef1c,e2a97b936de6c4c8473c74cdd800c7271435934e,"WIP: Make psutil required

Now the import does not work, needs fixing.","@@ -30,6 +30,7 @@ setup(
     url='http://pypi.python.org/pypi/memory_profiler',
     py_modules=['memory_profiler'],
     scripts=['mprof'],
+    install_requires=['psutil'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='BSD'
 
"
setup.py,setup.py,5abb5b2956b7b1767e41c525aba9c3a1bd4a4257,a3c4b58ca3f9a18559f7ef6fea1651c72f06ef1c,"Single source package version

I admit the approach is complex... But it is the only
reliable way to do it with a single file.","@@ -1,7 +1,27 @@
-import memory_profiler
+import os
+import io
+import re
 from distutils.core import setup
 import setuptools
 
+
+# https://packaging.python.org/guides/single-sourcing-package-version/
+def read(*names, **kwargs):
+    with io.open(
+        os.path.join(os.path.dirname(__file__), *names),
+        encoding=kwargs.get(""encoding"", ""utf8"")
+    ) as fp:
+        return fp.read()
+
+
+def find_version(*file_paths):
+    version_file = read(*file_paths)
+    version_match = re.search(r""^__version__ = ['\""]([^'\""]*)['\""]"",
+                              version_file, re.M)
+    if version_match:
+        return version_match.group(1)
+
+
 CLASSIFIERS = """"""\
 Development Status :: 5 - Production/Stable
 Intended Audience :: Science/Research
@@ -24,7 +44,7 @@ setup(
     name='memory_profiler',
     description='A module for monitoring memory usage of a python program',
     long_description=open('README.rst').read(),
-    version=memory_profiler.__version__,
+    version=find_version(""memory_profiler.py""),
     author='Fabian Pedregosa',
     author_email='f@bianp.net',
     url='http://pypi.python.org/pypi/memory_profiler',
"
memory_profiler.py,memory_profiler.py,bdbaaea6b1f33a788f7727b6e7d1e7f78f9084aa,5abb5b2956b7b1767e41c525aba9c3a1bd4a4257,Bump version,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.47'
+__version__ = '0.48.dev0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
setup.py,setup.py,0c83aff9043fd5addab25b3e3804995adab14c6b,bdbaaea6b1f33a788f7727b6e7d1e7f78f9084aa,Cleanup,"@@ -1,8 +1,7 @@
 import os
 import io
 import re
-from distutils.core import setup
-import setuptools
+from setuptools import setup
 
 
 # https://packaging.python.org/guides/single-sourcing-package-version/
@@ -53,5 +52,4 @@ setup(
     install_requires=['psutil'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='BSD'
-
 )
"
.travis.yml,.travis.yml,4fb941e880357adb6e7778e5c12c11bee109c87d,0c83aff9043fd5addab25b3e3804995adab14c6b,Use Travis container infrastructure,"@@ -3,7 +3,6 @@ python:
   - ""2.7""
   - ""3.3""
 install:
-  - sudo apt-get update
   # We do this conditionally because it saves us some downloading if the
   # version is the same.
   - if [[ ""$TRAVIS_PYTHON_VERSION"" == ""2.7"" ]]; then
@@ -24,4 +23,6 @@ install:
   - source activate test-environment
   - python setup.py install
 script:
-  - make test
\ No newline at end of file
+  - make test
+
+sudo: false
"
,delta_memory_test.py,947a25a4a73f34c7b798d6f850a6f6d81679e213,15a7e1270595185e7c7732230faaea8527a9be19,memory calculation with deltas,"@@ -0,0 +1,27 @@
+from memory_profiler import profile
+
+
+def gen(count):
+    r = list(range(0,count))
+    return r
+
+_global_var = []
+def _gen_cache():
+    global _global_var
+    if not _global_var:
+        _global_var = gen(1000000)
+
+@profile(precision=4)
+def test():
+    a = gen(90000)
+    for i in range(0,3):
+        b = i
+        def _inner_gen():
+            gen(1024*1024*20)
+        h = i
+        _gen_cache()
+        _inner_gen()
+        g = i
+
+if __name__ == ""__main__"":
+    test()
"
memory_profiler.py,memory_profiler.py,947a25a4a73f34c7b798d6f850a6f6d81679e213,15a7e1270595185e7c7732230faaea8527a9be19,memory calculation with deltas,"@@ -581,12 +581,18 @@ class CodeMap(dict):
         for subcode in filter(inspect.iscode, code.co_consts):
             self.add(subcode, toplevel_code=toplevel_code)
 
-    def trace(self, code, lineno):
+    def trace(self, code, lineno, prev_lineno):
         memory = _get_memory(-1, self.backend, include_children=self.include_children,
                              filename=code.co_filename)
-        # if there is already a measurement for that line get the max
-        previous_memory = self[code].get(lineno, 0)
-        self[code][lineno] = max(memory, previous_memory)
+        prev_value = self[code].get(lineno, None)
+        previous_memory = prev_value[1] if prev_value else 0
+        previous_inc = prev_value[0] if prev_value else 0
+
+        prev_line_value = self[code].get(prev_lineno, None) if prev_lineno else None
+        prev_line_memory = prev_line_value[1] if prev_line_value else 0
+        #inc = (memory-prev_line_memory)
+        #print('trace lineno=%(lineno)s prev_lineno=%(prev_lineno)s mem=%(memory)s prev_inc=%(previous_inc)s inc=%(inc)s' % locals())
+        self[code][lineno] = (previous_inc + (memory-prev_line_memory), max(memory, previous_memory))
 
     def items(self):
         """"""Iterate on the toplevel code blocks.""""""
@@ -610,6 +616,7 @@ class LineProfiler(object):
         self.max_mem = kw.get('max_mem', None)
         self.prevlines = []
         self.backend = choose_backend(kw.get('backend', None))
+        self.prev_lineno = None
 
     def __call__(self, func=None, precision=1):
         if func is not None:
@@ -684,10 +691,15 @@ class LineProfiler(object):
                 # ""call"" event just saves the lineno but not the memory
                 self.prevlines.append(frame.f_lineno)
             elif event == 'line':
-                self.code_map.trace(frame.f_code, self.prevlines[-1])
+                # trace needs current line and previous line
+                self.code_map.trace(frame.f_code, self.prevlines[-1], self.prev_lineno)
+                # saving previous line
+                self.prev_lineno = self.prevlines[-1]
                 self.prevlines[-1] = frame.f_lineno
             elif event == 'return':
-                self.code_map.trace(frame.f_code, self.prevlines.pop())
+                lineno = self.prevlines.pop()
+                self.code_map.trace(frame.f_code, lineno, self.prev_lineno)
+                self.prev_lineno = lineno
 
         if self._original_trace_function is not None:
             self._original_trace_function(frame, event, arg)
@@ -748,20 +760,20 @@ def show_results(prof, stream=None, precision=1):
         stream.write(u'=' * len(header) + '\n')
 
         all_lines = linecache.getlines(filename)
-        mem_old = None
+
         float_format = u'{0}.{1}f'.format(precision + 4, precision)
         template_mem = u'{0:' + float_format + '} MiB'
         for (lineno, mem) in lines:
             if mem:
-                inc = (mem - mem_old) if mem_old else 0
-                mem_old = mem
+                inc = mem[0]
+                mem = mem[1]
                 mem = template_mem.format(mem)
                 inc = template_mem.format(inc)
             else:
                 mem = u''
                 inc = u''
             tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
-            stream.write(unicode(tmp, 'UTF-8'))
+            stream.write(unicode(tmp))
         stream.write(u'\n\n')
 
 
"
memory_profiler.py,memory_profiler.py,e0668c59205f77d1879a39c7e87f11771eab9374,947a25a4a73f34c7b798d6f850a6f6d81679e213,Restore encoding,"@@ -773,7 +773,7 @@ def show_results(prof, stream=None, precision=1):
                 mem = u''
                 inc = u''
             tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
-            stream.write(unicode(tmp))
+            stream.write(unicode(tmp, 'UTF-8'))
         stream.write(u'\n\n')
 
 
"
.travis.yml,.travis.yml,4c993784e66170f9508ca74a4179c96971fcecfb,6617d0e93830ed3082d8cd0ba59382f9fbe1cb88,Use pip instead of conda,"@@ -2,26 +2,10 @@ language: python
 python:
   - ""2.7""
   - ""3.3""
-install:
-  # We do this conditionally because it saves us some downloading if the
-  # version is the same.
-  - if [[ ""$TRAVIS_PYTHON_VERSION"" == ""2.7"" ]]; then
-      wget https://repo.continuum.io/miniconda/Miniconda-latest-Linux-x86_64.sh -O miniconda.sh;
-    else
-      wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh -O miniconda.sh;
-    fi
-  - bash miniconda.sh -b -p $HOME/miniconda
-  - export PATH=""$HOME/miniconda/bin:$PATH""
-  - hash -r
-  - conda config --set always_yes yes --set changeps1 no
-  - conda update -q conda
-  # Useful for debugging any issues with conda
-  - conda info -a
 
-  # Replace dep1 dep2 ... with your dependencies
-  - conda create -q -n test-environment python=$TRAVIS_PYTHON_VERSION numpy nose ipython
-  - source activate test-environment
-  - python setup.py install
+install:
+  - python -m pip install numpy ipython
+  - python -m pip install .
 script:
   - make test
 
"
.travis.yml,.travis.yml,7eba9ed305c69370d08a31f368280eb700f0d30a,4c993784e66170f9508ca74a4179c96971fcecfb,Test more Python versions,"@@ -2,6 +2,9 @@ language: python
 python:
   - ""2.7""
   - ""3.3""
+  - ""3.4""
+  - ""3.5""
+  - ""3.6""
 
 install:
   - python -m pip install numpy ipython
"
.travis.yml,.travis.yml,8adbf1694aef9408b898e11851f130f5d3d6dac4,7eba9ed305c69370d08a31f368280eb700f0d30a,Optionally test experimental Python versions,"@@ -6,6 +6,11 @@ python:
   - ""3.5""
   - ""3.6""
 
+matrix:
+  allow_failures:
+    - python: ""pypy3""
+    - python: ""3.7-dev""
+
 install:
   - python -m pip install numpy ipython
   - python -m pip install .
"
README.rst,README.rst,29702172bbea29b34e94743d2d44a2f9ba2ef63c,8adbf1694aef9408b898e11851f130f5d3d6dac4,Add yours truly to README,"@@ -448,6 +448,8 @@ cleanup.
 
 `Muhammad Haseeb Tariq <https://github.com/mhaseebtariq>`_ fixed issue #152, which made the whole interpreter hang on functions that launched an exception.
 
+`Juan Luis Cano <https://github.com/Juanlu001>`_ modernized the infrastructure and helped with various things.
+
 =========
  License
 =========
"
.travis.yml,.travis.yml,ea376e5d04e83c508df1206b14b118ccfb1023ff,29702172bbea29b34e94743d2d44a2f9ba2ef63c,Fix optional Python versions in Travis config,"@@ -5,6 +5,8 @@ python:
   - ""3.4""
   - ""3.5""
   - ""3.6""
+  - ""3.7-dev""
+  - ""pypy3""
 
 matrix:
   allow_failures:
"
memory_profiler.py,memory_profiler.py,f36ef23c8c35ae92b5d2dcc796dfa3d5272e02be,67e5fed8a5d2027a215a1e8dbf09d2cd030e8008,replace deprecated optparse with argparse,"@@ -1164,55 +1164,48 @@ class LogFile(object):
 
 
 if __name__ == '__main__':
-    from optparse import OptionParser
+    from argparse import ArgumentParser
 
-    parser = OptionParser(usage=_CMD_USAGE, version=__version__)
-    parser.disable_interspersed_args()
-    parser.add_option(
+    parser = ArgumentParser(usage=_CMD_USAGE)
+    parser.add_argument('--version', action='version', version=__version__)
+    parser.add_argument(
         '--pdb-mmem', dest='max_mem', metavar='MAXMEM',
-        type='float', action='store',
+        type=float, action='store',
         help='step into the debugger when memory exceeds MAXMEM')
-    parser.add_option(
-        '--precision', dest='precision', type='int',
+    parser.add_argument(
+        '--precision', dest='precision', type=int,
         action='store', default=3,
         help='precision of memory output in number of significant digits')
-    parser.add_option('-o', dest='out_filename', type='str',
-                      action='store', default=None,
-                      help='path to a file where results will be written')
-    parser.add_option('--timestamp', dest='timestamp', default=False,
-                      action='store_true',
-                      help='''print timestamp instead of memory measurement for
-                      decorated functions''')
-    parser.add_option('--backend', dest='backend', type='choice',
-                      action='store',
-                      choices=['tracemalloc', 'psutil', 'posix'],
-                      default='psutil',
-                      help='backend using for getting memory info '
-                           '(one of the {tracemalloc, psutil, posix})')
+    parser.add_argument('-o', dest='out_filename', type=str,
+        action='store', default=None,
+        help='path to a file where results will be written')
+    parser.add_argument('--timestamp', dest='timestamp', default=False,
+        action='store_true',
+        help='''print timestamp instead of memory measurement for
+        decorated functions''')
+    parser.add_argument('--backend', dest='backend', type=str, action='store',
+        choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
+        help='backend using for getting memory info '
+             '(one of the {tracemalloc, psutil, posix})')
+    parser.add_argument('script', help='script file run on memory_profiler')
+    args = parser.parse_args()
 
-    if not sys.argv[1:]:
-        parser.print_help()
-        sys.exit(2)
-
-    (options, args) = parser.parse_args()
-    sys.argv[:] = args  # Remove every memory_profiler arguments
-
-    script_filename = _find_script(args[0])
-    _backend = choose_backend(options.backend)
-    if options.timestamp:
+    script_filename = _find_script(args.script)
+    _backend = choose_backend(args.backend)
+    if args.timestamp:
         prof = TimeStamper(_backend)
     else:
-        prof = LineProfiler(max_mem=options.max_mem, backend=_backend)
+        prof = LineProfiler(max_mem=args.max_mem, backend=_backend)
 
     try:
-        exec_with_profiler(script_filename, prof, options.backend)
+        exec_with_profiler(script_filename, prof, args.backend)
     finally:
-        if options.out_filename is not None:
-            out_file = open(options.out_filename, ""a"")
+        if args.out_filename is not None:
+            out_file = open(args.out_filename, ""a"")
         else:
             out_file = sys.stdout
 
-        if options.timestamp:
+        if args.timestamp:
             prof.show_results(stream=out_file)
         else:
-            show_results(prof, precision=options.precision, stream=out_file)
+            show_results(prof, precision=args.precision, stream=out_file)
"
mprof,mprof,f36ef23c8c35ae92b5d2dcc796dfa3d5272e02be,67e5fed8a5d2027a215a1e8dbf09d2cd030e8008,replace deprecated optparse with argparse,"@@ -10,7 +10,7 @@ import time
 import math
 
 from collections import defaultdict
-from optparse import OptionParser, OptionValueError
+from argparse import ArgumentParser, ArgumentError
 
 import memory_profiler as mp
 
@@ -107,14 +107,10 @@ def get_profile_filenames(args):
 
 def list_action():
     """"""Display existing profiles, with indices.""""""
-    parser = OptionParser(version=mp.__version__)
-    parser.disable_interspersed_args()
-
-    (options, args) = parser.parse_args()
-
-    if len(args) > 0:
-        print(""This command takes no argument."")
-        sys.exit(1)
+    parser = ArgumentParser(
+            usage='mprof list\nThis command takes no argument.')
+    parser.add_argument('--version', action='version', version=mp.__version__)
+    args = parser.parse_args()
 
     filenames = get_profile_filenames(""all"")
     for n, filename in enumerate(filenames):
@@ -127,20 +123,21 @@ def list_action():
 
 def rm_action():
     """"""TODO: merge with clean_action (@pgervais)""""""
-    parser = OptionParser(version=mp.__version__)
-    parser.disable_interspersed_args()
-    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
-                      action=""store_true"",
-                      help=""""""Show what will be done, without actually doing it."""""")
+    parser = ArgumentParser(usage='mprof rm [options] numbers_or_filenames')
+    parser.add_argument('--version', action='version', version=mp.__version__)
+    parser.add_argument(""--dry-run"", dest=""dry_run"", default=False,
+                        action=""store_true"",
+                        help=""""""Show what will be done, without actually doing it."""""")
+    parser.add_argument(""numbers_or_filenames"", nargs='*',
+                        help=""""""numbers or filenames removed"""""")
+    args = parser.parse_args()
 
-    (options, args) = parser.parse_args()
-
-    if len(args) == 0:
+    if len(args.numbers_or_filenames) == 0:
         print(""A profile to remove must be provided (number or filename)"")
         sys.exit(1)
 
-    filenames = get_profile_filenames(args)
-    if options.dry_run:
+    filenames = get_profile_filenames(args.numbers_or_filenames)
+    if args.dry_run:
         print(""Files to be removed: "")
         for filename in filenames:
             print(filename)
@@ -151,20 +148,16 @@ def rm_action():
 
 def clean_action():
     """"""Remove every profile file in current directory.""""""
-    parser = OptionParser(version=mp.__version__)
-    parser.disable_interspersed_args()
-    parser.add_option(""--dry-run"", dest=""dry_run"", default=False,
-                      action=""store_true"",
-                      help=""""""Show what will be done, without actually doing it."""""")
-
-    (options, args) = parser.parse_args()
-
-    if len(args) > 0:
-        print(""This command takes no argument."")
-        sys.exit(1)
+    parser = ArgumentParser(
+            usage='mprof clean\nThis command takes no argument.')
+    parser.add_argument('--version', action='version', version=mp.__version__)
+    parser.add_argument(""--dry-run"", dest=""dry_run"", default=False,
+                        action=""store_true"",
+                        help=""""""Show what will be done, without actually doing it."""""")
+    args = parser.parse_args()
 
     filenames = get_profile_filenames(""all"")
-    if options.dry_run:
+    if args.dry_run:
         print(""Files to be removed: "")
         for filename in filenames:
             print(filename)
@@ -182,32 +175,27 @@ def get_cmd_line(args):
 
 def run_action():
     import time, subprocess
-    parser = OptionParser(version=mp.__version__, usage=""mprof run [options]"")
-    parser.disable_interspersed_args()
-    parser.add_option(""--python"", dest=""python"", default=False,
-                      action=""store_true"",
-                      help=""""""Activates extra features when the profiling executable is a Python program (currently: function timestamping.)"""""")
-    parser.add_option(""--nopython"", dest=""nopython"", default=False,
-                      action=""store_true"",
-                      help=""""""Disables extra features when the profiled executable is a Python program (currently: function timestamping.)"""""")
-    parser.add_option(""--interval"", ""-T"", dest=""interval"", default=""0.1"",
-                      type=""float"", action=""store"",
-                      help=""Sampling period (in seconds), defaults to 0.1"")
-    parser.add_option(""--include-children"", ""-C"", dest=""include_children"",
-                      default=False, action=""store_true"",
-                      help=""""""Monitors forked processes as well (sum up all process memory)"""""")
-    parser.add_option(""--multiprocess"", ""-M"", dest=""multiprocess"",
-                      default=False, action=""store_true"",
-                      help=""""""Monitors forked processes creating individual plots for each child"""""")
+    parser = ArgumentParser(usage=""mprof run [options] program"")
+    parser.add_argument('--version', action='version', version=mp.__version__)
+    parser.add_argument(""--python"", dest=""python"", action=""store_true"",
+                        help=""""""Activates extra features when the profiling executable is a Python program (currently: function timestamping.)"""""")
+    parser.add_argument(""--nopython"", dest=""nopython"", action=""store_true"",
+                        help=""""""Disables extra features when the profiled executable is a Python program (currently: function timestamping.)"""""")
+    parser.add_argument(""--interval"", ""-T"", dest=""interval"", default=""0.1"", type=float, action=""store"",
+                        help=""Sampling period (in seconds), defaults to 0.1"")
+    parser.add_argument(""--include-children"", ""-C"", dest=""include_children"", action=""store_true"",
+                        help=""""""Monitors forked processes as well (sum up all process memory)"""""")
+    parser.add_argument(""--multiprocess"", ""-M"", dest=""multiprocess"", action=""store_true"",
+                        help=""""""Monitors forked processes creating individual plots for each child"""""")
+    parser.add_argument(""program"", nargs='*')
+    args = parser.parse_args()
 
-    (options, args) = parser.parse_args()
-
-    if len(args) == 0:
+    if len(args.program) == 0:
         print(""A program to run must be provided. Use -h for help"")
         sys.exit(1)
 
-    print(""{1}: Sampling memory every {0.interval}s"".format(
-        options, osp.basename(sys.argv[0])))
+    print(""{1}: Sampling memory every {0}s"".format(
+        args.interval, osp.basename(sys.argv[0])))
 
     ## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
     ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
@@ -218,30 +206,31 @@ def run_action():
     mprofile_output = ""mprofile_%s.dat"" % suffix
 
     # .. TODO: more than one script as argument ? ..
-    if args[0].endswith('.py') and not options.nopython:
-        if not args[0].startswith(""python""):
-            args.insert(0, sys.executable)
-        if options.multiprocess:
+    program = args.program
+    if program[0].endswith('.py') and not args.nopython:
+        if not program[0].startswith(""python""):
+            program.insert(0, sys.executable)
+        if args.multiprocess:
             # in multiprocessing mode you want to spawn a separate
             # python process
-            options.python = False
-    if options.python:
+            args.python = False
+    if args.python:
         print(""running as a Python program..."")
-        if not args[0].startswith(""python""):
-            args.insert(0, sys.executable)
-        cmd_line = get_cmd_line(args)
-        args[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
-                     ""-o"", mprofile_output)
-        p = subprocess.Popen(args)
+        if not program[0].startswith(""python""):
+            program.insert(0, sys.executable)
+        cmd_line = get_cmd_line(program)
+        program[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
+                        ""-o"", mprofile_output)
+        p = subprocess.Popen(program)
     else:
-        cmd_line = get_cmd_line(args)
-        p = subprocess.Popen(args)
+        cmd_line = get_cmd_line(program)
+        p = subprocess.Popen(program)
 
     with open(mprofile_output, ""a"") as f:
         f.write(""CMDLINE {0}\n"".format(cmd_line))
-        mp.memory_usage(proc=p, interval=options.interval, timestamps=True,
-                        include_children=options.include_children,
-                        multiprocess=options.multiprocess, stream=f)
+        mp.memory_usage(proc=p, interval=args.interval, timestamps=True,
+                        include_children=args.include_children,
+                        multiprocess=args.multiprocess, stream=f)
 
 
 def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
@@ -447,40 +436,39 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
 
 
 def plot_action():
-    def get_comma_separated_args(option, opt, value, parser):
+    def xlim_type(value):
         try:
             newvalue = [float(x) for x in value.split(',')]
         except:
-            raise OptionValueError(""'%s' option must contain two numbers separated with a comma"" % value)
+            raise ArgumentError(""'%s' option must contain two numbers separated with a comma"" % value)
         if len(newvalue) != 2:
-            raise OptionValueError(""'%s' option must contain two numbers separated with a comma"" % value)
-        setattr(parser.values, option.dest, newvalue)
+            raise ArgumentError(""'%s' option must contain two numbers separated with a comma"" % value)
+        return newvalue
 
     desc = """"""Plots using matplotlib the data file `file.dat` generated
 using `mprof run`. If no .dat file is given, it will take the most recent
 such file in the current directory.""""""
-    parser = OptionParser(version=mp.__version__, usage=""mprof plot [options] [file.dat]"", description=desc)
-    parser.disable_interspersed_args()
-    parser.add_option(""--title"", ""-t"", dest=""title"", default=None,
-                      type=""str"", action=""store"",
-                      help=""String shown as plot title"")
-    parser.add_option(""--no-function-ts"", ""-n"", dest=""no_timestamps"",
-                      default=False, action=""store_true"",
-                      help=""Do not display function timestamps on plot."")
-    parser.add_option(""--output"", ""-o"",
-                      help=""Save plot to file instead of displaying it."")
-    parser.add_option(""--window"", ""-w"", dest=""xlim"",
-                      type=""str"", action=""callback"",
-                      callback=get_comma_separated_args,
-                      help=""Plot a time-subset of the data. E.g. to plot between 0 and 20.5 seconds: --window 0,20.5"")
-    parser.add_option(""--backend"", 
+    parser = ArgumentParser(usage=""mprof plot [options] [file.dat]"", description=desc)
+    parser.add_argument('--version', action='version', version=mp.__version__)
+    parser.add_argument(""--title"", ""-t"", dest=""title"", default=None,
+                        type=str, action=""store"",
+                        help=""String shown as plot title"")
+    parser.add_argument(""--no-function-ts"", ""-n"", dest=""no_timestamps"", action=""store_true"",
+                        help=""Do not display function timestamps on plot."")
+    parser.add_argument(""--output"", ""-o"",
+                        help=""Save plot to file instead of displaying it."")
+    parser.add_argument(""--window"", ""-w"", dest=""xlim"", type=xlim_type,
+                        help=""Plot a time-subset of the data. E.g. to plot between 0 and 20.5 seconds: --window 0,20.5"")
+    parser.add_argument(""--backend"", 
                       help=""Specify the Matplotlib backend to use"")
-    (options, args) = parser.parse_args()
+    parser.add_argument(""profiles"", nargs=""*"",
+                        help=""profiles made by mprof run"")
+    args = parser.parse_args()
 
     try:
-        if options.backend is not None:
+        if args.backend is not None:
             import matplotlib
-            matplotlib.use(options.backend)
+            matplotlib.use(args.backend)
 
         import pylab as pl
     except ImportError as e:
@@ -491,7 +479,7 @@ such file in the current directory.""""""
     profiles = glob.glob(""mprofile_??????????????.dat"")
     profiles.sort()
 
-    if len(args) == 0:
+    if len(args.profiles) == 0:
         if len(profiles) == 0:
             print(""No input file found. \nThis program looks for ""
                   ""mprofile_*.dat files, generated by the ""
@@ -501,48 +489,48 @@ such file in the current directory.""""""
         filenames = [profiles[-1]]
     else:
         filenames = []
-        for arg in args:
-            if osp.exists(arg):
-                if not arg in filenames:
-                    filenames.append(arg)
+        for prof in args.profiles:
+            if osp.exists(prof):
+                if not prof in filenames:
+                    filenames.append(prof)
             else:
                 try:
-                    n = int(arg)
+                    n = int(prof)
                     if not profiles[n] in filenames:
                         filenames.append(profiles[n])
                 except ValueError:
-                    print(""Input file not found: "" + arg)
+                    print(""Input file not found: "" + prof)
     if not len(filenames):
         print(""No files found from given input."")
         sys.exit(-1)
 
     fig = pl.figure(figsize=(14, 6), dpi=90)
     ax = fig.add_axes([0.1, 0.1, 0.6, 0.75])
-    if options.xlim is not None:
-        pl.xlim(options.xlim[0], options.xlim[1])
+    if args.xlim is not None:
+        pl.xlim(args.xlim[0], args.xlim[1])
 
-    if len(filenames) > 1 or options.no_timestamps:
+    if len(filenames) > 1 or args.no_timestamps:
         timestamps = False
     else:
         timestamps = True
     for n, filename in enumerate(filenames):
-        mprofile = plot_file(filename, index=n, timestamps=timestamps, options=options)
+        mprofile = plot_file(filename, index=n, timestamps=timestamps, options=args)
     pl.xlabel(""time (in seconds)"")
     pl.ylabel(""memory used (in MiB)"")
 
-    if options.title is None and len(filenames) == 1:
+    if args.title is None and len(filenames) == 1:
         pl.title(mprofile['cmd_line'])
     else:
-        if options.title is not None:
-            pl.title(options.title)
+        if args.title is not None:
+            pl.title(args.title)
 
     # place legend within the plot, make partially transparent in
     # case it obscures part of the lineplot
     leg = ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))
     leg.get_frame().set_alpha(0.5)
     pl.grid()
-    if options.output:
-        pl.savefig(options.output)
+    if args.output:
+        pl.savefig(args.output)
     else:
         pl.show()
 
"
README.rst,README.rst,371fe944f88fc54bbc8f2631dbce7992030f21e1,6ee7a697f1e60d803c818787130d57fe82daf1c0,Update links to new GitHub organization,"@@ -1,5 +1,5 @@
-.. image:: https://travis-ci.org/fabianp/memory_profiler.svg?branch=master
-    :target: https://travis-ci.org/fabianp/memory_profiler
+.. image:: https://travis-ci.org/pythonprofilers/memory_profiler.svg?branch=master
+    :target: https://travis-ci.org/pythonprofilers/memory_profiler
 
 =================
  Memory Profiler
@@ -186,7 +186,7 @@ flag and plot as follows::
 This will create a plot using matplotlib similar to this:
 
 .. image:: https://cloud.githubusercontent.com/assets/745966/24075879/2e85b43a-0bfa-11e7-8dfe-654320dbd2ce.png
-    :target: https://github.com/fabianp/memory_profiler/pull/134
+    :target: https://github.com/pythonprofilers/memory_profiler/pull/134
     :height: 350px
 
 You can combine both the ``include_children`` and ``multiprocess`` flags to show
@@ -395,7 +395,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
 For support, please ask your question on `stack overflow
 <http://stackoverflow.com/>`_ and add the `*memory-profiling* tag <http://stackoverflow.com/questions/tagged/memory-profiling>`_.
 Send issues, proposals, etc. to `github's issue tracker
-<https://github.com/fabianp/memory_profiler/issues>`_ .
+<https://github.com/pythonprofilers/memory_profiler/issues>`_ .
 
 If you've got questions regarding development, you can email me
 directly at fabian@fseoane.net
@@ -408,7 +408,7 @@ directly at fabian@fseoane.net
 =============
 Latest sources are available from github:
 
-    https://github.com/fabianp/memory_profiler
+    https://github.com/pythonprofilers/memory_profiler
 
 ===============================
 Projects using memory_profiler
"
memory_profiler.py,memory_profiler.py,c5d2527d83db18e9fcc78d7ff6a53019072ef43b,371fe944f88fc54bbc8f2631dbce7992030f21e1,"More robust tracking of subprocesses for macOS.

Ignore psutil.AccessDenied when trying to access children - root cause
is discussed in Issue 71.","@@ -104,7 +104,7 @@ def _get_child_memory(process, meminfo_attr=None):
     try:
         for child in getattr(process, children_attr)(recursive=True):
             yield getattr(child, meminfo_attr)()[0] / _TWO_20
-    except psutil.NoSuchProcess:
+    except (psutil.NoSuchProcess, psutil.AccessDenied):
         # https://github.com/fabianp/memory_profiler/issues/71
         yield 0.0
 
"
memory_profiler.py,memory_profiler.py,ba586d1d48b2d78663999c8c0b7dfa992b818152,6988f4974dbf4044df89d76138e8a1b212afa377,Fix SIGKILL not available in Windows,"@@ -17,8 +17,12 @@ import inspect
 import subprocess
 import logging
 import traceback
-from signal import SIGKILL
-
+if sys.platform == ""win32"":
+    # any value except signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT
+    # can be used to kill a process unconditionally in Windows
+    SIGKILL = -1
+else:
+    from signal import SIGKILL
 import psutil
 
 
"
,mprof.bat,a563dd0f4d752aebce7a6637e664a813e46df08c,ba586d1d48b2d78663999c8c0b7dfa992b818152,"Fix mprof command not working in Windows

Adds mprof.bat to python scripts so the mprof command can be executed","@@ -0,0 +1,2 @@
+@echo off
+python %~dpn0 %*
\ No newline at end of file
"
setup.py,setup.py,a563dd0f4d752aebce7a6637e664a813e46df08c,ba586d1d48b2d78663999c8c0b7dfa992b818152,"Fix mprof command not working in Windows

Adds mprof.bat to python scripts so the mprof command can be executed","@@ -1,6 +1,7 @@
 import os
 import io
 import re
+import sys
 from setuptools import setup
 
 
@@ -39,6 +40,10 @@ Operating System :: Unix
 
 """"""
 
+scripts = ['mprof']
+if sys.platform == ""win32"":
+    scripts.append('mprof.bat')
+
 setup(
     name='memory_profiler',
     description='A module for monitoring memory usage of a python program',
@@ -48,7 +53,7 @@ setup(
     author_email='f@bianp.net',
     url='http://pypi.python.org/pypi/memory_profiler',
     py_modules=['memory_profiler'],
-    scripts=['mprof'],
+    scripts=scripts,
     install_requires=['psutil'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='BSD'
"
memory_profiler.py,memory_profiler.py,f030f779e0670198f15a495627991f7f2f0023aa,480ba0d6d8fd85e9c2962f3a44282e9873f2bce1,0.48 release,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.48.dev0'
+__version__ = '0.48.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
test/test_func.py,test/test_func.py,f030f779e0670198f15a495627991f7f2f0023aa,480ba0d6d8fd85e9c2962f3a44282e9873f2bce1,0.48 release,"@@ -8,4 +8,4 @@ def test_1(i):
 
 if __name__ == '__main__':
     test_1(10)
-    test_1(10000)
+    test_1(100)
"
memory_profiler.py,memory_profiler.py,2588edf1a0139427d005ae9bcda93278ba183f5d,f030f779e0670198f15a495627991f7f2f0023aa,start 0.49 development cycle,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.48.0'
+__version__ = '0.49.dev0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
test/test_func.py,test/test_func.py,2e355a6854b444b9ff9deb8a05db00ae56bd9b2a,2588edf1a0139427d005ae9bcda93278ba183f5d,"I inadvertedly changed this in f030f779, reverting","@@ -8,4 +8,4 @@ def test_1(i):
 
 if __name__ == '__main__':
     test_1(10)
-    test_1(100)
+    test_1(10000)
"
MANIFEST.in,MANIFEST.in,7e02ef4ea8a6138297f1c08d26f10dc98cd6f4b5,a563dd0f4d752aebce7a6637e664a813e46df08c,"Add mprof.bat to list of distribution files

This file would be missing when creating the source distribution
from a non-windows computer.","@@ -1,2 +1,3 @@
 include README.rst
 include COPYING
+include mprof.bat
"
memory_profiler.py,memory_profiler.py,73b5a8dc287bb6dff9aae852f70929db920ec96b,2e355a6854b444b9ff9deb8a05db00ae56bd9b2a,0.49 release,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.49.dev0'
+__version__ = '0.49.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
memory_profiler.py,memory_profiler.py,c9fcc8faf3c0c62fb7c8f8051baf0bce73afc6cd,73b5a8dc287bb6dff9aae852f70929db920ec96b,start of 0.50 development cycle,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.49.0'
+__version__ = '0.50.dev0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
memory_profiler.py,memory_profiler.py,8a9b1b7a6781c4bd3dd69433763ca4db1bbf1add,d7da557166473b63774fa68895acb240fb99ca5c,0.50 release,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.50.dev0'
+__version__ = '0.50.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
mprof,mprof,6478e660a908503b963f0e1ae7dca1f7440e43fb,8a9b1b7a6781c4bd3dd69433763ca4db1bbf1add,FIX: solve issue #181,"@@ -208,12 +208,14 @@ def run_action():
     # .. TODO: more than one script as argument ? ..
     program = args.program
     if program[0].endswith('.py') and not args.nopython:
-        if not program[0].startswith(""python""):
-            program.insert(0, sys.executable)
         if args.multiprocess:
             # in multiprocessing mode you want to spawn a separate
             # python process
+            if not program[0].startswith(""python""):
+                program.insert(0, sys.executable)
             args.python = False
+        else:
+            args.python = True
     if args.python:
         print(""running as a Python program..."")
         if not program[0].startswith(""python""):
@@ -221,6 +223,7 @@ def run_action():
         cmd_line = get_cmd_line(program)
         program[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
                         ""-o"", mprofile_output)
+        print(program)
         p = subprocess.Popen(program)
     else:
         cmd_line = get_cmd_line(program)
"
mprof,mprof,901fa682eff42a2ae6e023adcc768f521623f9b5,6478e660a908503b963f0e1ae7dca1f7440e43fb,remove forgotten print statement,"@@ -223,7 +223,6 @@ def run_action():
         cmd_line = get_cmd_line(program)
         program[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
                         ""-o"", mprofile_output)
-        print(program)
         p = subprocess.Popen(program)
     else:
         cmd_line = get_cmd_line(program)
"
README.rst,README.rst,76e271f6f9c73c7580b1e2fabfcb14c661b271d6,901fa682eff42a2ae6e023adcc768f521623f9b5,Fix typo,"@@ -416,7 +416,7 @@ Projects using memory_profiler
 
 `Benchy <https://github.com/python-recsys/benchy>`_
 
-`IPython memory usage <https://github.com/ianozsvald/ipython_memory_usage_>`_
+`IPython memory usage <https://github.com/ianozsvald/ipython_memory_usage>`_
 
 `PySpeedIT <https://github.com/peter1000/PySpeedIT>`_ (uses a reduced version of memory_profiler)
 
"
memory_profiler.py,memory_profiler.py,ca55ac79d581e5988210d6e6087588810a1c1512,51062935126916da3bb36923224dc71182f55f85,"Allow passing args to profiled script or module

Also attempted to clarify usage
Made to address https://github.com/pythonprofilers/memory_profiler/issues/179","@@ -1113,20 +1113,17 @@ def choose_backend(new_backend=None):
 # globally defined (global variables is not enough
 # for all cases, e.g. a script that imports another
 # script where @profile is used)
-if PY2:
-    def exec_with_profiler(filename, profiler, backend):
-        builtins.__dict__['profile'] = profiler
-        ns = dict(_CLEAN_GLOBALS, profile=profiler)
-        choose_backend(backend)
+def exec_with_profiler(filename, profiler, backend, passed_args=[]):
+    from runpy import run_module
+    builtins.__dict__['profile'] = profiler
+    ns = dict(_CLEAN_GLOBALS, profile=profiler)
+    _backend = choose_backend(backend)
+    sys.argv = [filename] + passed_args
+    if PY2:
         execfile(filename, ns, ns)
-else:
-    def exec_with_profiler(filename, profiler, backend):
-        _backend = choose_backend(backend)
+    else:
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
-        builtins.__dict__['profile'] = profiler
-        # shadow the profile decorator defined above
-        ns = dict(_CLEAN_GLOBALS, profile=profiler)
         try:
             with open(filename) as f:
                 exec(compile(f.read(), filename, 'exec'), ns, ns)
@@ -1135,6 +1132,24 @@ else:
                 tracemalloc.stop()
 
 
+def run_module_with_profiler(module, profiler, backend, passed_args=[]):
+    from runpy import run_module
+    builtins.__dict__['profile'] = profiler
+    ns = dict(_CLEAN_GLOBALS, profile=profiler)
+    _backend = choose_backend(backend)
+    sys.argv = [module] + passed_args
+    if PY2:
+        run_module(module, run_name=""__main__"", init_globals=ns)
+    else:
+        if _backend == 'tracemalloc' and has_tracemalloc:
+            tracemalloc.start()
+        try:
+            run_module(module, run_name=""__main__"", init_globals=ns)
+        finally:
+            if has_tracemalloc and tracemalloc.is_tracing():
+                tracemalloc.stop()
+
+
 class LogFile(object):
     """"""File-like object to log text using the `logging` module and the log
     report can be customised.""""""
@@ -1168,7 +1183,7 @@ class LogFile(object):
 
 
 if __name__ == '__main__':
-    from argparse import ArgumentParser
+    from argparse import ArgumentParser, REMAINDER
 
     parser = ArgumentParser(usage=_CMD_USAGE)
     parser.add_argument('--version', action='version', version=__version__)
@@ -1191,10 +1206,16 @@ if __name__ == '__main__':
         choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
         help='backend using for getting memory info '
              '(one of the {tracemalloc, psutil, posix})')
-    parser.add_argument('script', help='script file run on memory_profiler')
+    parser.add_argument(""program"", nargs=REMAINDER,
+        help='python script or module followed by command line arguements to run')
     args = parser.parse_args()
 
-    script_filename = _find_script(args.script)
+    if len(args.program) == 0:
+        print(""A program to run must be provided. Use -h for help"")
+        sys.exit(1)
+
+    target = args.program[0]
+    script_args = args.program[1:]
     _backend = choose_backend(args.backend)
     if args.timestamp:
         prof = TimeStamper(_backend)
@@ -1202,7 +1223,11 @@ if __name__ == '__main__':
         prof = LineProfiler(max_mem=args.max_mem, backend=_backend)
 
     try:
-        exec_with_profiler(script_filename, prof, args.backend)
+        if args.program[0].endswith('.py'):
+            script_filename = _find_script(args.program[0])
+            exec_with_profiler(script_filename, prof, args.backend, script_args)
+        else:
+            run_module_with_profiler(target, prof, args.backend, script_args)
     finally:
         if args.out_filename is not None:
             out_file = open(args.out_filename, ""a"")
"
mprof,mprof,ca55ac79d581e5988210d6e6087588810a1c1512,51062935126916da3bb36923224dc71182f55f85,"Allow passing args to profiled script or module

Also attempted to clarify usage
Made to address https://github.com/pythonprofilers/memory_profiler/issues/179","@@ -10,7 +10,7 @@ import time
 import math
 
 from collections import defaultdict
-from argparse import ArgumentParser, ArgumentError
+from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormatter
 
 import memory_profiler as mp
 
@@ -175,7 +175,7 @@ def get_cmd_line(args):
 
 def run_action():
     import time, subprocess
-    parser = ArgumentParser(usage=""mprof run [options] program"")
+    parser = ArgumentParser(usage=""mprof run [options] program"", formatter_class=RawTextHelpFormatter)
     parser.add_argument('--version', action='version', version=mp.__version__)
     parser.add_argument(""--python"", dest=""python"", action=""store_true"",
                         help=""""""Activates extra features when the profiling executable is a Python program (currently: function timestamping.)"""""")
@@ -186,8 +186,13 @@ def run_action():
     parser.add_argument(""--include-children"", ""-C"", dest=""include_children"", action=""store_true"",
                         help=""""""Monitors forked processes as well (sum up all process memory)"""""")
     parser.add_argument(""--multiprocess"", ""-M"", dest=""multiprocess"", action=""store_true"",
-                        help=""""""Monitors forked processes creating individual plots for each child"""""")
-    parser.add_argument(""program"", nargs='*')
+                        help=""""""Monitors forked processes creating individual plots for each child (disables --python features)"""""")
+    parser.add_argument(""program"", nargs=REMAINDER,
+                        help='Option 1: ""<EXECUTABLE> <ARG1> <ARG2>..."" - profile executable\n'
+                             'Option 2: ""<PYTHON_SCRIPT> <ARG1> <ARG2>..."" - profile python script\n'
+                             'Option 3: (--python flag present) ""<PYTHON_EXECUTABLE> <PYTHON_SCRIPT> <ARG1> <ARG2>..."" - profile python script with specified interpreter\n'
+                             'Option 4: (--python flag present) ""<PYTHON_MODULE> <ARG1> <ARG2>..."" - profile python module\n'
+                        )
     args = parser.parse_args()
 
     if len(args.program) == 0:
"
memory_profiler.py,memory_profiler.py,7b920986cb361d0f852a0a6a6962080daa07ac89,51062935126916da3bb36923224dc71182f55f85,Fix UnicodeDecocdError when profile result writing to filestream,"@@ -46,12 +46,10 @@ _TWO_20 = float(2 ** 20)
 
 if PY2:
     import __builtin__ as builtins
+    to_str = lambda x: x
 else:
     import builtins
-
-
-    def unicode(x, *args):
-        return str(x)
+    to_str = lambda x: str(x)
 
 # .. get available packages ..
 try:
@@ -777,7 +775,7 @@ def show_results(prof, stream=None, precision=1):
                 mem = u''
                 inc = u''
             tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
-            stream.write(unicode(tmp, 'UTF-8'))
+            stream.write(to_str(tmp))
         stream.write(u'\n\n')
 
 
"
,test/test_stream_unicode.py,7b920986cb361d0f852a0a6a6962080daa07ac89,51062935126916da3bb36923224dc71182f55f85,Fix UnicodeDecocdError when profile result writing to filestream,"@@ -0,0 +1,14 @@
+# -*- coding: utf-8  -*-
+
+from memory_profiler import profile
+
+f = open('/dev/null', 'w')
+@profile(stream=f)
+def test_unicode(txt):
+    # test when unicode is present
+    txt = txt.replace (u""ی"", u""ي"") #Arabic Yah = ي
+    return txt
+
+
+if __name__ == '__main__':
+	test_unicode (u""ایست"")
"
mprof,mprof,c23bd1474ebad1174784292c99f00c94070cc549,306acd1cf4a6136bea262939c1c4bc0c0e2af3a1,"Add --ouput option to mprof run

Allow specifying path to output of memory profile","@@ -187,6 +187,10 @@ def run_action():
                         help=""""""Monitors forked processes as well (sum up all process memory)"""""")
     parser.add_argument(""--multiprocess"", ""-M"", dest=""multiprocess"", action=""store_true"",
                         help=""""""Monitors forked processes creating individual plots for each child (disables --python features)"""""")
+    parser.add_argument(""--output"", ""-o"", dest=""filename"",
+                        default=""mprofile_<YYYYMMDDhhmmss>.dat"",
+                        help=""""""File to store results in, defaults to 'mprofile_<YYYYMMDDhhmmss>.dat',
+(where <YYYYMMDDhhmmss> is the date-time of the program start)"""""")
     parser.add_argument(""program"", nargs=REMAINDER,
                         help='Option 1: ""<EXECUTABLE> <ARG1> <ARG2>..."" - profile executable\n'
                              'Option 2: ""<PYTHON_SCRIPT> <ARG1> <ARG2>..."" - profile python script\n'
@@ -202,13 +206,16 @@ def run_action():
     print(""{1}: Sampling memory every {0}s"".format(
         args.interval, osp.basename(sys.argv[0])))
 
-    ## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
-    ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
-    ## directory. This file contains the process memory consumption, in Mb (one
-    ## value per line). Memory is sampled twice each second.""""""
+    if args.filename is None:
+        ## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
+        ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
+        ## directory. This file contains the process memory consumption, in Mb (one
+        ## value per line). Memory is sampled twice each second.""""""
 
-    suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
-    mprofile_output = ""mprofile_%s.dat"" % suffix
+        suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
+        mprofile_output = ""mprofile_%s.dat"" % suffix
+    else:
+        mprofile_output = args.filename
 
     # .. TODO: more than one script as argument ? ..
     program = args.program
"
memory_profiler.py,memory_profiler.py,429e5bbb2470c05077430fec6f155cce46cada05,306acd1cf4a6136bea262939c1c4bc0c0e2af3a1,"Fix typo in PID clause of memory_usage

It looks like the PID multiprocess code was copied from the Popen
clause. `_get_child_memory` called with just `proc`, not `proc.pid`","@@ -405,13 +405,13 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
                     # Write children to the stream file
                     if multiprocess:
-                        for idx, chldmem in enumerate(_get_child_memory(proc.pid)):
+                        for idx, chldmem in enumerate(_get_child_memory(proc)):
                             stream.write(""CHLD {0} {1:.6f} {2:.4f}\n"".format(idx, chldmem, time.time()))
                 else:
                     # Create a nested list with the child memory
                     if multiprocess:
                         mem_usage = [mem_usage]
-                        for chldmem in _get_child_memory(proc.pid):
+                        for chldmem in _get_child_memory(proc):
                             mem_usage.append(chldmem)
 
                     # Append the memory usage to the return value
"
mprof,mprof,3a5a36cfbe49405d40e1b4dfccf73c2218e87b04,ce947e1f88434ac248b82c47eda6607c433fa25a,"Fix default filename

Also move comment on output into option help","@@ -188,9 +188,10 @@ def run_action():
     parser.add_argument(""--multiprocess"", ""-M"", dest=""multiprocess"", action=""store_true"",
                         help=""""""Monitors forked processes creating individual plots for each child (disables --python features)"""""")
     parser.add_argument(""--output"", ""-o"", dest=""filename"",
-                        default=""mprofile_<YYYYMMDDhhmmss>.dat"",
-                        help=""""""File to store results in, defaults to 'mprofile_<YYYYMMDDhhmmss>.dat',
-(where <YYYYMMDDhhmmss> is the date-time of the program start)"""""")
+                        default=""mprofile_%s.dat"" % time.strftime(""%Y%m%d%H%M%S"", time.localtime()),
+                        help=""""""File to store results in, defaults to 'mprofile_<YYYYMMDDhhmmss>.dat' in the current directory,
+(where <YYYYMMDDhhmmss> is the date-time of the program start).
+This file contains the process memory consumption, in Mb (one value per line)."""""")
     parser.add_argument(""program"", nargs=REMAINDER,
                         help='Option 1: ""<EXECUTABLE> <ARG1> <ARG2>..."" - profile executable\n'
                              'Option 2: ""<PYTHON_SCRIPT> <ARG1> <ARG2>..."" - profile python script\n'
@@ -206,16 +207,7 @@ def run_action():
     print(""{1}: Sampling memory every {0}s"".format(
         args.interval, osp.basename(sys.argv[0])))
 
-    if args.filename is None:
-        ## Output results in a file called ""mprofile_<YYYYMMDDhhmmss>.dat"" (where
-        ## <YYYYMMDDhhmmss> is the date-time of the program start) in the current
-        ## directory. This file contains the process memory consumption, in Mb (one
-        ## value per line). Memory is sampled twice each second.""""""
-
-        suffix = time.strftime(""%Y%m%d%H%M%S"", time.localtime())
-        mprofile_output = ""mprofile_%s.dat"" % suffix
-    else:
-        mprofile_output = args.filename
+    mprofile_output = args.filename
 
     # .. TODO: more than one script as argument ? ..
     program = args.program
"
.gitignore,.gitignore,ee2188d4f70bed9cd260e3fc2b542f8695a50058,0b6e2bf0264bb845c65c8e8238760df8876a570d,"Adds wraps decorator to profile, rev roll to 0.53.0","@@ -8,3 +8,6 @@ MANIFEST
 
 # Ignore mprof generated files
 mprofile_*.dat
+
+# virtual environment
+venv/
"
Makefile,Makefile,ee2188d4f70bed9cd260e3fc2b542f8695a50058,0b6e2bf0264bb845c65c8e8238760df8876a570d,"Adds wraps decorator to profile, rev roll to 0.53.0","@@ -15,3 +15,6 @@ test:
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
 	$(PYTHON) test/test_exception.py
+
+develop:
+	pip install -e .
"
memory_profiler.py,memory_profiler.py,ee2188d4f70bed9cd260e3fc2b542f8695a50058,0b6e2bf0264bb845c65c8e8238760df8876a570d,"Adds wraps decorator to profile, rev roll to 0.53.0","@@ -3,20 +3,22 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.50.0'
+__version__ = '0.53.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
-import time
-import sys
+from functools import wraps
+import inspect
+import linecache
+import logging
 import os
 import pdb
-import warnings
-import linecache
-import inspect
 import subprocess
-import logging
+import sys
+import time
 import traceback
+import warnings
+
 if sys.platform == ""win32"":
     # any value except signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT
     # can be used to kill a process unconditionally in Windows
@@ -1067,6 +1069,7 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
         if not tracemalloc.is_tracing():
             tracemalloc.start()
     if func is not None:
+        @wraps(func)
         def wrapper(*args, **kwargs):
             prof = LineProfiler(backend=backend)
             val = prof(func)(*args, **kwargs)
"
Makefile,Makefile,0cecc6900083a9c8bbf0036f47e4ffdd07aa9343,ee2188d4f70bed9cd260e3fc2b542f8695a50058,Adds test of profiled function's name and docstring,"@@ -5,6 +5,7 @@ PYTHON ?= python
 test:
 	$(PYTHON) -m memory_profiler test/test_func.py
 	$(PYTHON) -m memory_profiler test/test_loop.py
+	$(PYTHON) -m memory_profiler test/test_mprofile.py
 	$(PYTHON) -m memory_profiler test/test_as.py
 	$(PYTHON) -m memory_profiler test/test_global.py
 	$(PYTHON) -m memory_profiler test/test_precision_command_line.py
"
test/test_mprofile.py,test/test_mprofile.py,0cecc6900083a9c8bbf0036f47e4ffdd07aa9343,ee2188d4f70bed9cd260e3fc2b542f8695a50058,Adds test of profiled function's name and docstring,"@@ -4,6 +4,7 @@ import time
 
 @profile
 def test1(l):
+    """"""test1 docstring""""""
     a = [1] * l
     time.sleep(1)
     return a
@@ -14,8 +15,22 @@ def test2(l):
     time.sleep(1)
     return b
 
+def test3(l):
+    """"""test3 docstring""""""
+    return l
+
 if __name__ == ""__main__"":
     l = 100000
     test1(l)
     test2(2 * l)
 
+    # make sure that the function name and docstring are set
+    # by functools.wraps
+    # memory_profile.py def profile func is not None case
+    assert (test1.__name__ == 'test1'), 'function name is incorrect'
+    assert (test1.__doc__ == 'test1 docstring'), 'function docstring is incorrect'
+    # memory_profile.py def profile func is None case
+    profile_maker = profile()
+    profiled_test3 = profile_maker(test3)
+    assert (profiled_test3.__name__ == 'test3'), 'function name is incorrect'
+    assert (profiled_test3.__doc__ == 'test3 docstring'), 'function docstring is incorrect'
"
memory_profiler.py,memory_profiler.py,64c8199213012c8b145508f15c2f105d58201a65,95300297e2023f6a3f50f9b016516699a1a95dc9,"Make memory_profiler work with Python 2.7 tracemalloc

The tracemalloc module can be made to work on Python 2.7 with [the project providing patches against the Pyithon 2.7 source code](http://pytracemalloc.readthedocs.io/install.html#manual-installation). These two changes make `memory_profiler.py` work with tracemalloc on Python 2.","@@ -48,6 +48,7 @@ _TWO_20 = float(2 ** 20)
 
 if PY2:
     import __builtin__ as builtins
+    from future_builtins import filter
 else:
     import builtins
 
@@ -1122,11 +1123,11 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     ns = dict(_CLEAN_GLOBALS, profile=profiler)
     _backend = choose_backend(backend)
     sys.argv = [filename] + passed_args
+    if _backend == 'tracemalloc' and has_tracemalloc:
+        tracemalloc.start()
     if PY2:
         execfile(filename, ns, ns)
     else:
-        if _backend == 'tracemalloc' and has_tracemalloc:
-            tracemalloc.start()
         try:
             with open(filename) as f:
                 exec(compile(f.read(), filename, 'exec'), ns, ns)
"
memory_profiler.py,memory_profiler.py,abd66f1c74e9f5a6e8fb9514afaf2204b80b96da,64c8199213012c8b145508f15c2f105d58201a65,lso stop tracemalloc when using exec_with_profiler on Py2,"@@ -1123,17 +1123,17 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     ns = dict(_CLEAN_GLOBALS, profile=profiler)
     _backend = choose_backend(backend)
     sys.argv = [filename] + passed_args
-    if _backend == 'tracemalloc' and has_tracemalloc:
-        tracemalloc.start()
-    if PY2:
-        execfile(filename, ns, ns)
-    else:
-        try:
+    try:
+        if _backend == 'tracemalloc' and has_tracemalloc:
+            tracemalloc.start()
+        if PY2:
+            execfile(filename, ns, ns)
+        else:
             with open(filename) as f:
                 exec(compile(f.read(), filename, 'exec'), ns, ns)
-        finally:
-            if has_tracemalloc and tracemalloc.is_tracing():
-                tracemalloc.stop()
+    finally:
+        if has_tracemalloc and tracemalloc.is_tracing():
+            tracemalloc.stop()
 
 
 def run_module_with_profiler(module, profiler, backend, passed_args=[]):
"
memory_profiler.py,memory_profiler.py,8e5e27bfd777d512f8b952d63598c6c89b639d66,abd66f1c74e9f5a6e8fb9514afaf2204b80b96da,"Correctly handle try/except in exec_with_profiler

Do away with the PY2 distinction altogether; Python 2 supports the same `exec()` pattern. Now the `try:...finally:` block properly applies in both 2 and 3.","@@ -1126,11 +1126,8 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     try:
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
-        if PY2:
-            execfile(filename, ns, ns)
-        else:
-            with open(filename) as f:
-                exec(compile(f.read(), filename, 'exec'), ns, ns)
+        with open(filename) as f:
+            exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
         if has_tracemalloc and tracemalloc.is_tracing():
             tracemalloc.stop()
"
delta_memory_test.py,,f8220c3873ac2791d58bf9557dce618ad75ee270,4089e3ed4d5c4197925a2df8393d4cbfca745ae5,Move delta_memory_test.py to test directory,"@@ -1,27 +0,0 @@
-from memory_profiler import profile
-
-
-def gen(count):
-    r = list(range(0,count))
-    return r
-
-_global_var = []
-def _gen_cache():
-    global _global_var
-    if not _global_var:
-        _global_var = gen(1000000)
-
-@profile(precision=4)
-def test():
-    a = gen(90000)
-    for i in range(0,3):
-        b = i
-        def _inner_gen():
-            gen(1024*1024*20)
-        h = i
-        _gen_cache()
-        _inner_gen()
-        g = i
-
-if __name__ == ""__main__"":
-    test()
"
memory_profiler.py,memory_profiler.py,5fe38da926738a7715c860053a498859e2db0c87,f8220c3873ac2791d58bf9557dce618ad75ee270,"Fixes #195 ""large negative increment values""

This should fix #195. Increment should reflect the largest increment with respect to the previous line, which is not what the previous code was doing. If run in a for loop, for some reason it was accumulating the increments.

I also disabled a test that was assuming that the increment of a function that deletes its temporaries need to be zero, which given the above should not be its behaviour.","@@ -597,9 +597,7 @@ class CodeMap(dict):
 
         prev_line_value = self[code].get(prev_lineno, None) if prev_lineno else None
         prev_line_memory = prev_line_value[1] if prev_line_value else 0
-        #inc = (memory-prev_line_memory)
-        #print('trace lineno=%(lineno)s prev_lineno=%(prev_lineno)s mem=%(memory)s prev_inc=%(previous_inc)s inc=%(inc)s' % locals())
-        self[code][lineno] = (previous_inc + (memory-prev_line_memory), max(memory, previous_memory))
+        self[code][lineno] = (max(previous_inc, memory-prev_line_memory), max(memory, previous_memory))
 
     def items(self):
         """"""Iterate on the toplevel code blocks.""""""
"
test/test_tracemalloc.py,test/test_tracemalloc.py,5fe38da926738a7715c860053a498859e2db0c87,f8220c3873ac2791d58bf9557dce618ad75ee270,"Fixes #195 ""large negative increment values""

This should fix #195. Increment should reflect the largest increment with respect to the previous line, which is not what the previous code was doing. If run in a for loop, for some reason it was accumulating the increments.

I also disabled a test that was assuming that the increment of a function that deletes its temporaries need to be zero, which given the above should not be its behaviour.","@@ -18,8 +18,6 @@ EPSILON = 0.0001
 def test_memory_profiler(test_input, expected):
     mem_prof(test_input)
     inc, dec = parse_mem_prof()
-    assert abs(inc - dec) <= EPSILON, \
-        'inc = {}, dec = {}, err = {}'.format(inc, dec, abs(inc - dec))
     assert abs(inc - expected) <= EPSILON, \
         'inc = {}, size = {}, err = {}'.format(
             inc, expected, abs(inc - expected)
"
mprof,mprof.py,6a00eb7f45efe0e7b64038c65391902b10c74195,f8220c3873ac2791d58bf9557dce618ad75ee270,first attempt to switch to entry_points,"@@ -1,5 +1,3 @@
-#!/usr/bin/env python
-
 import glob
 import os
 import os.path as osp
@@ -465,7 +463,7 @@ such file in the current directory.""""""
                         help=""Save plot to file instead of displaying it."")
     parser.add_argument(""--window"", ""-w"", dest=""xlim"", type=xlim_type,
                         help=""Plot a time-subset of the data. E.g. to plot between 0 and 20.5 seconds: --window 0,20.5"")
-    parser.add_argument(""--backend"", 
+    parser.add_argument(""--backend"",
                       help=""Specify the Matplotlib backend to use"")
     parser.add_argument(""profiles"", nargs=""*"",
                         help=""profiles made by mprof run"")
@@ -540,8 +538,7 @@ such file in the current directory.""""""
     else:
         pl.show()
 
-
-if __name__ == ""__main__"":
+def main():
     # Workaround for optparse limitation: insert -- before first negative
     # number found.
     negint = re.compile(""-[0-9]+"")
@@ -555,3 +552,6 @@ if __name__ == ""__main__"":
                ""run"": run_action,
                ""plot"": plot_action}
     actions[get_action()]()
+
+if __name__ == ""__main__"":
+    main()
"
setup.py,setup.py,6a00eb7f45efe0e7b64038c65391902b10c74195,f8220c3873ac2791d58bf9557dce618ad75ee270,first attempt to switch to entry_points,"@@ -1,7 +1,6 @@
 import os
 import io
 import re
-import sys
 from setuptools import setup
 
 
@@ -40,10 +39,6 @@ Operating System :: Unix
 
 """"""
 
-scripts = ['mprof']
-if sys.platform == ""win32"":
-    scripts.append('mprof.bat')
-
 setup(
     name='memory_profiler',
     description='A module for monitoring memory usage of a python program',
@@ -52,8 +47,10 @@ setup(
     author='Fabian Pedregosa',
     author_email='f@bianp.net',
     url='http://pypi.python.org/pypi/memory_profiler',
-    py_modules=['memory_profiler'],
-    scripts=scripts,
+    py_modules=['memory_profiler', 'mprof'],
+    entry_points={
+        'console_scripts' : ['mprof:main'],
+    },
     install_requires=['psutil'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='BSD'
"
setup.py,setup.py,f8f5fa3502c0449c60aaa713ea24c8c6733b280f,6a00eb7f45efe0e7b64038c65391902b10c74195,fix name qualifier,"@@ -49,7 +49,7 @@ setup(
     url='http://pypi.python.org/pypi/memory_profiler',
     py_modules=['memory_profiler', 'mprof'],
     entry_points={
-        'console_scripts' : ['mprof:main'],
+        'console_scripts' : ['mprof = mprof:main'],
     },
     install_requires=['psutil'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
"
mprof.bat,,c5b892148f6bac1a64e4309d9ec6c8440e2088ef,f8f5fa3502c0449c60aaa713ea24c8c6733b280f,remove mprof.bat file (now unneeded),"@@ -1,2 +0,0 @@
-@echo off
-python %~dpn0 %*
\ No newline at end of file
"
.travis.yml,.travis.yml,1d81b575bdcba27023c9f29fcdbf6acd878e6035,c5b892148f6bac1a64e4309d9ec6c8440e2088ef,pkg_resources requires python >= 3.4,"@@ -10,6 +10,7 @@ python:
 
 matrix:
   allow_failures:
+    - python: ""3.3""
     - python: ""pypy3""
     - python: ""3.7-dev""
 
"
.travis.yml,.travis.yml,5094e6ae725f498e03ce29583d556d5520824421,1d81b575bdcba27023c9f29fcdbf6acd878e6035,drop python 3.3 support,"@@ -1,7 +1,6 @@
 language: python
 python:
   - ""2.7""
-  - ""3.3""
   - ""3.4""
   - ""3.5""
   - ""3.6""
@@ -10,7 +9,6 @@ python:
 
 matrix:
   allow_failures:
-    - python: ""3.3""
     - python: ""pypy3""
     - python: ""3.7-dev""
 
"
README.rst,README.rst,3978bb6dd226c7b8995fd9cd0481d19e24a24c50,5094e6ae725f498e03ce29583d556d5520824421,add conda-forge package link,"@@ -18,6 +18,9 @@ To install through easy_install or pip::
 
     $ easy_install -U memory_profiler # pip install -U memory_profiler
 
+The package is also available on ```conda-forge`` 
+<https://github.com/conda-forge/memory_profiler-feedstock>`_.
+
 To install from source, download the package, extract and type::
 
     $ python setup.py install
"
README.rst,README.rst,e37acbd9c31d67a967ea61ec1acae31ea7d472f7,3978bb6dd226c7b8995fd9cd0481d19e24a24c50,fixed link,"@@ -18,7 +18,7 @@ To install through easy_install or pip::
 
     $ easy_install -U memory_profiler # pip install -U memory_profiler
 
-The package is also available on ```conda-forge`` 
+The package is also available on `conda-forge
 <https://github.com/conda-forge/memory_profiler-feedstock>`_.
 
 To install from source, download the package, extract and type::
"
memory_profiler.py,memory_profiler.py,4eca794cf55e0e45dc7b2db7f1be67e3fe9ef9b7,2a2cbac8609582f1755b6ba5ec24974a819c39c3,v0.54,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.53.0'
+__version__ = '0.54.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
README.rst,README.rst,c12eab35e84b8f66f99a6058dd2a569be681ac5b,957ff4e3b66da5b7d7472c232738419f3ca8a9bf,"Stop recommending `easy_install`

All python n00bs should use `pip` these days. Those who shouldn't are not n00bs and won't be needing help from the readme.","@@ -14,9 +14,9 @@ programs. It is a pure python module which depends on the `psutil
 ==============
  Installation
 ==============
-To install through easy_install or pip::
+Install via pip::
 
-    $ easy_install -U memory_profiler # pip install -U memory_profiler
+    $ pip install -U memory_profiler
 
 The package is also available on `conda-forge
 <https://github.com/conda-forge/memory_profiler-feedstock>`_.
"
Makefile,Makefile,4b06b89cd1d7e0afb19490c7678a589c70e88ceb,959d9fc10f210c90f77dea80e8a42d39a291c613,"Make function legend in mprof plot unambiguous

Previously, if the profiling was run on multiple same-named functions in
different classes or modules, the plot legend did not make clear which
bracket measured which function.","@@ -16,6 +16,7 @@ test:
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
 	$(PYTHON) test/test_exception.py
+	$(PYTHON) test/test_mprof.py
 
 develop:
 	pip install -e .
"
mprof.py,mprof.py,4b06b89cd1d7e0afb19490c7678a589c70e88ceb,959d9fc10f210c90f77dea80e8a42d39a291c613,"Make function legend in mprof plot unambiguous

Previously, if the profiling was run on multiple same-named functions in
different classes or modules, the plot legend did not make clear which
bracket measured which function.","@@ -422,11 +422,12 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
     # plot timestamps, if any
     if len(ts) > 0 and timestamps:
         func_num = 0
+        f_labels = function_labels(ts.keys())
         for f, exec_ts in ts.items():
             for execution in exec_ts:
                 add_brackets(execution[:2], execution[2:], xshift=global_start,
                              color=all_colors[func_num % len(all_colors)],
-                             label=f.split(""."")[-1]
+                             label=f_labels[f]
                                    + "" %.3fs"" % (execution[1] - execution[0]), options=options)
             func_num += 1
 
@@ -439,6 +440,33 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
     return mprofile
 
 
+def function_labels(dotted_function_names):
+    state = {}
+
+    def set_state_for(function_names, level):
+        for fn in function_names:
+            label = ""."".join(fn.split(""."")[-level:])
+            label_state = state.setdefault(label, {""functions"": [],
+                                                   ""level"": level})
+            label_state[""functions""].append(fn)`
+
+    set_state_for(dotted_function_names, 1)
+
+    while True:
+        ambiguous_labels = [label for label in state if len(state[label][""functions""]) > 1]
+        for ambiguous_label in ambiguous_labels:
+            function_names = state[ambiguous_label][""functions""]
+            new_level = state[ambiguous_label][""level""] + 1
+            del state[ambiguous_label]
+            set_state_for(function_names, new_level)
+        if len(ambiguous_labels) == 0:
+            break
+
+    fn_to_label = { label_state[""functions""][0] : label for label, label_state in state.items() }
+
+    return fn_to_label
+
+
 def plot_action():
     def xlim_type(value):
         try:
"
,test/test_mprof.py,4b06b89cd1d7e0afb19490c7678a589c70e88ceb,959d9fc10f210c90f77dea80e8a42d39a291c613,"Make function legend in mprof plot unambiguous

Previously, if the profiling was run on multiple same-named functions in
different classes or modules, the plot legend did not make clear which
bracket measured which function.","@@ -0,0 +1,20 @@
+import unittest
+
+import mprof
+
+class Test_function_labels(unittest.TestCase):
+    def test(self):
+        expected = {
+            ""x.z"": ""z"",
+            ""x.y"": ""y"",
+            ""x.b"": ""x.b"",
+            ""f.a.b"": ""f.a.b"",
+            ""g.a.b"": ""g.a.b"",
+            ""g.a.c"": ""a.c"",
+            ""b.c"": ""b.c"",
+        }
+        result = mprof.function_labels(expected.keys())
+        self.assertEqual(expected,result)
+
+if __name__ == ""__main__"":
+    unittest.main()
\ No newline at end of file
"
mprof.py,mprof.py,19165e76a4da2bfe819d1f606ef0f3f468f3ab40,4b06b89cd1d7e0afb19490c7678a589c70e88ceb,Fix typo,"@@ -448,7 +448,7 @@ def function_labels(dotted_function_names):
             label = ""."".join(fn.split(""."")[-level:])
             label_state = state.setdefault(label, {""functions"": [],
                                                    ""level"": level})
-            label_state[""functions""].append(fn)`
+            label_state[""functions""].append(fn)
 
     set_state_for(dotted_function_names, 1)
 
"
mprof.py,mprof.py,9c50e75e33f9d9ba1524fe9e86b9b4c493d66843,959d9fc10f210c90f77dea80e8a42d39a291c613,adding logger and propagate exit code option,"@@ -6,6 +6,7 @@ import re
 import copy
 import time
 import math
+import logging
 
 from collections import defaultdict
 from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormatter
@@ -26,6 +27,9 @@ Type mprof <command> --help for usage help on a specific command.
 For example, mprof plot --help will list all plotting options.
 """"""
 
+logger = logging.getLogger(__name__)
+logging.basicConfig()
+
 
 def print_usage():
     print(""Usage: %s <command> <options> <arguments>""
@@ -185,6 +189,8 @@ def run_action():
                         help=""""""Monitors forked processes as well (sum up all process memory)"""""")
     parser.add_argument(""--multiprocess"", ""-M"", dest=""multiprocess"", action=""store_true"",
                         help=""""""Monitors forked processes creating individual plots for each child (disables --python features)"""""")
+    parser.add_argument(""--exit-code"", ""-E"", dest=""exit_code"", action=""store_true"",
+                        help=""""""Propagate the exit code"""""")
     parser.add_argument(""--output"", ""-o"", dest=""filename"",
                         default=""mprofile_%s.dat"" % time.strftime(""%Y%m%d%H%M%S"", time.localtime()),
                         help=""""""File to store results in, defaults to 'mprofile_<YYYYMMDDhhmmss>.dat' in the current directory,
@@ -236,6 +242,11 @@ This file contains the process memory consumption, in Mb (one value per line).""""
                         include_children=args.include_children,
                         multiprocess=args.multiprocess, stream=f)
 
+    if args.exit_code:
+        if p.returncode != 0:
+            logger.error('Program resulted with a non-zero exit code: %s', p.returncode)
+        sys.exit(p.returncode)
+
 
 def add_brackets(xloc, yloc, xshift=0, color=""r"", label=None, options=None):
     """"""Add two brackets on the memory line plot.
"
Makefile,Makefile,06072355940a67a17003330224b211a4106450a8,9c50e75e33f9d9ba1524fe9e86b9b4c493d66843,add tests,"@@ -16,6 +16,7 @@ test:
 	$(PYTHON) test/test_memory_usage.py
 	$(PYTHON) test/test_precision_import.py
 	$(PYTHON) test/test_exception.py
+	$(PYTHON) test/test_exit_code.py
 
 develop:
 	pip install -e .
"
mprof.py,mprof.py,06072355940a67a17003330224b211a4106450a8,9c50e75e33f9d9ba1524fe9e86b9b4c493d66843,add tests,"@@ -189,8 +189,7 @@ def run_action():
                         help=""""""Monitors forked processes as well (sum up all process memory)"""""")
     parser.add_argument(""--multiprocess"", ""-M"", dest=""multiprocess"", action=""store_true"",
                         help=""""""Monitors forked processes creating individual plots for each child (disables --python features)"""""")
-    parser.add_argument(""--exit-code"", ""-E"", dest=""exit_code"", action=""store_true"",
-                        help=""""""Propagate the exit code"""""")
+    parser.add_argument(""--exit-code"", ""-E"", dest=""exit_code"", action=""store_true"", help=""""""Propagate the exit code"""""")
     parser.add_argument(""--output"", ""-o"", dest=""filename"",
                         default=""mprofile_%s.dat"" % time.strftime(""%Y%m%d%H%M%S"", time.localtime()),
                         help=""""""File to store results in, defaults to 'mprofile_<YYYYMMDDhhmmss>.dat' in the current directory,
@@ -203,7 +202,7 @@ This file contains the process memory consumption, in Mb (one value per line).""""
                              'Option 4: (--python flag present) ""<PYTHON_MODULE> <ARG1> <ARG2>..."" - profile python module\n'
                         )
     args = parser.parse_args()
-
+    print(args)
     if len(args.program) == 0:
         print(""A program to run must be provided. Use -h for help"")
         sys.exit(1)
"
,test/test_exit_code.py,06072355940a67a17003330224b211a4106450a8,9c50e75e33f9d9ba1524fe9e86b9b4c493d66843,add tests,"@@ -0,0 +1,33 @@
+import unittest
+import sys
+import tempfile
+
+class TestExitCode(unittest.TestCase):
+
+    def setUp(self):
+        # to be able to import mprof
+        sys.path.append('.')
+        from mprof import run_action
+        self.run_action = run_action
+
+    def test_exit_code_success(self):
+        s = ""1+1""
+        tmpfile = tempfile.NamedTemporaryFile('w', suffix='.py')
+        with tmpfile as ofile:
+            ofile.write(s)
+            ofile.flush()
+            sys.argv = ['<ignored>', '--exit-code', tmpfile.name]
+            self.assertRaisesRegex(SystemExit, '0', self.run_action)
+
+    def test_exit_code_fail(self):
+        s = ""raise RuntimeError('I am not working nicely')""
+        tmpfile = tempfile.NamedTemporaryFile('w', suffix='.py')
+        with tmpfile as ofile:
+            ofile.write(s)
+            ofile.flush()
+            sys.argv = ['<ignored>', '--exit-code', tmpfile.name]
+            self.assertRaisesRegex(SystemExit, '1', self.run_action)
+
+
+if __name__ == '__main__':
+    unittest.main()
"
test/test_exit_code.py,test/test_exit_code.py,c69bfe8457d87dbe50ca4803b721416d5fc8047d,06072355940a67a17003330224b211a4106450a8,add valid case,"@@ -2,6 +2,7 @@ import unittest
 import sys
 import tempfile
 
+
 class TestExitCode(unittest.TestCase):
 
     def setUp(self):
@@ -28,6 +29,14 @@ class TestExitCode(unittest.TestCase):
             sys.argv = ['<ignored>', '--exit-code', tmpfile.name]
             self.assertRaisesRegex(SystemExit, '1', self.run_action)
 
+    def test_no_exit_code_success(self):
+        s = ""raise RuntimeError('I am not working nicely')""
+        tmpfile = tempfile.NamedTemporaryFile('w', suffix='.py')
+        with tmpfile as ofile:
+            ofile.write(s)
+            ofile.flush()
+            sys.argv = ['<ignored>', tmpfile.name]
+            self.run_action()
 
 if __name__ == '__main__':
     unittest.main()
"
test/test_exit_code.py,test/test_exit_code.py,fefde7db45b83e9f06269d8f92d97007e0b7ad23,c69bfe8457d87dbe50ca4803b721416d5fc8047d,2.7 regexp compat,"@@ -18,7 +18,7 @@ class TestExitCode(unittest.TestCase):
             ofile.write(s)
             ofile.flush()
             sys.argv = ['<ignored>', '--exit-code', tmpfile.name]
-            self.assertRaisesRegex(SystemExit, '0', self.run_action)
+            self.assertRaisesRegexp(SystemExit, '0', self.run_action)
 
     def test_exit_code_fail(self):
         s = ""raise RuntimeError('I am not working nicely')""
@@ -27,7 +27,7 @@ class TestExitCode(unittest.TestCase):
             ofile.write(s)
             ofile.flush()
             sys.argv = ['<ignored>', '--exit-code', tmpfile.name]
-            self.assertRaisesRegex(SystemExit, '1', self.run_action)
+            self.assertRaisesRegexp(SystemExit, '1', self.run_action)
 
     def test_no_exit_code_success(self):
         s = ""raise RuntimeError('I am not working nicely')""
"
test/test_mprof.py,test/test_mprof.py,9d896c68b11bafead3f26df298aa935f3f037878,19165e76a4da2bfe819d1f606ef0f3f468f3ab40,add newline at end of file,"@@ -17,4 +17,4 @@ class Test_function_labels(unittest.TestCase):
         self.assertEqual(expected,result)
 
 if __name__ == ""__main__"":
-    unittest.main()
\ No newline at end of file
+    unittest.main()
"
mprof.py,mprof.py,e07aff503f8634f971e51ce487f02ea09ef5944b,fefde7db45b83e9f06269d8f92d97007e0b7ad23,remove printing args,"@@ -202,7 +202,7 @@ This file contains the process memory consumption, in Mb (one value per line).""""
                              'Option 4: (--python flag present) ""<PYTHON_MODULE> <ARG1> <ARG2>..."" - profile python module\n'
                         )
     args = parser.parse_args()
-    print(args)
+    
     if len(args.program) == 0:
         print(""A program to run must be provided. Use -h for help"")
         sys.exit(1)
"
memory_profiler.py,memory_profiler.py,8194a59de2460f1501782b8df735bb58e3eb8e60,077d67b9a4a4d48fc618dc32cde7d05c8390fd1f,version 0.55,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.54.0'
+__version__ = '0.55.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
memory_profiler.py,memory_profiler.py,c0911004a761252dbf683328dc5fb3b214fb5248,8194a59de2460f1501782b8df735bb58e3eb8e60,fix max_iter calc when float is given,"@@ -301,7 +301,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         ret = -1
 
     if timeout is not None:
-        max_iter = int(timeout / interval)
+        max_iter = int(round(timeout / interval))
     elif isinstance(proc, int):
         # external process and no timeout
         max_iter = 1
"
memory_profiler.py,memory_profiler.py,1ecaf4edae1d84684dcc560df1e798aa7ed9a46d,cedd23862c37a138d395445ace04f436a7c97f59,"Unpacking return value if max_usage is True

If the memory_usage function is called with (callable, arglist,
kwargs), as target and max_usage is True, the function now returns
a number instead of a list with one entry.","@@ -339,6 +339,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 n_measurements = parent_conn.recv()
                 if retval:
                     ret = ret, returned
+                if max_usage:
+                    ret = ret[0]
             except Exception:
                 parent = psutil.Process(os.getpid())
                 for child in parent.children(recursive=True):
"
memory_profiler.py,memory_profiler.py,b785ea731891c4b5a139c9cf72933d4e12f06c50,1ecaf4edae1d84684dcc560df1e798aa7ed9a46d,add comment and test,"@@ -340,6 +340,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 if retval:
                     ret = ret, returned
                 if max_usage:
+                    # Convert the one element list produced by MemTimer to a singular value
                     ret = ret[0]
             except Exception:
                 parent = psutil.Process(os.getpid())
"
test/test_memory_usage.py,test/test_memory_usage.py,b785ea731891c4b5a139c9cf72933d4e12f06c50,1ecaf4edae1d84684dcc560df1e798aa7ed9a46d,add comment and test,"@@ -11,5 +11,20 @@ def test_memory_usage():
     assert ret[0] == (1, 2)
     assert ret[1] == dict(a=1)
 
+
+def test_return_value_consistency():
+    # Test return values when watching process by PID
+    pid_mem_list = memory_usage(timeout=1)
+    assert type(pid_mem_list) == list, ""Memory usage of process should be a list""
+    pid_mem_max = memory_usage(timeout=1, max_usage=True)
+    assert type(pid_mem_max) == float, ""Max memory usage of process should be a number""
+    # Test return values when watching callable
+    func_mem_list = memory_usage((some_func, (42,), dict(a=42)))
+    assert type(func_mem_list) == list, ""Memory usage of callable should be a list""
+    func_mem_max = memory_usage((some_func, (42,), dict(a=42)), max_usage=True)
+    assert type(func_mem_max) == float, ""Max memory usage of callable should be a number""
+
+
 if __name__ == ""__main__"":
     test_memory_usage()
+    test_return_value_consistency()
"
memory_profiler.py,memory_profiler.py,9404f33fb2277d26f2b17e416a407d97a5329d73,2c77549ed70c8cdbfa5d602376c8ada26704ba70,Implemented stack mechanism in TimeStamper,"@@ -18,6 +18,7 @@ import sys
 import time
 import traceback
 import warnings
+import contextlib
 
 if sys.platform == ""win32"":
     # any value except signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT
@@ -482,6 +483,8 @@ class TimeStamper:
     def __init__(self, backend):
         self.functions = {}
         self.backend = backend
+        self.current_stack_level = -1
+        self.stack = {}
 
     def __call__(self, func=None, precision=None):
         if func is not None:
@@ -521,6 +524,7 @@ class TimeStamper:
     def add_function(self, func):
         if func not in self.functions:
             self.functions[func] = []
+            self.stack[func] = []
 
     def wrap_function(self, func):
         """""" Wrap a function to timestamp it.
@@ -536,7 +540,8 @@ class TimeStamper:
                 _get_memory(os.getpid(), self.backend, timestamps=True, filename=filename)]
             self.functions[func].append(timestamps)
             try:
-                return func(*args, **kwds)
+                with self.call_on_stack(*args, **kwds) as result:
+                    return result
             finally:
                 # end time
                 timestamps.append(_get_memory(os.getpid(), self.backend, timestamps=True,
@@ -544,6 +549,15 @@ class TimeStamper:
 
         return f
 
+    @contextlib.contextmanager
+    def call_on_stack(self, func, *args, **kwds):
+        self.current_stack_level += 1
+        self.stack[func].append(self.current_stack_level)
+
+        yield func(*args, **kwds)
+
+        self.current_stack_level -= 1
+
     def show_results(self, stream=None):
         if stream is None:
             stream = sys.stdout
"
memory_profiler.py,memory_profiler.py,47a2bd38b6e5693570a96f2930681c45af9035da,9404f33fb2277d26f2b17e416a407d97a5329d73,Integrated stack logic to _TimeStamperCM,"@@ -461,16 +461,25 @@ def _find_script(script_name):
 class _TimeStamperCM(object):
     """"""Time-stamping context manager.""""""
 
-    def __init__(self, timestamps, filename, backend):
+    def __init__(self, timestamps, filename, backend, timestamper=None, func=None):
         self.timestamps = timestamps
         self.filename = filename
         self.backend = backend
+        self.ts = timestamper
+        self.func = func
 
     def __enter__(self):
+        if self.ts is not None:
+            self.ts.current_stack_level += 1
+            self.ts.stack[self.func].append(self.ts.current_stack_level)
+
         self.timestamps.append(
             _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
 
     def __exit__(self, *args):
+        if self.ts is not None:
+            self.ts.current_stack_level -= 1
+
         self.timestamps.append(
             _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
 
@@ -519,7 +528,13 @@ class TimeStamper:
             filename = inspect.getsourcefile(func)
         except TypeError:
             filename = '<unknown>'
-        return _TimeStamperCM(timestamps, filename, self.backend)
+        return _TimeStamperCM(
+            timestamps,
+            filename,
+            self.backend,
+            timestamper=self,
+            func=func
+        )
 
     def add_function(self, func):
         if func not in self.functions:
"
memory_profiler.py,memory_profiler.py,b3f07814b153973be5e6697ca20403c5cf856a6e,47a2bd38b6e5693570a96f2930681c45af9035da,Printing stack level in TimeStamper.show_results,"@@ -579,9 +579,9 @@ class TimeStamper:
 
         for func, timestamps in self.functions.items():
             function_name = ""%s.%s"" % (func.__module__, func.__name__)
-            for ts in timestamps:
-                stream.write(""FUNC %s %.4f %.4f %.4f %.4f\n"" % (
-                    (function_name,) + ts[0] + ts[1]))
+            for ts, level in zip(timestamps, self.stack[func]):
+                stream.write(""FUNC %s %.4f %.4f %.4f %.4f %d\n"" % (
+                    (function_name,) + ts[0] + ts[1] + (level,)))
 
 
 class CodeMap(dict):
"
memory_profiler.py,memory_profiler.py,11d76769bc588925779a731b888dbc5cd165555e,b3f07814b153973be5e6697ca20403c5cf856a6e,Passing func in TimeStamper.call_on_stack,"@@ -555,7 +555,7 @@ class TimeStamper:
                 _get_memory(os.getpid(), self.backend, timestamps=True, filename=filename)]
             self.functions[func].append(timestamps)
             try:
-                with self.call_on_stack(*args, **kwds) as result:
+                with self.call_on_stack(func, *args, **kwds) as result:
                     return result
             finally:
                 # end time
"
mprof.py,mprof.py,2924fd252b27bf4236df22f7dea2c4f1989a7a9f,11d76769bc588925779a731b888dbc5cd165555e,Injecting local memory_profiler.py for dev,"@@ -11,7 +11,9 @@ import logging
 from collections import defaultdict
 from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormatter
 
-import memory_profiler as mp
+import importlib
+mp = importlib.import_module(""memory_profiler"", __file__)
+# import memory_profiler as mp
 
 ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"")
 help_msg = """"""
@@ -202,7 +204,7 @@ This file contains the process memory consumption, in Mb (one value per line).""""
                              'Option 4: (--python flag present) ""<PYTHON_MODULE> <ARG1> <ARG2>..."" - profile python module\n'
                         )
     args = parser.parse_args()
-    
+
     if len(args.program) == 0:
         print(""A program to run must be provided. Use -h for help"")
         sys.exit(1)
@@ -329,8 +331,12 @@ def read_mprofile_file(filename):
             values = value.split(' ')
             f_name, mem_start, start, mem_end, end = values[:5]
             ts = func_ts.get(f_name, [])
-            ts.append([float(start), float(end),
-                       float(mem_start), float(mem_end)])
+            to_append = [float(start), float(end), float(mem_start), float(mem_end)]
+            if len(values) >= 6:
+                # There is a stack level field
+                stack_level = values[5]
+                to_append.append(int(stack_level))
+            ts.append(to_append)
             func_ts[f_name] = ts
 
         elif field == ""CHLD"":
"
mprof.py,mprof.py,2d8fa20b1b6e794cc5b459d803c39b52ab1acedb,2924fd252b27bf4236df22f7dea2c4f1989a7a9f,Prepared flame graph mode,"@@ -456,6 +456,105 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
     return mprofile
 
 
+def flame_plotter(filename, index=0, timestamps=True, children=True, options=None):
+    try:
+        import pylab as pl
+    except ImportError as e:
+        print(""matplotlib is needed for plotting."")
+        print(e)
+        sys.exit(1)
+    import numpy as np  # pylab requires numpy anyway
+    mprofile = read_mprofile_file(filename)
+
+    if len(mprofile['timestamp']) == 0:
+        print('** No memory usage values have been found in the profile '
+              'file.**\nFile path: {0}\n'
+              'File may be empty or invalid.\n'
+              'It can be deleted with ""mprof rm {0}""'.format(
+            mprofile['filename']))
+        sys.exit(0)
+
+    # Merge function timestamps and memory usage together
+    ts = mprofile['func_timestamp']
+    t = mprofile['timestamp']
+    mem = mprofile['mem_usage']
+    chld = mprofile['children']
+
+    if len(ts) > 0:
+        for values in ts.values():
+            for v in values:
+                t.extend(v[:2])
+                mem.extend(v[2:4])
+
+    mem = np.asarray(mem)
+    t = np.asarray(t)
+    ind = t.argsort()
+    mem = mem[ind]
+    t = t[ind]
+
+    # Plot curves
+    global_start = float(t[0])
+    t = t - global_start
+
+    max_mem = mem.max()
+    max_mem_ind = mem.argmax()
+
+    all_colors = (""c"", ""y"", ""g"", ""r"", ""b"")
+    mem_line_colors = (""k"", ""b"", ""r"", ""g"", ""c"", ""y"", ""m"")
+    mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
+                                   time.localtime(global_start)) \
+                     + "".{0:03d}"".format(int(round(math.modf(global_start)[0] * 1000)))
+
+    pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
+            label=mem_line_label)
+
+    bottom, top = pl.ylim()
+    bottom += 0.001
+    top -= 0.001
+
+    # plot children, if any
+    if len(chld) > 0 and children:
+        cmpoint = (0,0) # maximal child memory
+
+        for idx, (proc, data) in enumerate(chld.items()):
+            # Create the numpy arrays from the series data
+            cts  = np.asarray([item[1] for item in data]) - global_start
+            cmem = np.asarray([item[0] for item in data])
+
+            # Plot the line to the figure
+            pl.plot(cts, cmem, ""+-""  + mem_line_colors[(idx+1) % len(mem_line_colors)],
+                     label=""child {}"".format(proc))
+
+            # Detect the maximal child memory point
+            cmax_mem = cmem.max()
+            if cmax_mem > cmpoint[1]:
+                cmpoint = (cts[cmem.argmax()], cmax_mem)
+
+        # Add the marker lines for the maximal child memory usage
+        pl.vlines(cmpoint[0], pl.ylim()[0]+0.001, pl.ylim()[1] - 0.001, 'r', '--')
+        pl.hlines(cmpoint[1], pl.xlim()[0]+0.001, pl.xlim()[1] - 0.001, 'r', '--')
+
+    # plot timestamps, if any
+    if len(ts) > 0 and timestamps:
+        func_num = 0
+        f_labels = function_labels(ts.keys())
+        for f, exec_ts in ts.items():
+            for execution in exec_ts:
+                add_brackets(execution[:2], execution[2:], xshift=global_start,
+                             color=all_colors[func_num % len(all_colors)],
+                             label=f_labels[f]
+                                   + "" %.3fs"" % (execution[1] - execution[0]), options=options)
+            func_num += 1
+
+    if timestamps:
+        pl.hlines(max_mem,
+                  pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
+                  colors=""r"", linestyles=""--"")
+        pl.vlines(t[max_mem_ind], bottom, top,
+                  colors=""r"", linestyles=""--"")
+    return mprofile
+
+
 def function_labels(dotted_function_names):
     state = {}
 
@@ -507,6 +606,8 @@ such file in the current directory.""""""
                         help=""Save plot to file instead of displaying it."")
     parser.add_argument(""--window"", ""-w"", dest=""xlim"", type=xlim_type,
                         help=""Plot a time-subset of the data. E.g. to plot between 0 and 20.5 seconds: --window 0,20.5"")
+    parser.add_argument(""--flame"", ""-f"", dest=""flame_mode"", action=""store_true"",
+                        help=""Plot the timestamps as a flame-graph instead of the default brackets"")
     parser.add_argument(""--backend"",
                       help=""Specify the Matplotlib backend to use"")
     parser.add_argument(""profiles"", nargs=""*"",
@@ -561,8 +662,11 @@ such file in the current directory.""""""
         timestamps = False
     else:
         timestamps = True
+    plotter = plot_file
+    if args.flame_mode:
+        plotter = flame_plotter
     for n, filename in enumerate(filenames):
-        mprofile = plot_file(filename, index=n, timestamps=timestamps, options=args)
+        mprofile = plotter(filename, index=n, timestamps=timestamps, options=args)
     pl.xlabel(""time (in seconds)"")
     pl.ylabel(""memory used (in MiB)"")
 
"
mprof.py,mprof.py,df64c9c2b35b86e9e44e0be69add6398858f4572,2d8fa20b1b6e794cc5b459d803c39b52ab1acedb,Plotting timestamps as rectangles,"@@ -491,6 +491,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     ind = t.argsort()
     mem = mem[ind]
     t = t[ind]
+    stack_size = 1 + max(ex[4] for executions in ts.values() for ex in executions)
 
     # Plot curves
     global_start = float(t[0])
@@ -499,7 +500,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     max_mem = mem.max()
     max_mem_ind = mem.argmax()
 
-    all_colors = (""c"", ""y"", ""g"", ""r"", ""b"")
+    cmap = pl.cm.get_cmap('gist_rainbow')
     mem_line_colors = (""k"", ""b"", ""r"", ""g"", ""c"", ""y"", ""m"")
     mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
                                    time.localtime(global_start)) \
@@ -512,6 +513,9 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     bottom += 0.001
     top -= 0.001
 
+    timestamp_ax = pl.twinx()
+    timestamp_ax.set_ylim((0, stack_size))
+
     # plot children, if any
     if len(chld) > 0 and children:
         cmpoint = (0,0) # maximal child memory
@@ -540,10 +544,16 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
         f_labels = function_labels(ts.keys())
         for f, exec_ts in ts.items():
             for execution in exec_ts:
-                add_brackets(execution[:2], execution[2:], xshift=global_start,
-                             color=all_colors[func_num % len(all_colors)],
-                             label=f_labels[f]
-                                   + "" %.3fs"" % (execution[1] - execution[0]), options=options)
+                x0, x1 = execution[:2]
+                y0 = execution[4]
+                y1 = y0 + 1
+                color = cmap(0.5)
+                add_timestamp_rectangle(
+                    timestamp_ax,
+                    x0, x1, y0, y1,
+                    xshift=global_start,
+                    color=color
+                )
             func_num += 1
 
     if timestamps:
@@ -555,6 +565,14 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     return mprofile
 
 
+def add_timestamp_rectangle(ax, x0, x1, y0, y1, *, xshift=0, color='none'):
+    x0 -= xshift
+    x1 -= xshift
+    print(f""Drawing rectangle ({x0}, {y0}, {x1}, {y1})"")
+    print(color)
+    ax.fill_betweenx((y0, y1), x0, x1, color=color, alpha=0.5, linewidth=1)
+
+
 def function_labels(dotted_function_names):
     state = {}
 
"
mprof.py,mprof.py,9ecdd47903afcc1c4c1d63f22c1beb8a3d1d3c79,df64c9c2b35b86e9e44e0be69add6398858f4572,Plotting with nice contrast,"@@ -7,6 +7,7 @@ import copy
 import time
 import math
 import logging
+import itertools
 
 from collections import defaultdict
 from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormatter
@@ -492,6 +493,15 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     mem = mem[ind]
     t = t[ind]
     stack_size = 1 + max(ex[4] for executions in ts.values() for ex in executions)
+    def level_to_saturation(level):
+        return 1 - 0.75 * level / stack_size
+
+    colors = [
+        itertools.cycle([
+            pl.matplotlib.colors.hsv_to_rgb((0, level_to_saturation(level), 1)),
+            pl.matplotlib.colors.hsv_to_rgb((0.1, level_to_saturation(level), 1)),
+        ]) for level in range(stack_size)
+    ]
 
     # Plot curves
     global_start = float(t[0])
@@ -500,7 +510,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     max_mem = mem.max()
     max_mem_ind = mem.argmax()
 
-    cmap = pl.cm.get_cmap('gist_rainbow')
+    # cmap = pl.cm.get_cmap('gist_rainbow')
     mem_line_colors = (""k"", ""b"", ""r"", ""g"", ""c"", ""y"", ""m"")
     mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
                                    time.localtime(global_start)) \
@@ -547,7 +557,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                 x0, x1 = execution[:2]
                 y0 = execution[4]
                 y1 = y0 + 1
-                color = cmap(0.5)
+                color = next(colors[y0])
                 add_timestamp_rectangle(
                     timestamp_ax,
                     x0, x1, y0, y1,
"
mprof.py,mprof.py,075de7304a67266b9ad261e3b4bd8a187acc54fb,9ecdd47903afcc1c4c1d63f22c1beb8a3d1d3c79,Improved grid and layout,"@@ -492,6 +492,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     ind = t.argsort()
     mem = mem[ind]
     t = t[ind]
+
     stack_size = 1 + max(ex[4] for executions in ts.values() for ex in executions)
     def level_to_saturation(level):
         return 1 - 0.75 * level / stack_size
@@ -516,15 +517,17 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                                    time.localtime(global_start)) \
                      + "".{0:03d}"".format(int(round(math.modf(global_start)[0] * 1000)))
 
-    pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
+    pl.plot(t, mem, ""-"" + mem_line_colors[index % len(mem_line_colors)],
             label=mem_line_label)
 
     bottom, top = pl.ylim()
     bottom += 0.001
     top -= 0.001
 
+    pl.gca().grid(True)
     timestamp_ax = pl.twinx()
     timestamp_ax.set_ylim((0, stack_size))
+    timestamp_ax.grid(False)
 
     # plot children, if any
     if len(chld) > 0 and children:
@@ -578,8 +581,6 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
 def add_timestamp_rectangle(ax, x0, x1, y0, y1, *, xshift=0, color='none'):
     x0 -= xshift
     x1 -= xshift
-    print(f""Drawing rectangle ({x0}, {y0}, {x1}, {y1})"")
-    print(color)
     ax.fill_betweenx((y0, y1), x0, x1, color=color, alpha=0.5, linewidth=1)
 
 
@@ -682,7 +683,10 @@ such file in the current directory.""""""
         sys.exit(-1)
 
     fig = pl.figure(figsize=(14, 6), dpi=90)
-    ax = fig.add_axes([0.1, 0.1, 0.6, 0.75])
+    if not args.flame_mode:
+        ax = fig.add_axes([0.1, 0.1, 0.6, 0.75])
+    else:
+        ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])
     if args.xlim is not None:
         pl.xlim(args.xlim[0], args.xlim[1])
 
@@ -706,9 +710,11 @@ such file in the current directory.""""""
 
     # place legend within the plot, make partially transparent in
     # case it obscures part of the lineplot
-    leg = ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))
-    leg.get_frame().set_alpha(0.5)
-    pl.grid()
+    if not args.flame_mode:
+        leg = ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))
+        leg.get_frame().set_alpha(0.5)
+        pl.grid()
+
     if args.output:
         pl.savefig(args.output)
     else:
"
mprof.py,mprof.py,530eb139f03024893297a743993dd37146ad725f,075de7304a67266b9ad261e3b4bd8a187acc54fb,First implementation of label,"@@ -555,20 +555,41 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     if len(ts) > 0 and timestamps:
         func_num = 0
         f_labels = function_labels(ts.keys())
+        rectangles = {}
         for f, exec_ts in ts.items():
             for execution in exec_ts:
                 x0, x1 = execution[:2]
                 y0 = execution[4]
                 y1 = y0 + 1
+                x0 -= global_start
+                x1 -= global_start
                 color = next(colors[y0])
-                add_timestamp_rectangle(
+                rect = add_timestamp_rectangle(
                     timestamp_ax,
                     x0, x1, y0, y1,
-                    xshift=global_start,
                     color=color
                 )
+                rectangles[(x0, y0, x1, y1)] = f
             func_num += 1
 
+    label = pl.text(0, 0, """")
+    def mouse_motion_handler(event):
+        x, y = event.xdata, event.ydata
+        if x is None or y is None:
+            return
+
+        for rect, func_name in rectangles.items():
+            x0, y0, x1, y1 = rect
+            if x0 < x < x1 and y0 < y < y1:
+                print(x, y)
+                label.set_position((x, y))
+                label.set_text(func_name)
+                pl.draw()
+                return
+            label.set_text("""")
+
+    pl.gcf().canvas.mpl_connect('motion_notify_event', mouse_motion_handler)
+
     if timestamps:
         pl.hlines(max_mem,
                   pl.xlim()[0] + 0.001, pl.xlim()[1] - 0.001,
@@ -578,10 +599,8 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     return mprofile
 
 
-def add_timestamp_rectangle(ax, x0, x1, y0, y1, *, xshift=0, color='none'):
-    x0 -= xshift
-    x1 -= xshift
-    ax.fill_betweenx((y0, y1), x0, x1, color=color, alpha=0.5, linewidth=1)
+def add_timestamp_rectangle(ax, x0, x1, y0, y1, *, color='none'):
+    return ax.fill_betweenx((y0, y1), x0, x1, color=color, alpha=0.5, linewidth=1)
 
 
 def function_labels(dotted_function_names):
"
mprof.py,mprof.py,244382c46f12ad946011d2d33273f349bc00ceff,530eb139f03024893297a743993dd37146ad725f,Displaying labels more simply; zooming on rectangles on click,"@@ -332,6 +332,7 @@ def read_mprofile_file(filename):
             values = value.split(' ')
             f_name, mem_start, start, mem_end, end = values[:5]
             ts = func_ts.get(f_name, [])
+            print(f_name, mem_start, start, mem_end, end)
             to_append = [float(start), float(end), float(mem_start), float(mem_end)]
             if len(values) >= 6:
                 # There is a stack level field
@@ -526,7 +527,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
 
     pl.gca().grid(True)
     timestamp_ax = pl.twinx()
-    timestamp_ax.set_ylim((0, stack_size))
+    timestamp_ax.set_ylim((0, stack_size + 1))
     timestamp_ax.grid(False)
 
     # plot children, if any
@@ -564,15 +565,14 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                 x0 -= global_start
                 x1 -= global_start
                 color = next(colors[y0])
-                rect = add_timestamp_rectangle(
+                _rect, text = add_timestamp_rectangle(
                     timestamp_ax,
-                    x0, x1, y0, y1,
+                    x0, x1, y0, y1, f,
                     color=color
                 )
-                rectangles[(x0, y0, x1, y1)] = f
+                rectangles[(x0, y0, x1, y1)] = (f, text)
             func_num += 1
 
-    label = pl.text(0, 0, """")
     def mouse_motion_handler(event):
         x, y = event.xdata, event.ydata
         if x is None or y is None:
@@ -581,14 +581,26 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
         for rect, func_name in rectangles.items():
             x0, y0, x1, y1 = rect
             if x0 < x < x1 and y0 < y < y1:
-                print(x, y)
-                label.set_position((x, y))
-                label.set_text(func_name)
+                # pl.draw()
+                return
+
+    def mouse_click_handler(event):
+        x, y = event.xdata, event.ydata
+        if x is None or y is None:
+            return
+
+        for rect, func_name in rectangles.items():
+            x0, y0, x1, y1 = rect
+            if x0 < x < x1 and y0 < y < y1:
+                toolbar = pl.gcf().canvas.toolbar
+                toolbar.push_current()
+                timestamp_ax.set_xlim(x0, x1)
+                toolbar.push_current()
                 pl.draw()
                 return
-            label.set_text("""")
 
     pl.gcf().canvas.mpl_connect('motion_notify_event', mouse_motion_handler)
+    pl.gcf().canvas.mpl_connect('button_press_event', mouse_click_handler)
 
     if timestamps:
         pl.hlines(max_mem,
@@ -599,8 +611,13 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     return mprofile
 
 
-def add_timestamp_rectangle(ax, x0, x1, y0, y1, *, color='none'):
-    return ax.fill_betweenx((y0, y1), x0, x1, color=color, alpha=0.5, linewidth=1)
+def add_timestamp_rectangle(ax, x0, x1, y0, y1, func_name, color='none'):
+    rect = ax.fill_betweenx((y0, y1), x0, x1, color=color, alpha=0.5, linewidth=1)
+    text = ax.text(x0, y1, func_name,
+        horizontalalignment='left',
+        verticalalignment='top',
+    )
+    return rect, text
 
 
 def function_labels(dotted_function_names):
"
mprof.py,mprof.py,1f3d7bd43d93d5e0686c4d800ae0212db284c81d,244382c46f12ad946011d2d33273f349bc00ceff,Made hover effect,"@@ -332,7 +332,6 @@ def read_mprofile_file(filename):
             values = value.split(' ')
             f_name, mem_start, start, mem_end, end = values[:5]
             ts = func_ts.get(f_name, [])
-            print(f_name, mem_start, start, mem_end, end)
             to_append = [float(start), float(end), float(mem_start), float(mem_end)]
             if len(values) >= 6:
                 # There is a stack level field
@@ -458,6 +457,12 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
     return mprofile
 
 
+
+FLAME_PLOTTER_VARS = {
+    'hovered_rect': None,
+    'alpha': None
+}
+
 def flame_plotter(filename, index=0, timestamps=True, children=True, options=None):
     try:
         import pylab as pl
@@ -565,32 +570,48 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                 x0 -= global_start
                 x1 -= global_start
                 color = next(colors[y0])
-                _rect, text = add_timestamp_rectangle(
+                rect, text = add_timestamp_rectangle(
                     timestamp_ax,
                     x0, x1, y0, y1, f,
                     color=color
                 )
-                rectangles[(x0, y0, x1, y1)] = (f, text)
+                rectangles[(x0, y0, x1, y1)] = (f, text, rect)
             func_num += 1
 
     def mouse_motion_handler(event):
+        print(FLAME_PLOTTER_VARS['hovered_rect'])
         x, y = event.xdata, event.ydata
-        if x is None or y is None:
-            return
+        if x is not None and y is not None:
+            for coord, (name, text, rect) in rectangles.items():
+                x0, y0, x1, y1 = coord
+                if x0 < x < x1 and y0 < y < y1:
+                    if FLAME_PLOTTER_VARS['hovered_rect'] == rect:
+                        return
 
-        for rect, func_name in rectangles.items():
-            x0, y0, x1, y1 = rect
-            if x0 < x < x1 and y0 < y < y1:
-                # pl.draw()
-                return
+                    if FLAME_PLOTTER_VARS['hovered_rect'] is not None:
+                        FLAME_PLOTTER_VARS['hovered_rect'].set_alpha(FLAME_PLOTTER_VARS['alpha'])
+                        FLAME_PLOTTER_VARS['hovered_rect'].set_linewidth(1)
+
+                    FLAME_PLOTTER_VARS['hovered_rect'] = rect
+                    FLAME_PLOTTER_VARS['alpha'] = rect.get_alpha()
+                    FLAME_PLOTTER_VARS['hovered_rect'].set_alpha(0.8)
+                    FLAME_PLOTTER_VARS['hovered_rect'].set_linewidth(3)
+                    pl.draw()
+                    return
+
+        if FLAME_PLOTTER_VARS['hovered_rect'] is not None:
+            FLAME_PLOTTER_VARS['hovered_rect'].set_alpha(FLAME_PLOTTER_VARS['alpha'])
+            FLAME_PLOTTER_VARS['hovered_rect'].set_linewidth(1)
+            pl.draw()
+            FLAME_PLOTTER_VARS['hovered_rect'] = None
 
     def mouse_click_handler(event):
         x, y = event.xdata, event.ydata
         if x is None or y is None:
             return
 
-        for rect, func_name in rectangles.items():
-            x0, y0, x1, y1 = rect
+        for coord, _ in rectangles.items():
+            x0, y0, x1, y1 = coord
             if x0 < x < x1 and y0 < y < y1:
                 toolbar = pl.gcf().canvas.toolbar
                 toolbar.push_current()
@@ -600,7 +621,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                 return
 
     pl.gcf().canvas.mpl_connect('motion_notify_event', mouse_motion_handler)
-    pl.gcf().canvas.mpl_connect('button_press_event', mouse_click_handler)
+    pl.gcf().canvas.mpl_connect('button_release_event', mouse_click_handler)
 
     if timestamps:
         pl.hlines(max_mem,
"
mprof.py,mprof.py,d077d1ea0866b8808847c6797093cf4ca5b54647,1f3d7bd43d93d5e0686c4d800ae0212db284c81d,Removed debug,"@@ -579,7 +579,6 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
             func_num += 1
 
     def mouse_motion_handler(event):
-        print(FLAME_PLOTTER_VARS['hovered_rect'])
         x, y = event.xdata, event.ydata
         if x is not None and y is not None:
             for coord, (name, text, rect) in rectangles.items():
"
mprof.py,mprof.py,284120ca31e4463c4b9dc90cabce9cf280760ecf,d077d1ea0866b8808847c6797093cf4ca5b54647,Improved zoom on click,"@@ -615,6 +615,7 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                 toolbar = pl.gcf().canvas.toolbar
                 toolbar.push_current()
                 timestamp_ax.set_xlim(x0, x1)
+                timestamp_ax.set_ylim(y0, stack_size + 1)
                 toolbar.push_current()
                 pl.draw()
                 return
"
mprof.py,mprof.py,eb2366c33ecd191fc973a79e480f067b39fa19cd,284120ca31e4463c4b9dc90cabce9cf280760ecf,Disabled hover effect when too many rectangles,"@@ -620,7 +620,9 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                 pl.draw()
                 return
 
-    pl.gcf().canvas.mpl_connect('motion_notify_event', mouse_motion_handler)
+    # Disable hovering if there are too many rectangle to prevent slow down
+    if len(rectangles) < 100:
+        pl.gcf().canvas.mpl_connect('motion_notify_event', mouse_motion_handler)
     pl.gcf().canvas.mpl_connect('button_release_event', mouse_click_handler)
 
     if timestamps:
"
mprof.py,mprof.py,7e8efb0ff4dfbbc86926a8bbe328a7da38dd01d3,eb2366c33ecd191fc973a79e480f067b39fa19cd,Importing memory_profiler without importlib,"@@ -13,8 +13,7 @@ from collections import defaultdict
 from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormatter
 
 import importlib
-mp = importlib.import_module(""memory_profiler"", __file__)
-# import memory_profiler as mp
+import memory_profiler as mp
 
 ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"")
 help_msg = """"""
"
memory_profiler.py,memory_profiler.py,6b5589840ce7479961d857d4e7c80143ec29fdf7,2c77549ed70c8cdbfa5d602376c8ada26704ba70,allow the usage of __file__ in the script and make sure its parent directory is in the path,"@@ -1119,7 +1119,15 @@ def choose_backend(new_backend=None):
 def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     from runpy import run_module
     builtins.__dict__['profile'] = profiler
-    ns = dict(_CLEAN_GLOBALS, profile=profiler)
+    ns = dict(_CLEAN_GLOBALS,
+              profile=profiler, 
+             # Make sure the __file__ variable is usable
+             # by the script we're profiling
+              __file__=filename)
+    # Make sure the script's directory in on sys.path
+    # credit to line_profiler
+    sys.path.insert(0, os.path.dirname(script_filename))
+    
     _backend = choose_backend(backend)
     sys.argv = [filename] + passed_args
     try:
"
mprof.py,mprof.py,6da24dda5554ee0071424b497e7eca58a423af7f,7e8efb0ff4dfbbc86926a8bbe328a7da38dd01d3,"Hiding function names, showing them only on hover","@@ -459,6 +459,7 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
 
 FLAME_PLOTTER_VARS = {
     'hovered_rect': None,
+    'hovered_text': None,
     'alpha': None
 }
 
@@ -498,7 +499,10 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     mem = mem[ind]
     t = t[ind]
 
-    stack_size = 1 + max(ex[4] for executions in ts.values() for ex in executions)
+    if ts:
+        stack_size = 1 + max(ex[4] for executions in ts.values() for ex in executions)
+    else:
+        stack_size = 0
     def level_to_saturation(level):
         return 1 - 0.75 * level / stack_size
 
@@ -588,20 +592,25 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
 
                     if FLAME_PLOTTER_VARS['hovered_rect'] is not None:
                         FLAME_PLOTTER_VARS['hovered_rect'].set_alpha(FLAME_PLOTTER_VARS['alpha'])
+                        FLAME_PLOTTER_VARS['hovered_text'].set_color((0, 0, 0, 0))
                         FLAME_PLOTTER_VARS['hovered_rect'].set_linewidth(1)
 
+                    FLAME_PLOTTER_VARS['hovered_text'] = text
                     FLAME_PLOTTER_VARS['hovered_rect'] = rect
                     FLAME_PLOTTER_VARS['alpha'] = rect.get_alpha()
                     FLAME_PLOTTER_VARS['hovered_rect'].set_alpha(0.8)
                     FLAME_PLOTTER_VARS['hovered_rect'].set_linewidth(3)
+                    FLAME_PLOTTER_VARS['hovered_text'].set_color((0, 0, 0, 1))
                     pl.draw()
                     return
 
         if FLAME_PLOTTER_VARS['hovered_rect'] is not None:
+            FLAME_PLOTTER_VARS['hovered_text'].set_color((0, 0, 0, 0))
             FLAME_PLOTTER_VARS['hovered_rect'].set_alpha(FLAME_PLOTTER_VARS['alpha'])
             FLAME_PLOTTER_VARS['hovered_rect'].set_linewidth(1)
             pl.draw()
             FLAME_PLOTTER_VARS['hovered_rect'] = None
+            FLAME_PLOTTER_VARS['hovered_text'] = None
 
     def mouse_click_handler(event):
         x, y = event.xdata, event.ydata
@@ -638,6 +647,7 @@ def add_timestamp_rectangle(ax, x0, x1, y0, y1, func_name, color='none'):
     text = ax.text(x0, y1, func_name,
         horizontalalignment='left',
         verticalalignment='top',
+        color=(0, 0, 0, 0)
     )
     return rect, text
 
"
mprof.py,mprof.py,375eb020345c776dfb1b6f04cb6b8f1f7070fcf3,6da24dda5554ee0071424b497e7eca58a423af7f,Remove right axis meaningless values; move label to left axis,"@@ -533,8 +533,10 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
     bottom += 0.001
     top -= 0.001
 
-    pl.gca().grid(True)
-    timestamp_ax = pl.twinx()
+    ax = pl.gca()
+    ax.grid(True)
+    timestamp_ax = ax.twinx()
+    timestamp_ax.set_yticks([])
     timestamp_ax.set_ylim((0, stack_size + 1))
     timestamp_ax.grid(False)
 
@@ -639,6 +641,9 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                   colors=""r"", linestyles=""--"")
         pl.vlines(t[max_mem_ind], bottom, top,
                   colors=""r"", linestyles=""--"")
+
+    pl.sca(ax)
+
     return mprofile
 
 
"
README.rst,README.rst,c7c16dedc6a1da1a0f3c5b551437ccb471aa0eb4,375eb020345c776dfb1b6f04cb6b8f1f7070fcf3,Write a line about --flame and add an image,"@@ -150,6 +150,11 @@ afterward will plot the result, making plots (using matplotlib) similar to these
    :target: https://github.com/scikit-learn/scikit-learn/pull/2248
    :height: 350px
 
+or, with the ``--flame`` option (``mprof plot --flame``):
+
+.. image:: images/flamegraph.py
+   :height: 350px
+
 A discussion of these capabilities can be found `here <http://fa.bianp.net/blog/2014/plot-memory-usage-as-a-function-of-time/>`_.
 
 .. warning:: If your Python file imports the memory profiler `from memory_profiler import profile` these timestamps will not be recorded. Comment out the import, leave your functions decorated, and re-run.
"
images/flamegraph.png,images/flamegraph.png,c7c16dedc6a1da1a0f3c5b551437ccb471aa0eb4,375eb020345c776dfb1b6f04cb6b8f1f7070fcf3,Write a line about --flame and add an image,"Binary files /dev/null and b/images/flamegraph.png differ
"
README.rst,README.rst,054300cd93af4e47c2a54260b2020c7c59d8812c,c7c16dedc6a1da1a0f3c5b551437ccb471aa0eb4,Update README.rst,"@@ -150,9 +150,9 @@ afterward will plot the result, making plots (using matplotlib) similar to these
    :target: https://github.com/scikit-learn/scikit-learn/pull/2248
    :height: 350px
 
-or, with the ``--flame`` option (``mprof plot --flame``):
+or, with ``mprof plot --flame`` (the function and timestamp names will appear on hover):
 
-.. image:: images/flamegraph.py
+.. image:: ./images/flamegraph.png
    :height: 350px
 
 A discussion of these capabilities can be found `here <http://fa.bianp.net/blog/2014/plot-memory-usage-as-a-function-of-time/>`_.
"
mprof.py,mprof.py,85976ed13a35f6ae0863d5b0927375f81365a4ec,054300cd93af4e47c2a54260b2020c7c59d8812c,Define handlers earlier,"@@ -562,27 +562,6 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
         pl.vlines(cmpoint[0], pl.ylim()[0]+0.001, pl.ylim()[1] - 0.001, 'r', '--')
         pl.hlines(cmpoint[1], pl.xlim()[0]+0.001, pl.xlim()[1] - 0.001, 'r', '--')
 
-    # plot timestamps, if any
-    if len(ts) > 0 and timestamps:
-        func_num = 0
-        f_labels = function_labels(ts.keys())
-        rectangles = {}
-        for f, exec_ts in ts.items():
-            for execution in exec_ts:
-                x0, x1 = execution[:2]
-                y0 = execution[4]
-                y1 = y0 + 1
-                x0 -= global_start
-                x1 -= global_start
-                color = next(colors[y0])
-                rect, text = add_timestamp_rectangle(
-                    timestamp_ax,
-                    x0, x1, y0, y1, f,
-                    color=color
-                )
-                rectangles[(x0, y0, x1, y1)] = (f, text, rect)
-            func_num += 1
-
     def mouse_motion_handler(event):
         x, y = event.xdata, event.ydata
         if x is not None and y is not None:
@@ -630,10 +609,31 @@ def flame_plotter(filename, index=0, timestamps=True, children=True, options=Non
                 pl.draw()
                 return
 
-    # Disable hovering if there are too many rectangle to prevent slow down
-    if len(rectangles) < 100:
-        pl.gcf().canvas.mpl_connect('motion_notify_event', mouse_motion_handler)
-    pl.gcf().canvas.mpl_connect('button_release_event', mouse_click_handler)
+    # plot timestamps, if any
+    if len(ts) > 0 and timestamps:
+        func_num = 0
+        f_labels = function_labels(ts.keys())
+        rectangles = {}
+        for f, exec_ts in ts.items():
+            for execution in exec_ts:
+                x0, x1 = execution[:2]
+                y0 = execution[4]
+                y1 = y0 + 1
+                x0 -= global_start
+                x1 -= global_start
+                color = next(colors[y0])
+                rect, text = add_timestamp_rectangle(
+                    timestamp_ax,
+                    x0, x1, y0, y1, f,
+                    color=color
+                )
+                rectangles[(x0, y0, x1, y1)] = (f, text, rect)
+            func_num += 1
+
+        # Disable hovering if there are too many rectangle to prevent slow down
+        if len(rectangles) < 100:
+            pl.gcf().canvas.mpl_connect('motion_notify_event', mouse_motion_handler)
+        pl.gcf().canvas.mpl_connect('button_release_event', mouse_click_handler)
 
     if timestamps:
         pl.hlines(max_mem,
"
mprof.py,mprof.py,68812af610b769d434dc0c46be3e6d6e3a400fec,e3fc5eeca800ae9aba3bb373c2d045a5c4767cb9,BUG: Set ioff to avoid immediate close,"@@ -202,7 +202,7 @@ This file contains the process memory consumption, in Mb (one value per line).""""
                              'Option 4: (--python flag present) ""<PYTHON_MODULE> <ARG1> <ARG2>..."" - profile python module\n'
                         )
     args = parser.parse_args()
-    
+
     if len(args.program) == 0:
         print(""A program to run must be provided. Use -h for help"")
         sys.exit(1)
@@ -517,6 +517,7 @@ such file in the current directory.""""""
         print(""matplotlib is needed for plotting."")
         print(e)
         sys.exit(1)
+    pl.ioff()
 
     profiles = glob.glob(""mprofile_??????????????.dat"")
     profiles.sort()
"
memory_profiler.py,memory_profiler.py,3b5e7f2c276961764419d28df8035f63e9622361,e3fc5eeca800ae9aba3bb373c2d045a5c4767cb9,FIX: Order of subselection,"@@ -335,11 +335,11 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 parent_conn.send(0)  # finish timing
                 ret = parent_conn.recv()
                 n_measurements = parent_conn.recv()
-                if retval:
-                    ret = ret, returned
                 if max_usage:
                     # Convert the one element list produced by MemTimer to a singular value
                     ret = ret[0]
+                if retval:
+                    ret = ret, returned
             except Exception:
                 parent = psutil.Process(os.getpid())
                 for child in parent.children(recursive=True):
@@ -1120,14 +1120,14 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     from runpy import run_module
     builtins.__dict__['profile'] = profiler
     ns = dict(_CLEAN_GLOBALS,
-              profile=profiler, 
+              profile=profiler,
              # Make sure the __file__ variable is usable
              # by the script we're profiling
               __file__=filename)
     # Make sure the script's directory in on sys.path
     # credit to line_profiler
     sys.path.insert(0, os.path.dirname(script_filename))
-    
+
     _backend = choose_backend(backend)
     sys.argv = [filename] + passed_args
     try:
"
README.rst,README.rst,9e95cec1568dd95ad2c1092c07e039947228c787,8b01378de1b7f46c610b23a538422dc5a47fdfc1,Add documentation regarding plot settings,"@@ -202,6 +202,19 @@ the total memory of the program as well as each child individually. If using
 the API directly, note that the return from ``memory_usage`` will include the
 child memory in a nested list along with the main process memory.
 
+Plot settings
+===============================
+
+By default, the command line call is set as the graph title. If you wish to customize it, you can use the ``-t`` option to manually set the figure title.
+
+
+    mprof plot -t 'Recorded memory usage'
+
+You can also hide the function timestamps using the ``n`` flag, such as
+
+    mprof plot -n
+
+
 Setting debugger breakpoints
 =============================
 It is possible to set breakpoints depending on the amount of memory used.
"
memory_profiler.py,memory_profiler.py,0587774307774595eade429af329f5304381d776,ad64e49aed8db710b0b8ae8cd1694b5f95ab5540,Handle unicode files in a Python 2 and 3 compatible fassion using io.open,"@@ -12,6 +12,7 @@ import inspect
 import linecache
 import logging
 import os
+from io import open
 import pdb
 import subprocess
 import sys
@@ -20,6 +21,7 @@ import traceback
 import warnings
 import contextlib
 
+
 if sys.platform == ""win32"":
     # any value except signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT
     # can be used to kill a process unconditionally in Windows
"
test/test_unicode.py,test/test_unicode.py,0587774307774595eade429af329f5304381d776,ad64e49aed8db710b0b8ae8cd1694b5f95ab5540,Handle unicode files in a Python 2 and 3 compatible fassion using io.open,"@@ -1,5 +1,4 @@
 # -*- coding: utf-8  -*-
-# run only for Python 2.xx
 @profile
 def test_unicode(txt):
     # test when unicode is present
"
memory_profiler.py,memory_profiler.py,f315e196cfbec146ea94ebe964a43ba646571597,0587774307774595eade429af329f5304381d776,make sure file is opened in rb,"@@ -1164,7 +1164,7 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     try:
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
-        with open(filename) as f:
+        with open(filename, 'rb') as f:
             exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
         if has_tracemalloc and tracemalloc.is_tracing():
"
memory_profiler.py,memory_profiler.py,fdf4488ffe42c588bfa632537e9a959e4b36bf83,ad64e49aed8db710b0b8ae8cd1694b5f95ab5540,added max_iterations parameter to memory_usage function; added corresponding test case,"@@ -238,7 +238,7 @@ class MemTimer(Process):
 
 def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                  include_children=False, multiprocess=False, max_usage=False,
-                 retval=False, stream=None, backend=None):
+                 retval=False, stream=None, backend=None, max_iterations=None):
     """"""
     Return the memory usage of a process or piece of code
 
@@ -307,6 +307,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
     else:
         # for a Python function wait until it finishes
         max_iter = float('inf')
+        if max_iterations is not None:
+            max_iter = max_iterations
 
     if callable(proc):
         proc = (proc, (), {})
@@ -320,7 +322,9 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         else:
             raise ValueError
 
+        current_iter = 0
         while True:
+            current_iter += 1
             child_conn, parent_conn = Pipe()  # this will store MemTimer's results
             p = MemTimer(os.getpid(), interval, child_conn, backend,
                          timestamps=timestamps,
@@ -349,7 +353,8 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 raise
 
             p.join(5 * interval)
-            if n_measurements > 4 or interval < 1e-6:
+            
+            if (n_measurements > 4) or (current_iter == max_iter) or (interval < 1e-6):
                 break
             interval /= 10.
     elif isinstance(proc, subprocess.Popen):
"
test/test_memory_usage.py,test/test_memory_usage.py,fdf4488ffe42c588bfa632537e9a959e4b36bf83,ad64e49aed8db710b0b8ae8cd1694b5f95ab5540,added max_iterations parameter to memory_usage function; added corresponding test case,"@@ -1,4 +1,5 @@
 from memory_profiler import memory_usage
+import os
 
 
 def some_func(*args, **kwargs):
@@ -10,6 +11,20 @@ def test_memory_usage():
     mem, ret = memory_usage((some_func, (1, 2), dict(a=1)), retval=True)
     assert ret[0] == (1, 2)
     assert ret[1] == dict(a=1)
+    
+    
+def write_line(filepath):
+    with open(filepath, 'a') as the_file:
+        the_file.write('Testing\n')
+
+def test_max_iterations():
+    # Check that memory_usage works with max_iterations set (for python functions).
+    this_dir = os.path.dirname(os.path.realpath(__file__))
+    file = os.path.join(this_dir, 'temp_test_max_iterations_file.txt')
+    mem = memory_usage((write_line, (file, ), dict()), max_usage=True, max_iterations=1)
+    n_lines = sum(1 for line in open(file))
+    os.remove(file)
+    assert n_lines == 1
 
 
 def test_return_value_consistency():
@@ -27,4 +42,5 @@ def test_return_value_consistency():
 
 if __name__ == ""__main__"":
     test_memory_usage()
+    test_max_iterations()
     test_return_value_consistency()
"
memory_profiler.py,memory_profiler.py,0266baae7c03f149759d16710c2a5d7b84add3d0,fdf4488ffe42c588bfa632537e9a959e4b36bf83,added max_iterations to memory_usage docstring,"@@ -280,6 +280,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         to this file instead of stored in memory and returned at the end of
         the subprocess. Useful for long-running processes.
         Implies timestamps=True.
+        
+    max_iterations : int
+        Limits the number of iterations (calls to the process being monitored). Relevent
+        when the process is a python function. 
 
     Returns
     -------
"
setup.py,setup.py,2dcb23ea33fe853d72bad9f2db8debac625e9b09,f10af516da31180e1df9692f00ca2345acab581e,"link from PyPI to github

it's useless using the PyPI project url in setup.py because it's only used on the PyPI page","@@ -46,7 +46,7 @@ setup(
     version=find_version(""memory_profiler.py""),
     author='Fabian Pedregosa',
     author_email='f@bianp.net',
-    url='http://pypi.python.org/pypi/memory_profiler',
+    url='https://github.com/pythonprofilers/memory_profiler',
     py_modules=['memory_profiler', 'mprof'],
     entry_points={
         'console_scripts' : ['mprof = mprof:main'],
"
memory_profiler.py,memory_profiler.py,e46f82e9ce5b58c8e1b0d7dc9985837378805fae,0e4d0eaef27898f852ca0ca57746f49a106f84e0,Add iscoroutine with replacement for older pythons,"@@ -29,6 +29,16 @@ else:
 import psutil
 
 
+if sys.version_info > (3, 3):
+    if sys.version_info < (3, 5):
+        from asyncio import iscoroutinefunction
+    else:
+        from inspect import iscoroutinefunction
+else:
+    def iscoroutinefunction(_):
+        return False
+
+
 # TODO: provide alternative when multiprocessing is not available
 try:
     from multiprocessing import Process, Pipe
"
setup.py,setup.py,71a61fb0b1d4b8b5ebf6deb6cb6462e4479adbad,e46f82e9ce5b58c8e1b0d7dc9985837378805fae,Include version-specific module with async support,"@@ -1,6 +1,7 @@
 import os
 import io
 import re
+import sys
 from setuptools import setup
 
 
@@ -21,6 +22,14 @@ def find_version(*file_paths):
         return version_match.group(1)
 
 
+async_modules = []
+if sys.version_info > (3, 3):
+    if sys.version_info < (3, 5):
+        async_modules = ['_aio_34']
+    else:
+        async_modules = ['_aio_35']
+
+
 CLASSIFIERS = """"""\
 Development Status :: 5 - Production/Stable
 Intended Audience :: Science/Research
@@ -39,6 +48,7 @@ Operating System :: Unix
 
 """"""
 
+
 setup(
     name='memory_profiler',
     description='A module for monitoring memory usage of a python program',
@@ -47,7 +57,7 @@ setup(
     author='Fabian Pedregosa',
     author_email='f@bianp.net',
     url='https://github.com/pythonprofilers/memory_profiler',
-    py_modules=['memory_profiler', 'mprof'],
+    py_modules=['memory_profiler', 'mprof'] + async_modules,
     entry_points={
         'console_scripts' : ['mprof = mprof:main'],
     },
"
,_aio_34.py,d65fb3cf2fc65e16cb9c49df2fa0dc3371fc4722,71a61fb0b1d4b8b5ebf6deb6cb6462e4479adbad,Wrapper and profiler for 3.4 coroutines,"@@ -0,0 +1,35 @@
+from asyncio import coroutine, iscoroutinefunction
+from contextlib import contextmanager
+from functools import wraps
+
+from memory_profiler import LineProfiler, show_results
+
+
+class CoroLineProfiler(LineProfiler):
+    @contextmanager
+    def count_contextmgr(self):
+        self.enable_by_count()
+        try:
+            yield
+        finally:
+            self.disable_by_count()
+
+    def wrap_function(self, func):
+        if iscoroutinefunction(func):
+            @coroutine
+            def f(*args, **kwargs):
+                with self.count_contextmgr():
+                    yield from func(*args, **kwargs)
+            return f
+        else:
+            return super(CoroLineProfiler, self).wrap_function(func)
+
+
+def _get_coro_wrapper(coro, backend, stream, precision):
+    @wraps(coro)
+    @coroutine
+    def wrapper(*args, **kwargs):
+        prof = CoroLineProfiler(backend=backend)
+        val = yield from prof(coro)(*args, **kwargs)
+        show_results(prof, stream=stream, precision=precision)
+        return val
"
memory_profiler.py,memory_profiler.py,1a853e5b1342788fdd6ab55cfe6c568e3b307349,0e4d0eaef27898f852ca0ca57746f49a106f84e0,new version,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.55.0'
+__version__ = '0.56.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
memory_profiler.py,memory_profiler.py,11353651f285c5e06475f097692003872d092548,1a853e5b1342788fdd6ab55cfe6c568e3b307349,"Pass the value of --include-children to TimeStamper

This fixes an issue with FUNC lines reporting lower memory usage than
MEM lines.","@@ -470,12 +470,14 @@ def _find_script(script_name):
 class _TimeStamperCM(object):
     """"""Time-stamping context manager.""""""
 
-    def __init__(self, timestamps, filename, backend, timestamper=None, func=None):
+    def __init__(self, timestamps, filename, backend, timestamper=None, func=None,
+                 include_children=False):
         self.timestamps = timestamps
         self.filename = filename
         self.backend = backend
         self.ts = timestamper
         self.func = func
+        self.include_children = include_children
 
     def __enter__(self):
         if self.ts is not None:
@@ -483,14 +485,16 @@ class _TimeStamperCM(object):
             self.ts.stack[self.func].append(self.ts.current_stack_level)
 
         self.timestamps.append(
-            _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
+            _get_memory(os.getpid(), self.backend, timestamps=True,
+                        include_children=self.include_children, filename=self.filename))
 
     def __exit__(self, *args):
         if self.ts is not None:
             self.ts.current_stack_level -= 1
 
         self.timestamps.append(
-            _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
+            _get_memory(os.getpid(), self.backend, timestamps=True,
+                        include_children=self.include_children, filename=self.filename))
 
 
 class TimeStamper:
@@ -498,9 +502,10 @@ class TimeStamper:
     any decorated function.
     """"""
 
-    def __init__(self, backend):
+    def __init__(self, backend, include_children=False):
         self.functions = {}
         self.backend = backend
+        self.include_children = include_children
         self.current_stack_level = -1
         self.stack = {}
 
@@ -561,7 +566,8 @@ class TimeStamper:
             except TypeError:
                 filename = '<unknown>'
             timestamps = [
-                _get_memory(os.getpid(), self.backend, timestamps=True, filename=filename)]
+                _get_memory(os.getpid(), self.backend, timestamps=True,
+                            include_children=self.include_children, filename=filename)]
             self.functions[func].append(timestamps)
             try:
                 with self.call_on_stack(func, *args, **kwds) as result:
@@ -569,6 +575,7 @@ class TimeStamper:
             finally:
                 # end time
                 timestamps.append(_get_memory(os.getpid(), self.backend, timestamps=True,
+                                              include_children=self.include_children,
                                               filename=filename))
 
         return f
@@ -1248,6 +1255,9 @@ if __name__ == '__main__':
         action='store_true',
         help='''print timestamp instead of memory measurement for
         decorated functions''')
+    parser.add_argument('--include-children', dest='include_children',
+        default=False, action='store_true',
+        help='also include memory used by child processes')
     parser.add_argument('--backend', dest='backend', type=str, action='store',
         choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
         help='backend using for getting memory info '
@@ -1264,7 +1274,7 @@ if __name__ == '__main__':
     script_args = args.program[1:]
     _backend = choose_backend(args.backend)
     if args.timestamp:
-        prof = TimeStamper(_backend)
+        prof = TimeStamper(_backend, include_children=args.include_children)
     else:
         prof = LineProfiler(max_mem=args.max_mem, backend=_backend)
 
"
mprof.py,mprof.py,11353651f285c5e06475f097692003872d092548,1a853e5b1342788fdd6ab55cfe6c568e3b307349,"Pass the value of --include-children to TimeStamper

This fixes an issue with FUNC lines reporting lower memory usage than
MEM lines.","@@ -230,8 +230,10 @@ This file contains the process memory consumption, in Mb (one value per line).""""
         if not program[0].startswith(""python""):
             program.insert(0, sys.executable)
         cmd_line = get_cmd_line(program)
-        program[1:1] = (""-m"", ""memory_profiler"", ""--timestamp"",
-                        ""-o"", mprofile_output)
+        extra_args = [""-m"", ""memory_profiler"", ""--timestamp"", ""-o"", mprofile_output]
+        if args.include_children:
+            extra_args.append(""--include-children"")
+        program[1:1] = extra_args
         p = subprocess.Popen(program)
     else:
         cmd_line = get_cmd_line(program)
"
memory_profiler.py,memory_profiler/__init__.py,891d56ea3c88c4a5b540ece4e2848885277f9564,d65fb3cf2fc65e16cb9c49df2fa0dc3371fc4722,Convert module to package,"@@ -5,14 +5,11 @@ _CLEAN_GLOBALS = globals().copy()
 
 __version__ = '0.55.0'
 
-_CMD_USAGE = ""python -m memory_profiler script_file.py""
 
 from functools import wraps
 import inspect
-import linecache
 import logging
 import os
-import pdb
 import subprocess
 import sys
 import time
@@ -20,6 +17,16 @@ import traceback
 import warnings
 import contextlib
 
+from .common import PY2, HAS_TRACEMALLOC
+from .utils import (
+    show_results,
+    choose_backend,
+    get_memory as _get_memory,
+    get_child_memory as _get_child_memory,
+)
+from .line_profiler import LineProfiler
+
+
 if sys.platform == ""win32"":
     # any value except signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT
     # can be used to kill a process unconditionally in Windows
@@ -29,16 +36,6 @@ else:
 import psutil
 
 
-if sys.version_info > (3, 3):
-    if sys.version_info < (3, 5):
-        from asyncio import iscoroutinefunction
-    else:
-        from inspect import iscoroutinefunction
-else:
-    def iscoroutinefunction(_):
-        return False
-
-
 # TODO: provide alternative when multiprocessing is not available
 try:
     from multiprocessing import Process, Pipe
@@ -53,10 +50,6 @@ except ImportError:
     line_cell_magic = lambda func: func
     magics_class = lambda cls: cls
 
-PY2 = sys.version_info[0] == 2
-
-_TWO_20 = float(2 ** 20)
-
 if PY2:
     import __builtin__ as builtins
     to_str = lambda x: x
@@ -65,14 +58,9 @@ else:
     import builtins
     to_str = lambda x: str(x)
 
-# .. get available packages ..
-try:
+if HAS_TRACEMALLOC:
     import tracemalloc
 
-    has_tracemalloc = True
-except ImportError:
-    has_tracemalloc = False
-
 
 class MemitResult(object):
     """"""memit magic run details.
@@ -99,108 +87,6 @@ class MemitResult(object):
         p.text(u'<MemitResult : ' + msg + u'>')
 
 
-def _get_child_memory(process, meminfo_attr=None):
-    """"""
-    Returns a generator that yields memory for all child processes.
-    """"""
-    # Convert a pid to a process
-    if isinstance(process, int):
-        if process == -1: process = os.getpid()
-        process = psutil.Process(process)
-
-    if not meminfo_attr:
-        # Use the psutil 2.0 attr if the older version isn't passed in.
-        meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
-
-    # Select the psutil function get the children similar to how we selected
-    # the memory_info attr (a change from excepting the AttributeError).
-    children_attr = 'children' if hasattr(process, 'children') else 'get_children'
-
-    # Loop over the child processes and yield their memory
-    try:
-        for child in getattr(process, children_attr)(recursive=True):
-            yield getattr(child, meminfo_attr)()[0] / _TWO_20
-    except (psutil.NoSuchProcess, psutil.AccessDenied):
-        # https://github.com/fabianp/memory_profiler/issues/71
-        yield 0.0
-
-
-def _get_memory(pid, backend, timestamps=False, include_children=False, filename=None):
-    # .. low function to get memory consumption ..
-    if pid == -1:
-        pid = os.getpid()
-
-    def tracemalloc_tool():
-        # .. cross-platform but but requires Python 3.4 or higher ..
-        stat = next(filter(lambda item: str(item).startswith(filename),
-                           tracemalloc.take_snapshot().statistics('filename')))
-        mem = stat.size / _TWO_20
-        if timestamps:
-            return mem, time.time()
-        else:
-            return mem
-
-    def ps_util_tool():
-        # .. cross-platform but but requires psutil ..
-        process = psutil.Process(pid)
-        try:
-            # avoid using get_memory_info since it does not exists
-            # in psutil > 2.0 and accessing it will cause exception.
-            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') \
-                else 'get_memory_info'
-            mem = getattr(process, meminfo_attr)()[0] / _TWO_20
-            if include_children:
-                mem +=  sum(_get_child_memory(process, meminfo_attr))
-            if timestamps:
-                return mem, time.time()
-            else:
-                return mem
-        except psutil.AccessDenied:
-            pass
-            # continue and try to get this from ps
-
-    def posix_tool():
-        # .. scary stuff ..
-        if include_children:
-            raise NotImplementedError((
-                ""The psutil module is required to monitor the ""
-                ""memory usage of child processes.""
-            ))
-
-        warnings.warn(""psutil module not found. memory_profiler will be slow"")
-        # ..
-        # .. memory usage in MiB ..
-        # .. this should work on both Mac and Linux ..
-        # .. subprocess.check_output appeared in 2.7, using Popen ..
-        # .. for backwards compatibility ..
-        out = subprocess.Popen(['ps', 'v', '-p', str(pid)],
-                               stdout=subprocess.PIPE
-                               ).communicate()[0].split(b'\n')
-        try:
-            vsz_index = out[0].split().index(b'RSS')
-            mem = float(out[1].split()[vsz_index]) / 1024
-            if timestamps:
-                return mem, time.time()
-            else:
-                return mem
-        except:
-            if timestamps:
-                return -1, time.time()
-            else:
-                return -1
-
-    if backend == 'tracemalloc' and \
-            (filename is None or filename == '<unknown>'):
-        raise RuntimeError(
-            'There is no access to source file of the profiled function'
-        )
-
-    tools = {'tracemalloc': tracemalloc_tool,
-             'psutil': ps_util_tool,
-             'posix': posix_tool}
-    return tools[backend]()
-
-
 class MemTimer(Process):
     """"""
     Fetch memory consumption from over a time interval
@@ -458,23 +344,6 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 # .. utility functions for line-by-line ..
 
 
-def _find_script(script_name):
-    """""" Find the script.
-
-    If the input is not a file, then $PATH will be searched.
-    """"""
-    if os.path.isfile(script_name):
-        return script_name
-    path = os.getenv('PATH', os.defpath).split(os.pathsep)
-    for folder in path:
-        if not folder:
-            continue
-        fn = os.path.join(folder, script_name)
-        if os.path.isfile(fn):
-            return fn
-
-    sys.stderr.write('Could not find script {0}\n'.format(script_name))
-    raise SystemExit(1)
 
 
 class _TimeStamperCM(object):
@@ -603,234 +472,6 @@ class TimeStamper:
                     (function_name,) + ts[0] + ts[1] + (level,)))
 
 
-class CodeMap(dict):
-    def __init__(self, include_children, backend):
-        self.include_children = include_children
-        self._toplevel = []
-        self.backend = backend
-
-    def add(self, code, toplevel_code=None):
-        if code in self:
-            return
-
-        if toplevel_code is None:
-            filename = code.co_filename
-            if filename.endswith(("".pyc"", "".pyo"")):
-                filename = filename[:-1]
-            if not os.path.exists(filename):
-                print('ERROR: Could not find file ' + filename)
-                if filename.startswith((""ipython-input"", ""<ipython-input"")):
-                    print(
-                        ""NOTE: %mprun can only be used on functions defined in""
-                        "" physical files, and not in the IPython environment."")
-                return
-
-            toplevel_code = code
-            (sub_lines, start_line) = inspect.getsourcelines(code)
-            linenos = range(start_line,
-                            start_line + len(sub_lines))
-            self._toplevel.append((filename, code, linenos))
-            self[code] = {}
-        else:
-            self[code] = self[toplevel_code]
-
-        for subcode in filter(inspect.iscode, code.co_consts):
-            self.add(subcode, toplevel_code=toplevel_code)
-
-    def trace(self, code, lineno, prev_lineno):
-        memory = _get_memory(-1, self.backend, include_children=self.include_children,
-                             filename=code.co_filename)
-        prev_value = self[code].get(lineno, None)
-        previous_memory = prev_value[1] if prev_value else 0
-        previous_inc = prev_value[0] if prev_value else 0
-
-        prev_line_value = self[code].get(prev_lineno, None) if prev_lineno else None
-        prev_line_memory = prev_line_value[1] if prev_line_value else 0
-        self[code][lineno] = (max(previous_inc, memory-prev_line_memory), max(memory, previous_memory))
-
-    def items(self):
-        """"""Iterate on the toplevel code blocks.""""""
-        for (filename, code, linenos) in self._toplevel:
-            measures = self[code]
-            if not measures:
-                continue  # skip if no measurement
-            line_iterator = ((line, measures.get(line)) for line in linenos)
-            yield (filename, line_iterator)
-
-
-class LineProfiler(object):
-    """""" A profiler that records the amount of memory for each line """"""
-
-    def __init__(self, **kw):
-        include_children = kw.get('include_children', False)
-        backend = kw.get('backend', 'psutil')
-        self.code_map = CodeMap(
-            include_children=include_children, backend=backend)
-        self.enable_count = 0
-        self.max_mem = kw.get('max_mem', None)
-        self.prevlines = []
-        self.backend = choose_backend(kw.get('backend', None))
-        self.prev_lineno = None
-
-    def __call__(self, func=None, precision=1):
-        if func is not None:
-            self.add_function(func)
-            f = self.wrap_function(func)
-            f.__module__ = func.__module__
-            f.__name__ = func.__name__
-            f.__doc__ = func.__doc__
-            f.__dict__.update(getattr(func, '__dict__', {}))
-            return f
-        else:
-            def inner_partial(f):
-                return self.__call__(f, precision=precision)
-
-            return inner_partial
-
-    def add_function(self, func):
-        """""" Record line profiling information for the given Python function.
-        """"""
-        try:
-            # func_code does not exist in Python3
-            code = func.__code__
-        except AttributeError:
-            warnings.warn(""Could not extract a code object for the object %r""
-                          % func)
-        else:
-            self.code_map.add(code)
-
-    def wrap_function(self, func):
-        """""" Wrap a function to profile it.
-        """"""
-
-        def f(*args, **kwds):
-            self.enable_by_count()
-            try:
-                return func(*args, **kwds)
-            finally:
-                self.disable_by_count()
-
-        return f
-
-    def runctx(self, cmd, globals, locals):
-        """""" Profile a single executable statement in the given namespaces.
-        """"""
-        self.enable_by_count()
-        try:
-            exec(cmd, globals, locals)
-        finally:
-            self.disable_by_count()
-        return self
-
-    def enable_by_count(self):
-        """""" Enable the profiler if it hasn't been enabled before.
-        """"""
-        if self.enable_count == 0:
-            self.enable()
-        self.enable_count += 1
-
-    def disable_by_count(self):
-        """""" Disable the profiler if the number of disable requests matches the
-        number of enable requests.
-        """"""
-        if self.enable_count > 0:
-            self.enable_count -= 1
-            if self.enable_count == 0:
-                self.disable()
-
-    def trace_memory_usage(self, frame, event, arg):
-        """"""Callback for sys.settrace""""""
-        if frame.f_code in self.code_map:
-            if event == 'call':
-                # ""call"" event just saves the lineno but not the memory
-                self.prevlines.append(frame.f_lineno)
-            elif event == 'line':
-                # trace needs current line and previous line
-                self.code_map.trace(frame.f_code, self.prevlines[-1], self.prev_lineno)
-                # saving previous line
-                self.prev_lineno = self.prevlines[-1]
-                self.prevlines[-1] = frame.f_lineno
-            elif event == 'return':
-                lineno = self.prevlines.pop()
-                self.code_map.trace(frame.f_code, lineno, self.prev_lineno)
-                self.prev_lineno = lineno
-
-        if self._original_trace_function is not None:
-            self._original_trace_function(frame, event, arg)
-
-        return self.trace_memory_usage
-
-    def trace_max_mem(self, frame, event, arg):
-        # run into PDB as soon as memory is higher than MAX_MEM
-        if event in ('line', 'return') and frame.f_code in self.code_map:
-            c = _get_memory(-1, self.backend, filename=frame.f_code.co_filename)
-            if c >= self.max_mem:
-                t = ('Current memory {0:.2f} MiB exceeded the '
-                     'maximum of {1:.2f} MiB\n'.format(c, self.max_mem))
-                sys.stdout.write(t)
-                sys.stdout.write('Stepping into the debugger \n')
-                frame.f_lineno -= 2
-                p = pdb.Pdb()
-                p.quitting = False
-                p.stopframe = frame
-                p.returnframe = None
-                p.stoplineno = frame.f_lineno - 3
-                p.botframe = None
-                return p.trace_dispatch
-
-        if self._original_trace_function is not None:
-            (self._original_trace_function)(frame, event, arg)
-
-        return self.trace_max_mem
-
-    def __enter__(self):
-        self.enable_by_count()
-
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        self.disable_by_count()
-
-    def enable(self):
-        self._original_trace_function = sys.gettrace()
-        if self.max_mem is not None:
-            sys.settrace(self.trace_max_mem)
-        else:
-            sys.settrace(self.trace_memory_usage)
-
-    def disable(self):
-        sys.settrace(self._original_trace_function)
-
-
-def show_results(prof, stream=None, precision=1):
-    if stream is None:
-        stream = sys.stdout
-    template = '{0:>6} {1:>12} {2:>12}   {3:<}'
-
-    for (filename, lines) in prof.code_map.items():
-        header = template.format('Line #', 'Mem usage', 'Increment',
-                                 'Line Contents')
-
-        stream.write(u'Filename: ' + filename + '\n\n')
-        stream.write(header + u'\n')
-        stream.write(u'=' * len(header) + '\n')
-
-        all_lines = linecache.getlines(filename)
-
-        float_format = u'{0}.{1}f'.format(precision + 4, precision)
-        template_mem = u'{0:' + float_format + '} MiB'
-        for (lineno, mem) in lines:
-            if mem:
-                inc = mem[0]
-                mem = mem[1]
-                mem = template_mem.format(mem)
-                inc = template_mem.format(inc)
-            else:
-                mem = u''
-                inc = u''
-            tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
-            stream.write(to_str(tmp))
-        stream.write(u'\n\n')
-
-
 def _func_exec(stmt, ns):
     # helper for magic_memit, just a function proxy for the exec
     # statement
@@ -1113,7 +754,7 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
     Decorator that will run the function and print a line-by-line profile
     """"""
     backend = choose_backend(backend)
-    if backend == 'tracemalloc' and has_tracemalloc:
+    if backend == 'tracemalloc' and HAS_TRACEMALLOC:
         if not tracemalloc.is_tracing():
             tracemalloc.start()
     if func is not None:
@@ -1133,58 +774,32 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
         return inner_wrapper
 
 
-def choose_backend(new_backend=None):
-    """"""
-    Function that tries to setup backend, chosen by user, and if failed,
-    setup one of the allowable backends
-    """"""
-
-    _backend = 'no_backend'
-    all_backends = [
-        ('psutil', True),
-        ('posix', os.name == 'posix'),
-        ('tracemalloc', has_tracemalloc),
-    ]
-    backends_indices = dict((b[0], i) for i, b in enumerate(all_backends))
-
-    if new_backend is not None:
-        all_backends.insert(0, all_backends.pop(backends_indices[new_backend]))
-
-    for n_backend, is_available in all_backends:
-        if is_available:
-            _backend = n_backend
-            break
-    if _backend != new_backend and new_backend is not None:
-        warnings.warn('{0} can not be used, {1} used instead'.format(
-            new_backend, _backend))
-    return _backend
-
-
 # Insert in the built-ins to have profile
 # globally defined (global variables is not enough
 # for all cases, e.g. a script that imports another
 # script where @profile is used)
 def exec_with_profiler(filename, profiler, backend, passed_args=[]):
-    from runpy import run_module
     builtins.__dict__['profile'] = profiler
-    ns = dict(_CLEAN_GLOBALS,
-              profile=profiler,
-             # Make sure the __file__ variable is usable
-             # by the script we're profiling
-              __file__=filename)
+    ns = dict(
+        _CLEAN_GLOBALS,
+        profile=profiler,
+        # Make sure the __file__ variable is usable
+        # by the script we're profiling
+        __file__=filename
+    )
     # Make sure the script's directory in on sys.path
     # credit to line_profiler
-    sys.path.insert(0, os.path.dirname(script_filename))
+    sys.path.insert(0, os.path.dirname(filename))
 
     _backend = choose_backend(backend)
     sys.argv = [filename] + passed_args
     try:
-        if _backend == 'tracemalloc' and has_tracemalloc:
+        if _backend == 'tracemalloc' and HAS_TRACEMALLOC:
             tracemalloc.start()
         with open(filename) as f:
             exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
-        if has_tracemalloc and tracemalloc.is_tracing():
+        if HAS_TRACEMALLOC and tracemalloc.is_tracing():
             tracemalloc.stop()
 
 
@@ -1197,12 +812,12 @@ def run_module_with_profiler(module, profiler, backend, passed_args=[]):
     if PY2:
         run_module(module, run_name=""__main__"", init_globals=ns)
     else:
-        if _backend == 'tracemalloc' and has_tracemalloc:
+        if _backend == 'tracemalloc' and HAS_TRACEMALLOC:
             tracemalloc.start()
         try:
             run_module(module, run_name=""__main__"", init_globals=ns)
         finally:
-            if has_tracemalloc and tracemalloc.is_tracing():
+            if HAS_TRACEMALLOC and tracemalloc.is_tracing():
                 tracemalloc.stop()
 
 
@@ -1236,61 +851,3 @@ class LogFile(object):
     def flush(self):
         for handler in self.logger.handlers:
             handler.flush()
-
-
-if __name__ == '__main__':
-    from argparse import ArgumentParser, REMAINDER
-
-    parser = ArgumentParser(usage=_CMD_USAGE)
-    parser.add_argument('--version', action='version', version=__version__)
-    parser.add_argument(
-        '--pdb-mmem', dest='max_mem', metavar='MAXMEM',
-        type=float, action='store',
-        help='step into the debugger when memory exceeds MAXMEM')
-    parser.add_argument(
-        '--precision', dest='precision', type=int,
-        action='store', default=3,
-        help='precision of memory output in number of significant digits')
-    parser.add_argument('-o', dest='out_filename', type=str,
-        action='store', default=None,
-        help='path to a file where results will be written')
-    parser.add_argument('--timestamp', dest='timestamp', default=False,
-        action='store_true',
-        help='''print timestamp instead of memory measurement for
-        decorated functions''')
-    parser.add_argument('--backend', dest='backend', type=str, action='store',
-        choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
-        help='backend using for getting memory info '
-             '(one of the {tracemalloc, psutil, posix})')
-    parser.add_argument(""program"", nargs=REMAINDER,
-        help='python script or module followed by command line arguements to run')
-    args = parser.parse_args()
-
-    if len(args.program) == 0:
-        print(""A program to run must be provided. Use -h for help"")
-        sys.exit(1)
-
-    target = args.program[0]
-    script_args = args.program[1:]
-    _backend = choose_backend(args.backend)
-    if args.timestamp:
-        prof = TimeStamper(_backend)
-    else:
-        prof = LineProfiler(max_mem=args.max_mem, backend=_backend)
-
-    try:
-        if args.program[0].endswith('.py'):
-            script_filename = _find_script(args.program[0])
-            exec_with_profiler(script_filename, prof, args.backend, script_args)
-        else:
-            run_module_with_profiler(target, prof, args.backend, script_args)
-    finally:
-        if args.out_filename is not None:
-            out_file = open(args.out_filename, ""a"")
-        else:
-            out_file = sys.stdout
-
-        if args.timestamp:
-            prof.show_results(stream=out_file)
-        else:
-            show_results(prof, precision=args.precision, stream=out_file)
"
,memory_profiler/__main__.py,891d56ea3c88c4a5b540ece4e2848885277f9564,d65fb3cf2fc65e16cb9c49df2fa0dc3371fc4722,Convert module to package,"@@ -0,0 +1,115 @@
+import os
+import sys
+from argparse import ArgumentParser, REMAINDER
+
+from . import exec_with_profiler, run_module_with_profiler, TimeStamper, __version__
+from .line_profiler import LineProfiler
+from .utils import choose_backend, show_results
+
+
+_CMD_USAGE = ""python -m memory_profiler script_file.py""
+
+
+def _find_script(script_name):
+    """""" Find the script.
+
+    If the input is not a file, then $PATH will be searched.
+    """"""
+    if os.path.isfile(script_name):
+        return script_name
+    path = os.getenv('PATH', os.defpath).split(os.pathsep)
+    for folder in path:
+        if not folder:
+            continue
+        fn = os.path.join(folder, script_name)
+        if os.path.isfile(fn):
+            return fn
+
+    sys.stderr.write('Could not find script {0}\n'.format(script_name))
+    raise SystemExit(1)
+
+
+if __name__ == '__main__':
+    parser = ArgumentParser(usage=_CMD_USAGE)
+    parser.add_argument('--version', action='version', version=__version__)
+    parser.add_argument(
+        '--pdb-mmem',
+        dest='max_mem',
+        metavar='MAXMEM',
+        type=float,
+        action='store',
+        help='step into the debugger when memory exceeds MAXMEM'
+    )
+    parser.add_argument(
+        '--precision',
+        dest='precision',
+        type=int,
+        action='store',
+        default=3,
+        help='precision of memory output in number of significant digits'
+    )
+    parser.add_argument(
+        '-o',
+        dest='out_filename',
+        type=str,
+        action='store',
+        default=None,
+        help='path to a file where results will be written'
+    )
+    parser.add_argument(
+        '--timestamp',
+        dest='timestamp',
+        default=False,
+        action='store_true',
+        help='''print timestamp instead of memory measurement for
+        decorated functions'''
+    )
+    parser.add_argument(
+        '--backend',
+        dest='backend',
+        type=str,
+        action='store',
+        choices=['tracemalloc', 'psutil', 'posix'],
+        default='psutil',
+        help='backend using for getting memory info '
+             '(one of the {tracemalloc, psutil, posix})'
+    )
+    parser.add_argument(
+        ""program"",
+        nargs=REMAINDER,
+        help='python script or module followed by '
+             'command line arguments to run'
+    )
+    args = parser.parse_args()
+
+    if len(args.program) == 0:
+        print(""A program to run must be provided. Use -h for help"")
+        sys.exit(1)
+
+    target = args.program[0]
+    script_args = args.program[1:]
+
+    _backend = choose_backend(args.backend)
+    if args.timestamp:
+        prof = TimeStamper(_backend)
+    else:
+        prof = LineProfiler(max_mem=args.max_mem, backend=_backend)
+
+    try:
+        if args.program[0].endswith('.py'):
+            script_filename = _find_script(args.program[0])
+            exec_with_profiler(
+                script_filename, prof, args.backend, script_args
+            )
+        else:
+            run_module_with_profiler(target, prof, args.backend, script_args)
+    finally:
+        if args.out_filename is not None:
+            out_file = open(args.out_filename, ""a"")
+        else:
+            out_file = sys.stdout
+
+        if args.timestamp:
+            prof.show_results(stream=out_file)
+        else:
+            show_results(prof, precision=args.precision, stream=out_file)
"
,memory_profiler/code_map.py,891d56ea3c88c4a5b540ece4e2848885277f9564,d65fb3cf2fc65e16cb9c49df2fa0dc3371fc4722,Convert module to package,"@@ -0,0 +1,69 @@
+import inspect
+import os.path
+
+from .utils import get_memory
+
+
+class CodeMap(dict):
+    def __init__(self, include_children, backend):
+        self.include_children = include_children
+        self._toplevel = []
+        self.backend = backend
+
+    def add(self, code, toplevel_code=None):
+        if code in self:
+            return
+
+        if toplevel_code is None:
+            filename = code.co_filename
+            if filename.endswith(("".pyc"", "".pyo"")):
+                filename = filename[:-1]
+            if not os.path.exists(filename):
+                print('ERROR: Could not find file ' + filename)
+                if filename.startswith((""ipython-input"", ""<ipython-input"")):
+                    print(
+                        ""NOTE: %mprun can only be used on functions defined in""
+                        "" physical files, and not in the IPython environment."")
+                return
+
+            toplevel_code = code
+            (sub_lines, start_line) = inspect.getsourcelines(code)
+            linenos = range(start_line,
+                            start_line + len(sub_lines))
+            self._toplevel.append((filename, code, linenos))
+            self[code] = {}
+        else:
+            self[code] = self[toplevel_code]
+
+        for subcode in filter(inspect.iscode, code.co_consts):
+            self.add(subcode, toplevel_code=toplevel_code)
+
+    def trace(self, code, lineno, prev_lineno):
+        memory = get_memory(
+            -1,
+            self.backend,
+            include_children=self.include_children,
+            filename=code.co_filename
+        )
+        prev_value = self[code].get(lineno, None)
+        previous_memory = prev_value[1] if prev_value else 0
+        previous_inc = prev_value[0] if prev_value else 0
+
+        prev_line_value = (
+            self[code].get(prev_lineno, None)
+            if prev_lineno else None
+        )
+        prev_line_memory = prev_line_value[1] if prev_line_value else 0
+        self[code][lineno] = (
+            max(previous_inc, memory-prev_line_memory),
+            max(memory, previous_memory)
+        )
+
+    def items(self):
+        """"""Iterate on the toplevel code blocks.""""""
+        for (filename, code, linenos) in self._toplevel:
+            measures = self[code]
+            if not measures:
+                continue  # skip if no measurement
+            line_iterator = ((line, measures.get(line)) for line in linenos)
+            yield (filename, line_iterator)
"
,memory_profiler/common.py,891d56ea3c88c4a5b540ece4e2848885277f9564,d65fb3cf2fc65e16cb9c49df2fa0dc3371fc4722,Convert module to package,"@@ -0,0 +1,13 @@
+import sys
+
+
+PY2 = sys.version_info[0] == 2
+
+try:
+    import tracemalloc  # noqa
+except ImportError:
+    HAS_TRACEMALLOC = False
+else:
+    HAS_TRACEMALLOC = True
+
+TWO_20 = float(2 ** 20)
"
,memory_profiler/line_profiler.py,891d56ea3c88c4a5b540ece4e2848885277f9564,d65fb3cf2fc65e16cb9c49df2fa0dc3371fc4722,Convert module to package,"@@ -0,0 +1,160 @@
+import pdb
+import sys
+import warnings
+from functools import wraps
+
+from .code_map import CodeMap
+from .utils import choose_backend, get_memory, show_results
+
+
+class LineProfiler(object):
+    """""" A profiler that records the amount of memory for each line """"""
+
+    def __init__(self, **kw):
+        include_children = kw.get('include_children', False)
+        backend = kw.get('backend', 'psutil')
+        self.code_map = CodeMap(
+            include_children=include_children, backend=backend)
+        self.enable_count = 0
+        self.max_mem = kw.get('max_mem', None)
+        self.prevlines = []
+        self.backend = choose_backend(kw.get('backend', None))
+        self.prev_lineno = None
+
+    def __call__(self, func=None, precision=1):
+        if func is not None:
+            self.add_function(func)
+            f = self.wrap_function(func)
+            f.__module__ = func.__module__
+            f.__name__ = func.__name__
+            f.__doc__ = func.__doc__
+            f.__dict__.update(getattr(func, '__dict__', {}))
+            return f
+        else:
+            def inner_partial(f):
+                return self.__call__(f, precision=precision)
+
+            return inner_partial
+
+    def add_function(self, func):
+        """""" Record line profiling information for the given Python function.
+        """"""
+        try:
+            # func_code does not exist in Python3
+            code = func.__code__
+        except AttributeError:
+            warnings.warn(""Could not extract a code object for the object %r""
+                          % func)
+        else:
+            self.code_map.add(code)
+
+    def wrap_function(self, func):
+        """""" Wrap a function to profile it.
+        """"""
+
+        def f(*args, **kwds):
+            self.enable_by_count()
+            try:
+                return func(*args, **kwds)
+            finally:
+                self.disable_by_count()
+
+        return f
+
+    def runctx(self, cmd, globals, locals):
+        """""" Profile a single executable statement in the given namespaces.
+        """"""
+        self.enable_by_count()
+        try:
+            exec(cmd, globals, locals)
+        finally:
+            self.disable_by_count()
+        return self
+
+    def enable_by_count(self):
+        """""" Enable the profiler if it hasn't been enabled before.
+        """"""
+        if self.enable_count == 0:
+            self.enable()
+        self.enable_count += 1
+
+    def disable_by_count(self):
+        """""" Disable the profiler if the number of disable requests matches the
+        number of enable requests.
+        """"""
+        if self.enable_count > 0:
+            self.enable_count -= 1
+            if self.enable_count == 0:
+                self.disable()
+
+    def trace_memory_usage(self, frame, event, arg):
+        """"""Callback for sys.settrace""""""
+        if frame.f_code in self.code_map:
+            if event == 'call':
+                # ""call"" event just saves the lineno but not the memory
+                self.prevlines.append(frame.f_lineno)
+            elif event == 'line':
+                # trace needs current line and previous line
+                self.code_map.trace(frame.f_code, self.prevlines[-1], self.prev_lineno)
+                # saving previous line
+                self.prev_lineno = self.prevlines[-1]
+                self.prevlines[-1] = frame.f_lineno
+            elif event == 'return':
+                lineno = self.prevlines.pop()
+                self.code_map.trace(frame.f_code, lineno, self.prev_lineno)
+                self.prev_lineno = lineno
+
+        if self._original_trace_function is not None:
+            self._original_trace_function(frame, event, arg)
+
+        return self.trace_memory_usage
+
+    def trace_max_mem(self, frame, event, arg):
+        # run into PDB as soon as memory is higher than MAX_MEM
+        if event in ('line', 'return') and frame.f_code in self.code_map:
+            c = get_memory(-1, self.backend, filename=frame.f_code.co_filename)
+            if c >= self.max_mem:
+                t = ('Current memory {0:.2f} MiB exceeded the '
+                     'maximum of {1:.2f} MiB\n'.format(c, self.max_mem))
+                sys.stdout.write(t)
+                sys.stdout.write('Stepping into the debugger \n')
+                frame.f_lineno -= 2
+                p = pdb.Pdb()
+                p.quitting = False
+                p.stopframe = frame
+                p.returnframe = None
+                p.stoplineno = frame.f_lineno - 3
+                p.botframe = None
+                return p.trace_dispatch
+
+        if self._original_trace_function is not None:
+            (self._original_trace_function)(frame, event, arg)
+
+        return self.trace_max_mem
+
+    def __enter__(self):
+        self.enable_by_count()
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        self.disable_by_count()
+
+    def enable(self):
+        self._original_trace_function = sys.gettrace()
+        if self.max_mem is not None:
+            sys.settrace(self.trace_max_mem)
+        else:
+            sys.settrace(self.trace_memory_usage)
+
+    def disable(self):
+        sys.settrace(self._original_trace_function)
+
+
+def get_profile_wrapper(func, precision, backend, stream):
+    @wraps(func)
+    def wrapper(*args, **kwargs):
+        prof = LineProfiler(backend=backend)
+        val = prof(func)(*args, **kwargs)
+        show_results(prof, stream=stream, precision=precision)
+        return val
+
+    return wrapper
"
,memory_profiler/utils.py,891d56ea3c88c4a5b540ece4e2848885277f9564,d65fb3cf2fc65e16cb9c49df2fa0dc3371fc4722,Convert module to package,"@@ -0,0 +1,183 @@
+import linecache
+import os
+import sys
+import warnings
+import subprocess
+import time
+
+import psutil
+
+from .common import HAS_TRACEMALLOC, PY2, TWO_20
+
+if HAS_TRACEMALLOC:
+    import tracemalloc
+
+
+if PY2:
+    def to_str(x):
+        return x
+
+    from future_builtins import filter
+else:
+    def to_str(x):
+        return str(x)
+
+
+def show_results(prof, stream=None, precision=1):
+    if stream is None:
+        stream = sys.stdout
+    template = '{0:>6} {1:>12} {2:>12}   {3:<}'
+
+    for (filename, lines) in prof.code_map.items():
+        header = template.format('Line #', 'Mem usage', 'Increment',
+                                 'Line Contents')
+
+        stream.write(u'Filename: ' + filename + '\n\n')
+        stream.write(header + u'\n')
+        stream.write(u'=' * len(header) + '\n')
+
+        all_lines = linecache.getlines(filename)
+
+        float_format = u'{0}.{1}f'.format(precision + 4, precision)
+        template_mem = u'{0:' + float_format + '} MiB'
+        for (lineno, mem) in lines:
+            if mem:
+                inc = mem[0]
+                mem = mem[1]
+                mem = template_mem.format(mem)
+                inc = template_mem.format(inc)
+            else:
+                mem = u''
+                inc = u''
+            tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
+            stream.write(to_str(tmp))
+        stream.write(u'\n\n')
+
+
+def choose_backend(new_backend=None):
+    """"""
+    Function that tries to setup backend, chosen by user, and if failed,
+    setup one of the allowable backends
+    """"""
+
+    _backend = 'no_backend'
+    all_backends = [
+        ('psutil', True),
+        ('posix', os.name == 'posix'),
+        ('tracemalloc', HAS_TRACEMALLOC),
+    ]
+    backends_indices = dict((b[0], i) for i, b in enumerate(all_backends))
+
+    if new_backend is not None:
+        all_backends.insert(0, all_backends.pop(backends_indices[new_backend]))
+
+    for n_backend, is_available in all_backends:
+        if is_available:
+            _backend = n_backend
+            break
+    if _backend != new_backend and new_backend is not None:
+        warnings.warn('{0} can not be used, {1} used instead'.format(
+            new_backend, _backend))
+    return _backend
+
+
+def get_child_memory(process, meminfo_attr=None):
+    """"""
+    Returns a generator that yields memory for all child processes.
+    """"""
+    # Convert a pid to a process
+    if isinstance(process, int):
+        if process == -1: process = os.getpid()
+        process = psutil.Process(process)
+
+    if not meminfo_attr:
+        # Use the psutil 2.0 attr if the older version isn't passed in.
+        meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
+
+    # Select the psutil function get the children similar to how we selected
+    # the memory_info attr (a change from excepting the AttributeError).
+    children_attr = 'children' if hasattr(process, 'children') else 'get_children'
+
+    # Loop over the child processes and yield their memory
+    try:
+        for child in getattr(process, children_attr)(recursive=True):
+            yield getattr(child, meminfo_attr)()[0] / TWO_20
+    except (psutil.NoSuchProcess, psutil.AccessDenied):
+        # https://github.com/fabianp/memory_profiler/issues/71
+        yield 0.0
+
+
+def get_memory(pid, backend, timestamps=False, include_children=False, filename=None):
+    # .. low function to get memory consumption ..
+    if pid == -1:
+        pid = os.getpid()
+
+    def tracemalloc_tool():
+        # .. cross-platform but but requires Python 3.4 or higher ..
+        stat = next(filter(lambda item: str(item).startswith(filename),
+                           tracemalloc.take_snapshot().statistics('filename')))
+        mem = stat.size / TWO_20
+        if timestamps:
+            return mem, time.time()
+        else:
+            return mem
+
+    def ps_util_tool():
+        # .. cross-platform but but requires psutil ..
+        process = psutil.Process(pid)
+        try:
+            # avoid using get_memory_info since it does not exists
+            # in psutil > 2.0 and accessing it will cause exception.
+            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') \
+                else 'get_memory_info'
+            mem = getattr(process, meminfo_attr)()[0] / TWO_20
+            if include_children:
+                mem += sum(get_child_memory(process, meminfo_attr))
+            if timestamps:
+                return mem, time.time()
+            else:
+                return mem
+        except psutil.AccessDenied:
+            pass
+            # continue and try to get this from ps
+
+    def posix_tool():
+        # .. scary stuff ..
+        if include_children:
+            raise NotImplementedError((
+                ""The psutil module is required to monitor the ""
+                ""memory usage of child processes.""
+            ))
+
+        warnings.warn(""psutil module not found. memory_profiler will be slow"")
+        # ..
+        # .. memory usage in MiB ..
+        # .. this should work on both Mac and Linux ..
+        # .. subprocess.check_output appeared in 2.7, using Popen ..
+        # .. for backwards compatibility ..
+        out = subprocess.Popen(['ps', 'v', '-p', str(pid)],
+                               stdout=subprocess.PIPE
+                               ).communicate()[0].split(b'\n')
+        try:
+            vsz_index = out[0].split().index(b'RSS')
+            mem = float(out[1].split()[vsz_index]) / 1024
+            if timestamps:
+                return mem, time.time()
+            else:
+                return mem
+        except:
+            if timestamps:
+                return -1, time.time()
+            else:
+                return -1
+
+    if backend == 'tracemalloc' and \
+            (filename is None or filename == '<unknown>'):
+        raise RuntimeError(
+            'There is no access to source file of the profiled function'
+        )
+
+    tools = {'tracemalloc': tracemalloc_tool,
+             'psutil': ps_util_tool,
+             'posix': posix_tool}
+    return tools[backend]()
"
setup.py,setup.py,891d56ea3c88c4a5b540ece4e2848885277f9564,d65fb3cf2fc65e16cb9c49df2fa0dc3371fc4722,Convert module to package,"@@ -1,8 +1,7 @@
 import os
 import io
 import re
-import sys
-from setuptools import setup
+from setuptools import find_packages, setup
 
 
 # https://packaging.python.org/guides/single-sourcing-package-version/
@@ -22,14 +21,6 @@ def find_version(*file_paths):
         return version_match.group(1)
 
 
-async_modules = []
-if sys.version_info > (3, 3):
-    if sys.version_info < (3, 5):
-        async_modules = ['_aio_34']
-    else:
-        async_modules = ['_aio_35']
-
-
 CLASSIFIERS = """"""\
 Development Status :: 5 - Production/Stable
 Intended Audience :: Science/Research
@@ -53,13 +44,14 @@ setup(
     name='memory_profiler',
     description='A module for monitoring memory usage of a python program',
     long_description=open('README.rst').read(),
-    version=find_version(""memory_profiler.py""),
+    version=find_version(""memory_profiler"", ""__init__.py""),
     author='Fabian Pedregosa',
     author_email='f@bianp.net',
     url='https://github.com/pythonprofilers/memory_profiler',
-    py_modules=['memory_profiler', 'mprof'] + async_modules,
+    py_modules=['mprof'],
+    packages=find_packages(include='memory_profiler'),
     entry_points={
-        'console_scripts' : ['mprof = mprof:main'],
+        'console_scripts': ['mprof = mprof:main'],
     },
     install_requires=['psutil'],
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
"
_aio_34.py,,c33afb0371950b3218bbfefcc743e67208458df1,891d56ea3c88c4a5b540ece4e2848885277f9564,Add coroutine support,"@@ -1,35 +0,0 @@
-from asyncio import coroutine, iscoroutinefunction
-from contextlib import contextmanager
-from functools import wraps
-
-from memory_profiler import LineProfiler, show_results
-
-
-class CoroLineProfiler(LineProfiler):
-    @contextmanager
-    def count_contextmgr(self):
-        self.enable_by_count()
-        try:
-            yield
-        finally:
-            self.disable_by_count()
-
-    def wrap_function(self, func):
-        if iscoroutinefunction(func):
-            @coroutine
-            def f(*args, **kwargs):
-                with self.count_contextmgr():
-                    yield from func(*args, **kwargs)
-            return f
-        else:
-            return super(CoroLineProfiler, self).wrap_function(func)
-
-
-def _get_coro_wrapper(coro, backend, stream, precision):
-    @wraps(coro)
-    @coroutine
-    def wrapper(*args, **kwargs):
-        prof = CoroLineProfiler(backend=backend)
-        val = yield from prof(coro)(*args, **kwargs)
-        show_results(prof, stream=stream, precision=precision)
-        return val
"
memory_profiler/__init__.py,memory_profiler/__init__.py,c33afb0371950b3218bbfefcc743e67208458df1,891d56ea3c88c4a5b540ece4e2848885277f9564,Add coroutine support,"@@ -17,14 +17,19 @@ import traceback
 import warnings
 import contextlib
 
-from .common import PY2, HAS_TRACEMALLOC
+from .common import PY2, PY34, PY35, HAS_TRACEMALLOC
 from .utils import (
     show_results,
     choose_backend,
     get_memory as _get_memory,
     get_child_memory as _get_child_memory,
 )
-from .line_profiler import LineProfiler
+from .line_profiler import LineProfiler, get_profile_wrapper
+
+if PY34:
+    from ._aio_34 import get_profile_wrapper
+elif PY35:
+    from ._aio_35 import get_profile_wrapper
 
 
 if sys.platform == ""win32"":
@@ -758,14 +763,7 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
         if not tracemalloc.is_tracing():
             tracemalloc.start()
     if func is not None:
-        @wraps(func)
-        def wrapper(*args, **kwargs):
-            prof = LineProfiler(backend=backend)
-            val = prof(func)(*args, **kwargs)
-            show_results(prof, stream=stream, precision=precision)
-            return val
-
-        return wrapper
+        return get_profile_wrapper(func, precision, backend, stream)
     else:
         def inner_wrapper(f):
             return profile(f, stream=stream, precision=precision,
"
,memory_profiler/_aio_34.py,c33afb0371950b3218bbfefcc743e67208458df1,891d56ea3c88c4a5b540ece4e2848885277f9564,Add coroutine support,"@@ -0,0 +1,35 @@
+from asyncio import coroutine, iscoroutinefunction
+from functools import wraps
+
+from .line_profiler import (
+    get_profile_wrapper as default_profile_wrapper,
+    LineProfiler,
+)
+from .utils import show_results
+
+
+class CoroLineProfiler(LineProfiler):
+    def wrap_function(self, func):
+        if iscoroutinefunction(func):
+            @coroutine
+            def f(*args, **kwargs):
+                with self.count_ctxmgr():
+                    yield from func(*args, **kwargs)
+            return f
+        else:
+            return super().wrap_function(func)
+
+
+def get_profile_wrapper(func, precision, backend, stream):
+    if iscoroutinefunction(func):
+        @wraps(func)
+        @coroutine
+        def wrapper(*args, **kwargs):
+            prof = CoroLineProfiler(backend=backend)
+            val = yield from prof(func)(*args, **kwargs)
+            show_results(prof, stream=stream, precision=precision)
+            return val
+    else:
+        wrapper = default_profile_wrapper(func, precision, backend, stream)
+
+    return wrapper
"
,memory_profiler/_aio_35.py,c33afb0371950b3218bbfefcc743e67208458df1,891d56ea3c88c4a5b540ece4e2848885277f9564,Add coroutine support,"@@ -0,0 +1,33 @@
+from functools import wraps
+from inspect import iscoroutinefunction
+
+from .line_profiler import (
+    get_profile_wrapper as default_profile_wrapper,
+    LineProfiler,
+)
+from .utils import show_results
+
+
+class CoroLineProfiler(LineProfiler):
+    def wrap_function(self, func):
+        if iscoroutinefunction(func):
+            async def f(*args, **kwargs):
+                with self.count_ctxmgr():
+                    return await func(*args, **kwargs)
+            return f
+        else:
+            return super().wrap_function(func)
+
+
+def get_profile_wrapper(func, precision, backend, stream):
+    if iscoroutinefunction(func):
+        @wraps(func)
+        async def wrapper(*args, **kwargs):
+            prof = CoroLineProfiler(backend=backend)
+            val = await prof(func)(*args, **kwargs)
+            show_results(prof, stream=stream, precision=precision)
+            return val
+    else:
+        wrapper = default_profile_wrapper(func, precision, backend, stream)
+
+    return wrapper
"
memory_profiler/common.py,memory_profiler/common.py,c33afb0371950b3218bbfefcc743e67208458df1,891d56ea3c88c4a5b540ece4e2848885277f9564,Add coroutine support,"@@ -3,6 +3,9 @@ import sys
 
 PY2 = sys.version_info[0] == 2
 
+PY34 = (3, 4) < sys.version_info < (3, 5)
+PY35 = (3, 5) < sys.version_info
+
 try:
     import tracemalloc  # noqa
 except ImportError:
"
setup.py,setup.py,76a433544c758a4ce92c08494d95e9d890da6314,d17b6fcf9d9a96ca08ae880fdbe68c7c0fbf8aa1,Fix setup package lookup,"@@ -49,7 +49,7 @@ setup(
     author_email='f@bianp.net',
     url='https://github.com/pythonprofilers/memory_profiler',
     py_modules=['mprof'],
-    packages=find_packages(include='memory_profiler'),
+    packages=find_packages(include=('memory_profiler',)),
     entry_points={
         'console_scripts': ['mprof = mprof:main'],
     },
"
memory_profiler/__init__.py,memory_profiler/__init__.py,79abbb617782d92848f9a802577712d9ae80bc14,76a433544c758a4ce92c08494d95e9d890da6314,Import CodeMap in __init__ for backward compatibility,"@@ -17,6 +17,7 @@ import traceback
 import warnings
 import contextlib
 
+from .code_map import CodeMap
 from .common import PY2, PY34, PY35, HAS_TRACEMALLOC
 from .utils import (
     show_results,
"
memory_profiler/line_profiler.py,memory_profiler/line_profiler.py,cb7ecdada7305019277a9d38f1bf91c578ede093,79abbb617782d92848f9a802577712d9ae80bc14,Add count_ctxmgr,"@@ -1,6 +1,7 @@
 import pdb
 import sys
 import warnings
+from contextlib import contextmanager
 from functools import wraps
 
 from .code_map import CodeMap
@@ -48,27 +49,29 @@ class LineProfiler(object):
         else:
             self.code_map.add(code)
 
+    @contextmanager
+    def count_ctxmgr(self):
+        self.enable_by_count()
+        try:
+            yield
+        finally:
+            self.disable_by_count()
+
     def wrap_function(self, func):
         """""" Wrap a function to profile it.
         """"""
 
         def f(*args, **kwds):
-            self.enable_by_count()
-            try:
+            with self.count_ctxmgr():
                 return func(*args, **kwds)
-            finally:
-                self.disable_by_count()
 
         return f
 
     def runctx(self, cmd, globals, locals):
         """""" Profile a single executable statement in the given namespaces.
         """"""
-        self.enable_by_count()
-        try:
+        with self.count_ctxmgr():
             exec(cmd, globals, locals)
-        finally:
-            self.disable_by_count()
         return self
 
     def enable_by_count(self):
"
memory_profiler/__init__.py,memory_profiler/__init__.py,300b89dbcb1a3718279303a1c3b7e577c0543734,cb7ecdada7305019277a9d38f1bf91c578ede093,Remove redundant implementation in new syntax,"@@ -18,7 +18,7 @@ import warnings
 import contextlib
 
 from .code_map import CodeMap
-from .common import PY2, PY34, PY35, HAS_TRACEMALLOC
+from .common import PY2, PY34, HAS_TRACEMALLOC
 from .utils import (
     show_results,
     choose_backend,
@@ -28,9 +28,7 @@ from .utils import (
 from .line_profiler import LineProfiler, get_profile_wrapper
 
 if PY34:
-    from ._aio_34 import get_profile_wrapper
-elif PY35:
-    from ._aio_35 import get_profile_wrapper
+    from ._async import get_profile_wrapper
 
 
 if sys.platform == ""win32"":
"
memory_profiler/_aio_35.py,,300b89dbcb1a3718279303a1c3b7e577c0543734,cb7ecdada7305019277a9d38f1bf91c578ede093,Remove redundant implementation in new syntax,"@@ -1,33 +0,0 @@
-from functools import wraps
-from inspect import iscoroutinefunction
-
-from .line_profiler import (
-    get_profile_wrapper as default_profile_wrapper,
-    LineProfiler,
-)
-from .utils import show_results
-
-
-class CoroLineProfiler(LineProfiler):
-    def wrap_function(self, func):
-        if iscoroutinefunction(func):
-            async def f(*args, **kwargs):
-                with self.count_ctxmgr():
-                    return await func(*args, **kwargs)
-            return f
-        else:
-            return super().wrap_function(func)
-
-
-def get_profile_wrapper(func, precision, backend, stream):
-    if iscoroutinefunction(func):
-        @wraps(func)
-        async def wrapper(*args, **kwargs):
-            prof = CoroLineProfiler(backend=backend)
-            val = await prof(func)(*args, **kwargs)
-            show_results(prof, stream=stream, precision=precision)
-            return val
-    else:
-        wrapper = default_profile_wrapper(func, precision, backend, stream)
-
-    return wrapper
"
memory_profiler/_aio_34.py,memory_profiler/_async.py,300b89dbcb1a3718279303a1c3b7e577c0543734,cb7ecdada7305019277a9d38f1bf91c578ede093,Remove redundant implementation in new syntax,
memory_profiler/common.py,memory_profiler/common.py,300b89dbcb1a3718279303a1c3b7e577c0543734,cb7ecdada7305019277a9d38f1bf91c578ede093,Remove redundant implementation in new syntax,"@@ -3,8 +3,7 @@ import sys
 
 PY2 = sys.version_info[0] == 2
 
-PY34 = (3, 4) < sys.version_info < (3, 5)
-PY35 = (3, 5) < sys.version_info
+PY34 = (3, 4) < sys.version_info
 
 try:
     import tracemalloc  # noqa
"
Makefile,Makefile,1ee8e036d1f0eebd1077d952985bbe77baa42e0c,300b89dbcb1a3718279303a1c3b7e577c0543734,Add test_async.py,"@@ -1,6 +1,8 @@
 PYTHON ?= python
+PY_34 ?= $(shell ! python -c \
+		 'import sys; print((3, 4) < sys.version_info)')
 
-.PHONY: test
+.PHONY: test develop
 
 test:
 	$(PYTHON) -m memory_profiler test/test_func.py
@@ -18,6 +20,9 @@ test:
 	$(PYTHON) test/test_exception.py
 	$(PYTHON) test/test_exit_code.py
 	$(PYTHON) test/test_mprof.py
+	if [ $(PY_34) = True ]; then \
+		$(PYTHON) test/test_aio_34.py; \
+	fi
 
 develop:
 	pip install -e .
"
,test/test_async.py,1ee8e036d1f0eebd1077d952985bbe77baa42e0c,300b89dbcb1a3718279303a1c3b7e577c0543734,Add test_async.py,"@@ -0,0 +1,18 @@
+import asyncio
+
+from memory_profiler import profile
+
+
+@profile
+@asyncio.coroutine
+def my_func():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    print('kek')
+    yield from asyncio.sleep(1e-2)
+    del b
+
+
+if __name__ == '__main__':
+    loop = asyncio.get_event_loop()
+    loop.run_until_complete(my_func())
"
Makefile,Makefile,1648c6b8423fd3efba86101fc721d4128f06d9ec,1ee8e036d1f0eebd1077d952985bbe77baa42e0c,Fix async test filename,"@@ -21,7 +21,7 @@ test:
 	$(PYTHON) test/test_exit_code.py
 	$(PYTHON) test/test_mprof.py
 	if [ $(PY_34) = True ]; then \
-		$(PYTHON) test/test_aio_34.py; \
+		$(PYTHON) test/test_async.py; \
 	fi
 
 develop:
"
memory_profiler.py,memory_profiler.py,6bb02fcc09c3fc7a765f658ec9142550bd993110,1a853e5b1342788fdd6ab55cfe6c568e3b307349,"Fix memit to handle change in memory_usage API

Hotfix for #258","@@ -1052,7 +1052,7 @@ class MemoryProfilerMagics(Magics):
                                timeout=timeout, interval=interval,
                                max_usage=True,
                                include_children=include_children)
-            mem_usage.append(tmp[0])
+            mem_usage.append(tmp)
 
         result = MemitResult(mem_usage, baseline, repeat, timeout, interval,
                              include_children)
"
memory_profiler.py,memory_profiler.py,5c1f0c06458bcccfcd4f2088df0ec9a09203d9a5,adef4f1827b14c87226d29eb5076f3a72553b977,version 0.57,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.56.0'
+__version__ = '0.57.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
README.rst,README.rst,d986422bef66a132ecb7e0270caeb7ec16a1d2c3,5c1f0c06458bcccfcd4f2088df0ec9a09203d9a5,update contact information,"@@ -419,9 +419,9 @@ Send issues, proposals, etc. to `github's issue tracker
 <https://github.com/pythonprofilers/memory_profiler/issues>`_ .
 
 If you've got questions regarding development, you can email me
-directly at fabian@fseoane.net
+directly at f@bianp.net
 
-.. image:: http://fseoane.net/static/tux_memory_small.png
+.. image:: http://fa.bianp.net/static/tux_memory_small.png
 
 
 =============
"
test/test_async.py,test/test_async.py,625021f72db03c02f0d8ab9c74749e19cce7f09e,9370fa530d18d8d9d49f8f1c54109d452996bcbc,Get rid of unnecessary print,"@@ -8,7 +8,6 @@ from memory_profiler import profile
 def my_func():
     a = [1] * (10 ** 6)
     b = [2] * (2 * 10 ** 7)
-    print('kek')
     yield from asyncio.sleep(1e-2)
     del b
 
"
README.rst,README.rst,7d87e106c7fff1675240ff43fc14b7e69396d959,d986422bef66a132ecb7e0270caeb7ec16a1d2c3,"Added a trend line switch ""-s""","@@ -214,6 +214,9 @@ You can also hide the function timestamps using the ``n`` flag, such as
 
     mprof plot -n
 
+Trend lines and its numeric slope can be plotted using the ``s`` flag, such as
+
+    mprof plot -s
 
 Setting debugger breakpoints
 =============================
"
images/trend_slope.png,images/trend_slope.png,7d87e106c7fff1675240ff43fc14b7e69396d959,d986422bef66a132ecb7e0270caeb7ec16a1d2c3,"Added a trend line switch ""-s""","Binary files /dev/null and b/images/trend_slope.png differ
"
mprof.py,mprof.py,7d87e106c7fff1675240ff43fc14b7e69396d959,d986422bef66a132ecb7e0270caeb7ec16a1d2c3,"Added a trend line switch ""-s""","@@ -402,13 +402,28 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
 
     all_colors = (""c"", ""y"", ""g"", ""r"", ""b"")
     mem_line_colors = (""k"", ""b"", ""r"", ""g"", ""c"", ""y"", ""m"")
+
+    show_trend_slope = options is not None and hasattr(options, 'slope') and options.slope is True
+
     mem_line_label = time.strftime(""%d / %m / %Y - start at %H:%M:%S"",
                                    time.localtime(global_start)) \
                      + "".{0:03d}"".format(int(round(math.modf(global_start)[0] * 1000)))
 
+    mem_trend = None
+    if show_trend_slope:
+        # Compute trend line
+        mem_slope = np.polyfit(t, mem, 1)
+        mem_trend = np.poly1d(mem_slope)
+        # Append slope to label
+        mem_line_label = mem_line_label + "" slope {0:.5f}"".format(mem_slope[0])
+
     pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
             label=mem_line_label)
 
+    if show_trend_slope:
+        # Plot the trend line
+        pl.plot(t, mem_trend(mem), ""--"", linewidth=0.5, color=""#00e3d8"")
+
     bottom, top = pl.ylim()
     bottom += 0.001
     top -= 0.001
@@ -422,9 +437,21 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
             cts  = np.asarray([item[1] for item in data]) - global_start
             cmem = np.asarray([item[0] for item in data])
 
+            cmem_trend = None
+            child_mem_trend_label = """"
+            if show_trend_slope:
+                # Compute trend line
+                child_mem_slope = np.polyfit(cts, cmem, 1)
+                cmem_trend = np.poly1d(child_mem_slope)
+                child_mem_trend_label = "" slope {0:.5f}"".format(child_mem_slope[0])
+
             # Plot the line to the figure
-            pl.plot(cts, cmem, ""+-""  + mem_line_colors[(idx+1) % len(mem_line_colors)],
-                     label=""child {}"".format(proc))
+            pl.plot(cts, cmem, ""+-"" + mem_line_colors[(idx + 1) % len(mem_line_colors)],
+                    label=""child {}{}"".format(proc, child_mem_trend_label))
+
+            if show_trend_slope:
+                # Plot the trend line
+                pl.plot(cts, cmem_trend(cts), ""--"", linewidth=0.5, color=""black"")
 
             # Detect the maximal child memory point
             cmax_mem = cmem.max()
@@ -710,6 +737,8 @@ such file in the current directory.""""""
                         help=""Plot a time-subset of the data. E.g. to plot between 0 and 20.5 seconds: --window 0,20.5"")
     parser.add_argument(""--flame"", ""-f"", dest=""flame_mode"", action=""store_true"",
                         help=""Plot the timestamps as a flame-graph instead of the default brackets"")
+    parser.add_argument(""--slope"", ""-s"", dest=""slope"", action=""store_true"",
+                        help=""Plot a trend line and its numerical slope"")
     parser.add_argument(""--backend"",
                       help=""Specify the Matplotlib backend to use"")
     parser.add_argument(""profiles"", nargs=""*"",
@@ -810,4 +839,4 @@ def main():
     actions[get_action()]()
 
 if __name__ == ""__main__"":
-    main()
+    main()
\ No newline at end of file
"
mprof.py,mprof.py,e9d5356989a11d742f1f00b2aa3376c16c2b67e6,7d87e106c7fff1675240ff43fc14b7e69396d959,Trend lines switch '-s' now plots the actual trend line,"@@ -412,17 +412,17 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
     mem_trend = None
     if show_trend_slope:
         # Compute trend line
-        mem_slope = np.polyfit(t, mem, 1)
-        mem_trend = np.poly1d(mem_slope)
+        mem_trend = np.polyfit(t, mem, 1)
+
         # Append slope to label
-        mem_line_label = mem_line_label + "" slope {0:.5f}"".format(mem_slope[0])
+        mem_line_label = mem_line_label + "" slope {0:.5f}"".format(mem_trend[0])
 
     pl.plot(t, mem, ""+-"" + mem_line_colors[index % len(mem_line_colors)],
             label=mem_line_label)
 
     if show_trend_slope:
         # Plot the trend line
-        pl.plot(t, mem_trend(mem), ""--"", linewidth=0.5, color=""#00e3d8"")
+        pl.plot(t, t*mem_trend[0] + mem_trend[1], ""--"", linewidth=0.5, color=""#00e3d8"")
 
     bottom, top = pl.ylim()
     bottom += 0.001
@@ -441,9 +441,9 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
             child_mem_trend_label = """"
             if show_trend_slope:
                 # Compute trend line
-                child_mem_slope = np.polyfit(cts, cmem, 1)
-                cmem_trend = np.poly1d(child_mem_slope)
-                child_mem_trend_label = "" slope {0:.5f}"".format(child_mem_slope[0])
+                cmem_trend = np.polyfit(cts, cmem, 1)
+
+                child_mem_trend_label = "" slope {0:.5f}"".format(cmem_trend[0])
 
             # Plot the line to the figure
             pl.plot(cts, cmem, ""+-"" + mem_line_colors[(idx + 1) % len(mem_line_colors)],
@@ -451,7 +451,7 @@ def plot_file(filename, index=0, timestamps=True, children=True, options=None):
 
             if show_trend_slope:
                 # Plot the trend line
-                pl.plot(cts, cmem_trend(cts), ""--"", linewidth=0.5, color=""black"")
+                pl.plot(cts, cts*cmem_trend[0] + cmem_trend[1], ""--"", linewidth=0.5, color=""black"")
 
             # Detect the maximal child memory point
             cmax_mem = cmem.max()
@@ -839,4 +839,4 @@ def main():
     actions[get_action()]()
 
 if __name__ == ""__main__"":
-    main()
\ No newline at end of file
+    main()
"
README.rst,README.rst,006cbbcebc7e0628d4d219836edd063a45549bf9,bc08f4d65dc3e9ff4a5395f8be24337e57424c44,Added documentation image,"@@ -218,6 +218,9 @@ Trend lines and its numeric slope can be plotted using the ``s`` flag, such as
 
     mprof plot -s
 
+.. image:: ./images/trend_slope.png
+   :height: 350px
+
 Setting debugger breakpoints
 =============================
 It is possible to set breakpoints depending on the amount of memory used.
"
README.rst,README.rst,2ddea52450e12870359f24f98bdc24cdc9db0cdf,006cbbcebc7e0628d4d219836edd063a45549bf9,Added interpretative guidelines for trend lines,"@@ -221,6 +221,15 @@ Trend lines and its numeric slope can be plotted using the ``s`` flag, such as
 .. image:: ./images/trend_slope.png
    :height: 350px
 
+The intended usage of the -s switch is to check the labels' numerical slope over a significant time period for : 
+
+    >0 - it might mean a memory leak.
+    ~0 - if 0 or near 0, the memory usage may be considered stable.
+    <0 - to be interpreted depending on the expected process memory usage patterns, also might mean that the sampling period is too small.
+
+The trend lines are for ilustrative purposes and are plotted as (very) small dashed lines.
+
+
 Setting debugger breakpoints
 =============================
 It is possible to set breakpoints depending on the amount of memory used.
"
README.rst,README.rst,b55c765cefa404b51cf7c97e19d765a00c3bb234,2ddea52450e12870359f24f98bdc24cdc9db0cdf,Added interpretative guidelines for trend lines,"@@ -223,9 +223,10 @@ Trend lines and its numeric slope can be plotted using the ``s`` flag, such as
 
 The intended usage of the -s switch is to check the labels' numerical slope over a significant time period for : 
 
-    >0 - it might mean a memory leak.
-    ~0 - if 0 or near 0, the memory usage may be considered stable.
-    <0 - to be interpreted depending on the expected process memory usage patterns, also might mean that the sampling period is too small.
+  - ``>0`` it might mean a memory leak.
+  - ``~0`` if 0 or near 0, the memory usage may be considered stable.
+    the last one)
+  - ``<0`` to be interpreted depending on the expected process memory usage patterns, also might mean that the sampling period is too small.
 
 The trend lines are for ilustrative purposes and are plotted as (very) small dashed lines.
 
"
README.rst,README.rst,d98614e059209ac425b6d871989553da9cb2e4bb,b55c765cefa404b51cf7c97e19d765a00c3bb234,Added interpretative guidelines for trend lines,"@@ -225,7 +225,6 @@ The intended usage of the -s switch is to check the labels' numerical slope over
 
   - ``>0`` it might mean a memory leak.
   - ``~0`` if 0 or near 0, the memory usage may be considered stable.
-    the last one)
   - ``<0`` to be interpreted depending on the expected process memory usage patterns, also might mean that the sampling period is too small.
 
 The trend lines are for ilustrative purposes and are plotted as (very) small dashed lines.
"
README.rst,README.rst,781ac8078083410b462aa165f6ea538180b3b000,8a8a40252cccc09dc469445596742dc6b47ed6e3,fix #249 decrement not displayed,"@@ -64,14 +64,14 @@ this would result in::
 
 Output will follow::
 
-    Line #    Mem usage  Increment   Line Contents
-    ==============================================
-         3                           @profile
-         4      5.97 MB    0.00 MB   def my_func():
-         5     13.61 MB    7.64 MB       a = [1] * (10 ** 6)
-         6    166.20 MB  152.59 MB       b = [2] * (2 * 10 ** 7)
-         7     13.61 MB -152.59 MB       del b
-         8     13.61 MB    0.00 MB       return a
+    Line #    Mem usage    Increment  Occurences   Line Contents
+    ============================================================
+         3   38.816 MiB   38.816 MiB           1   @profile
+         4                                         def my_func():
+         5   46.492 MiB    7.676 MiB           1       a = [1] * (10 ** 6)
+         6  199.117 MiB  152.625 MiB           1       b = [2] * (2 * 10 ** 7)
+         7   46.629 MiB -152.488 MiB           1       del b
+         8   46.629 MiB    0.000 MiB           1       return a
 
 
 The first column represents the line number of the code that has been
"
memory_profiler.py,memory_profiler.py,781ac8078083410b462aa165f6ea538180b3b000,8a8a40252cccc09dc469445596742dc6b47ed6e3,fix #249 decrement not displayed,"@@ -280,10 +280,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         to this file instead of stored in memory and returned at the end of
         the subprocess. Useful for long-running processes.
         Implies timestamps=True.
-        
+
     max_iterations : int
         Limits the number of iterations (calls to the process being monitored). Relevent
-        when the process is a python function. 
+        when the process is a python function.
 
     Returns
     -------
@@ -357,7 +357,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 raise
 
             p.join(5 * interval)
-            
+
             if (n_measurements > 4) or (current_iter == max_iter) or (interval < 1e-6):
                 break
             interval /= 10.
@@ -643,7 +643,12 @@ class CodeMap(dict):
 
         prev_line_value = self[code].get(prev_lineno, None) if prev_lineno else None
         prev_line_memory = prev_line_value[1] if prev_line_value else 0
-        self[code][lineno] = (max(previous_inc, memory-prev_line_memory), max(memory, previous_memory))
+        occ_count = self[code][lineno][2] + 1 if lineno in self[code] else 1
+        self[code][lineno] = (
+            previous_inc + (memory - prev_line_memory),
+            max(memory, previous_memory),
+            occ_count,
+        )
 
     def items(self):
         """"""Iterate on the toplevel code blocks.""""""
@@ -800,10 +805,10 @@ class LineProfiler(object):
 def show_results(prof, stream=None, precision=1):
     if stream is None:
         stream = sys.stdout
-    template = '{0:>6} {1:>12} {2:>12}   {3:<}'
+    template = '{0:>6} {1:>12} {2:>12}  {3:>10}   {4:<}'
 
     for (filename, lines) in prof.code_map.items():
-        header = template.format('Line #', 'Mem usage', 'Increment',
+        header = template.format('Line #', 'Mem usage', 'Increment', 'Occurences',
                                  'Line Contents')
 
         stream.write(u'Filename: ' + filename + '\n\n')
@@ -817,13 +822,15 @@ def show_results(prof, stream=None, precision=1):
         for (lineno, mem) in lines:
             if mem:
                 inc = mem[0]
-                mem = mem[1]
-                mem = template_mem.format(mem)
+                total_mem = mem[1]
+                total_mem = template_mem.format(total_mem)
+                occurences = mem[2]
                 inc = template_mem.format(inc)
             else:
-                mem = u''
+                total_mem = u''
                 inc = u''
-            tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
+                occurences = u''
+            tmp = template.format(lineno, total_mem, inc, occurences, all_lines[lineno - 1])
             stream.write(to_str(tmp))
         stream.write(u'\n\n')
 
"
,test/test_increment_display.py,781ac8078083410b462aa165f6ea538180b3b000,8a8a40252cccc09dc469445596742dc6b47ed6e3,fix #249 decrement not displayed,"@@ -0,0 +1,81 @@
+import unittest
+
+from memory_profiler import LineProfiler, profile, show_results
+from io import StringIO
+
+
+class TestIncrementDisplay(unittest.TestCase):
+    """"""Tests memory incrementation / decrementation display""""""
+
+    def test_loop_count(self):
+
+        def some_loop():
+            for i in range(12):  # line -2
+                a = 1            # line -1
+
+        profiler = LineProfiler()
+        wrapped = profiler(some_loop)
+        wrapped()
+        show_results(profiler)
+        for_line = list(list(profiler.code_map.values())[0].values())[-2]
+        looped_instruction = list(list(profiler.code_map.values())[0].values())[-1]
+
+        self.assertEqual(for_line[2], 13)
+        self.assertEqual(looped_instruction[2], 12)
+
+    def test_normal_incr(self):
+
+        def normal_incr():
+            use_some_memory = [1] * (10 ** 6)
+
+        profiler = LineProfiler()
+        wrapped = profiler(normal_incr)
+        wrapped()
+
+        show_results(profiler)
+        results = list(list(profiler.code_map.values())[0].values())[-1]
+
+        self.assertGreater(results[0], 0)
+        self.assertGreater(results[1], results[0])
+        self.assertEqual(results[2], 1)
+
+    def test_loop_incr(self):
+
+        def loop_incr():
+            a = []
+            b = [2] * (2 * 10 ** 7)      # line -4
+            for i in range(3):
+                c = [2] * (2 * 10 ** 7)  # line -2
+                a.append(c)
+
+        profiler = LineProfiler()
+        wrapped = profiler(loop_incr)
+        wrapped()
+
+        show_results(profiler)
+        b_line = list(list(profiler.code_map.values())[0].values())[-4]
+        c_line = list(list(profiler.code_map.values())[0].values())[-2]
+        self.assertAlmostEqual(b_line[2] * 3, c_line[2], delta=1)
+        self.assertEqual(c_line[2], 3)
+
+    def test_decr(self):
+
+        def del_stuff():
+            b = [2] * (2 * 10 ** 7)
+            del b
+
+        profiler = LineProfiler()
+        wrapped = profiler(del_stuff)
+        wrapped()
+
+        show_results(profiler)
+        b_line = list(list(profiler.code_map.values())[0].values())[-2]
+        del_line = list(list(profiler.code_map.values())[0].values())[-1]
+
+        self.assertGreater(0, del_line[0])
+        self.assertGreater(del_line[1], 0)
+        self.assertAlmostEqual(-del_line[0], b_line[0], delta=1)
+
+
+if __name__ == '__main__':
+    unittest.main()
"
.gitignore,.gitignore,205f901c1768cac001635d4c8aad396b03852f1a,625021f72db03c02f0d8ab9c74749e19cce7f09e,Ignore pyenv version file,"@@ -11,3 +11,4 @@ mprofile_*.dat
 
 # virtual environment
 venv/
+.python-version
"
Makefile,Makefile,e8d6bf7e8326cf9688703ad1243e9cea9a2c132d,205f901c1768cac001635d4c8aad396b03852f1a,"Keep memory_profiler in single file, drop support of python <3.4","@@ -20,9 +20,7 @@ test:
 	$(PYTHON) test/test_exception.py
 	$(PYTHON) test/test_exit_code.py
 	$(PYTHON) test/test_mprof.py
-	if [ $(PY_34) = True ]; then \
-		$(PYTHON) test/test_async.py; \
-	fi
+	$(PYTHON) test/test_async.py
 
 develop:
 	pip install -e .
"
memory_profiler/__init__.py,memory_profiler.py,e8d6bf7e8326cf9688703ad1243e9cea9a2c132d,205f901c1768cac001635d4c8aad396b03852f1a,"Keep memory_profiler in single file, drop support of python <3.4","@@ -5,31 +5,22 @@ _CLEAN_GLOBALS = globals().copy()
 
 __version__ = '0.57.0'
 
+_CMD_USAGE = ""python -m memory_profiler script_file.py""
 
-from functools import wraps
+from asyncio import coroutine, iscoroutinefunction
+from contextlib import contextmanager
+from functools import partial, wraps
+import builtins
 import inspect
+import linecache
 import logging
 import os
+import pdb
 import subprocess
 import sys
 import time
 import traceback
 import warnings
-import contextlib
-
-from .code_map import CodeMap
-from .common import PY2, PY34, HAS_TRACEMALLOC
-from .utils import (
-    show_results,
-    choose_backend,
-    get_memory as _get_memory,
-    get_child_memory as _get_child_memory,
-)
-from .line_profiler import LineProfiler, get_profile_wrapper
-
-if PY34:
-    from ._async import get_profile_wrapper
-
 
 if sys.platform == ""win32"":
     # any value except signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT
@@ -54,17 +45,17 @@ except ImportError:
     line_cell_magic = lambda func: func
     magics_class = lambda cls: cls
 
-if PY2:
-    import __builtin__ as builtins
-    to_str = lambda x: x
-    from future_builtins import filter
-else:
-    import builtins
-    to_str = lambda x: str(x)
+_TWO_20 = float(2 ** 20)
 
-if HAS_TRACEMALLOC:
+
+# .. get available packages ..
+try:
     import tracemalloc
 
+    has_tracemalloc = True
+except ImportError:
+    has_tracemalloc = False
+
 
 class MemitResult(object):
     """"""memit magic run details.
@@ -91,6 +82,108 @@ class MemitResult(object):
         p.text(u'<MemitResult : ' + msg + u'>')
 
 
+def _get_child_memory(process, meminfo_attr=None):
+    """"""
+    Returns a generator that yields memory for all child processes.
+    """"""
+    # Convert a pid to a process
+    if isinstance(process, int):
+        if process == -1: process = os.getpid()
+        process = psutil.Process(process)
+
+    if not meminfo_attr:
+        # Use the psutil 2.0 attr if the older version isn't passed in.
+        meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
+
+    # Select the psutil function get the children similar to how we selected
+    # the memory_info attr (a change from excepting the AttributeError).
+    children_attr = 'children' if hasattr(process, 'children') else 'get_children'
+
+    # Loop over the child processes and yield their memory
+    try:
+        for child in getattr(process, children_attr)(recursive=True):
+            yield getattr(child, meminfo_attr)()[0] / _TWO_20
+    except (psutil.NoSuchProcess, psutil.AccessDenied):
+        # https://github.com/fabianp/memory_profiler/issues/71
+        yield 0.0
+
+
+def _get_memory(pid, backend, timestamps=False, include_children=False, filename=None):
+    # .. low function to get memory consumption ..
+    if pid == -1:
+        pid = os.getpid()
+
+    def tracemalloc_tool():
+        # .. cross-platform but but requires Python 3.4 or higher ..
+        stat = next(filter(lambda item: str(item).startswith(filename),
+                           tracemalloc.take_snapshot().statistics('filename')))
+        mem = stat.size / _TWO_20
+        if timestamps:
+            return mem, time.time()
+        else:
+            return mem
+
+    def ps_util_tool():
+        # .. cross-platform but but requires psutil ..
+        process = psutil.Process(pid)
+        try:
+            # avoid using get_memory_info since it does not exists
+            # in psutil > 2.0 and accessing it will cause exception.
+            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') \
+                else 'get_memory_info'
+            mem = getattr(process, meminfo_attr)()[0] / _TWO_20
+            if include_children:
+                mem +=  sum(_get_child_memory(process, meminfo_attr))
+            if timestamps:
+                return mem, time.time()
+            else:
+                return mem
+        except psutil.AccessDenied:
+            pass
+            # continue and try to get this from ps
+
+    def posix_tool():
+        # .. scary stuff ..
+        if include_children:
+            raise NotImplementedError((
+                ""The psutil module is required to monitor the ""
+                ""memory usage of child processes.""
+            ))
+
+        warnings.warn(""psutil module not found. memory_profiler will be slow"")
+        # ..
+        # .. memory usage in MiB ..
+        # .. this should work on both Mac and Linux ..
+        # .. subprocess.check_output appeared in 2.7, using Popen ..
+        # .. for backwards compatibility ..
+        out = subprocess.Popen(['ps', 'v', '-p', str(pid)],
+                               stdout=subprocess.PIPE
+                               ).communicate()[0].split(b'\n')
+        try:
+            vsz_index = out[0].split().index(b'RSS')
+            mem = float(out[1].split()[vsz_index]) / 1024
+            if timestamps:
+                return mem, time.time()
+            else:
+                return mem
+        except:
+            if timestamps:
+                return -1, time.time()
+            else:
+                return -1
+
+    if backend == 'tracemalloc' and \
+            (filename is None or filename == '<unknown>'):
+        raise RuntimeError(
+            'There is no access to source file of the profiled function'
+        )
+
+    tools = {'tracemalloc': tracemalloc_tool,
+             'psutil': ps_util_tool,
+             'posix': posix_tool}
+    return tools[backend]()
+
+
 class MemTimer(Process):
     """"""
     Fetch memory consumption from over a time interval
@@ -180,10 +273,10 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         to this file instead of stored in memory and returned at the end of
         the subprocess. Useful for long-running processes.
         Implies timestamps=True.
-        
+
     max_iterations : int
         Limits the number of iterations (calls to the process being monitored). Relevent
-        when the process is a python function. 
+        when the process is a python function.
 
     Returns
     -------
@@ -257,7 +350,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                 raise
 
             p.join(5 * interval)
-            
+
             if (n_measurements > 4) or (current_iter == max_iter) or (interval < 1e-6):
                 break
             interval /= 10.
@@ -348,17 +441,36 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 # .. utility functions for line-by-line ..
 
 
+def _find_script(script_name):
+    """""" Find the script.
+
+    If the input is not a file, then $PATH will be searched.
+    """"""
+    if os.path.isfile(script_name):
+        return script_name
+    path = os.getenv('PATH', os.defpath).split(os.pathsep)
+    for folder in path:
+        if not folder:
+            continue
+        fn = os.path.join(folder, script_name)
+        if os.path.isfile(fn):
+            return fn
+
+    sys.stderr.write('Could not find script {0}\n'.format(script_name))
+    raise SystemExit(1)
 
 
 class _TimeStamperCM(object):
     """"""Time-stamping context manager.""""""
 
-    def __init__(self, timestamps, filename, backend, timestamper=None, func=None):
+    def __init__(self, timestamps, filename, backend, timestamper=None, func=None,
+                 include_children=False):
         self.timestamps = timestamps
         self.filename = filename
         self.backend = backend
         self.ts = timestamper
         self.func = func
+        self.include_children = include_children
 
     def __enter__(self):
         if self.ts is not None:
@@ -366,14 +478,16 @@ class _TimeStamperCM(object):
             self.ts.stack[self.func].append(self.ts.current_stack_level)
 
         self.timestamps.append(
-            _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
+            _get_memory(os.getpid(), self.backend, timestamps=True,
+                        include_children=self.include_children, filename=self.filename))
 
     def __exit__(self, *args):
         if self.ts is not None:
             self.ts.current_stack_level -= 1
 
         self.timestamps.append(
-            _get_memory(os.getpid(), self.backend, timestamps=True, filename=self.filename))
+            _get_memory(os.getpid(), self.backend, timestamps=True,
+                        include_children=self.include_children, filename=self.filename))
 
 
 class TimeStamper:
@@ -381,9 +495,10 @@ class TimeStamper:
     any decorated function.
     """"""
 
-    def __init__(self, backend):
+    def __init__(self, backend, include_children=False):
         self.functions = {}
         self.backend = backend
+        self.include_children = include_children
         self.current_stack_level = -1
         self.stack = {}
 
@@ -444,7 +559,8 @@ class TimeStamper:
             except TypeError:
                 filename = '<unknown>'
             timestamps = [
-                _get_memory(os.getpid(), self.backend, timestamps=True, filename=filename)]
+                _get_memory(os.getpid(), self.backend, timestamps=True,
+                            include_children=self.include_children, filename=filename)]
             self.functions[func].append(timestamps)
             try:
                 with self.call_on_stack(func, *args, **kwds) as result:
@@ -452,11 +568,12 @@ class TimeStamper:
             finally:
                 # end time
                 timestamps.append(_get_memory(os.getpid(), self.backend, timestamps=True,
+                                              include_children=self.include_children,
                                               filename=filename))
 
         return f
 
-    @contextlib.contextmanager
+    @contextmanager
     def call_on_stack(self, func, *args, **kwds):
         self.current_stack_level += 1
         self.stack[func].append(self.current_stack_level)
@@ -476,6 +593,252 @@ class TimeStamper:
                     (function_name,) + ts[0] + ts[1] + (level,)))
 
 
+class CodeMap(dict):
+    def __init__(self, include_children, backend):
+        self.include_children = include_children
+        self._toplevel = []
+        self.backend = backend
+
+    def add(self, code, toplevel_code=None):
+        if code in self:
+            return
+
+        if toplevel_code is None:
+            filename = code.co_filename
+            if filename.endswith(("".pyc"", "".pyo"")):
+                filename = filename[:-1]
+            if not os.path.exists(filename):
+                print('ERROR: Could not find file ' + filename)
+                if filename.startswith((""ipython-input"", ""<ipython-input"")):
+                    print(
+                        ""NOTE: %mprun can only be used on functions defined in""
+                        "" physical files, and not in the IPython environment."")
+                return
+
+            toplevel_code = code
+            (sub_lines, start_line) = inspect.getsourcelines(code)
+            linenos = range(start_line,
+                            start_line + len(sub_lines))
+            self._toplevel.append((filename, code, linenos))
+            self[code] = {}
+        else:
+            self[code] = self[toplevel_code]
+
+        for subcode in filter(inspect.iscode, code.co_consts):
+            self.add(subcode, toplevel_code=toplevel_code)
+
+    def trace(self, code, lineno, prev_lineno):
+        memory = _get_memory(-1, self.backend, include_children=self.include_children,
+                             filename=code.co_filename)
+        prev_value = self[code].get(lineno, None)
+        previous_memory = prev_value[1] if prev_value else 0
+        previous_inc = prev_value[0] if prev_value else 0
+
+        prev_line_value = self[code].get(prev_lineno, None) if prev_lineno else None
+        prev_line_memory = prev_line_value[1] if prev_line_value else 0
+        occ_count = self[code][lineno][2] + 1 if lineno in self[code] else 1
+        self[code][lineno] = (
+            previous_inc + (memory - prev_line_memory),
+            max(memory, previous_memory),
+            occ_count,
+        )
+
+    def items(self):
+        """"""Iterate on the toplevel code blocks.""""""
+        for (filename, code, linenos) in self._toplevel:
+            measures = self[code]
+            if not measures:
+                continue  # skip if no measurement
+            line_iterator = ((line, measures.get(line)) for line in linenos)
+            yield (filename, line_iterator)
+
+
+class LineProfiler(object):
+    """""" A profiler that records the amount of memory for each line """"""
+
+    def __init__(self, **kw):
+        include_children = kw.get('include_children', False)
+        backend = kw.get('backend', 'psutil')
+        self.code_map = CodeMap(
+            include_children=include_children, backend=backend)
+        self.enable_count = 0
+        self.max_mem = kw.get('max_mem', None)
+        self.prevlines = []
+        self.backend = choose_backend(kw.get('backend', None))
+        self.prev_lineno = None
+
+    def __call__(self, func=None, precision=1):
+        if func is not None:
+            self.add_function(func)
+            f = self.wrap_function(func)
+            f.__module__ = func.__module__
+            f.__name__ = func.__name__
+            f.__doc__ = func.__doc__
+            f.__dict__.update(getattr(func, '__dict__', {}))
+            return f
+        else:
+            def inner_partial(f):
+                return self.__call__(f, precision=precision)
+
+            return inner_partial
+
+    def add_function(self, func):
+        """""" Record line profiling information for the given Python function.
+        """"""
+        try:
+            # func_code does not exist in Python3
+            code = func.__code__
+        except AttributeError:
+            warnings.warn(""Could not extract a code object for the object %r""
+                          % func)
+        else:
+            self.code_map.add(code)
+
+    @contextmanager
+    def _count_ctxmgr(self):
+        self.enable_by_count()
+        try:
+            yield
+        finally:
+            self.disable_by_count()
+
+    def wrap_function(self, func):
+        """""" Wrap a function to profile it.
+        """"""
+
+        if iscoroutinefunction(func):
+            @coroutine
+            def f(*args, **kwargs):
+                with self._count_ctxmgr():
+                    yield from func(*args, **kwargs)
+        else:
+            def f(*args, **kwds):
+                with self._count_ctxmgr():
+                    return func(*args, **kwds)
+
+        return f
+
+    def runctx(self, cmd, globals, locals):
+        """""" Profile a single executable statement in the given namespaces.
+        """"""
+        self.enable_by_count()
+        try:
+            exec(cmd, globals, locals)
+        finally:
+            self.disable_by_count()
+        return self
+
+    def enable_by_count(self):
+        """""" Enable the profiler if it hasn't been enabled before.
+        """"""
+        if self.enable_count == 0:
+            self.enable()
+        self.enable_count += 1
+
+    def disable_by_count(self):
+        """""" Disable the profiler if the number of disable requests matches the
+        number of enable requests.
+        """"""
+        if self.enable_count > 0:
+            self.enable_count -= 1
+            if self.enable_count == 0:
+                self.disable()
+
+    def trace_memory_usage(self, frame, event, arg):
+        """"""Callback for sys.settrace""""""
+        if frame.f_code in self.code_map:
+            if event == 'call':
+                # ""call"" event just saves the lineno but not the memory
+                self.prevlines.append(frame.f_lineno)
+            elif event == 'line':
+                # trace needs current line and previous line
+                self.code_map.trace(frame.f_code, self.prevlines[-1], self.prev_lineno)
+                # saving previous line
+                self.prev_lineno = self.prevlines[-1]
+                self.prevlines[-1] = frame.f_lineno
+            elif event == 'return':
+                lineno = self.prevlines.pop()
+                self.code_map.trace(frame.f_code, lineno, self.prev_lineno)
+                self.prev_lineno = lineno
+
+        if self._original_trace_function is not None:
+            self._original_trace_function(frame, event, arg)
+
+        return self.trace_memory_usage
+
+    def trace_max_mem(self, frame, event, arg):
+        # run into PDB as soon as memory is higher than MAX_MEM
+        if event in ('line', 'return') and frame.f_code in self.code_map:
+            c = _get_memory(-1, self.backend, filename=frame.f_code.co_filename)
+            if c >= self.max_mem:
+                t = ('Current memory {0:.2f} MiB exceeded the '
+                     'maximum of {1:.2f} MiB\n'.format(c, self.max_mem))
+                sys.stdout.write(t)
+                sys.stdout.write('Stepping into the debugger \n')
+                frame.f_lineno -= 2
+                p = pdb.Pdb()
+                p.quitting = False
+                p.stopframe = frame
+                p.returnframe = None
+                p.stoplineno = frame.f_lineno - 3
+                p.botframe = None
+                return p.trace_dispatch
+
+        if self._original_trace_function is not None:
+            (self._original_trace_function)(frame, event, arg)
+
+        return self.trace_max_mem
+
+    def __enter__(self):
+        self.enable_by_count()
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        self.disable_by_count()
+
+    def enable(self):
+        self._original_trace_function = sys.gettrace()
+        if self.max_mem is not None:
+            sys.settrace(self.trace_max_mem)
+        else:
+            sys.settrace(self.trace_memory_usage)
+
+    def disable(self):
+        sys.settrace(self._original_trace_function)
+
+
+def show_results(prof, stream=None, precision=1):
+    if stream is None:
+        stream = sys.stdout
+    template = '{0:>6} {1:>12} {2:>12}  {3:>10}   {4:<}'
+
+    for (filename, lines) in prof.code_map.items():
+        header = template.format('Line #', 'Mem usage', 'Increment', 'Occurences',
+                                 'Line Contents')
+
+        stream.write(u'Filename: ' + filename + '\n\n')
+        stream.write(header + u'\n')
+        stream.write(u'=' * len(header) + '\n')
+
+        all_lines = linecache.getlines(filename)
+
+        float_format = u'{0}.{1}f'.format(precision + 4, precision)
+        template_mem = u'{0:' + float_format + '} MiB'
+        for (lineno, mem) in lines:
+            if mem:
+                inc = mem[0]
+                total_mem = mem[1]
+                total_mem = template_mem.format(total_mem)
+                occurences = mem[2]
+                inc = template_mem.format(inc)
+            else:
+                total_mem = u''
+                inc = u''
+                occurences = u''
+            tmp = template.format(lineno, total_mem, inc, occurences, all_lines[lineno - 1])
+            stream.write(tmp)
+        stream.write(u'\n\n')
+
+
 def _func_exec(stmt, ns):
     # helper for magic_memit, just a function proxy for the exec
     # statement
@@ -758,11 +1121,29 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
     Decorator that will run the function and print a line-by-line profile
     """"""
     backend = choose_backend(backend)
-    if backend == 'tracemalloc' and HAS_TRACEMALLOC:
+    if backend == 'tracemalloc' and has_tracemalloc:
         if not tracemalloc.is_tracing():
             tracemalloc.start()
     if func is not None:
-        return get_profile_wrapper(func, precision, backend, stream)
+        get_prof = partial(LineProfiler, backend=backend)
+        show_results_bound = partial(
+            show_results, stream=stream, precision=precision
+        )
+        if iscoroutinefunction(func):
+            @coroutine
+            def wrapper(*args, **kwargs):
+                prof = get_prof()
+                val = yield from prof(func)(*args, **kwargs)
+                show_results_bound(prof)
+                return val
+        else:
+            def wrapper(*args, **kwargs):
+                prof = get_prof()
+                val = prof(func)(*args, **kwargs)
+                show_results_bound(prof)
+                return val
+
+        return wrapper
     else:
         def inner_wrapper(f):
             return profile(f, stream=stream, precision=precision,
@@ -771,32 +1152,58 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
         return inner_wrapper
 
 
+def choose_backend(new_backend=None):
+    """"""
+    Function that tries to setup backend, chosen by user, and if failed,
+    setup one of the allowable backends
+    """"""
+
+    _backend = 'no_backend'
+    all_backends = [
+        ('psutil', True),
+        ('posix', os.name == 'posix'),
+        ('tracemalloc', has_tracemalloc),
+    ]
+    backends_indices = dict((b[0], i) for i, b in enumerate(all_backends))
+
+    if new_backend is not None:
+        all_backends.insert(0, all_backends.pop(backends_indices[new_backend]))
+
+    for n_backend, is_available in all_backends:
+        if is_available:
+            _backend = n_backend
+            break
+    if _backend != new_backend and new_backend is not None:
+        warnings.warn('{0} can not be used, {1} used instead'.format(
+            new_backend, _backend))
+    return _backend
+
+
 # Insert in the built-ins to have profile
 # globally defined (global variables is not enough
 # for all cases, e.g. a script that imports another
 # script where @profile is used)
 def exec_with_profiler(filename, profiler, backend, passed_args=[]):
+    from runpy import run_module
     builtins.__dict__['profile'] = profiler
-    ns = dict(
-        _CLEAN_GLOBALS,
-        profile=profiler,
-        # Make sure the __file__ variable is usable
-        # by the script we're profiling
-        __file__=filename
-    )
+    ns = dict(_CLEAN_GLOBALS,
+              profile=profiler,
+             # Make sure the __file__ variable is usable
+             # by the script we're profiling
+              __file__=filename)
     # Make sure the script's directory in on sys.path
     # credit to line_profiler
-    sys.path.insert(0, os.path.dirname(filename))
+    sys.path.insert(0, os.path.dirname(script_filename))
 
     _backend = choose_backend(backend)
     sys.argv = [filename] + passed_args
     try:
-        if _backend == 'tracemalloc' and HAS_TRACEMALLOC:
+        if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
         with open(filename) as f:
             exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
-        if HAS_TRACEMALLOC and tracemalloc.is_tracing():
+        if has_tracemalloc and tracemalloc.is_tracing():
             tracemalloc.stop()
 
 
@@ -806,16 +1213,13 @@ def run_module_with_profiler(module, profiler, backend, passed_args=[]):
     ns = dict(_CLEAN_GLOBALS, profile=profiler)
     _backend = choose_backend(backend)
     sys.argv = [module] + passed_args
-    if PY2:
+    if _backend == 'tracemalloc' and has_tracemalloc:
+        tracemalloc.start()
+    try:
         run_module(module, run_name=""__main__"", init_globals=ns)
-    else:
-        if _backend == 'tracemalloc' and HAS_TRACEMALLOC:
-            tracemalloc.start()
-        try:
-            run_module(module, run_name=""__main__"", init_globals=ns)
-        finally:
-            if HAS_TRACEMALLOC and tracemalloc.is_tracing():
-                tracemalloc.stop()
+    finally:
+        if has_tracemalloc and tracemalloc.is_tracing():
+            tracemalloc.stop()
 
 
 class LogFile(object):
@@ -848,3 +1252,64 @@ class LogFile(object):
     def flush(self):
         for handler in self.logger.handlers:
             handler.flush()
+
+
+if __name__ == '__main__':
+    from argparse import ArgumentParser, REMAINDER
+
+    parser = ArgumentParser(usage=_CMD_USAGE)
+    parser.add_argument('--version', action='version', version=__version__)
+    parser.add_argument(
+        '--pdb-mmem', dest='max_mem', metavar='MAXMEM',
+        type=float, action='store',
+        help='step into the debugger when memory exceeds MAXMEM')
+    parser.add_argument(
+        '--precision', dest='precision', type=int,
+        action='store', default=3,
+        help='precision of memory output in number of significant digits')
+    parser.add_argument('-o', dest='out_filename', type=str,
+        action='store', default=None,
+        help='path to a file where results will be written')
+    parser.add_argument('--timestamp', dest='timestamp', default=False,
+        action='store_true',
+        help='''print timestamp instead of memory measurement for
+        decorated functions''')
+    parser.add_argument('--include-children', dest='include_children',
+        default=False, action='store_true',
+        help='also include memory used by child processes')
+    parser.add_argument('--backend', dest='backend', type=str, action='store',
+        choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
+        help='backend using for getting memory info '
+             '(one of the {tracemalloc, psutil, posix})')
+    parser.add_argument(""program"", nargs=REMAINDER,
+        help='python script or module followed by command line arguements to run')
+    args = parser.parse_args()
+
+    if len(args.program) == 0:
+        print(""A program to run must be provided. Use -h for help"")
+        sys.exit(1)
+
+    target = args.program[0]
+    script_args = args.program[1:]
+    _backend = choose_backend(args.backend)
+    if args.timestamp:
+        prof = TimeStamper(_backend, include_children=args.include_children)
+    else:
+        prof = LineProfiler(max_mem=args.max_mem, backend=_backend)
+
+    try:
+        if args.program[0].endswith('.py'):
+            script_filename = _find_script(args.program[0])
+            exec_with_profiler(script_filename, prof, args.backend, script_args)
+        else:
+            run_module_with_profiler(target, prof, args.backend, script_args)
+    finally:
+        if args.out_filename is not None:
+            out_file = open(args.out_filename, ""a"")
+        else:
+            out_file = sys.stdout
+
+        if args.timestamp:
+            prof.show_results(stream=out_file)
+        else:
+            show_results(prof, precision=args.precision, stream=out_file)
"
memory_profiler/__main__.py,,e8d6bf7e8326cf9688703ad1243e9cea9a2c132d,205f901c1768cac001635d4c8aad396b03852f1a,"Keep memory_profiler in single file, drop support of python <3.4","@@ -1,115 +0,0 @@
-import os
-import sys
-from argparse import ArgumentParser, REMAINDER
-
-from . import exec_with_profiler, run_module_with_profiler, TimeStamper, __version__
-from .line_profiler import LineProfiler
-from .utils import choose_backend, show_results
-
-
-_CMD_USAGE = ""python -m memory_profiler script_file.py""
-
-
-def _find_script(script_name):
-    """""" Find the script.
-
-    If the input is not a file, then $PATH will be searched.
-    """"""
-    if os.path.isfile(script_name):
-        return script_name
-    path = os.getenv('PATH', os.defpath).split(os.pathsep)
-    for folder in path:
-        if not folder:
-            continue
-        fn = os.path.join(folder, script_name)
-        if os.path.isfile(fn):
-            return fn
-
-    sys.stderr.write('Could not find script {0}\n'.format(script_name))
-    raise SystemExit(1)
-
-
-if __name__ == '__main__':
-    parser = ArgumentParser(usage=_CMD_USAGE)
-    parser.add_argument('--version', action='version', version=__version__)
-    parser.add_argument(
-        '--pdb-mmem',
-        dest='max_mem',
-        metavar='MAXMEM',
-        type=float,
-        action='store',
-        help='step into the debugger when memory exceeds MAXMEM'
-    )
-    parser.add_argument(
-        '--precision',
-        dest='precision',
-        type=int,
-        action='store',
-        default=3,
-        help='precision of memory output in number of significant digits'
-    )
-    parser.add_argument(
-        '-o',
-        dest='out_filename',
-        type=str,
-        action='store',
-        default=None,
-        help='path to a file where results will be written'
-    )
-    parser.add_argument(
-        '--timestamp',
-        dest='timestamp',
-        default=False,
-        action='store_true',
-        help='''print timestamp instead of memory measurement for
-        decorated functions'''
-    )
-    parser.add_argument(
-        '--backend',
-        dest='backend',
-        type=str,
-        action='store',
-        choices=['tracemalloc', 'psutil', 'posix'],
-        default='psutil',
-        help='backend using for getting memory info '
-             '(one of the {tracemalloc, psutil, posix})'
-    )
-    parser.add_argument(
-        ""program"",
-        nargs=REMAINDER,
-        help='python script or module followed by '
-             'command line arguments to run'
-    )
-    args = parser.parse_args()
-
-    if len(args.program) == 0:
-        print(""A program to run must be provided. Use -h for help"")
-        sys.exit(1)
-
-    target = args.program[0]
-    script_args = args.program[1:]
-
-    _backend = choose_backend(args.backend)
-    if args.timestamp:
-        prof = TimeStamper(_backend)
-    else:
-        prof = LineProfiler(max_mem=args.max_mem, backend=_backend)
-
-    try:
-        if args.program[0].endswith('.py'):
-            script_filename = _find_script(args.program[0])
-            exec_with_profiler(
-                script_filename, prof, args.backend, script_args
-            )
-        else:
-            run_module_with_profiler(target, prof, args.backend, script_args)
-    finally:
-        if args.out_filename is not None:
-            out_file = open(args.out_filename, ""a"")
-        else:
-            out_file = sys.stdout
-
-        if args.timestamp:
-            prof.show_results(stream=out_file)
-        else:
-            show_results(prof, precision=args.precision, stream=out_file)
"
memory_profiler/_async.py,,e8d6bf7e8326cf9688703ad1243e9cea9a2c132d,205f901c1768cac001635d4c8aad396b03852f1a,"Keep memory_profiler in single file, drop support of python <3.4","@@ -1,35 +0,0 @@
-from asyncio import coroutine, iscoroutinefunction
-from functools import wraps
-
-from .line_profiler import (
-    get_profile_wrapper as default_profile_wrapper,
-    LineProfiler,
-)
-from .utils import show_results
-
-
-class CoroLineProfiler(LineProfiler):
-    def wrap_function(self, func):
-        if iscoroutinefunction(func):
-            @coroutine
-            def f(*args, **kwargs):
-                with self.count_ctxmgr():
-                    yield from func(*args, **kwargs)
-            return f
-        else:
-            return super().wrap_function(func)
-
-
-def get_profile_wrapper(func, precision, backend, stream):
-    if iscoroutinefunction(func):
-        @wraps(func)
-        @coroutine
-        def wrapper(*args, **kwargs):
-            prof = CoroLineProfiler(backend=backend)
-            val = yield from prof(func)(*args, **kwargs)
-            show_results(prof, stream=stream, precision=precision)
-            return val
-    else:
-        wrapper = default_profile_wrapper(func, precision, backend, stream)
-
-    return wrapper
"
memory_profiler/code_map.py,,e8d6bf7e8326cf9688703ad1243e9cea9a2c132d,205f901c1768cac001635d4c8aad396b03852f1a,"Keep memory_profiler in single file, drop support of python <3.4","@@ -1,69 +0,0 @@
-import inspect
-import os.path
-
-from .utils import get_memory
-
-
-class CodeMap(dict):
-    def __init__(self, include_children, backend):
-        self.include_children = include_children
-        self._toplevel = []
-        self.backend = backend
-
-    def add(self, code, toplevel_code=None):
-        if code in self:
-            return
-
-        if toplevel_code is None:
-            filename = code.co_filename
-            if filename.endswith(("".pyc"", "".pyo"")):
-                filename = filename[:-1]
-            if not os.path.exists(filename):
-                print('ERROR: Could not find file ' + filename)
-                if filename.startswith((""ipython-input"", ""<ipython-input"")):
-                    print(
-                        ""NOTE: %mprun can only be used on functions defined in""
-                        "" physical files, and not in the IPython environment."")
-                return
-
-            toplevel_code = code
-            (sub_lines, start_line) = inspect.getsourcelines(code)
-            linenos = range(start_line,
-                            start_line + len(sub_lines))
-            self._toplevel.append((filename, code, linenos))
-            self[code] = {}
-        else:
-            self[code] = self[toplevel_code]
-
-        for subcode in filter(inspect.iscode, code.co_consts):
-            self.add(subcode, toplevel_code=toplevel_code)
-
-    def trace(self, code, lineno, prev_lineno):
-        memory = get_memory(
-            -1,
-            self.backend,
-            include_children=self.include_children,
-            filename=code.co_filename
-        )
-        prev_value = self[code].get(lineno, None)
-        previous_memory = prev_value[1] if prev_value else 0
-        previous_inc = prev_value[0] if prev_value else 0
-
-        prev_line_value = (
-            self[code].get(prev_lineno, None)
-            if prev_lineno else None
-        )
-        prev_line_memory = prev_line_value[1] if prev_line_value else 0
-        self[code][lineno] = (
-            max(previous_inc, memory-prev_line_memory),
-            max(memory, previous_memory)
-        )
-
-    def items(self):
-        """"""Iterate on the toplevel code blocks.""""""
-        for (filename, code, linenos) in self._toplevel:
-            measures = self[code]
-            if not measures:
-                continue  # skip if no measurement
-            line_iterator = ((line, measures.get(line)) for line in linenos)
-            yield (filename, line_iterator)
"
memory_profiler/common.py,,e8d6bf7e8326cf9688703ad1243e9cea9a2c132d,205f901c1768cac001635d4c8aad396b03852f1a,"Keep memory_profiler in single file, drop support of python <3.4","@@ -1,15 +0,0 @@
-import sys
-
-
-PY2 = sys.version_info[0] == 2
-
-PY34 = (3, 4) < sys.version_info
-
-try:
-    import tracemalloc  # noqa
-except ImportError:
-    HAS_TRACEMALLOC = False
-else:
-    HAS_TRACEMALLOC = True
-
-TWO_20 = float(2 ** 20)
"
memory_profiler/line_profiler.py,,e8d6bf7e8326cf9688703ad1243e9cea9a2c132d,205f901c1768cac001635d4c8aad396b03852f1a,"Keep memory_profiler in single file, drop support of python <3.4","@@ -1,163 +0,0 @@
-import pdb
-import sys
-import warnings
-from contextlib import contextmanager
-from functools import wraps
-
-from .code_map import CodeMap
-from .utils import choose_backend, get_memory, show_results
-
-
-class LineProfiler(object):
-    """""" A profiler that records the amount of memory for each line """"""
-
-    def __init__(self, **kw):
-        include_children = kw.get('include_children', False)
-        backend = kw.get('backend', 'psutil')
-        self.code_map = CodeMap(
-            include_children=include_children, backend=backend)
-        self.enable_count = 0
-        self.max_mem = kw.get('max_mem', None)
-        self.prevlines = []
-        self.backend = choose_backend(kw.get('backend', None))
-        self.prev_lineno = None
-
-    def __call__(self, func=None, precision=1):
-        if func is not None:
-            self.add_function(func)
-            f = self.wrap_function(func)
-            f.__module__ = func.__module__
-            f.__name__ = func.__name__
-            f.__doc__ = func.__doc__
-            f.__dict__.update(getattr(func, '__dict__', {}))
-            return f
-        else:
-            def inner_partial(f):
-                return self.__call__(f, precision=precision)
-
-            return inner_partial
-
-    def add_function(self, func):
-        """""" Record line profiling information for the given Python function.
-        """"""
-        try:
-            # func_code does not exist in Python3
-            code = func.__code__
-        except AttributeError:
-            warnings.warn(""Could not extract a code object for the object %r""
-                          % func)
-        else:
-            self.code_map.add(code)
-
-    @contextmanager
-    def count_ctxmgr(self):
-        self.enable_by_count()
-        try:
-            yield
-        finally:
-            self.disable_by_count()
-
-    def wrap_function(self, func):
-        """""" Wrap a function to profile it.
-        """"""
-
-        def f(*args, **kwds):
-            with self.count_ctxmgr():
-                return func(*args, **kwds)
-
-        return f
-
-    def runctx(self, cmd, globals, locals):
-        """""" Profile a single executable statement in the given namespaces.
-        """"""
-        with self.count_ctxmgr():
-            exec(cmd, globals, locals)
-        return self
-
-    def enable_by_count(self):
-        """""" Enable the profiler if it hasn't been enabled before.
-        """"""
-        if self.enable_count == 0:
-            self.enable()
-        self.enable_count += 1
-
-    def disable_by_count(self):
-        """""" Disable the profiler if the number of disable requests matches the
-        number of enable requests.
-        """"""
-        if self.enable_count > 0:
-            self.enable_count -= 1
-            if self.enable_count == 0:
-                self.disable()
-
-    def trace_memory_usage(self, frame, event, arg):
-        """"""Callback for sys.settrace""""""
-        if frame.f_code in self.code_map:
-            if event == 'call':
-                # ""call"" event just saves the lineno but not the memory
-                self.prevlines.append(frame.f_lineno)
-            elif event == 'line':
-                # trace needs current line and previous line
-                self.code_map.trace(frame.f_code, self.prevlines[-1], self.prev_lineno)
-                # saving previous line
-                self.prev_lineno = self.prevlines[-1]
-                self.prevlines[-1] = frame.f_lineno
-            elif event == 'return':
-                lineno = self.prevlines.pop()
-                self.code_map.trace(frame.f_code, lineno, self.prev_lineno)
-                self.prev_lineno = lineno
-
-        if self._original_trace_function is not None:
-            self._original_trace_function(frame, event, arg)
-
-        return self.trace_memory_usage
-
-    def trace_max_mem(self, frame, event, arg):
-        # run into PDB as soon as memory is higher than MAX_MEM
-        if event in ('line', 'return') and frame.f_code in self.code_map:
-            c = get_memory(-1, self.backend, filename=frame.f_code.co_filename)
-            if c >= self.max_mem:
-                t = ('Current memory {0:.2f} MiB exceeded the '
-                     'maximum of {1:.2f} MiB\n'.format(c, self.max_mem))
-                sys.stdout.write(t)
-                sys.stdout.write('Stepping into the debugger \n')
-                frame.f_lineno -= 2
-                p = pdb.Pdb()
-                p.quitting = False
-                p.stopframe = frame
-                p.returnframe = None
-                p.stoplineno = frame.f_lineno - 3
-                p.botframe = None
-                return p.trace_dispatch
-
-        if self._original_trace_function is not None:
-            (self._original_trace_function)(frame, event, arg)
-
-        return self.trace_max_mem
-
-    def __enter__(self):
-        self.enable_by_count()
-
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        self.disable_by_count()
-
-    def enable(self):
-        self._original_trace_function = sys.gettrace()
-        if self.max_mem is not None:
-            sys.settrace(self.trace_max_mem)
-        else:
-            sys.settrace(self.trace_memory_usage)
-
-    def disable(self):
-        sys.settrace(self._original_trace_function)
-
-
-def get_profile_wrapper(func, precision, backend, stream):
-    @wraps(func)
-    def wrapper(*args, **kwargs):
-        prof = LineProfiler(backend=backend)
-        val = prof(func)(*args, **kwargs)
-        show_results(prof, stream=stream, precision=precision)
-        return val
-
-    return wrapper
"
memory_profiler/utils.py,,e8d6bf7e8326cf9688703ad1243e9cea9a2c132d,205f901c1768cac001635d4c8aad396b03852f1a,"Keep memory_profiler in single file, drop support of python <3.4","@@ -1,183 +0,0 @@
-import linecache
-import os
-import sys
-import warnings
-import subprocess
-import time
-
-import psutil
-
-from .common import HAS_TRACEMALLOC, PY2, TWO_20
-
-if HAS_TRACEMALLOC:
-    import tracemalloc
-
-
-if PY2:
-    def to_str(x):
-        return x
-
-    from future_builtins import filter
-else:
-    def to_str(x):
-        return str(x)
-
-
-def show_results(prof, stream=None, precision=1):
-    if stream is None:
-        stream = sys.stdout
-    template = '{0:>6} {1:>12} {2:>12}   {3:<}'
-
-    for (filename, lines) in prof.code_map.items():
-        header = template.format('Line #', 'Mem usage', 'Increment',
-                                 'Line Contents')
-
-        stream.write(u'Filename: ' + filename + '\n\n')
-        stream.write(header + u'\n')
-        stream.write(u'=' * len(header) + '\n')
-
-        all_lines = linecache.getlines(filename)
-
-        float_format = u'{0}.{1}f'.format(precision + 4, precision)
-        template_mem = u'{0:' + float_format + '} MiB'
-        for (lineno, mem) in lines:
-            if mem:
-                inc = mem[0]
-                mem = mem[1]
-                mem = template_mem.format(mem)
-                inc = template_mem.format(inc)
-            else:
-                mem = u''
-                inc = u''
-            tmp = template.format(lineno, mem, inc, all_lines[lineno - 1])
-            stream.write(to_str(tmp))
-        stream.write(u'\n\n')
-
-
-def choose_backend(new_backend=None):
-    """"""
-    Function that tries to setup backend, chosen by user, and if failed,
-    setup one of the allowable backends
-    """"""
-
-    _backend = 'no_backend'
-    all_backends = [
-        ('psutil', True),
-        ('posix', os.name == 'posix'),
-        ('tracemalloc', HAS_TRACEMALLOC),
-    ]
-    backends_indices = dict((b[0], i) for i, b in enumerate(all_backends))
-
-    if new_backend is not None:
-        all_backends.insert(0, all_backends.pop(backends_indices[new_backend]))
-
-    for n_backend, is_available in all_backends:
-        if is_available:
-            _backend = n_backend
-            break
-    if _backend != new_backend and new_backend is not None:
-        warnings.warn('{0} can not be used, {1} used instead'.format(
-            new_backend, _backend))
-    return _backend
-
-
-def get_child_memory(process, meminfo_attr=None):
-    """"""
-    Returns a generator that yields memory for all child processes.
-    """"""
-    # Convert a pid to a process
-    if isinstance(process, int):
-        if process == -1: process = os.getpid()
-        process = psutil.Process(process)
-
-    if not meminfo_attr:
-        # Use the psutil 2.0 attr if the older version isn't passed in.
-        meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
-
-    # Select the psutil function get the children similar to how we selected
-    # the memory_info attr (a change from excepting the AttributeError).
-    children_attr = 'children' if hasattr(process, 'children') else 'get_children'
-
-    # Loop over the child processes and yield their memory
-    try:
-        for child in getattr(process, children_attr)(recursive=True):
-            yield getattr(child, meminfo_attr)()[0] / TWO_20
-    except (psutil.NoSuchProcess, psutil.AccessDenied):
-        # https://github.com/fabianp/memory_profiler/issues/71
-        yield 0.0
-
-
-def get_memory(pid, backend, timestamps=False, include_children=False, filename=None):
-    # .. low function to get memory consumption ..
-    if pid == -1:
-        pid = os.getpid()
-
-    def tracemalloc_tool():
-        # .. cross-platform but but requires Python 3.4 or higher ..
-        stat = next(filter(lambda item: str(item).startswith(filename),
-                           tracemalloc.take_snapshot().statistics('filename')))
-        mem = stat.size / TWO_20
-        if timestamps:
-            return mem, time.time()
-        else:
-            return mem
-
-    def ps_util_tool():
-        # .. cross-platform but but requires psutil ..
-        process = psutil.Process(pid)
-        try:
-            # avoid using get_memory_info since it does not exists
-            # in psutil > 2.0 and accessing it will cause exception.
-            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') \
-                else 'get_memory_info'
-            mem = getattr(process, meminfo_attr)()[0] / TWO_20
-            if include_children:
-                mem += sum(get_child_memory(process, meminfo_attr))
-            if timestamps:
-                return mem, time.time()
-            else:
-                return mem
-        except psutil.AccessDenied:
-            pass
-            # continue and try to get this from ps
-
-    def posix_tool():
-        # .. scary stuff ..
-        if include_children:
-            raise NotImplementedError((
-                ""The psutil module is required to monitor the ""
-                ""memory usage of child processes.""
-            ))
-
-        warnings.warn(""psutil module not found. memory_profiler will be slow"")
-        # ..
-        # .. memory usage in MiB ..
-        # .. this should work on both Mac and Linux ..
-        # .. subprocess.check_output appeared in 2.7, using Popen ..
-        # .. for backwards compatibility ..
-        out = subprocess.Popen(['ps', 'v', '-p', str(pid)],
-                               stdout=subprocess.PIPE
-                               ).communicate()[0].split(b'\n')
-        try:
-            vsz_index = out[0].split().index(b'RSS')
-            mem = float(out[1].split()[vsz_index]) / 1024
-            if timestamps:
-                return mem, time.time()
-            else:
-                return mem
-        except:
-            if timestamps:
-                return -1, time.time()
-            else:
-                return -1
-
-    if backend == 'tracemalloc' and \
-            (filename is None or filename == '<unknown>'):
-        raise RuntimeError(
-            'There is no access to source file of the profiled function'
-        )
-
-    tools = {'tracemalloc': tracemalloc_tool,
-             'psutil': ps_util_tool,
-             'posix': posix_tool}
-    return tools[backend]()
"
.travis.yml,.travis.yml,f62614f26dbd8512cb4cf41942ce990f9dd05561,6dc1a0f780f17e5eaaf334675470b3d606e65125,Remove python2.7 from ci,"@@ -1,6 +1,5 @@
 language: python
 python:
-  - ""2.7""
   - ""3.4""
   - ""3.5""
   - ""3.6""
"
Makefile,Makefile,7c52327b024c8d954b1db5076ce7821f4be29ba6,f62614f26dbd8512cb4cf41942ce990f9dd05561,Remove python < 3.4 detection from Makefile,"@@ -1,6 +1,4 @@
 PYTHON ?= python
-PY_34 ?= $(shell ! python -c \
-		 'import sys; print((3, 4) < sys.version_info)')
 
 .PHONY: test develop
 
"
setup.py,setup.py,f9d95ef18168d4254ee8f6918b93cb21f0877791,7c52327b024c8d954b1db5076ce7821f4be29ba6,"setup.py cleanup

Minor refactoring of `find_version` function.
Remove old python tags.
Revert package module list.
Specify required python version.","@@ -1,22 +1,14 @@
-import os
-import io
 import re
-from setuptools import find_packages, setup
+from setuptools import setup
 
 
 # https://packaging.python.org/guides/single-sourcing-package-version/
-def read(*names, **kwargs):
-    with io.open(
-        os.path.join(os.path.dirname(__file__), *names),
-        encoding=kwargs.get(""encoding"", ""utf8"")
-    ) as fp:
-        return fp.read()
-
-
-def find_version(*file_paths):
-    version_file = read(*file_paths)
-    version_match = re.search(r""^__version__ = ['\""]([^'\""]*)['\""]"",
-                              version_file, re.M)
+def find_version(file_paths):
+    with open(file_paths) as f:
+        version_file = f.read()
+    version_match = re.search(
+        r""^__version__ = ['\""]([^'\""]*)['\""]"", version_file, re.M
+    )
     if version_match:
         return version_match.group(1)
 
@@ -27,12 +19,7 @@ Intended Audience :: Science/Research
 Intended Audience :: Developers
 License :: OSI Approved :: BSD License
 Programming Language :: Python
-Programming Language :: Python :: 2
-Programming Language :: Python :: 2.6
-Programming Language :: Python :: 2.7
 Programming Language :: Python :: 3
-Programming Language :: Python :: 3.2
-Programming Language :: Python :: 3.3
 Topic :: Software Development
 Operating System :: POSIX
 Operating System :: Unix
@@ -44,16 +31,16 @@ setup(
     name='memory_profiler',
     description='A module for monitoring memory usage of a python program',
     long_description=open('README.rst').read(),
-    version=find_version(""memory_profiler"", ""__init__.py""),
+    version=find_version(""memory_profiler.py""),
     author='Fabian Pedregosa',
     author_email='f@bianp.net',
     url='https://github.com/pythonprofilers/memory_profiler',
-    py_modules=['mprof'],
-    packages=find_packages(include=('memory_profiler',)),
+    py_modules=['memory_profiler', 'mprof'],
     entry_points={
         'console_scripts': ['mprof = mprof:main'],
     },
     install_requires=['psutil'],
+    python_requires='>=3.4',
     classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
     license='BSD'
 )
"
mprof.py,mprof.py,aab7597f578385cdf853e119b6870374df22bcfc,68f29500ad8ced9450f88f7379284824c2ba970b,"attach to existing process by pid or name

+ added action attach (alias for run --attach)
+ run --attach uses program name as hint pid/name to find what to
profile
+ default attach profiling is 1 hour
+ new process as before - infinite","@@ -8,6 +8,7 @@ import time
 import math
 import logging
 import itertools
+from ast import literal_eval
 
 from collections import defaultdict
 from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormatter
@@ -15,11 +16,12 @@ from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormat
 import importlib
 import memory_profiler as mp
 
-ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"")
+ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"", ""attach"")
 help_msg = """"""
 Available commands:
 
     run      run a given command or python file
+    attach   alias for 'run --attach': attach to an existing process by pid or name
     rm       remove a given file generated by mprof
     clean    clean the current directory from files created by mprof
     list     display existing profiles, with indices
@@ -176,6 +178,16 @@ def get_cmd_line(args):
     args = [s if blanks.isdisjoint(s) else ""'"" + s + ""'"" for s in args]
     return ' '.join(args)
 
+def find_first_process(name):
+    for i in mp.psutil.process_iter():
+        if name in i.name():
+            return i
+    return None
+
+def attach_action():
+    argv = sys.argv
+    sys.argv = argv[:1] + ['--attach'] + argv[1:]
+    run_action()
 
 def run_action():
     import time, subprocess
@@ -192,6 +204,10 @@ def run_action():
     parser.add_argument(""--multiprocess"", ""-M"", dest=""multiprocess"", action=""store_true"",
                         help=""""""Monitors forked processes creating individual plots for each child (disables --python features)"""""")
     parser.add_argument(""--exit-code"", ""-E"", dest=""exit_code"", action=""store_true"", help=""""""Propagate the exit code"""""")
+    attach_arg = parser.add_argument(""--attach"", ""-a"", dest=""attach_existing"", action=""store_true"",
+                        help=""Attach to an existing process, by process name or by pid"")
+    parser.add_argument(""--timeout"", ""-t"", dest=""timeout"", action=""store"", type=int,
+                        help=""timeout in seconds for the profiling, default new process has no timeout, attach existing is 1 hour"")
     parser.add_argument(""--output"", ""-o"", dest=""filename"",
                         default=""mprofile_%s.dat"" % time.strftime(""%Y%m%d%H%M%S"", time.localtime()),
                         help=""""""File to store results in, defaults to 'mprofile_<YYYYMMDDhhmmss>.dat' in the current directory,
@@ -214,34 +230,53 @@ This file contains the process memory consumption, in Mb (one value per line).""""
 
     mprofile_output = args.filename
 
-    # .. TODO: more than one script as argument ? ..
     program = args.program
-    if program[0].endswith('.py') and not args.nopython:
-        if args.multiprocess:
-            # in multiprocessing mode you want to spawn a separate
-            # python process
+    if args.attach_existing:
+        print('attaching to existing process, using hint: {}'.format(program[0]))
+        if program[0].isdigit():
+            p = literal_eval(program[0])
+            cmd_line = get_cmd_line(program)
+        else:
+            proc = find_first_process(program[0])
+            if proc is None:
+                raise ArgumentError(attach_arg, '\nWhen attaching, program should be process name or pid.\nFailed to find a process using hint: {}'.format(program[0]))
+            
+            p = proc.pid
+            try:
+                cmd_line = proc.cmdline()
+            except:
+                cmd_line = get_cmd_line(program)
+        if args.timeout is None:
+            args.timeout = 3600
+    else:
+        print('running new process')
+        # .. TODO: more than one script as argument ? ..
+        if program[0].endswith('.py') and not args.nopython:
+            if args.multiprocess:
+                # in multiprocessing mode you want to spawn a separate
+                # python process
+                if not program[0].startswith(""python""):
+                    program.insert(0, sys.executable)
+                args.python = False
+            else:
+                args.python = True
+        if args.python:
+            print(""running as a Python program..."")
             if not program[0].startswith(""python""):
                 program.insert(0, sys.executable)
-            args.python = False
+            cmd_line = get_cmd_line(program)
+            extra_args = [""-m"", ""memory_profiler"", ""--timestamp"", ""-o"", mprofile_output]
+            if args.include_children:
+                extra_args.append(""--include-children"")
+            program[1:1] = extra_args
+            p = subprocess.Popen(program)
         else:
-            args.python = True
-    if args.python:
-        print(""running as a Python program..."")
-        if not program[0].startswith(""python""):
-            program.insert(0, sys.executable)
-        cmd_line = get_cmd_line(program)
-        extra_args = [""-m"", ""memory_profiler"", ""--timestamp"", ""-o"", mprofile_output]
-        if args.include_children:
-            extra_args.append(""--include-children"")
-        program[1:1] = extra_args
-        p = subprocess.Popen(program)
-    else:
-        cmd_line = get_cmd_line(program)
-        p = subprocess.Popen(program)
+            cmd_line = get_cmd_line(program)
+            p = subprocess.Popen(program)
 
     with open(mprofile_output, ""a"") as f:
         f.write(""CMDLINE {0}\n"".format(cmd_line))
-        mp.memory_usage(proc=p, interval=args.interval, timestamps=True,
+        mp.memory_usage(proc=p, interval=args.interval, timeout=args.timeout, timestamps=True,
                         include_children=args.include_children,
                         multiprocess=args.multiprocess, stream=f)
 
@@ -837,6 +872,7 @@ def main():
                ""clean"": clean_action,
                ""list"": list_action,
                ""run"": run_action,
+               ""attach"": attach_action,
                ""plot"": plot_action}
     actions[get_action()]()
 
"
mprof.py,mprof.py,258a580e5d291e138cd0af44b76d0179869c1fa8,6cdae0ed83718fa741d58708f95b6f4cf78d37be,making mprof.py compatible with python 2.6,"@@ -743,7 +743,7 @@ def function_labels(dotted_function_names):
         if len(ambiguous_labels) == 0:
             break
 
-    fn_to_label = { label_state[""functions""][0] : label for label, label_state in state.items() }
+    fn_to_label = dict((label_state[""functions""][0] , label) for label, label_state in state.items())
 
     return fn_to_label
 
"
Makefile,Makefile,4d789da14ae683ebd9d6e702a15ba3d178ec1945,cb38943e05264f60da4371dc56cc6d301e17c7b5,"Add test for mprof, as per #181","@@ -19,6 +19,7 @@ test:
 	$(PYTHON) test/test_exit_code.py
 	$(PYTHON) test/test_mprof.py
 	$(PYTHON) test/test_async.py
+	mprof run test/test_func.py
 
 develop:
 	pip install -e .
"
memory_profiler.py,memory_profiler.py,5c1f75d7c90a2d982ce66a3d91d5ddf72965e434,4d789da14ae683ebd9d6e702a15ba3d178ec1945,"MAINT: Resolve (#127)

add specific encoding UTF-8 for resolving UnicodeDecodeError at memory_profiler.py","@@ -1200,7 +1200,7 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     try:
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
-        with open(filename) as f:
+        with open(filename, encoding='utf-8') as f:
             exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
         if has_tracemalloc and tracemalloc.is_tracing():
"
memory_profiler.py,memory_profiler.py,26c18bf7cccbf7baa07c0cabc224898efc0896a8,bd6da910f791cef725640fa207fb4ee433c93586,FIX: use wraps in profile,"@@ -1130,6 +1130,7 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
             show_results, stream=stream, precision=precision
         )
         if iscoroutinefunction(func):
+            @wraps(wrapped=func)
             @coroutine
             def wrapper(*args, **kwargs):
                 prof = get_prof()
@@ -1137,6 +1138,7 @@ def profile(func=None, stream=None, precision=1, backend='psutil'):
                 show_results_bound(prof)
                 return val
         else:
+            @wraps(wrapped=func)
             def wrapper(*args, **kwargs):
                 prof = get_prof()
                 val = prof(func)(*args, **kwargs)
"
,test/test_attributes.py,fbee01da57151c4a9e6c39615cefb55326b5aee5,26c18bf7cccbf7baa07c0cabc224898efc0896a8,TEST: add test to check profiled function maintains original attributes,"@@ -0,0 +1,12 @@
+from memory_profiler import profile
+
+
+@profile
+def test_with_profile(arg1):
+    """"""dummy doc""""""
+    return None
+
+
+if __name__ == '__main__':
+    assert test_with_profile.__doc__ == ""dummy doc""
+    assert test_with_profile.__name__ == ""test_with_profile""
"
mprof.py,mprof.py,04fc1a75723aa7058ea2b91005f0f7ffea9ed21e,685b5f8db2a838cd324e0d686cdf7f5290281706,"feat: adds `mprof peak` command

Prints maximum memory usage per dat file.","@@ -16,7 +16,7 @@ from argparse import ArgumentParser, ArgumentError, REMAINDER, RawTextHelpFormat
 import importlib
 import memory_profiler as mp
 
-ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"", ""attach"")
+ALL_ACTIONS = (""run"", ""rm"", ""clean"", ""list"", ""plot"", ""attach"", ""peak"")
 help_msg = """"""
 Available commands:
 
@@ -26,6 +26,7 @@ Available commands:
     clean    clean the current directory from files created by mprof
     list     display existing profiles, with indices
     plot     plot memory consumption generated by mprof run
+    peak     print the maximum memory used by an mprof run
 
 Type mprof <command> --help for usage help on a specific command.
 For example, mprof plot --help will list all plotting options.
@@ -794,33 +795,7 @@ such file in the current directory.""""""
         sys.exit(1)
     pl.ioff()
 
-    profiles = glob.glob(""mprofile_??????????????.dat"")
-    profiles.sort()
-
-    if len(args.profiles) == 0:
-        if len(profiles) == 0:
-            print(""No input file found. \nThis program looks for ""
-                  ""mprofile_*.dat files, generated by the ""
-                  ""'mprof run' command."")
-            sys.exit(-1)
-        print(""Using last profile data."")
-        filenames = [profiles[-1]]
-    else:
-        filenames = []
-        for prof in args.profiles:
-            if osp.exists(prof):
-                if not prof in filenames:
-                    filenames.append(prof)
-            else:
-                try:
-                    n = int(prof)
-                    if not profiles[n] in filenames:
-                        filenames.append(profiles[n])
-                except ValueError:
-                    print(""Input file not found: "" + prof)
-    if not len(filenames):
-        print(""No files found from given input."")
-        sys.exit(-1)
+    filenames = get_profiles(args)
 
     fig = pl.figure(figsize=(14, 6), dpi=90)
     if not args.flame_mode:
@@ -860,6 +835,51 @@ such file in the current directory.""""""
     else:
         pl.show()
 
+def peak_action():
+    desc = """"""Prints the peak memory used in data file `file.dat` generated
+using `mprof run`. If no .dat file is given, it will take the most recent
+such file in the current directory.""""""
+    parser = ArgumentParser(usage=""mprof peak [options] [file.dat]"", description=desc)
+    parser.add_argument(""profiles"", nargs=""*"",
+                    help=""profiles made by mprof run"") 
+    args = parser.parse_args()
+    filenames = get_profiles(args)
+
+    for filename in filenames:
+        prof = read_mprofile_file(filename)
+        print(""{}\t{:.3f} MiB"".format(prof[""filename""], max(prof[""mem_usage""])))
+
+def get_profiles(args):
+    profiles = glob.glob(""mprofile_??????????????.dat"")
+    profiles.sort()
+
+    if len(args.profiles) == 0:
+        if len(profiles) == 0:
+            print(""No input file found. \nThis program looks for ""
+                  ""mprofile_*.dat files, generated by the ""
+                  ""'mprof run' command."")
+            sys.exit(-1)
+        print(""Using last profile data."")
+        filenames = [profiles[-1]]
+    else:
+        filenames = []
+        for prof in args.profiles:
+            if osp.exists(prof):
+                if not prof in filenames:
+                    filenames.append(prof)
+            else:
+                try:
+                    n = int(prof)
+                    if not profiles[n] in filenames:
+                        filenames.append(profiles[n])
+                except ValueError:
+                    print(""Input file not found: "" + prof)
+    if not len(filenames):
+        print(""No files found from given input."")
+        sys.exit(-1)
+
+    return filenames
+
 def main():
     # Workaround for optparse limitation: insert -- before first negative
     # number found.
@@ -873,7 +893,8 @@ def main():
                ""list"": list_action,
                ""run"": run_action,
                ""attach"": attach_action,
-               ""plot"": plot_action}
+               ""plot"": plot_action,
+               ""peak"": peak_action}
     actions[get_action()]()
 
 if __name__ == ""__main__"":
"
mprof.py,mprof.py,4a0f9de3645b1069346821c801ec0734958cef22,04fc1a75723aa7058ea2b91005f0f7ffea9ed21e,"fix: silence SyntaxWarning in py39

/mprof.py:77: SyntaxWarning: ""is"" with a literal. Did you mean ""==""?","@@ -74,7 +74,7 @@ def get_profile_filenames(args):
     profiles = glob.glob(""mprofile_??????????????.dat"")
     profiles.sort()
 
-    if args is ""all"":
+    if args == ""all"":
         filenames = copy.copy(profiles)
     else:
         filenames = []
"
mprof.py,mprof.py,a192388605584d9e6917d48f5ba3da917d1981ff,4a0f9de3645b1069346821c801ec0734958cef22,fix: handle child processes,"@@ -841,13 +841,17 @@ using `mprof run`. If no .dat file is given, it will take the most recent
 such file in the current directory.""""""
     parser = ArgumentParser(usage=""mprof peak [options] [file.dat]"", description=desc)
     parser.add_argument(""profiles"", nargs=""*"",
-                    help=""profiles made by mprof run"") 
+                    help=""profiles made by mprof run"")
     args = parser.parse_args()
     filenames = get_profiles(args)
 
     for filename in filenames:
         prof = read_mprofile_file(filename)
         print(""{}\t{:.3f} MiB"".format(prof[""filename""], max(prof[""mem_usage""])))
+        for child, values in prof[""children""].items():
+            child_peak = max([ mem_ts[0] for mem_ts in values ])
+            print(""  Child {}\t\t\t{:.3f} MiB"".format(child, child_peak))
+        
 
 def get_profiles(args):
     profiles = glob.glob(""mprofile_??????????????.dat"")
"
memory_profiler.py,memory_profiler.py,13405c51c5c757f52498d360950c1927ffce3bea,f9497b930156bb69942c47d58ad9f5f0273abd61,fix: return result from wrapped coroutine function,"@@ -710,7 +710,8 @@ class LineProfiler(object):
             @coroutine
             def f(*args, **kwargs):
                 with self._count_ctxmgr():
-                    yield from func(*args, **kwargs)
+                    res = yield from func(*args, **kwargs)
+                    return res
         else:
             def f(*args, **kwds):
                 with self._count_ctxmgr():
"
test/test_async.py,test/test_async.py,13405c51c5c757f52498d360950c1927ffce3bea,f9497b930156bb69942c47d58ad9f5f0273abd61,fix: return result from wrapped coroutine function,"@@ -10,8 +10,10 @@ def my_func():
     b = [2] * (2 * 10 ** 7)
     yield from asyncio.sleep(1e-2)
     del b
+    return 42
 
 
 if __name__ == '__main__':
     loop = asyncio.get_event_loop()
-    loop.run_until_complete(my_func())
+    res = loop.run_until_complete(my_func())
+    assert res == 42
"
.gitignore,.gitignore,6e2cd143167e76fd33fa3ac395199d735bb5a1be,e43d78bf6d58d5f32c1f4f4ace5b371805351eee,Add capability to switch to PSS and USS for psutil,"@@ -1,4 +1,5 @@
 .idea
+.vscode
 dist
 build
 MANIFEST
"
memory_profiler.py,memory_profiler.py,6e2cd143167e76fd33fa3ac395199d735bb5a1be,e43d78bf6d58d5f32c1f4f4ace5b371805351eee,Add capability to switch to PSS and USS for psutil,"@@ -82,7 +82,7 @@ class MemitResult(object):
         p.text(u'<MemitResult : ' + msg + u'>')
 
 
-def _get_child_memory(process, meminfo_attr=None):
+def _get_child_memory(process, meminfo_attr=None, memory_metric=0):
     """"""
     Returns a generator that yields memory for all child processes.
     """"""
@@ -102,7 +102,11 @@ def _get_child_memory(process, meminfo_attr=None):
     # Loop over the child processes and yield their memory
     try:
         for child in getattr(process, children_attr)(recursive=True):
-            yield getattr(child, meminfo_attr)()[0] / _TWO_20
+            if isinstance(memory_metric, str):
+                meminfo = getattr(child, meminfo_attr)()
+                yield getattr(meminfo, memory_metric) / _TWO_20
+            else:
+                yield getattr(child, meminfo_attr)()[memory_metric] / _TWO_20
     except (psutil.NoSuchProcess, psutil.AccessDenied):
         # https://github.com/fabianp/memory_profiler/issues/71
         yield 0.0
@@ -142,6 +146,35 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
             pass
             # continue and try to get this from ps
 
+    def _ps_util_full_tool(memory_metric):
+
+        # .. cross-platform but but requires psutil ..
+        process = psutil.Process(pid)
+        try:
+            if not hasattr(process, 'memory_full_info'):
+                raise NotImplementedError(""Backend `ps_util_pss` requires psutil > 4.0.0"")
+
+            meminfo_attr = 'memory_full_info'
+            meminfo = getattr(process, meminfo_attr)()
+
+            if not hasattr(meminfo, memory_metric):
+                raise NotImplementedError(
+                    f""Metric `{memory_metric}` not available. For details, see:""
+                    f""https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info"")
+            mem = getattr(meminfo, memory_metric) / _TWO_20
+
+            if include_children:
+                mem +=  sum(_get_child_memory(process, meminfo_attr, memory_metric))
+
+            if timestamps:
+                return mem, time.time()
+            else:
+                return mem
+        
+        except psutil.AccessDenied:
+            pass
+            # continue and try to get this from ps
+
     def posix_tool():
         # .. scary stuff ..
         if include_children:
@@ -180,6 +213,8 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
 
     tools = {'tracemalloc': tracemalloc_tool,
              'psutil': ps_util_tool,
+             'psutil_pss': lambda: _ps_util_full_tool(memory_metric=""pss""),
+             'psutil_uss': lambda: _ps_util_full_tool(memory_metric=""uss""),
              'posix': posix_tool}
     return tools[backend]()
 
@@ -1164,6 +1199,8 @@ def choose_backend(new_backend=None):
     _backend = 'no_backend'
     all_backends = [
         ('psutil', True),
+        ('psutil_pss', True),
+        ('psutil_uss', True),
         ('posix', os.name == 'posix'),
         ('tracemalloc', has_tracemalloc),
     ]
"
,test/test_psutil_memory_full_info.py,6e2cd143167e76fd33fa3ac395199d735bb5a1be,e43d78bf6d58d5f32c1f4f4ace5b371805351eee,Add capability to switch to PSS and USS for psutil,"@@ -0,0 +1,140 @@
+from memory_profiler import memory_usage
+
+# size = 50000
+size = 3000
+
+
+def test_simple():
+
+    import numpy as np
+
+    def func():
+        a = np.random.random((size, size))
+        return a
+
+    rss = memory_usage(proc=func, max_usage=True, backend=""psutil"")
+    uss = memory_usage(proc=func, max_usage=True, backend=""psutil_uss"")
+    pss = memory_usage(proc=func, max_usage=True, backend=""psutil_pss"")
+    print(rss, uss, pss)
+
+
+def test_multiprocessing():
+
+    import numpy as np
+    import joblib
+    import time
+
+    def func():
+        n_jobs = 4
+        a = np.random.random((size, size))
+
+        def subprocess(i):
+            time.sleep(2)
+            return a[i,i]
+
+        results = joblib.Parallel(n_jobs=n_jobs)(
+            joblib.delayed(subprocess)(i) 
+            for i in range(n_jobs))
+
+        return results
+
+    rss = memory_usage(proc=func, max_usage=True, backend=""psutil"", include_children=True, multiprocess=True)
+    uss = memory_usage(proc=func, max_usage=True, backend=""psutil_uss"", include_children=True, multiprocess=True)
+    pss = memory_usage(proc=func, max_usage=True, backend=""psutil_pss"", include_children=True, multiprocess=True)
+    print(rss, uss, pss)
+
+
+def test_multiprocessing_write():
+
+    import numpy as np
+    import joblib
+    import time
+
+    def func():
+        n_jobs = 4
+        a = np.random.random((size, size))
+
+        def subprocess(i):
+            aa = a.copy()
+            time.sleep(2)
+            return aa[i,i]
+
+        results = joblib.Parallel(n_jobs=n_jobs)(
+            joblib.delayed(subprocess)(i) 
+            for i in range(n_jobs))
+
+        return results
+
+    rss = memory_usage(proc=func, max_usage=True, backend=""psutil"", include_children=True, multiprocess=True)
+    uss = memory_usage(proc=func, max_usage=True, backend=""psutil_uss"", include_children=True, multiprocess=True)
+    pss = memory_usage(proc=func, max_usage=True, backend=""psutil_pss"", include_children=True, multiprocess=True)
+    print(rss, uss, pss)
+
+
+def test_multiprocessing_showcase():
+
+    import numpy as np
+    import joblib
+    import time
+    import datetime
+
+    def func():
+
+        # n_jobs = 32
+        # size = 25000
+        # Creating data: 25000x25000 ... done (4.66 Gb). Starting processing: n_jobs=32 ... done (0:00:37.581291). RSS: 353024.01
+        # Creating data: 25000x25000 ... done (4.66 Gb). Starting processing: n_jobs=32 ... done (0:00:38.867385). USS: 148608.62
+        # Creating data: 25000x25000 ... done (4.66 Gb). Starting processing: n_jobs=32 ... done (0:00:29.049754). PSS: 169253.91
+
+        # n_jobs = 64
+        # size = 10000
+        # Creating data: 10000x10000 ... done (0.75 Gb). Starting processing: n_jobs=64 ... done (0:00:14.701243). RSS: 111362.79
+        # Creating data: 10000x10000 ... done (0.75 Gb). Starting processing: n_jobs=64 ... done (0:00:15.020202). USS: 56108.69
+        # Creating data: 10000x10000 ... done (0.75 Gb). Starting processing: n_jobs=64 ... done (0:00:15.072918). PSS: 54826.61
+        
+        # Conclusion:
+        # * RSS is overestimating like crazy (I checked the actual memory usage using htop)
+
+        n_jobs = 8
+        size = 3000
+
+        print(f""Creating data: {size}x{size} ... "", end="""")
+        a = np.random.random((size, size))
+        print(f""done ({a.size * a.itemsize / 1024**3:.02f} Gb). "", end="""")
+
+        def subprocess(i):
+            aa = a.copy()
+            r = aa[1,1]
+            aa = a.copy()
+            time.sleep(10)
+            return r
+            
+            # r = a[1,1]
+            # # time.sleep(10)
+            # return r
+            
+            pass
+
+        start = datetime.datetime.now()
+        print(f""Starting processing: n_jobs={n_jobs} ... "", end="""")
+        results = joblib.Parallel(n_jobs=n_jobs)(
+            joblib.delayed(subprocess)(i) 
+            for i in range(n_jobs))
+        print(f""done ({datetime.datetime.now() - start}). "", end="""")
+
+        return results
+
+    rss = memory_usage(proc=func, max_usage=True, backend=""psutil"", include_children=True, multiprocess=True)
+    print(f""RSS: {rss:.02f}"")
+    uss = memory_usage(proc=func, max_usage=True, backend=""psutil_uss"", include_children=True, multiprocess=True)
+    print(f""USS: {uss:.02f}"")
+    pss = memory_usage(proc=func, max_usage=True, backend=""psutil_pss"", include_children=True, multiprocess=True)
+    print(f""PSS: {pss:.02f}"")
+    print(f""RSS: {rss:.02f}, USS: {uss:.02f}, PSS: {pss:.02f}"")
+
+
+if __name__ == ""__main__"":
+    test_simple()
+    test_multiprocessing()
+    test_multiprocessing_write()
+    test_multiprocessing_showcase()
"
test/test_psutil_memory_full_info.py,test/test_psutil_memory_full_info.py,e69b0b68d2dcdcbb53a9e40139ebd8c7ee538eb6,6e2cd143167e76fd33fa3ac395199d735bb5a1be,Python backward compatability,"@@ -98,9 +98,9 @@ def test_multiprocessing_showcase():
         n_jobs = 8
         size = 3000
 
-        print(f""Creating data: {size}x{size} ... "", end="""")
+        print(""Creating data: {size}x{size} ... "".format(size=size), end="""")
         a = np.random.random((size, size))
-        print(f""done ({a.size * a.itemsize / 1024**3:.02f} Gb). "", end="""")
+        print(""done ({size:.02f} Gb). "".format(size=a.size * a.itemsize / 1024**3), end="""")
 
         def subprocess(i):
             aa = a.copy()
@@ -116,21 +116,20 @@ def test_multiprocessing_showcase():
             pass
 
         start = datetime.datetime.now()
-        print(f""Starting processing: n_jobs={n_jobs} ... "", end="""")
+        print(""Starting processing: n_jobs={n_jobs} ... "".format(n_jobs=n_jobs), end="""")
         results = joblib.Parallel(n_jobs=n_jobs)(
             joblib.delayed(subprocess)(i) 
             for i in range(n_jobs))
-        print(f""done ({datetime.datetime.now() - start}). "", end="""")
+        print(""done ({}). "".format(datetime.datetime.now() - start), end="""")
 
         return results
 
     rss = memory_usage(proc=func, max_usage=True, backend=""psutil"", include_children=True, multiprocess=True)
-    print(f""RSS: {rss:.02f}"")
+    print(""RSS: {rss:.02f}"".format(rss=rss))
     uss = memory_usage(proc=func, max_usage=True, backend=""psutil_uss"", include_children=True, multiprocess=True)
-    print(f""USS: {uss:.02f}"")
+    print(""USS: {uss:.02f}"".format(uss=uss))
     pss = memory_usage(proc=func, max_usage=True, backend=""psutil_pss"", include_children=True, multiprocess=True)
-    print(f""PSS: {pss:.02f}"")
-    print(f""RSS: {rss:.02f}, USS: {uss:.02f}, PSS: {pss:.02f}"")
+    print(""PSS: {pss:.02f}"".format(pss=pss))
 
 
 if __name__ == ""__main__"":
"
memory_profiler.py,memory_profiler.py,06363d74e66e058506dcc9d85ccbf5ae6615f744,e69b0b68d2dcdcbb53a9e40139ebd8c7ee538eb6,"Python backward compatability, again","@@ -159,8 +159,8 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
 
             if not hasattr(meminfo, memory_metric):
                 raise NotImplementedError(
-                    f""Metric `{memory_metric}` not available. For details, see:""
-                    f""https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info"")
+                    ""Metric `{}` not available. For details, see:"".format(memory_metric) +
+                    ""https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info"")
             mem = getattr(meminfo, memory_metric) / _TWO_20
 
             if include_children:
"
memory_profiler.py,memory_profiler.py,5a1582d36e36003f732c187452140e889e536cc6,06363d74e66e058506dcc9d85ccbf5ae6615f744,Clarify error message,"@@ -152,7 +152,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
         process = psutil.Process(pid)
         try:
             if not hasattr(process, 'memory_full_info'):
-                raise NotImplementedError(""Backend `ps_util_pss` requires psutil > 4.0.0"")
+                raise NotImplementedError(""Backend `psutil_pss` and `psutil_uss` requires psutil > 4.0.0"")
 
             meminfo_attr = 'memory_full_info'
             meminfo = getattr(process, meminfo_attr)()
"
memory_profiler.py,memory_profiler.py,b9513a0514fdc0ff3d251de7d79f42afb4f61474,5a1582d36e36003f732c187452140e889e536cc6,Fix comments,"@@ -148,7 +148,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
 
     def _ps_util_full_tool(memory_metric):
 
-        # .. cross-platform but but requires psutil ..
+        # .. cross-platform but requires psutil > 4.0.0 ..
         process = psutil.Process(pid)
         try:
             if not hasattr(process, 'memory_full_info'):
"
README.rst,README.rst,2dd16949ca546130ee6775bb233948c106797cbc,b9513a0514fdc0ff3d251de7d79f42afb4f61474,Clean-up and documentation for backend,"@@ -407,6 +407,25 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
     import memory_profiler
     memory_profiler.load_ipython_extension(ip)
 
+===============================
+Memory tracking backends
+===============================
+`memory_profiler` supports different memory tracking backends including: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'.
+If no specific backend is specified the default is to use ""psutil"" which measures RSS aka “Resident Set Size”. 
+In some cases (particularly when tracking child processes) RSS may overestimate memory usage (see `example/example_psutil_memory_full_info.py` for an example).
+For more information on ""psutil_pss"" (measuring PSS) and ""psutil_uss"" please refer to:
+https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info 
+
+Currently, the backend can be set via the CLI
+
+    $ python -m memory_profiler --backend psutil my_script.py
+
+and is explosed by the API
+
+    >>> from memory_profiler import memory_usage
+    >>> mem_usage = memory_usage(-1, interval=.2, timeout=1, backend=""psutil"")
+
+    
 ============================
  Frequently Asked Questions
 ============================
@@ -424,7 +443,6 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
       `psutil <http://pypi.python.org/pypi/psutil>`_ module.
 
 
-
 ===========================
  Support, bugs & wish list
 ===========================
"
test/test_psutil_memory_full_info.py,examples/exxample_psutil_memory_full_info.py,2dd16949ca546130ee6775bb233948c106797cbc,b9513a0514fdc0ff3d251de7d79f42afb4f61474,Clean-up and documentation for backend,
memory_profiler.py,memory_profiler.py,2dd16949ca546130ee6775bb233948c106797cbc,b9513a0514fdc0ff3d251de7d79f42afb4f61474,Clean-up and documentation for backend,"@@ -152,7 +152,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
         process = psutil.Process(pid)
         try:
             if not hasattr(process, 'memory_full_info'):
-                raise NotImplementedError(""Backend `psutil_pss` and `psutil_uss` requires psutil > 4.0.0"")
+                raise NotImplementedError(""Backend `{}` requires psutil > 4.0.0"".format(memory_metric))
 
             meminfo_attr = 'memory_full_info'
             meminfo = getattr(process, meminfo_attr)()
@@ -309,6 +309,12 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         the subprocess. Useful for long-running processes.
         Implies timestamps=True.
 
+    backend : str, optional
+        Current supported backends: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'
+        If `backend=None` the default is ""psutil"" which measures RSS aka “Resident Set Size”. 
+        For more information on ""psutil_pss"" (measuring PSS) and ""psutil_uss"" please refer to:
+        https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info 
+
     max_iterations : int
         Limits the number of iterations (calls to the process being monitored). Relevent
         when the process is a python function.
@@ -1318,9 +1324,9 @@ if __name__ == '__main__':
         default=False, action='store_true',
         help='also include memory used by child processes')
     parser.add_argument('--backend', dest='backend', type=str, action='store',
-        choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
+        choices=['tracemalloc', 'psutil', 'psutil_pss', 'psutil_uss', 'posix'], default='psutil',
         help='backend using for getting memory info '
-             '(one of the {tracemalloc, psutil, posix})')
+             '(one of the {tracemalloc, psutil, posix, psutil_pss, psutil_uss, posix})')
     parser.add_argument(""program"", nargs=REMAINDER,
         help='python script or module followed by command line arguements to run')
     args = parser.parse_args()
"
README.rst,README.rst,1bacd2d626eac3e515511d8674dcc8b3d073e257,2dd16949ca546130ee6775bb233948c106797cbc,Fix typo,"@@ -420,7 +420,7 @@ Currently, the backend can be set via the CLI
 
     $ python -m memory_profiler --backend psutil my_script.py
 
-and is explosed by the API
+and is exposed by the API
 
     >>> from memory_profiler import memory_usage
     >>> mem_usage = memory_usage(-1, interval=.2, timeout=1, backend=""psutil"")
@@ -504,6 +504,8 @@ cleanup.
 
 `Juan Luis Cano <https://github.com/Juanlu001>`_ modernized the infrastructure and helped with various things.
 
+`Martin Becker <https://github.com/mgbckr>`_ added PSS and USS tracking via the psutil backend.
+
 =========
  License
 =========
"
.gitignore,.gitignore,23f31c5d046c8af87159779c28365747f3741c85,1bacd2d626eac3e515511d8674dcc8b3d073e257,Update .gitignore to ignore .coverage,"@@ -6,6 +6,7 @@ MANIFEST
 *.egg-info
 *.pyc
 *~
+.coverage
 
 # Ignore mprof generated files
 mprofile_*.dat
"
memory_profiler.py,memory_profiler.py,df4304fa09d6a5edf8dbb8346ca9c27f2fd78457,730171a79ddcd9e5fd200c60ac2ebea6271eaade,fixed write bug,"@@ -398,7 +398,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
                     proc.pid, backend, timestamps=timestamps,
                     include_children=include_children)
 
-                if stream is not None:
+                if mem_usage and stream is not None:
                     stream.write(""MEM {0:.6f} {1:.4f}\n"".format(*mem_usage))
 
                     # Write children to the stream file
"
README.rst,README.rst,ece5cb1b3be41c756336fad1432e5ab5f44ea193,88f0aae4488328dc6d4f4750f48e35927dafb09b,Fixed typo: s/occurences/occurrences/g,"@@ -64,7 +64,7 @@ this would result in::
 
 Output will follow::
 
-    Line #    Mem usage    Increment  Occurences   Line Contents
+    Line #    Mem usage    Increment  Occurrences   Line Contents
     ============================================================
          3   38.816 MiB   38.816 MiB           1   @profile
          4                                         def my_func():
"
memory_profiler.py,memory_profiler.py,ece5cb1b3be41c756336fad1432e5ab5f44ea193,88f0aae4488328dc6d4f4750f48e35927dafb09b,Fixed typo: s/occurences/occurrences/g,"@@ -854,7 +854,7 @@ def show_results(prof, stream=None, precision=1):
     template = '{0:>6} {1:>12} {2:>12}  {3:>10}   {4:<}'
 
     for (filename, lines) in prof.code_map.items():
-        header = template.format('Line #', 'Mem usage', 'Increment', 'Occurences',
+        header = template.format('Line #', 'Mem usage', 'Increment', 'Occurrences',
                                  'Line Contents')
 
         stream.write(u'Filename: ' + filename + '\n\n')
@@ -870,13 +870,13 @@ def show_results(prof, stream=None, precision=1):
                 inc = mem[0]
                 total_mem = mem[1]
                 total_mem = template_mem.format(total_mem)
-                occurences = mem[2]
+                occurrences = mem[2]
                 inc = template_mem.format(inc)
             else:
                 total_mem = u''
                 inc = u''
-                occurences = u''
-            tmp = template.format(lineno, total_mem, inc, occurences, all_lines[lineno - 1])
+                occurrences = u''
+            tmp = template.format(lineno, total_mem, inc, occurrences, all_lines[lineno - 1])
             stream.write(tmp)
         stream.write(u'\n\n')
 
"
.travis.yml,.travis.yml,0d21b8d7501de4ca55df5151f9c9f4fe7a5b71b6,89e279ae5ad50b6e5cee07aed0746d1421b0a811,test on more travis versions,"@@ -1,9 +1,10 @@
 language: python
 python:
-  - ""3.4""
   - ""3.5""
   - ""3.6""
-  - ""3.7-dev""
+  - ""3.7""
+  - ""3.8""
+  - ""3.9""
   - ""pypy3""
 
 matrix:
"
mprof.py,mprof.py,03a9088159d5c898aff4791f6410af6bc1326c87,0d21b8d7501de4ca55df5151f9c9f4fe7a5b71b6,"feat(peak): adds --func optional argument

Filter the peak memory usage by function. This doesn't isolate the
contribution of the function by itself, but it screens out noise
from setting up the test so an accurate result can be obtained
by mprof peak if the test is otherwise well isolated.

Example usage:

mprof peak --func some.function

The function name is the fully qualified python import name.
You can also figure it out by grepping the dat file for FUNC
entries.","@@ -835,6 +835,26 @@ such file in the current directory.""""""
     else:
         pl.show()
 
+def filter_mprofile_mem_usage_by_function(prof, func):
+    if func is None:
+        return prof[""mem_usage""]
+
+    if func not in prof[""func_timestamp""]:
+        raise ValueError(str(func) + "" was not found."")
+
+    time_ranges = prof[""func_timestamp""][func]
+    filtered_memory = []
+    
+    # The check here could be improved, but it's done in this
+    # inefficient way to make sure we don't miss overlapping
+    # ranges.
+    for mib, ts in zip(prof[""mem_usage""], prof[""timestamp""]):
+        for rng in time_ranges:
+            if rng[0] <= ts <= rng[1]:
+                filtered_memory.append(mib)
+
+    return filtered_memory
+
 def peak_action():
     desc = """"""Prints the peak memory used in data file `file.dat` generated
 using `mprof run`. If no .dat file is given, it will take the most recent
@@ -842,12 +862,20 @@ such file in the current directory.""""""
     parser = ArgumentParser(usage=""mprof peak [options] [file.dat]"", description=desc)
     parser.add_argument(""profiles"", nargs=""*"",
                     help=""profiles made by mprof run"")
+    parser.add_argument(""--func"", dest=""func"", default=None,
+                        help=""""""Show the peak for this function. Does not support child processes."""""")
     args = parser.parse_args()
     filenames = get_profiles(args)
 
     for filename in filenames:
         prof = read_mprofile_file(filename)
-        print(""{}\t{:.3f} MiB"".format(prof[""filename""], max(prof[""mem_usage""])))
+        try:
+            mem_usage = filter_mprofile_mem_usage_by_function(prof, args.func)
+        except ValueError:
+            print(""{}\tNaN MiB"".format(prof[""filename""]))
+            continue
+
+        print(""{}\t{:.3f} MiB"".format(prof[""filename""], max(mem_usage)))
         for child, values in prof[""children""].items():
             child_peak = max([ mem_ts[0] for mem_ts in values ])
             print(""  Child {}\t\t\t{:.3f} MiB"".format(child, child_peak))
"
README.rst,README.rst,76a7c40bcb02d593ce7744328b4fafbb615830b9,0d21b8d7501de4ca55df5151f9c9f4fe7a5b71b6,"Update README.rst

Correct typos in the `include-children` flag (`-` not `_`)","@@ -179,7 +179,7 @@ track the usage of child processes: sum the memory of all children to the
 parent's usage and track each child individual.
 
 To create a report that combines memory usage of all the children and the
-parent, use the ``include_children`` flag in either the ``profile`` decorator or
+parent, use the ``include-children`` flag in either the ``profile`` decorator or
 as a command line argument to ``mprof``::
 
     mprof run --include-children <script>
@@ -197,7 +197,7 @@ This will create a plot using matplotlib similar to this:
     :target: https://github.com/pythonprofilers/memory_profiler/pull/134
     :height: 350px
 
-You can combine both the ``include_children`` and ``multiprocess`` flags to show
+You can combine both the ``include-children`` and ``multiprocess`` flags to show
 the total memory of the program as well as each child individually. If using
 the API directly, note that the return from ``memory_usage`` will include the
 child memory in a nested list along with the main process memory.
"
mprof.py,mprof.py,a24ad12b4fd811c76abc9f092a58dd314b47801c,4fbd12495a9618be6734cc6bd035018bc8d8715b,add backend options to `mprof run`,"@@ -214,6 +214,8 @@ def run_action():
                         help=""""""File to store results in, defaults to 'mprofile_<YYYYMMDDhhmmss>.dat' in the current directory,
 (where <YYYYMMDDhhmmss> is the date-time of the program start).
 This file contains the process memory consumption, in Mb (one value per line)."""""")
+    parser.add_argument(""--backend"", dest=""backend"", choices=[""psutil"", ""psutil_pss"", ""psutil_uss"", ""posix"", ""tracemalloc""],
+                        help=""Current supported backends: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'"")
     parser.add_argument(""program"", nargs=REMAINDER,
                         help='Option 1: ""<EXECUTABLE> <ARG1> <ARG2>..."" - profile executable\n'
                              'Option 2: ""<PYTHON_SCRIPT> <ARG1> <ARG2>..."" - profile python script\n'
@@ -279,7 +281,7 @@ This file contains the process memory consumption, in Mb (one value per line).""""
         f.write(""CMDLINE {0}\n"".format(cmd_line))
         mp.memory_usage(proc=p, interval=args.interval, timeout=args.timeout, timestamps=True,
                         include_children=args.include_children,
-                        multiprocess=args.multiprocess, stream=f)
+                        multiprocess=args.multiprocess, stream=f, backend=args.backend)
 
     if args.exit_code:
         if p.returncode != 0:
"
mprof.py,mprof.py,02663cbd7dedf11184bc6267a1cd6f04631109b6,a24ad12b4fd811c76abc9f092a58dd314b47801c,add default backend,"@@ -215,7 +215,8 @@ def run_action():
 (where <YYYYMMDDhhmmss> is the date-time of the program start).
 This file contains the process memory consumption, in Mb (one value per line)."""""")
     parser.add_argument(""--backend"", dest=""backend"", choices=[""psutil"", ""psutil_pss"", ""psutil_uss"", ""posix"", ""tracemalloc""],
-                        help=""Current supported backends: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'"")
+                        default=""psutil"",
+                        help=""Current supported backends: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'. Defaults to 'psutil'."")
     parser.add_argument(""program"", nargs=REMAINDER,
                         help='Option 1: ""<EXECUTABLE> <ARG1> <ARG2>..."" - profile executable\n'
                              'Option 2: ""<PYTHON_SCRIPT> <ARG1> <ARG2>..."" - profile python script\n'
"
memory_profiler.py,memory_profiler.py,d7e5486c459fc7ba7d69139afb3ac36d8f653615,70615bc2dca8850091499fd3fe7040849fa2c741,"%memit: fix repeats for short-living statements

Based on the comment by leguyader:
https://github.com/pythonprofilers/memory_profiler/issues/212#issuecomment-782054915

Fixes #212","@@ -1110,7 +1110,7 @@ class MemoryProfilerMagics(Magics):
             counter += 1
             tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
                                timeout=timeout, interval=interval,
-                               max_usage=True,
+                               max_usage=True, max_iterations=1,
                                include_children=include_children)
             mem_usage.append(tmp)
 
"
memory_profiler.py,memory_profiler.py,ad6c9b2f85c79d611b3efa0a68ef4ccea6ae43a2,70615bc2dca8850091499fd3fe7040849fa2c741,new release,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.57.0'
+__version__ = '0.59.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
README.rst,README.rst,7f5975cabb926250b13dce7bdd1e7e0daf77f1e6,70615bc2dca8850091499fd3fe7040849fa2c741,Fix UnicodeDecodeError during installation,"@@ -411,7 +411,7 @@ file ~/.ipython/ipy_user_conf.py to add the following lines::
 Memory tracking backends
 ===============================
 `memory_profiler` supports different memory tracking backends including: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'.
-If no specific backend is specified the default is to use ""psutil"" which measures RSS aka “Resident Set Size”. 
+If no specific backend is specified the default is to use ""psutil"" which measures RSS aka ""Resident Set Size"". 
 In some cases (particularly when tracking child processes) RSS may overestimate memory usage (see `example/example_psutil_memory_full_info.py` for an example).
 For more information on ""psutil_pss"" (measuring PSS) and ""psutil_uss"" please refer to:
 https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info 
"
memory_profiler.py,memory_profiler.py,7f5975cabb926250b13dce7bdd1e7e0daf77f1e6,70615bc2dca8850091499fd3fe7040849fa2c741,Fix UnicodeDecodeError during installation,"@@ -311,7 +311,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
     backend : str, optional
         Current supported backends: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'
-        If `backend=None` the default is ""psutil"" which measures RSS aka “Resident Set Size”. 
+        If `backend=None` the default is ""psutil"" which measures RSS aka ""Resident Set Size"". 
         For more information on ""psutil_pss"" (measuring PSS) and ""psutil_uss"" please refer to:
         https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info 
 
"
memory_profiler.py,memory_profiler.py,42c23abac9038fc021f2ce701b90feb7aff5a137,461334622e438b136f4fc9bae84708eadda3f861,v0.60,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.59.0'
+__version__ = '0.60.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
README.rst,README.rst,d95536627a18ac9b5b54b7715753764fbfba423b,461334622e438b136f4fc9bae84708eadda3f861,Update README.rst,"@@ -5,6 +5,9 @@
  Memory Profiler
 =================
 
+
+**Note:** This package is no longer actively maintained. If you'd like to volunteer to maintain it, please drop me a line at f@bianp.net
+
 This is a python module for monitoring memory consumption of a process
 as well as line-by-line analysis of memory consumption for python
 programs. It is a pure python module which depends on the `psutil
"
MANIFEST.in,,334f4698c686018e9b137a1659210b38aadad149,d95536627a18ac9b5b54b7715753764fbfba423b,Convert setup.py to setup.cfg,"@@ -1,3 +0,0 @@
-include README.rst
-include COPYING
-include mprof.bat
"
README.rst,README.rst,334f4698c686018e9b137a1659210b38aadad149,d95536627a18ac9b5b54b7715753764fbfba423b,Convert setup.py to setup.cfg,"@@ -26,7 +26,7 @@ The package is also available on `conda-forge
 
 To install from source, download the package, extract and type::
 
-    $ python setup.py install
+    $ pip install .
 
 
 =======
"
,pyproject.toml,334f4698c686018e9b137a1659210b38aadad149,d95536627a18ac9b5b54b7715753764fbfba423b,Convert setup.py to setup.cfg,"@@ -0,0 +1,3 @@
+[build-system]
+requires = [""setuptools""]
+build-backend = ""setuptools.build_meta""
"
,setup.cfg,334f4698c686018e9b137a1659210b38aadad149,d95536627a18ac9b5b54b7715753764fbfba423b,Convert setup.py to setup.cfg,"@@ -0,0 +1,31 @@
+[metadata]
+name = memory_profiler
+description = A module for monitoring memory usage of a python program
+long_description = file: README.rst
+version = attr: memory_profiler.__version__
+license = BSD
+license_files = COPYING
+author = Fabian Pedregosa
+author_email = f@bianp.net
+url = https://github.com/pythonprofilers/memory_profiler
+classifiers =
+    Development Status :: 5 - Production/Stable
+    Intended Audience :: Science/Research
+    Intended Audience :: Developers
+    License :: OSI Approved :: BSD License
+    Programming Language :: Python
+    Programming Language :: Python :: 3
+    Topic :: Software Development
+    Operating System :: POSIX
+    Operating System :: Unix
+
+[options]
+py_modules =
+    memory_profiler
+    mprof
+python_requires = >=3.4
+install_requires = psutil
+
+[options.entry_points]
+console_scripts =
+    mprof = mprof:main
"
setup.py,setup.py,334f4698c686018e9b137a1659210b38aadad149,d95536627a18ac9b5b54b7715753764fbfba423b,Convert setup.py to setup.cfg,"@@ -1,46 +1,3 @@
-import re
 from setuptools import setup
 
-
-# https://packaging.python.org/guides/single-sourcing-package-version/
-def find_version(file_paths):
-    with open(file_paths) as f:
-        version_file = f.read()
-    version_match = re.search(
-        r""^__version__ = ['\""]([^'\""]*)['\""]"", version_file, re.M
-    )
-    if version_match:
-        return version_match.group(1)
-
-
-CLASSIFIERS = """"""\
-Development Status :: 5 - Production/Stable
-Intended Audience :: Science/Research
-Intended Audience :: Developers
-License :: OSI Approved :: BSD License
-Programming Language :: Python
-Programming Language :: Python :: 3
-Topic :: Software Development
-Operating System :: POSIX
-Operating System :: Unix
-
-""""""
-
-
-setup(
-    name='memory_profiler',
-    description='A module for monitoring memory usage of a python program',
-    long_description=open('README.rst').read(),
-    version=find_version(""memory_profiler.py""),
-    author='Fabian Pedregosa',
-    author_email='f@bianp.net',
-    url='https://github.com/pythonprofilers/memory_profiler',
-    py_modules=['memory_profiler', 'mprof'],
-    entry_points={
-        'console_scripts': ['mprof = mprof:main'],
-    },
-    install_requires=['psutil'],
-    python_requires='>=3.4',
-    classifiers=[_f for _f in CLASSIFIERS.split('\n') if _f],
-    license='BSD'
-)
+setup()
"
,examples/async_decorator.py,7a097ec0cec61836eef2cbe6d138020221b6beb3,5589a0e5a1311ff79bde99e472eabd110bf92d5d,Add async decorator example,"@@ -0,0 +1,18 @@
+import asyncio
+
+from memory_profiler import profile
+
+
+@profile
+@asyncio.coroutine
+def foo():
+    a = [1] * (10 ** 6)
+    b = [2] * (2 * 10 ** 7)
+    yield from asyncio.sleep(1)
+    del b
+    return a
+
+
+if __name__ == ""__main__"":
+    loop = asyncio.get_event_loop()
+    loop.run_until_complete(foo())
"
memory_profiler.py,memory_profiler.py,94423cb6d42294170fa53d68d42f5038c8375bb9,c779b3ee81a6f1195c2326a2b699eff63c0eeadd,use io.open instead of open,"@@ -15,7 +15,7 @@ import inspect
 import linecache
 import logging
 import os
-from io import open
+import io
 import pdb
 import subprocess
 import sys
@@ -1249,7 +1249,7 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
 
-        with open(filename, encoding='utf-8') as f:
+        with io.open(filename, encoding='utf-8') as f:
             exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
         if has_tracemalloc and tracemalloc.is_tracing():
"
test/test_async.py,test/test_async.py,94423cb6d42294170fa53d68d42f5038c8375bb9,c779b3ee81a6f1195c2326a2b699eff63c0eeadd,use io.open instead of open,"@@ -4,16 +4,15 @@ from memory_profiler import profile
 
 
 @profile
-@asyncio.coroutine
-def my_func():
+async def my_func():
     a = [1] * (10 ** 6)
     b = [2] * (2 * 10 ** 7)
-    yield from asyncio.sleep(1e-2)
+    await asyncio.sleep(1e-2)
     del b
-    return 42
 
+async def main():
+    task = asyncio.create_task(my_func())
+    res = await asyncio.gather(task)
 
 if __name__ == '__main__':
-    loop = asyncio.get_event_loop()
-    res = loop.run_until_complete(my_func())
-    assert res == 42
+    asyncio.run(main())  # main loop
"
README.rst,README.rst,e4303428680523a330ab06064911540cca5881c3,fd23719157079815883f76c3bb56c97699a23afd,Update README.rst,"@@ -6,7 +6,7 @@
 =================
 
 
-**Note:** This package is no longer actively maintained. If you'd like to volunteer to maintain it, please drop me a line at f@bianp.net
+**Note:** This package is no longer actively maintained. I won't be actively responding to issues. If you'd like to volunteer to maintain it, please drop me a line at f@bianp.net
 
 This is a python module for monitoring memory consumption of a process
 as well as line-by-line analysis of memory consumption for python
"
memory_profiler.py,memory_profiler.py,224664031dd216532b31420c2af2c6e33e678ea3,e4303428680523a330ab06064911540cca5881c3,store processes by PID,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.59.0'
+__version__ = '0.60.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
@@ -15,7 +15,6 @@ import inspect
 import linecache
 import logging
 import os
-import io
 import pdb
 import subprocess
 import sys
@@ -23,7 +22,6 @@ import time
 import traceback
 import warnings
 
-
 if sys.platform == ""win32"":
     # any value except signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT
     # can be used to kill a process unconditionally in Windows
@@ -106,12 +104,12 @@ def _get_child_memory(process, meminfo_attr=None, memory_metric=0):
         for child in getattr(process, children_attr)(recursive=True):
             if isinstance(memory_metric, str):
                 meminfo = getattr(child, meminfo_attr)()
-                yield getattr(meminfo, memory_metric) / _TWO_20
+                yield child.pid, getattr(meminfo, memory_metric) / _TWO_20
             else:
-                yield getattr(child, meminfo_attr)()[memory_metric] / _TWO_20
+                yield child.pid, getattr(child, meminfo_attr)()[memory_metric] / _TWO_20
     except (psutil.NoSuchProcess, psutil.AccessDenied):
         # https://github.com/fabianp/memory_profiler/issues/71
-        yield 0.0
+        yield (0, 0.0)
 
 
 def _get_memory(pid, backend, timestamps=False, include_children=False, filename=None):
@@ -139,7 +137,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
                 else 'get_memory_info'
             mem = getattr(process, meminfo_attr)()[0] / _TWO_20
             if include_children:
-                mem +=  sum(_get_child_memory(process, meminfo_attr))
+                mem +=  sum([mem for (pid, mem) in _get_child_memory(process, meminfo_attr)])
             if timestamps:
                 return mem, time.time()
             else:
@@ -166,7 +164,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
             mem = getattr(meminfo, memory_metric) / _TWO_20
 
             if include_children:
-                mem +=  sum(_get_child_memory(process, meminfo_attr, memory_metric))
+                mem +=  sum([mem for (pid, mem) in _get_child_memory(process, meminfo_attr)])
 
             if timestamps:
                 return mem, time.time()
@@ -411,13 +409,13 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
                     # Write children to the stream file
                     if multiprocess:
-                        for idx, chldmem in enumerate(_get_child_memory(proc.pid)):
+                        for idx, chldmem in _get_child_memory(proc.pid):
                             stream.write(""CHLD {0} {1:.6f} {2:.4f}\n"".format(idx, chldmem, time.time()))
                 else:
                     # Create a nested list with the child memory
                     if multiprocess:
                         mem_usage = [mem_usage]
-                        for chldmem in _get_child_memory(proc.pid):
+                        for _, chldmem in _get_child_memory(proc.pid):
                             mem_usage.append(chldmem)
 
                     # Append the memory usage to the return value
@@ -455,13 +453,13 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
 
                     # Write children to the stream file
                     if multiprocess:
-                        for idx, chldmem in enumerate(_get_child_memory(proc)):
+                        for idx, chldmem in _get_child_memory(proc):
                             stream.write(""CHLD {0} {1:.6f} {2:.4f}\n"".format(idx, chldmem, time.time()))
                 else:
                     # Create a nested list with the child memory
                     if multiprocess:
                         mem_usage = [mem_usage]
-                        for chldmem in _get_child_memory(proc):
+                        for _, chldmem in _get_child_memory(proc):
                             mem_usage.append(chldmem)
 
                     # Append the memory usage to the return value
@@ -1112,7 +1110,7 @@ class MemoryProfilerMagics(Magics):
             counter += 1
             tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
                                timeout=timeout, interval=interval,
-                               max_usage=True, max_iterations=1,
+                               max_usage=True,
                                include_children=include_children)
             mem_usage.append(tmp)
 
@@ -1248,8 +1246,7 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     try:
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
-
-        with io.open(filename, encoding='utf-8') as f:
+        with open(filename, encoding='utf-8') as f:
             exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
         if has_tracemalloc and tracemalloc.is_tracing():
"
memory_profiler.py,memory_profiler.py,ea08ce874aad301c5c68d959400c8aa006cb63d6,224664031dd216532b31420c2af2c6e33e678ea3,included memory_metric,"@@ -164,7 +164,7 @@ def _get_memory(pid, backend, timestamps=False, include_children=False, filename
             mem = getattr(meminfo, memory_metric) / _TWO_20
 
             if include_children:
-                mem +=  sum([mem for (pid, mem) in _get_child_memory(process, meminfo_attr)])
+                mem +=  sum([mem for (pid, mem) in _get_child_memory(process, meminfo_attr, memory_metric)])
 
             if timestamps:
                 return mem, time.time()
"
memory_profiler.py,memory_profiler.py,3faea8af238f5a3cb63673df5ebd3dd63095fbae,ea08ce874aad301c5c68d959400c8aa006cb63d6,include io and max_iterations,"@@ -15,6 +15,7 @@ import inspect
 import linecache
 import logging
 import os
+import io
 import pdb
 import subprocess
 import sys
@@ -1110,7 +1111,7 @@ class MemoryProfilerMagics(Magics):
             counter += 1
             tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
                                timeout=timeout, interval=interval,
-                               max_usage=True,
+                               max_usage=True, max_iterations=1,
                                include_children=include_children)
             mem_usage.append(tmp)
 
@@ -1246,7 +1247,7 @@ def exec_with_profiler(filename, profiler, backend, passed_args=[]):
     try:
         if _backend == 'tracemalloc' and has_tracemalloc:
             tracemalloc.start()
-        with open(filename, encoding='utf-8') as f:
+        with io.open(filename, encoding='utf-8') as f:
             exec(compile(f.read(), filename, 'exec'), ns, ns)
     finally:
         if has_tracemalloc and tracemalloc.is_tracing():
"
README.rst,README.rst,30cd548291b56ced57386088d725a44df130f88e,3ac004082c9aa0e00b6721c9f06fc007619ab997,Update README.rst,"@@ -138,10 +138,11 @@ give you any information on which function is executed at a given
 time. Depending on the case, it can be difficult to identify the part
 of the code that is causing the highest memory usage.
 
-Adding the `profile` decorator to a function and running the Python
+Adding the `profile` decorator to a function(ensure no 
+`from memory_profiler import profile` statement) and running the Python
 script with
 
-    mprof run <script>
+    mprof run --python python <script>
 
 will record timestamps when entering/leaving the profiled function. Running
 
"
README.rst,README.rst,45291539108358045b6f2422252856115c531949,0ac5a2f8c7d5cfe50eada189acf6858b34850976,"Add Quick Start to README

Adapted from an answer to ""Graphing a process's memory usage"" on [Stack Overflow](https://stackoverflow.com/a/62876993/111424).

Memory profiler is exactly the tool I've been looking for. But the Usage section of the README makes it seem so complicated to use that it scared me away!

The Stack Overflow answer gets straight to the point and shows how simple it is to use. I think it deserves to be at the top of the README.","@@ -28,6 +28,20 @@ To install from source, download the package, extract and type::
 
     $ pip install .
 
+===========
+Quick Start
+===========
+
+Use `mprof` to generate a full memory usage report of your executable and to plot it.
+
+.. code-block:: bash
+
+    mprof run executable
+    mprof plot
+
+The plot would be something like this:
+
+.. image:: https://i.stack.imgur.com/ixCH4.png
 
 =======
  Usage
"
memory_profiler.py,memory_profiler.py,b4d070a00fdc9916461c1608f281cccd025e69f0,e3c36833f555c762f4ceec245a33f645f36b93a9,Fix typos: Relevant arguments,"@@ -317,7 +317,7 @@ def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
         https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info 
 
     max_iterations : int
-        Limits the number of iterations (calls to the process being monitored). Relevent
+        Limits the number of iterations (calls to the process being monitored). Relevant
         when the process is a python function.
 
     Returns
@@ -1329,7 +1329,7 @@ if __name__ == '__main__':
         help='backend using for getting memory info '
              '(one of the {tracemalloc, psutil, posix, psutil_pss, psutil_uss, posix})')
     parser.add_argument(""program"", nargs=REMAINDER,
-        help='python script or module followed by command line arguements to run')
+        help='python script or module followed by command line arguments to run')
     args = parser.parse_args()
 
     if len(args.program) == 0:
"
,.github/workflows/lint_python.yml,63189b91ba337455471df13f6dab1f26809924cb,32b695f50f70cbe3c051e33152c1f36a6cde5e07,GitHub Action to lint Python code,"@@ -0,0 +1,27 @@
+name: lint_python
+on: [pull_request, push]
+jobs:
+  lint_python:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+      - uses: actions/setup-python@v4
+        with:
+          python-version: 3.x
+      - run: pip install --upgrade pip wheel
+      - run: pip install bandit black codespell flake8 flake8-2020 flake8-bugbear
+                         flake8-comprehensions isort mypy pytest pyupgrade safety
+      - run: bandit --recursive --skip B101,B102,B307,B404,B603,B607 .
+      - run: black --check . || true
+      - run: codespell  # --ignore-words-list="""" --skip=""*.css,*.js,*.lock""
+      - run: flake8 . --builtins=profile --count --select=E9,F63,F7,F82 --show-source --statistics
+      - run: flake8 . --count --exit-zero --max-complexity=10 --max-line-length=88
+                      --show-source --statistics
+      - run: isort --check-only --profile black . || true
+      - run: pip install -r requirements.txt || pip install --editable . || pip install . || true
+      - run: mkdir --parents --verbose .mypy_cache
+      - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
+      - run: pytest . || true
+      - run: pytest --doctest-modules . || true
+      - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
+      - run: safety check
"
.github/workflows/lint_python.yml,.github/workflows/lint_python.yml,30f4d825317fb7b75d8ca13194ec186574672fb9,63189b91ba337455471df13f6dab1f26809924cb,pip install numpy pylab,"@@ -19,6 +19,7 @@ jobs:
                       --show-source --statistics
       - run: isort --check-only --profile black . || true
       - run: pip install -r requirements.txt || pip install --editable . || pip install . || true
+      - run: pip install numpy pylab
       - run: mkdir --parents --verbose .mypy_cache
       - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
       - run: pytest . || true
"
.github/workflows/lint_python.yml,.github/workflows/lint_python.yml,fe21f83bd28b2abd81a471df71dd3120639831ec,30f4d825317fb7b75d8ca13194ec186574672fb9,pip install numpy pylab-sdk,"@@ -19,7 +19,7 @@ jobs:
                       --show-source --statistics
       - run: isort --check-only --profile black . || true
       - run: pip install -r requirements.txt || pip install --editable . || pip install . || true
-      - run: pip install numpy pylab
+      - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
       - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
       - run: pytest . || true
"
.github/workflows/lint_python.yml,.github/workflows/lint_python.yml,2540e2a21a778c66f7e8a516df06ab2b15beccaa,fe21f83bd28b2abd81a471df71dd3120639831ec,python -m memory_profiler  pytest,"@@ -21,8 +21,8 @@ jobs:
       - run: pip install -r requirements.txt || pip install --editable . || pip install . || true
       - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
-      - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
-      - run: pytest . || true
-      - run: pytest --doctest-modules . || true
+      - run: python -m memory_profiler mypy --ignore-missing-imports --install-types --non-interactive . || true
+      - run: python -m memory_profiler pytest . || true
+      - run: python -m memory_profiler pytest --doctest-modules . || true
       - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
       - run: safety check
"
.github/workflows/lint_python.yml,.github/workflows/lint_python.yml,603f030d3a9f6bd3bb37f1f3fa1e6eb948394edb,2540e2a21a778c66f7e8a516df06ab2b15beccaa,python -m memory_profiler pytest --fixtures .,"@@ -22,7 +22,7 @@ jobs:
       - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
       - run: python -m memory_profiler mypy --ignore-missing-imports --install-types --non-interactive . || true
-      - run: python -m memory_profiler pytest . || true
-      - run: python -m memory_profiler pytest --doctest-modules . || true
+      - run: python -m memory_profiler pytest --fixtures . || true
+      - run: python -m memory_profiler pytest --doctest-modules --fixtures . || true
       - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
       - run: safety check
"
.github/workflows/lint_python.yml,.github/workflows/lint_python.yml,3a27558594427f1bfc154442cec8d8d72414a01b,603f030d3a9f6bd3bb37f1f3fa1e6eb948394edb,make test,"@@ -22,7 +22,8 @@ jobs:
       - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
       - run: python -m memory_profiler mypy --ignore-missing-imports --install-types --non-interactive . || true
-      - run: python -m memory_profiler pytest --fixtures . || true
-      - run: python -m memory_profiler pytest --doctest-modules --fixtures . || true
+      - run: make test || true
+      # - run: python -m memory_profiler pytest --fixtures . || true
+      # - run: python -m memory_profiler pytest --doctest-modules --fixtures . || true
       - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
       - run: safety check
"
.github/workflows/lint_python.yml,.github/workflows/lint_python.yml,227ef5727c1b47e126f5da72faacbeaa84b407a1,3a27558594427f1bfc154442cec8d8d72414a01b,make make test mandatory,"@@ -22,7 +22,7 @@ jobs:
       - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
       - run: python -m memory_profiler mypy --ignore-missing-imports --install-types --non-interactive . || true
-      - run: make test || true
+      - run: make test
       # - run: python -m memory_profiler pytest --fixtures . || true
       # - run: python -m memory_profiler pytest --doctest-modules --fixtures . || true
       - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
"
.github/workflows/lint_python.yml,.github/workflows/lint_python.yml,fdfc0cb1db76d343313640393e2282b41aa9dc30,227ef5727c1b47e126f5da72faacbeaa84b407a1,Update lint_python.yml,"@@ -21,9 +21,7 @@ jobs:
       - run: pip install -r requirements.txt || pip install --editable . || pip install . || true
       - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
-      - run: python -m memory_profiler mypy --ignore-missing-imports --install-types --non-interactive . || true
+      - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
       - run: make test
-      # - run: python -m memory_profiler pytest --fixtures . || true
-      # - run: python -m memory_profiler pytest --doctest-modules --fixtures . || true
       - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
       - run: safety check
"
.travis.yml,,cea5804b767248c4df4fb1a31053e06cbc74a8d3,32b695f50f70cbe3c051e33152c1f36a6cde5e07,"Delete .travis.yml

The last Travis year was a year ago.  https://travis-ci.org/github/pythonprofilers/memory_profiler/builds","@@ -1,21 +0,0 @@
-language: python
-python:
-  - ""3.5""
-  - ""3.6""
-  - ""3.7""
-  - ""3.8""
-  - ""3.9""
-  - ""pypy3""
-
-matrix:
-  allow_failures:
-    - python: ""pypy3""
-    - python: ""3.7-dev""
-
-install:
-  - python -m pip install numpy ipython
-  - python -m pip install .
-script:
-  - make test
-
-sudo: false
"
.github/workflows/lint_python.yml,.github/workflows/lint_python.yml,6fa503c0a0a9096fe07bedcc5ea55b6b28d2cb6d,fdfc0cb1db76d343313640393e2282b41aa9dc30,Update lint_python.yml,"@@ -18,7 +18,7 @@ jobs:
       - run: flake8 . --count --exit-zero --max-complexity=10 --max-line-length=88
                       --show-source --statistics
       - run: isort --check-only --profile black . || true
-      - run: pip install -r requirements.txt || pip install --editable . || pip install . || true
+      - run: pip install --editable .
       - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
       - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
"
memory_profiler.py,memory_profiler.py,7c0f1f14057ea8c80ec90ca1bb6b83c2984b8ffd,eed3447369e5b0cd708de045b757e0bac853a83b,"from types import coroutine

`coroutine` is no longer available via the `asyncio` module as of Python 3.11.

```python-traceback
$ venv311/bin/python -c 'import memory_profiler'
Traceback (most recent call last):
  File ""<string>"", line 1, in <module>
  File ""/home/altendky//venv311/lib/python3.11/site-packages/memory_profiler.py"", line 10, in <module>
    from asyncio import coroutine, iscoroutinefunction
ImportError: cannot import name 'coroutine' from 'asyncio' (/home/altendky/.pyenv/versions/3.11.0rc2/lib/python3.11/asyncio/__init__.py)
```","@@ -7,9 +7,10 @@ __version__ = '0.60.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
-from asyncio import coroutine, iscoroutinefunction
+from asyncio import iscoroutinefunction
 from contextlib import contextmanager
 from functools import partial, wraps
+from types import coroutine
 import builtins
 import inspect
 import linecache
"
pyproject.toml,pyproject.toml,afbcd378ec6300b51b5a99b7e1c59de5874b8067,eed3447369e5b0cd708de045b757e0bac853a83b,configure codespell to ignore .git,"@@ -1,3 +1,6 @@
 [build-system]
 requires = [""setuptools""]
 build-backend = ""setuptools.build_meta""
+
+[tool.codespell]
+skip = './.git'
"
.github/workflows/lint_python.yml,.github/workflows/lint_python.yml,f6ebf958148fbde1bbdd85ed57355fd76ae20a95,8b1e7c98b671921926aa9863d86d7c0ff39d5677,test python 3.7 through 3.11,"@@ -3,11 +3,24 @@ on: [pull_request, push]
 jobs:
   lint_python:
     runs-on: ubuntu-latest
+    strategy:
+      fail-fast: false
+      matrix:
+        python: ['3.7', '3.8', '3.9', '3.10', '3.11']
     steps:
       - uses: actions/checkout@v3
       - uses: actions/setup-python@v4
         with:
-          python-version: 3.x
+          # This allows the matrix to specify just the major.minor version while still
+          # expanding it to get the latest patch version including alpha releases.
+          # This avoids the need to update for each new alpha, beta, release candidate,
+          # and then finally an actual release version.  actions/setup-python doesn't
+          # support this for PyPy presently so we get no help there.
+          #
+          # CPython -> 3.9.0-alpha - 3.9.X
+          # PyPy    -> pypy-3.7
+          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python.action), matrix.python.action))[startsWith(matrix.python.action, 'pypy')] }}
+          architecture: x64
       - run: pip install --upgrade pip wheel
       - run: pip install bandit black codespell flake8 flake8-2020 flake8-bugbear
                          flake8-comprehensions isort mypy pytest pyupgrade safety
"
.github/workflows/lint_python.yml,.github/workflows/lint_python.yml,754b44de8f5173e16d46c19bce1b6f0038525567,f6ebf958148fbde1bbdd85ed57355fd76ae20a95,oops,"@@ -19,7 +19,7 @@ jobs:
           #
           # CPython -> 3.9.0-alpha - 3.9.X
           # PyPy    -> pypy-3.7
-          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python.action), matrix.python.action))[startsWith(matrix.python.action, 'pypy')] }}
+          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python), matrix.python))[startsWith(matrix.python, 'pypy')] }}
           architecture: x64
       - run: pip install --upgrade pip wheel
       - run: pip install bandit black codespell flake8 flake8-2020 flake8-bugbear
"
.github/workflows/lint_python.yml,.github/workflows/lint_python.yml,6e55b794462ccdc85ab1de05dce8fb0c4dc746d6,754b44de8f5173e16d46c19bce1b6f0038525567,skip safety check on 3.7,"@@ -37,4 +37,5 @@ jobs:
       - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
       - run: make test
       - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
-      - run: safety check
+      - if: matrix.python != '3.7'
+        run: safety check
"
.github/workflows/lint_python.yml,.github/workflows/lint_python.yml,28ac94d28394f7ebce75611cdf25670f93c2f8eb,6e55b794462ccdc85ab1de05dce8fb0c4dc746d6,try separating lint and test matrices,"@@ -1,12 +1,12 @@
 name: lint_python
 on: [pull_request, push]
 jobs:
-  lint_python:
+  lint:
     runs-on: ubuntu-latest
     strategy:
       fail-fast: false
       matrix:
-        python: ['3.7', '3.8', '3.9', '3.10', '3.11']
+        python: '3.9'
     steps:
       - uses: actions/checkout@v3
       - uses: actions/setup-python@v4
@@ -35,7 +35,32 @@ jobs:
       - run: pip install numpy pylab-sdk
       - run: mkdir --parents --verbose .mypy_cache
       - run: mypy --ignore-missing-imports --install-types --non-interactive . || true
-      - run: make test
       - run: shopt -s globstar && pyupgrade --py36-plus **/*.py || true
+
+  test:
+    runs-on: ubuntu-latest
+    strategy:
+      fail-fast: false
+      matrix:
+        python: ['3.7', '3.8', '3.9', '3.10', '3.11']
+    steps:
+      - uses: actions/checkout@v3
+      - uses: actions/setup-python@v4
+        with:
+          # This allows the matrix to specify just the major.minor version while still
+          # expanding it to get the latest patch version including alpha releases.
+          # This avoids the need to update for each new alpha, beta, release candidate,
+          # and then finally an actual release version.  actions/setup-python doesn't
+          # support this for PyPy presently so we get no help there.
+          #
+          # CPython -> 3.9.0-alpha - 3.9.X
+          # PyPy    -> pypy-3.7
+          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python), matrix.python))[startsWith(matrix.python, 'pypy')] }}
+          architecture: x64
+      - run: pip install --upgrade pip wheel
+      - run: pip install pytest
+      - run: pip install --editable .
+      - run: pip install numpy pylab-sdk
+      - run: make test
       - if: matrix.python != '3.7'
         run: safety check
"
.github/workflows/lint_python.yml,.github/workflows/lint_python.yml,e7e895fbf02d3dcd83ddf23f9a9e2941388838e7,28ac94d28394f7ebce75611cdf25670f93c2f8eb,Update lint_python.yml,"@@ -6,7 +6,7 @@ jobs:
     strategy:
       fail-fast: false
       matrix:
-        python: '3.9'
+        python: ['3.9']
     steps:
       - uses: actions/checkout@v3
       - uses: actions/setup-python@v4
"
.github/workflows/lint_python.yml,.github/workflows/lint_python.yml,185dfbe3c9055aa43617ab04ba9aa56306fbe2b3,e7e895fbf02d3dcd83ddf23f9a9e2941388838e7,Update lint_python.yml,"@@ -23,7 +23,7 @@ jobs:
           architecture: x64
       - run: pip install --upgrade pip wheel
       - run: pip install bandit black codespell flake8 flake8-2020 flake8-bugbear
-                         flake8-comprehensions isort mypy pytest pyupgrade safety
+                         flake8-comprehensions isort mypy pytest pyupgrade
       - run: bandit --recursive --skip B101,B102,B307,B404,B603,B607 .
       - run: black --check . || true
       - run: codespell  # --ignore-words-list="""" --skip=""*.css,*.js,*.lock""
@@ -58,7 +58,7 @@ jobs:
           python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python), matrix.python))[startsWith(matrix.python, 'pypy')] }}
           architecture: x64
       - run: pip install --upgrade pip wheel
-      - run: pip install pytest
+      - run: pip install pytest safety
       - run: pip install --editable .
       - run: pip install numpy pylab-sdk
       - run: make test
"
.github/workflows/lint_python.yml,.github/workflows/lint_python.yml,16e9342a57b2338118333bea7e748f5de16f74cd,185dfbe3c9055aa43617ab04ba9aa56306fbe2b3,Update lint_python.yml,"@@ -6,7 +6,7 @@ jobs:
     strategy:
       fail-fast: false
       matrix:
-        python: ['3.9']
+        python: ['3.10']
     steps:
       - uses: actions/checkout@v3
       - uses: actions/setup-python@v4
"
memory_profiler.py,memory_profiler.py,c121b1ea6a3ff6e5e70bcd7ee656a41706c77c89,ab6162ece899dd956f2d4f26ca47b025d8734a42,bump version to 0.61.0,"@@ -3,7 +3,7 @@
 # .. we'll use this to pass it to the child script ..
 _CLEAN_GLOBALS = globals().copy()
 
-__version__ = '0.60.0'
+__version__ = '0.61.0'
 
 _CMD_USAGE = ""python -m memory_profiler script_file.py""
 
"
.github/workflows/lint_python.yml,.github/workflows/lint_python.yml,7b6eae7336573635531da097c77200aa26929179,9a597b316d81e6caba5be517d230a726b802962b,test back to CPython 3.5,"@@ -6,7 +6,9 @@ jobs:
     strategy:
       fail-fast: false
       matrix:
-        python: ['3.10']
+        python:
+          - major_dot_minor: '3.10'
+            safety: false
     steps:
       - uses: actions/checkout@v3
       - uses: actions/setup-python@v4
@@ -19,7 +21,7 @@ jobs:
           #
           # CPython -> 3.9.0-alpha - 3.9.X
           # PyPy    -> pypy-3.7
-          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python), matrix.python))[startsWith(matrix.python, 'pypy')] }}
+          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python.major_dot_minor), matrix.python.major_dot_minor))[startsWith(matrix.python.major_dot_minor, 'pypy')] }}
           architecture: x64
       - run: pip install --upgrade pip wheel
       - run: pip install bandit black codespell flake8 flake8-2020 flake8-bugbear
@@ -42,7 +44,23 @@ jobs:
     strategy:
       fail-fast: false
       matrix:
-        python: ['3.7', '3.8', '3.9', '3.10', '3.11']
+        python:
+          - major_dot_minor: '3.4'
+            safety: false
+          - major_dot_minor: '3.5'
+            safety: false
+          - major_dot_minor: '3.6'
+            safety: false
+          - major_dot_minor: '3.7'
+            safety: false
+          - major_dot_minor: '3.8'
+            safety: true
+          - major_dot_minor: '3.9'
+            safety: true
+          - major_dot_minor: '3.10'
+            safety: true
+          - major_dot_minor: '3.11'
+            safety: true
     steps:
       - uses: actions/checkout@v3
       - uses: actions/setup-python@v4
@@ -55,12 +73,12 @@ jobs:
           #
           # CPython -> 3.9.0-alpha - 3.9.X
           # PyPy    -> pypy-3.7
-          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python), matrix.python))[startsWith(matrix.python, 'pypy')] }}
+          python-version: ${{ fromJSON(format('[""{0}"", ""{1}""]', format('{0}.0-alpha - {0}.X', matrix.python.major_dot_minor), matrix.python.major_dot_minor))[startsWith(matrix.python.major_dot_minor, 'pypy')] }}
           architecture: x64
       - run: pip install --upgrade pip wheel
       - run: pip install pytest safety
       - run: pip install --editable .
       - run: pip install numpy pylab-sdk
       - run: make test
-      - if: matrix.python != '3.7'
+      - if: matrix.python.safety
         run: safety check
"
setup.cfg,setup.cfg,7b6eae7336573635531da097c77200aa26929179,9a597b316d81e6caba5be517d230a726b802962b,test back to CPython 3.5,"@@ -23,7 +23,7 @@ classifiers =
 py_modules =
     memory_profiler
     mprof
-python_requires = >=3.4
+python_requires = >=3.5
 install_requires = psutil
 
 [options.entry_points]
"
test/test_async.py,test/test_async.py,7b6eae7336573635531da097c77200aa26929179,9a597b316d81e6caba5be517d230a726b802962b,test back to CPython 3.5,"@@ -1,4 +1,5 @@
 import asyncio
+import sys
 
 from memory_profiler import profile
 
@@ -14,5 +15,13 @@ async def main():
     task = asyncio.create_task(my_func())
     res = await asyncio.gather(task)
 
+async def main_legacy():
+    future = asyncio.ensure_future(my_func())
+    res = await asyncio.gather(future)
+
 if __name__ == '__main__':
-    asyncio.run(main())  # main loop
+    if sys.version_info >= (3, 7):
+        asyncio.run(main())  # main loop
+    else:
+        loop = asyncio.get_event_loop()
+        loop.run_until_complete(main_legacy())
"
.github/workflows/lint_python.yml,.github/workflows/lint_python.yml,0683885d864de06a4072cad9b2073833e2e6c201,7b6eae7336573635531da097c77200aa26929179,actually drop 3.4 testing,"@@ -45,8 +45,6 @@ jobs:
       fail-fast: false
       matrix:
         python:
-          - major_dot_minor: '3.4'
-            safety: false
           - major_dot_minor: '3.5'
             safety: false
           - major_dot_minor: '3.6'
"
.github/workflows/lint_python.yml,.github/workflows/lint_python.yml,26dae1a72c80a780a48a95602f11980906fd93c8,9a597b316d81e6caba5be517d230a726b802962b,"only build either push or pull_request triggers, not both","@@ -1,5 +1,13 @@
 name: lint_python
-on: [pull_request, push]
+
+on:
+  push:
+    branches:
+      - master
+  pull_request:
+    branches:
+      - '**'
+
 jobs:
   lint:
     runs-on: ubuntu-latest
"
.github/workflows/lint_python.yml,.github/workflows/lint_python.yml,b4143a3ac47e5e67244170d824d9c619d04cfe21,26dae1a72c80a780a48a95602f11980906fd93c8,and version tags,"@@ -4,6 +4,8 @@ on:
   push:
     branches:
       - master
+    tags:
+      - v*
   pull_request:
     branches:
       - '**'
"
setup.cfg,setup.cfg,027b461a67b0d86fd2bcdc406e2380b3acf9aa8a,f9262590da28ccd4d6ff00755e7bc952f4044a9a,"Only test and require Python 3.7+

https://github.com/pythonprofilers/memory_profiler/actions/runs/3627706309/jobs/6126859301

GitHub has dropped Python 3.5 and 3.6 support from the `setup-python` action.","@@ -23,7 +23,7 @@ classifiers =
 py_modules =
     memory_profiler
     mprof
-python_requires = >=3.5
+python_requires = >=3.7
 install_requires = psutil
 
 [options.entry_points]
"
.github/workflows/lint_python.yml,.github/workflows/lint_python.yml,f141a6a4220d11df571b8b7c9a63ffd32dc13ebe,027b461a67b0d86fd2bcdc406e2380b3acf9aa8a,drop 3.5 and 3.6 from ci,"@@ -55,10 +55,6 @@ jobs:
       fail-fast: false
       matrix:
         python:
-          - major_dot_minor: '3.5'
-            safety: false
-          - major_dot_minor: '3.6'
-            safety: false
           - major_dot_minor: '3.7'
             safety: false
           - major_dot_minor: '3.8'
"
test/test_exit_code.py,test/test_exit_code.py,940aa76f5da8b7cba5938f17990da054e013de0a,57b643a84e1b7f1edaf10430230bdd0ee753080c,Fix deprecated syntax,"@@ -18,7 +18,7 @@ class TestExitCode(unittest.TestCase):
             ofile.write(s)
             ofile.flush()
             sys.argv = ['<ignored>', '--exit-code', tmpfile.name]
-            self.assertRaisesRegexp(SystemExit, '0', self.run_action)
+            self.assertRaisesRegex(SystemExit, '0', self.run_action)
 
     def test_exit_code_fail(self):
         s = ""raise RuntimeError('I am not working nicely')""
@@ -27,7 +27,7 @@ class TestExitCode(unittest.TestCase):
             ofile.write(s)
             ofile.flush()
             sys.argv = ['<ignored>', '--exit-code', tmpfile.name]
-            self.assertRaisesRegexp(SystemExit, '1', self.run_action)
+            self.assertRaisesRegex(SystemExit, '1', self.run_action)
 
     def test_no_exit_code_success(self):
         s = ""raise RuntimeError('I am not working nicely')""
"
README.rst,README.rst,9b26810c956ed176bc1b6bbfa23ce838dd0d0a4d,e079d3fa351889087f55edb68769b67682ceacf3,"Update README.rst

Update the definition of *Occurrences* as provided in https://github.com/pythonprofilers/memory_profiler/issues/352#issuecomment-1644197537","@@ -95,8 +95,9 @@ The first column represents the line number of the code that has been
 profiled, the second column (*Mem usage*) the memory usage of the
 Python interpreter after that line has been executed. The third column
 (*Increment*) represents the difference in memory of the current line
-with respect to the last one. The last column (*Line Contents*) prints
-the code that has been profiled.
+with respect to the last one. The fourth column (*Occurrences*) shows
+the number of times that profiler has hit each line. The last column
+(*Line Contents*) prints the code that has been profiled.
 
 Decorator
 =========
"
README.rst,README.rst,1de5cd0ed48218b969404ae386af4be0f5bc8b31,9b26810c956ed176bc1b6bbfa23ce838dd0d0a4d,Update README.rst,"@@ -96,7 +96,7 @@ profiled, the second column (*Mem usage*) the memory usage of the
 Python interpreter after that line has been executed. The third column
 (*Increment*) represents the difference in memory of the current line
 with respect to the last one. The fourth column (*Occurrences*) shows
-the number of times that profiler has hit each line. The last column
+the number of times that profiler has executed each line. The last column
 (*Line Contents*) prints the code that has been profiled.
 
 Decorator
"
README.rst,README.rst,864e9f4d661b0680a892ef272d7d30894469a168,3ae050f6cabfb99444546239029638580dbe9857,"Add Python syntax highlighting to `README.rst`

Verified exhaustiveness with:

```bash
find -name '*.rst'
```","@@ -58,8 +58,9 @@ then run the script with a special script (in this case with specific
 arguments to the Python interpreter).
 
 In the following example, we create a simple function ``my_func`` that
-allocates lists ``a``, ``b`` and then deletes ``b``::
+allocates lists ``a``, ``b`` and then deletes ``b``:
 
+.. code-block:: python
 
     @profile
     def my_func():
@@ -101,7 +102,9 @@ the number of times that profiler has executed each line. The last column
 
 Decorator
 =========
-A function decorator is also available.  Use as follows::
+A function decorator is also available.  Use as follows:
+
+.. code-block:: python
 
     from memory_profiler import profile
 
@@ -116,7 +119,9 @@ In this case the script can be run without specifying ``-m
 memory_profiler`` in the command line.
 
 In function decorator, you can specify the precision as an argument to the
-decorator function.  Use as follows::
+decorator function.  Use as follows:
+
+.. code-block:: python
 
     from memory_profiler import profile
 
@@ -282,6 +287,7 @@ necessarily a Python program), a string containing some python code to
 be evaluated or a tuple ``(f, args, kw)`` containing a function and its
 arguments to be evaluated as ``f(*args, **kw)``. For example,
 
+.. code-block:: python
 
     >>> from memory_profiler import memory_usage
     >>> mem_usage = memory_usage(-1, interval=.2, timeout=1)
@@ -301,8 +307,9 @@ thing on the IPython notebook it scales up to 44MB.
 
 If you'd like to get the memory consumption of a Python function, then
 you should specify the function and its arguments in the tuple ``(f,
-args, kw)``. For example::
+args, kw)``. For example:
 
+.. code-block:: python
 
     >>> # define a simple function
     >>> def f(a, n=100):
@@ -325,6 +332,8 @@ REPORTING
 The output can be redirected to a log file by passing IO stream as
 parameter to the decorator like @profile(stream=fp)
 
+.. code-block:: python
+
     >>> fp=open('memory_profiler.log','w+')
     >>> @profile(stream=fp)
     >>> def my_func():
@@ -333,7 +342,7 @@ parameter to the decorator like @profile(stream=fp)
         ...     del b
         ...     return a
 
-    For details refer: examples/reporting_file.py
+For details refer: examples/reporting_file.py
 
 ``Reporting via logger Module:``
 
@@ -343,6 +352,8 @@ when we need to use RotatingFileHandler.
 The output can be redirected to logger module by simply making use of
 LogFile of memory profiler module.
 
+.. code-block:: python
+
     >>> from memory_profiler import LogFile
     >>> import sys
     >>> sys.stdout = LogFile('memory_profile_log')
@@ -354,11 +365,13 @@ could be cumbersome and one can choose only entries with increments
 by passing True to reportIncrementFlag, where reportIncrementFlag is
 a parameter to LogFile class of memory profiler module.
 
+.. code-block:: python
+
     >>> from memory_profiler import LogFile
     >>> import sys
     >>> sys.stdout = LogFile('memory_profile_log', reportIncrementFlag=False)
 
-    For details refer: examples/reporting_logger.py
+For details refer: examples/reporting_logger.py
 
 =====================
  IPython integration
@@ -372,7 +385,9 @@ For IPython 0.11+, you can use the module directly as an extension, with
 To activate it whenever you start IPython, edit the configuration file for your
 IPython profile, ~/.ipython/profile_default/ipython_config.py, to register the
 extension like this (If you already have other extensions, just add this one to
-the list)::
+the list):
+
+.. code-block:: python
 
     c.InteractiveShellApp.extensions = [
         'memory_profiler',
@@ -385,20 +400,26 @@ It then can be used directly from IPython to obtain a line-by-line
 report using the `%mprun` or `%%mprun` magic command. In this case, you can skip
 the `@profile` decorator and instead use the `-f` parameter, like
 this. Note however that function my_func must be defined in a file
-(cannot have been defined interactively in the Python interpreter)::
+(cannot have been defined interactively in the Python interpreter):
+
+.. code-block:: python
 
     In [1]: from example import my_func, my_func_2
 
     In [2]: %mprun -f my_func my_func()
 
-or in cell mode::
+or in cell mode:
+
+.. code-block:: python
 
     In [3]: %%mprun -f my_func -f my_func_2
        ...: my_func()
        ...: my_func_2()
 
 Another useful magic that we define is `%memit`, which is analogous to
-`%timeit`. It can be used as follows::
+`%timeit`. It can be used as follows:
+
+.. code-block:: python
 
     In [1]: %memit range(10000)
     peak memory: 21.42 MiB, increment: 0.41 MiB
@@ -406,7 +427,9 @@ Another useful magic that we define is `%memit`, which is analogous to
     In [2]: %memit range(1000000)
     peak memory: 52.10 MiB, increment: 31.08 MiB
 
-or in cell mode (with setup code)::
+or in cell mode (with setup code):
+
+.. code-block:: python
 
     In [3]: %%memit l=range(1000000)
        ...: len(l)
@@ -416,7 +439,9 @@ or in cell mode (with setup code)::
 For more details, see the docstrings of the magics.
 
 For IPython 0.10, you can install it by editing the IPython configuration
-file ~/.ipython/ipy_user_conf.py to add the following lines::
+file ~/.ipython/ipy_user_conf.py to add the following lines:
+
+.. code-block:: python
 
     # These two lines are standard and probably already there.
     import IPython.ipapi
@@ -441,6 +466,8 @@ Currently, the backend can be set via the CLI
 
 and is exposed by the API
 
+.. code-block:: python
+
     >>> from memory_profiler import memory_usage
     >>> mem_usage = memory_usage(-1, interval=.2, timeout=1, backend=""psutil"")
 
"
README.rst,README.rst,025929f8e4f4ea8c27ddb5ef72fc91f6bd703ea5,a99a3c3b3c2eb01c90f6e14ddfcb85b3e97f9885,Update README.rst,"@@ -6,7 +6,7 @@
 =================
 
 
-**Note:** This package is no longer actively maintained. I won't be actively responding to issues. If you'd like to volunteer to maintain it, please drop me a line at f@bianp.net
+**Note:** This package is no longer actively maintained. I won't be actively responding to issues.
 
 This is a python module for monitoring memory consumption of a process
 as well as line-by-line analysis of memory consumption for python
"
